const createBinanceSubgraph;
const req = require;

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof req&&req;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof req&&req,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(req,module,exports){
const createBinanceSubgraph = req('../index.js');
module.exports = createBinanceSubgraph;

},{"../index.js":2}],2:[function(req,module,exports){
const createBinanceSubgraph= require("./src/index.js");



module.exports =createBinanceSubgraph;

},{"./src/index.js":271}],3:[function(req,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// This currentContext variable will only be used if the makeSlotClass
// function is called, which happens only if this is the first copy of the
// @wry/context package to be imported.
var currentContext = null;
// This unique internal object is used to denote the absence of a value
// for a given Slot, and is never exposed to outside code.
var MISSING_VALUE = {};
var idCounter = 1;
// Although we can't do anything about the cost of duplicated code from
// accidentally bundling multiple copies of the @wry/context package, we can
// avoid creating the Slot class more than once using makeSlotClass.
var makeSlotClass = function () { return /** @class */ (function () {
    function Slot() {
        // If you have a Slot object, you can find out its slot.id, but you cannot
        // guess the slot.id of a Slot you don't have access to, thanks to the
        // randomized suffix.
        this.id = [
            "slot",
            idCounter++,
            Date.now(),
            Math.random().toString(36).slice(2),
        ].join(":");
    }
    Slot.prototype.hasValue = function () {
        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
            // We use the Slot object iself as a key to its value, which means the
            // value cannot be obtained without a reference to the Slot object.
            if (this.id in context_1.slots) {
                var value = context_1.slots[this.id];
                if (value === MISSING_VALUE)
                    break;
                if (context_1 !== currentContext) {
                    // Cache the value in currentContext.slots so the next lookup will
                    // be faster. This caching is safe because the tree of contexts and
                    // the values of the slots are logically immutable.
                    currentContext.slots[this.id] = value;
                }
                return true;
            }
        }
        if (currentContext) {
            // If a value was not found for this Slot, it's never going to be found
            // no matter how many times we look it up, so we might as well cache
            // the absence of the value, too.
            currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
    };
    Slot.prototype.getValue = function () {
        if (this.hasValue()) {
            return currentContext.slots[this.id];
        }
    };
    Slot.prototype.withValue = function (value, callback,
    // Given the prevalence of arrow functions, specifying arguments is likely
    // to be much more common than specifying `this`, hence this ordering:
    args, thisArg) {
        var _a;
        var slots = (_a = {
                __proto__: null
            },
            _a[this.id] = value,
            _a);
        var parent = currentContext;
        currentContext = { parent: parent, slots: slots };
        try {
            // Function.prototype.apply allows the arguments array argument to be
            // omitted or undefined, so args! is fine here.
            return callback.apply(thisArg, args);
        }
        finally {
            currentContext = parent;
        }
    };
    // Capture the current context and wrap a callback function so that it
    // reestablishes the captured context when called.
    Slot.bind = function (callback) {
        var context = currentContext;
        return function () {
            var saved = currentContext;
            try {
                currentContext = context;
                return callback.apply(this, arguments);
            }
            finally {
                currentContext = saved;
            }
        };
    };
    // Immediately run a callback function without any captured context.
    Slot.noContext = function (callback,
    // Given the prevalence of arrow functions, specifying arguments is likely
    // to be much more common than specifying `this`, hence this ordering:
    args, thisArg) {
        if (currentContext) {
            var saved = currentContext;
            try {
                currentContext = null;
                // Function.prototype.apply allows the arguments array argument to be
                // omitted or undefined, so args! is fine here.
                return callback.apply(thisArg, args);
            }
            finally {
                currentContext = saved;
            }
        }
        else {
            return callback.apply(thisArg, args);
        }
    };
    return Slot;
}()); };
// We store a single global implementation of the Slot class as a permanent
// non-enumerable symbol property of the Array constructor. This obfuscation
// does nothing to prevent access to the Slot class, but at least it ensures
// the implementation (i.e. currentContext) cannot be tampered with, and all
// copies of the @wry/context package (hopefully just one) will share the
// same Slot implementation. Since the first copy of the @wry/context package
// to be imported wins, this technique imposes a very high cost for any
// future breaking changes to the Slot class.
var globalKey = "@wry/context:Slot";
var host = Array;
var Slot = host[globalKey] || function () {
    var Slot = makeSlotClass();
    try {
        Object.defineProperty(host, globalKey, {
            value: host[globalKey] = Slot,
            enumerable: false,
            writable: false,
            configurable: false,
        });
    }
    finally {
        return Slot;
    }
}();

var bind = Slot.bind, noContext = Slot.noContext;
function setTimeoutWithContext(callback, delay) {
    return setTimeout(bind(callback), delay);
}
// Turn any generator function into an async function (using yield instead
// of await), with context automatically preserved across yields.
function asyncFromGen(genFn) {
    return function () {
        var gen = genFn.apply(this, arguments);
        var boundNext = bind(gen.next);
        var boundThrow = bind(gen.throw);
        return new Promise(function (resolve, reject) {
            function invoke(method, argument) {
                try {
                    var result = method.call(gen, argument);
                }
                catch (error) {
                    return reject(error);
                }
                var next = result.done ? resolve : invokeNext;
                if (isPromiseLike(result.value)) {
                    result.value.then(next, result.done ? reject : invokeThrow);
                }
                else {
                    next(result.value);
                }
            }
            var invokeNext = function (value) { return invoke(boundNext, value); };
            var invokeThrow = function (error) { return invoke(boundThrow, error); };
            invokeNext();
        });
    };
}
function isPromiseLike(value) {
    return value && typeof value.then === "function";
}
// If you use the fibers npm package to implement coroutines in Node.js,
// you should call this function at least once to ensure context management
// remains coherent across any yields.
var wrappedFibers = [];
function wrapYieldingFiberMethods(Fiber) {
    // There can be only one implementation of Fiber per process, so this array
    // should never grow longer than one element.
    if (wrappedFibers.indexOf(Fiber) < 0) {
        var wrap = function (obj, method) {
            var fn = obj[method];
            obj[method] = function () {
                return noContext(fn, arguments, this);
            };
        };
        // These methods can yield, according to
        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100
        wrap(Fiber, "yield");
        wrap(Fiber.prototype, "run");
        wrap(Fiber.prototype, "throwInto");
        wrappedFibers.push(Fiber);
    }
    return Fiber;
}

exports.Slot = Slot;
exports.asyncFromGen = asyncFromGen;
exports.bind = bind;
exports.noContext = noContext;
exports.setTimeout = setTimeoutWithContext;
exports.wrapYieldingFiberMethods = wrapYieldingFiberMethods;

},{}],4:[function(req,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _a = Object.prototype, toString = _a.toString, hasOwnProperty = _a.hasOwnProperty;
var previousComparisons = new Map();
/**
 * Performs a deep equality check on two JavaScript values, tolerating cycles.
 */
function equal(a, b) {
    try {
        return check(a, b);
    }
    finally {
        previousComparisons.clear();
    }
}
function check(a, b) {
    // If the two values are strictly equal, our job is easy.
    if (a === b) {
        return true;
    }
    // Object.prototype.toString returns a representation of the runtime type of
    // the given value that is considerably more precise than typeof.
    var aTag = toString.call(a);
    var bTag = toString.call(b);
    // If the runtime types of a and b are different, they could maybe be equal
    // under some interpretation of equality, but for simplicity and performance
    // we just return false instead.
    if (aTag !== bTag) {
        return false;
    }
    switch (aTag) {
        case '[object Array]':
            // Arrays are a lot like other objects, but we can cheaply compare their
            // lengths as a short-cut before comparing their elements.
            if (a.length !== b.length)
                return false;
        // Fall through to object case...
        case '[object Object]': {
            if (previouslyCompared(a, b))
                return true;
            var aKeys = Object.keys(a);
            var bKeys = Object.keys(b);
            // If `a` and `b` have a different number of enumerable keys, they
            // must be different.
            var keyCount = aKeys.length;
            if (keyCount !== bKeys.length)
                return false;
            // Now make sure they have the same keys.
            for (var k = 0; k < keyCount; ++k) {
                if (!hasOwnProperty.call(b, aKeys[k])) {
                    return false;
                }
            }
            // Finally, check deep equality of all child properties.
            for (var k = 0; k < keyCount; ++k) {
                var key = aKeys[k];
                if (!check(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        case '[object Error]':
            return a.name === b.name && a.message === b.message;
        case '[object Number]':
            // Handle NaN, which is !== itself.
            if (a !== a)
                return b !== b;
        // Fall through to shared +a === +b case...
        case '[object Boolean]':
        case '[object Date]':
            return +a === +b;
        case '[object RegExp]':
        case '[object String]':
            return a == "" + b;
        case '[object Map]':
        case '[object Set]': {
            if (a.size !== b.size)
                return false;
            if (previouslyCompared(a, b))
                return true;
            var aIterator = a.entries();
            var isMap = aTag === '[object Map]';
            while (true) {
                var info = aIterator.next();
                if (info.done)
                    break;
                // If a instanceof Set, aValue === aKey.
                var _a = info.value, aKey = _a[0], aValue = _a[1];
                // So this works the same way for both Set and Map.
                if (!b.has(aKey)) {
                    return false;
                }
                // However, we care about deep equality of values only when dealing
                // with Map structures.
                if (isMap && !check(aValue, b.get(aKey))) {
                    return false;
                }
            }
            return true;
        }
    }
    // Otherwise the values are not equal.
    return false;
}
function previouslyCompared(a, b) {
    // Though cyclic references can make an object graph appear infinite from the
    // perspective of a depth-first traversal, the graph still contains a finite
    // number of distinct object references. We use the previousComparisons cache
    // to avoid comparing the same pair of object references more than once, which
    // guarantees termination (even if we end up comparing every object in one
    // graph to every object in the other graph, which is extremely unlikely),
    // while still allowing weird isomorphic structures (like rings with different
    // lengths) a chance to pass the equality test.
    var bSet = previousComparisons.get(a);
    if (bSet) {
        // Return true here because we can be sure false will be returned somewhere
        // else if the objects are not equivalent.
        if (bSet.has(b))
            return true;
    }
    else {
        previousComparisons.set(a, bSet = new Set);
    }
    bSet.add(b);
    return false;
}

exports.default = equal;
exports.equal = equal;

},{}],5:[function(req,module,exports){
(function (process){
exports.__esModule = true;
var _exportNames = {
  gql: true,
  HttpLink: true
};
exports.default = exports.gql = void 0;

var _tslib = req("tslib");

var _apolloClient = _interopreqWildcard(req("apollo-client"));

Object.keys(_apolloClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _apolloClient[key];
});

var _apolloLink = req("apollo-link");

Object.keys(_apolloLink).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _apolloLink[key];
});

var _apolloCacheInmemory = req("apollo-cache-inmemory");

Object.keys(_apolloCacheInmemory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _apolloCacheInmemory[key];
});

var _apolloLinkHttp = req("apollo-link-http");

exports.HttpLink = _apolloLinkHttp.HttpLink;

var _apolloLinkError = req("apollo-link-error");

var _graphqlTag = _interopreqDefault(req("graphql-tag"));

exports.gql = _graphqlTag.default;

var _tsInvariant = req("ts-invariant");

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopreqWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var PRESET_CONFIG_KEYS = ['request', 'uri', 'credentials', 'headers', 'fetch', 'fetchOptions', 'clientState', 'onError', 'cacheRedirects', 'cache', 'name', 'version', 'resolvers', 'typeDefs', 'fragmentMatcher'];

var DefaultClient = function (_super) {
  (0, _tslib.__extends)(DefaultClient, _super);

  function DefaultClient(config) {
    if (config === void 0) {
      config = {};
    }

    var _this = this;

    if (config) {
      var diff = Object.keys(config).filter(function (key) {
        return PRESET_CONFIG_KEYS.indexOf(key) === -1;
      });

      if (diff.length > 0) {
        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('ApolloBoost was initialized with unsupported options: ' + ("" + diff.join(' ')));
      }
    }

    var request = config.request,
        uri = config.uri,
        credentials = config.credentials,
        headers = config.headers,
        fetch = config.fetch,
        fetchOptions = config.fetchOptions,
        clientState = config.clientState,
        cacheRedirects = config.cacheRedirects,
        errorCallback = config.onError,
        name = config.name,
        version = config.version,
        resolvers = config.resolvers,
        typeDefs = config.typeDefs,
        fragmentMatcher = config.fragmentMatcher;
    var cache = config.cache;
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!cache || !cacheRedirects, 1) : (0, _tsInvariant.invariant)(!cache || !cacheRedirects, 'Incompatible cache configuration. When not providing `cache`, ' + 'configure the provided instance with `cacheRedirects` instead.');

    if (!cache) {
      cache = cacheRedirects ? new _apolloCacheInmemory.InMemoryCache({
        cacheRedirects: cacheRedirects
      }) : new _apolloCacheInmemory.InMemoryCache();
    }

    var errorLink = errorCallback ? (0, _apolloLinkError.onError)(errorCallback) : (0, _apolloLinkError.onError)(function (_a) {
      var graphQLErrors = _a.graphQLErrors,
          networkError = _a.networkError;

      if (graphQLErrors) {
        graphQLErrors.map(function (_a) {
          var message = _a.message,
              locations = _a.locations,
              path = _a.path;
          return process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn("[GraphQL error]: Message: " + message + ", Location: " + (locations + ", Path: " + path));
        });
      }

      if (networkError) {
        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn("[Network error]: " + networkError);
      }
    });
    var requestHandler = request ? new _apolloLink.ApolloLink(function (operation, forward) {
      return new _apolloLink.Observable(function (observer) {
        var handle;
        Promise.resolve(operation).then(function (oper) {
          return request(oper);
        }).then(function () {
          handle = forward(operation).subscribe({
            next: observer.next.bind(observer),
            error: observer.error.bind(observer),
            complete: observer.complete.bind(observer)
          });
        }).catch(observer.error.bind(observer));
        return function () {
          if (handle) {
            handle.unsubscribe();
          }
        };
      });
    }) : false;
    var httpLink = new _apolloLinkHttp.HttpLink({
      uri: uri || '/graphql',
      fetch: fetch,
      fetchOptions: fetchOptions || {},
      credentials: credentials || 'same-origin',
      headers: headers || {}
    });

    var link = _apolloLink.ApolloLink.from([errorLink, requestHandler, httpLink].filter(function (x) {
      return !!x;
    }));

    var activeResolvers = resolvers;
    var activeTypeDefs = typeDefs;
    var activeFragmentMatcher = fragmentMatcher;

    if (clientState) {
      if (clientState.defaults) {
        cache.writeData({
          data: clientState.defaults
        });
      }

      activeResolvers = clientState.resolvers;
      activeTypeDefs = clientState.typeDefs;
      activeFragmentMatcher = clientState.fragmentMatcher;
    }

    _this = _super.call(this, {
      cache: cache,
      link: link,
      name: name,
      version: version,
      resolvers: activeResolvers,
      typeDefs: activeTypeDefs,
      fragmentMatcher: activeFragmentMatcher
    }) || this;
    return _this;
  }

  return DefaultClient;
}(_apolloClient.default);

var _default = DefaultClient;

exports.default = _default;

}).call(this,req('_process'))
},{"_process":307,"apollo-cache-inmemory":6,"apollo-client":8,"apollo-link":13,"apollo-link-error":9,"apollo-link-http":12,"graphql-tag":206,"ts-invariant":259,"tslib":260}],6:[function(req,module,exports){
(function (process){
exports.__esModule = true;
exports.assertIdValue = assertIdValue;
exports.defaultDataIdFromObject = defaultDataIdFromObject;
exports.defaultNormalizedCacheFactory = defaultNormalizedCacheFactory$1;
exports.enhanceErrorWithDocument = enhanceErrorWithDocument;
exports.WriteError = exports.StoreWriter = exports.StoreReader = exports.ObjectCache = exports.IntrospectionFragmentMatcher = exports.InMemoryCache = exports.HeuristicFragmentMatcher = void 0;

var _tslib = req("tslib");

var _apolloCache = req("apollo-cache");

var _apolloUtilities = req("apollo-utilities");

var _optimism = req("optimism");

var _tsInvariant = req("ts-invariant");

var haveWarned = false;

function shouldWarn() {
  var answer = !haveWarned;

  if (!(0, _apolloUtilities.isTest)()) {
    haveWarned = true;
  }

  return answer;
}

var HeuristicFragmentMatcher = function () {
  function HeuristicFragmentMatcher() {}

  HeuristicFragmentMatcher.prototype.ensureReady = function () {
    return Promise.resolve();
  };

  HeuristicFragmentMatcher.prototype.canBypassInit = function () {
    return true;
  };

  HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
    var obj = context.store.get(idValue.id);
    var isRootQuery = idValue.id === 'ROOT_QUERY';

    if (!obj) {
      return isRootQuery;
    }

    var _a = obj.__typename,
        __typename = _a === void 0 ? isRootQuery && 'Query' : _a;

    if (!__typename) {
      if (shouldWarn()) {
        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);
        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " + "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
      }

      return 'heuristic';
    }

    if (__typename === typeCondition) {
      return true;
    }

    if (shouldWarn()) {
      process.env.NODE_ENV === "production" || _tsInvariant.invariant.error('You are using the simple (heuristic) fragment matcher, but your ' + 'queries contain union or interface types. Apollo Client will not be ' + 'able to accurately map fragments. To make this error go away, use ' + 'the `IntrospectionFragmentMatcher` as described in the docs: ' + 'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');
    }

    return 'heuristic';
  };

  return HeuristicFragmentMatcher;
}();

exports.HeuristicFragmentMatcher = HeuristicFragmentMatcher;

var IntrospectionFragmentMatcher = function () {
  function IntrospectionFragmentMatcher(options) {
    if (options && options.introspectionQueryResultData) {
      this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
      this.isReady = true;
    } else {
      this.isReady = false;
    }

    this.match = this.match.bind(this);
  }

  IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(this.isReady, 6) : (0, _tsInvariant.invariant)(this.isReady, 'FragmentMatcher.match() was called before FragmentMatcher.init()');
    var obj = context.store.get(idValue.id);
    var isRootQuery = idValue.id === 'ROOT_QUERY';

    if (!obj) {
      return isRootQuery;
    }

    var _a = obj.__typename,
        __typename = _a === void 0 ? isRootQuery && 'Query' : _a;

    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(__typename, 7) : (0, _tsInvariant.invariant)(__typename, "Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));

    if (__typename === typeCondition) {
      return true;
    }

    var implementingTypes = this.possibleTypesMap[typeCondition];

    if (__typename && implementingTypes && implementingTypes.indexOf(__typename) > -1) {
      return true;
    }

    return false;
  };

  IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {
    var typeMap = {};

    introspectionResultData.__schema.types.forEach(function (type) {
      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
        typeMap[type.name] = type.possibleTypes.map(function (implementingType) {
          return implementingType.name;
        });
      }
    });

    return typeMap;
  };

  return IntrospectionFragmentMatcher;
}();

exports.IntrospectionFragmentMatcher = IntrospectionFragmentMatcher;
var hasOwn = Object.prototype.hasOwnProperty;

var DepTrackingCache = function () {
  function DepTrackingCache(data) {
    var _this = this;

    if (data === void 0) {
      data = Object.create(null);
    }

    this.data = data;
    this.depend = (0, _optimism.wrap)(function (dataId) {
      return _this.data[dataId];
    }, {
      disposable: true,
      makeCacheKey: function (dataId) {
        return dataId;
      }
    });
  }

  DepTrackingCache.prototype.toObject = function () {
    return this.data;
  };

  DepTrackingCache.prototype.get = function (dataId) {
    this.depend(dataId);
    return this.data[dataId];
  };

  DepTrackingCache.prototype.set = function (dataId, value) {
    var oldValue = this.data[dataId];

    if (value !== oldValue) {
      this.data[dataId] = value;
      this.depend.dirty(dataId);
    }
  };

  DepTrackingCache.prototype.delete = function (dataId) {
    if (hasOwn.call(this.data, dataId)) {
      delete this.data[dataId];
      this.depend.dirty(dataId);
    }
  };

  DepTrackingCache.prototype.clear = function () {
    this.replace(null);
  };

  DepTrackingCache.prototype.replace = function (newData) {
    var _this = this;

    if (newData) {
      Object.keys(newData).forEach(function (dataId) {
        _this.set(dataId, newData[dataId]);
      });
      Object.keys(this.data).forEach(function (dataId) {
        if (!hasOwn.call(newData, dataId)) {
          _this.delete(dataId);
        }
      });
    } else {
      Object.keys(this.data).forEach(function (dataId) {
        _this.delete(dataId);
      });
    }
  };

  return DepTrackingCache;
}();

function defaultNormalizedCacheFactory(seed) {
  return new DepTrackingCache(seed);
}

var StoreReader = function () {
  function StoreReader(_a) {
    var _this = this;

    var _b = _a === void 0 ? {} : _a,
        _c = _b.cacheKeyRoot,
        cacheKeyRoot = _c === void 0 ? new _optimism.KeyTrie(_apolloUtilities.canUseWeakMap) : _c,
        _d = _b.freezeResults,
        freezeResults = _d === void 0 ? false : _d;

    var _e = this,
        executeStoreQuery = _e.executeStoreQuery,
        executeSelectionSet = _e.executeSelectionSet,
        executeSubSelectedArray = _e.executeSubSelectedArray;

    this.freezeResults = freezeResults;
    this.executeStoreQuery = (0, _optimism.wrap)(function (options) {
      return executeStoreQuery.call(_this, options);
    }, {
      makeCacheKey: function (_a) {
        var query = _a.query,
            rootValue = _a.rootValue,
            contextValue = _a.contextValue,
            variableValues = _a.variableValues,
            fragmentMatcher = _a.fragmentMatcher;

        if (contextValue.store instanceof DepTrackingCache) {
          return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
        }
      }
    });
    this.executeSelectionSet = (0, _optimism.wrap)(function (options) {
      return executeSelectionSet.call(_this, options);
    }, {
      makeCacheKey: function (_a) {
        var selectionSet = _a.selectionSet,
            rootValue = _a.rootValue,
            execContext = _a.execContext;

        if (execContext.contextValue.store instanceof DepTrackingCache) {
          return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
        }
      }
    });
    this.executeSubSelectedArray = (0, _optimism.wrap)(function (options) {
      return executeSubSelectedArray.call(_this, options);
    }, {
      makeCacheKey: function (_a) {
        var field = _a.field,
            array = _a.array,
            execContext = _a.execContext;

        if (execContext.contextValue.store instanceof DepTrackingCache) {
          return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
        }
      }
    });
  }

  StoreReader.prototype.readQueryFromStore = function (options) {
    return this.diffQueryAgainstStore((0, _tslib.__assign)({}, options, {
      returnPartialData: false
    })).result;
  };

  StoreReader.prototype.diffQueryAgainstStore = function (_a) {
    var store = _a.store,
        query = _a.query,
        variables = _a.variables,
        previousResult = _a.previousResult,
        _b = _a.returnPartialData,
        returnPartialData = _b === void 0 ? true : _b,
        _c = _a.rootId,
        rootId = _c === void 0 ? 'ROOT_QUERY' : _c,
        fragmentMatcherFunction = _a.fragmentMatcherFunction,
        config = _a.config;
    var queryDefinition = (0, _apolloUtilities.getQueryDefinition)(query);
    variables = (0, _apolloUtilities.assign)({}, (0, _apolloUtilities.getDefaultValues)(queryDefinition), variables);
    var context = {
      store: store,
      dataIdFromObject: config && config.dataIdFromObject,
      cacheRedirects: config && config.cacheRedirects || {}
    };
    var execResult = this.executeStoreQuery({
      query: query,
      rootValue: {
        type: 'id',
        id: rootId,
        generated: true,
        typename: 'Query'
      },
      contextValue: context,
      variableValues: variables,
      fragmentMatcher: fragmentMatcherFunction
    });
    var hasMissingFields = execResult.missing && execResult.missing.length > 0;

    if (hasMissingFields && !returnPartialData) {
      execResult.missing.forEach(function (info) {
        if (info.tolerable) return;
        throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(8) : new _tsInvariant.InvariantError("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
      });
    }

    if (previousResult) {
      if ((0, _apolloUtilities.isEqual)(previousResult, execResult.result)) {
        execResult.result = previousResult;
      }
    }

    return {
      result: execResult.result,
      complete: !hasMissingFields
    };
  };

  StoreReader.prototype.executeStoreQuery = function (_a) {
    var query = _a.query,
        rootValue = _a.rootValue,
        contextValue = _a.contextValue,
        variableValues = _a.variableValues,
        _b = _a.fragmentMatcher,
        fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
    var mainDefinition = (0, _apolloUtilities.getMainDefinition)(query);
    var fragments = (0, _apolloUtilities.getFragmentDefinitions)(query);
    var fragmentMap = (0, _apolloUtilities.createFragmentMap)(fragments);
    var execContext = {
      query: query,
      fragmentMap: fragmentMap,
      contextValue: contextValue,
      variableValues: variableValues,
      fragmentMatcher: fragmentMatcher
    };
    return this.executeSelectionSet({
      selectionSet: mainDefinition.selectionSet,
      rootValue: rootValue,
      execContext: execContext
    });
  };

  StoreReader.prototype.executeSelectionSet = function (_a) {
    var _this = this;

    var selectionSet = _a.selectionSet,
        rootValue = _a.rootValue,
        execContext = _a.execContext;
    var fragmentMap = execContext.fragmentMap,
        contextValue = execContext.contextValue,
        variables = execContext.variableValues;
    var finalResult = {
      result: null
    };
    var objectsToMerge = [];
    var object = contextValue.store.get(rootValue.id);
    var typename = object && object.__typename || rootValue.id === 'ROOT_QUERY' && 'Query' || void 0;

    function handleMissing(result) {
      var _a;

      if (result.missing) {
        finalResult.missing = finalResult.missing || [];

        (_a = finalResult.missing).push.apply(_a, result.missing);
      }

      return result.result;
    }

    selectionSet.selections.forEach(function (selection) {
      var _a;

      if (!(0, _apolloUtilities.shouldInclude)(selection, variables)) {
        return;
      }

      if ((0, _apolloUtilities.isField)(selection)) {
        var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));

        if (typeof fieldResult !== 'undefined') {
          objectsToMerge.push((_a = {}, _a[(0, _apolloUtilities.resultKeyNameFromField)(selection)] = fieldResult, _a));
        }
      } else {
        var fragment = void 0;

        if ((0, _apolloUtilities.isInlineFragment)(selection)) {
          fragment = selection;
        } else {
          fragment = fragmentMap[selection.name.value];

          if (!fragment) {
            throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(9) : new _tsInvariant.InvariantError("No fragment named " + selection.name.value);
          }
        }

        var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;
        var match = !typeCondition || execContext.fragmentMatcher(rootValue, typeCondition, contextValue);

        if (match) {
          var fragmentExecResult = _this.executeSelectionSet({
            selectionSet: fragment.selectionSet,
            rootValue: rootValue,
            execContext: execContext
          });

          if (match === 'heuristic' && fragmentExecResult.missing) {
            fragmentExecResult = (0, _tslib.__assign)({}, fragmentExecResult, {
              missing: fragmentExecResult.missing.map(function (info) {
                return (0, _tslib.__assign)({}, info, {
                  tolerable: true
                });
              })
            });
          }

          objectsToMerge.push(handleMissing(fragmentExecResult));
        }
      }
    });
    finalResult.result = (0, _apolloUtilities.mergeDeepArray)(objectsToMerge);

    if (this.freezeResults && process.env.NODE_ENV !== 'production') {
      Object.freeze(finalResult.result);
    }

    return finalResult;
  };

  StoreReader.prototype.executeField = function (object, typename, field, execContext) {
    var variables = execContext.variableValues,
        contextValue = execContext.contextValue;
    var fieldName = field.name.value;
    var args = (0, _apolloUtilities.argumentsObjectFromField)(field, variables);
    var info = {
      resultKey: (0, _apolloUtilities.resultKeyNameFromField)(field),
      directives: (0, _apolloUtilities.getDirectiveInfoFromField)(field, variables)
    };
    var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);

    if (Array.isArray(readStoreResult.result)) {
      return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
        field: field,
        array: readStoreResult.result,
        execContext: execContext
      }));
    }

    if (!field.selectionSet) {
      assertSelectionSetForIdValue(field, readStoreResult.result);

      if (this.freezeResults && process.env.NODE_ENV !== 'production') {
        (0, _apolloUtilities.maybeDeepFreeze)(readStoreResult);
      }

      return readStoreResult;
    }

    if (readStoreResult.result == null) {
      return readStoreResult;
    }

    return this.combineExecResults(readStoreResult, this.executeSelectionSet({
      selectionSet: field.selectionSet,
      rootValue: readStoreResult.result,
      execContext: execContext
    }));
  };

  StoreReader.prototype.combineExecResults = function () {
    var execResults = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      execResults[_i] = arguments[_i];
    }

    var missing;
    execResults.forEach(function (execResult) {
      if (execResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, execResult.missing);
      }
    });
    return {
      result: execResults.pop().result,
      missing: missing
    };
  };

  StoreReader.prototype.executeSubSelectedArray = function (_a) {
    var _this = this;

    var field = _a.field,
        array = _a.array,
        execContext = _a.execContext;
    var missing;

    function handleMissing(childResult) {
      if (childResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, childResult.missing);
      }

      return childResult.result;
    }

    array = array.map(function (item) {
      if (item === null) {
        return null;
      }

      if (Array.isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field: field,
          array: item,
          execContext: execContext
        }));
      }

      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          rootValue: item,
          execContext: execContext
        }));
      }

      assertSelectionSetForIdValue(field, item);
      return item;
    });

    if (this.freezeResults && process.env.NODE_ENV !== 'production') {
      Object.freeze(array);
    }

    return {
      result: array,
      missing: missing
    };
  };

  return StoreReader;
}();

exports.StoreReader = StoreReader;

function assertSelectionSetForIdValue(field, value) {
  if (!field.selectionSet && (0, _apolloUtilities.isIdValue)(value)) {
    throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(10) : new _tsInvariant.InvariantError("Missing selection set for object of type " + value.typename + " returned for query field " + field.name.value);
  }
}

function defaultFragmentMatcher() {
  return true;
}

function assertIdValue(idValue) {
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)((0, _apolloUtilities.isIdValue)(idValue), 11) : (0, _tsInvariant.invariant)((0, _apolloUtilities.isIdValue)(idValue), "Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.");
}

function readStoreResolver(object, typename, fieldName, args, context, _a) {
  var resultKey = _a.resultKey,
      directives = _a.directives;
  var storeKeyName = fieldName;

  if (args || directives) {
    storeKeyName = (0, _apolloUtilities.getStoreKeyName)(storeKeyName, args, directives);
  }

  var fieldValue = void 0;

  if (object) {
    fieldValue = object[storeKeyName];

    if (typeof fieldValue === 'undefined' && context.cacheRedirects && typeof typename === 'string') {
      var type = context.cacheRedirects[typename];

      if (type) {
        var resolver = type[fieldName];

        if (resolver) {
          fieldValue = resolver(object, args, {
            getCacheKey: function (storeObj) {
              var id = context.dataIdFromObject(storeObj);
              return id && (0, _apolloUtilities.toIdValue)({
                id: id,
                typename: storeObj.__typename
              });
            }
          });
        }
      }
    }
  }

  if (typeof fieldValue === 'undefined') {
    return {
      result: fieldValue,
      missing: [{
        object: object,
        fieldName: storeKeyName,
        tolerable: false
      }]
    };
  }

  if ((0, _apolloUtilities.isJsonValue)(fieldValue)) {
    fieldValue = fieldValue.json;
  }

  return {
    result: fieldValue
  };
}

var ObjectCache = function () {
  function ObjectCache(data) {
    if (data === void 0) {
      data = Object.create(null);
    }

    this.data = data;
  }

  ObjectCache.prototype.toObject = function () {
    return this.data;
  };

  ObjectCache.prototype.get = function (dataId) {
    return this.data[dataId];
  };

  ObjectCache.prototype.set = function (dataId, value) {
    this.data[dataId] = value;
  };

  ObjectCache.prototype.delete = function (dataId) {
    this.data[dataId] = void 0;
  };

  ObjectCache.prototype.clear = function () {
    this.data = Object.create(null);
  };

  ObjectCache.prototype.replace = function (newData) {
    this.data = newData || Object.create(null);
  };

  return ObjectCache;
}();

exports.ObjectCache = ObjectCache;

function defaultNormalizedCacheFactory$1(seed) {
  return new ObjectCache(seed);
}

var WriteError = function (_super) {
  (0, _tslib.__extends)(WriteError, _super);

  function WriteError() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'WriteError';
    return _this;
  }

  return WriteError;
}(Error);

exports.WriteError = WriteError;

function enhanceErrorWithDocument(error, document) {
  var enhancedError = new WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
  enhancedError.message += '\n' + error.message;
  enhancedError.stack = error.stack;
  return enhancedError;
}

var StoreWriter = function () {
  function StoreWriter() {}

  StoreWriter.prototype.writeQueryToStore = function (_a) {
    var query = _a.query,
        result = _a.result,
        _b = _a.store,
        store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,
        variables = _a.variables,
        dataIdFromObject = _a.dataIdFromObject,
        fragmentMatcherFunction = _a.fragmentMatcherFunction;
    return this.writeResultToStore({
      dataId: 'ROOT_QUERY',
      result: result,
      document: query,
      store: store,
      variables: variables,
      dataIdFromObject: dataIdFromObject,
      fragmentMatcherFunction: fragmentMatcherFunction
    });
  };

  StoreWriter.prototype.writeResultToStore = function (_a) {
    var dataId = _a.dataId,
        result = _a.result,
        document = _a.document,
        _b = _a.store,
        store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,
        variables = _a.variables,
        dataIdFromObject = _a.dataIdFromObject,
        fragmentMatcherFunction = _a.fragmentMatcherFunction;
    var operationDefinition = (0, _apolloUtilities.getOperationDefinition)(document);

    try {
      return this.writeSelectionSetToStore({
        result: result,
        dataId: dataId,
        selectionSet: operationDefinition.selectionSet,
        context: {
          store: store,
          processedData: {},
          variables: (0, _apolloUtilities.assign)({}, (0, _apolloUtilities.getDefaultValues)(operationDefinition), variables),
          dataIdFromObject: dataIdFromObject,
          fragmentMap: (0, _apolloUtilities.createFragmentMap)((0, _apolloUtilities.getFragmentDefinitions)(document)),
          fragmentMatcherFunction: fragmentMatcherFunction
        }
      });
    } catch (e) {
      throw enhanceErrorWithDocument(e, document);
    }
  };

  StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
    var _this = this;

    var result = _a.result,
        dataId = _a.dataId,
        selectionSet = _a.selectionSet,
        context = _a.context;
    var variables = context.variables,
        store = context.store,
        fragmentMap = context.fragmentMap;
    selectionSet.selections.forEach(function (selection) {
      var _a;

      if (!(0, _apolloUtilities.shouldInclude)(selection, variables)) {
        return;
      }

      if ((0, _apolloUtilities.isField)(selection)) {
        var resultFieldKey = (0, _apolloUtilities.resultKeyNameFromField)(selection);
        var value = result[resultFieldKey];

        if (typeof value !== 'undefined') {
          _this.writeFieldToStore({
            dataId: dataId,
            value: value,
            field: selection,
            context: context
          });
        } else {
          var isDefered = false;
          var isClient = false;

          if (selection.directives && selection.directives.length) {
            isDefered = selection.directives.some(function (directive) {
              return directive.name && directive.name.value === 'defer';
            });
            isClient = selection.directives.some(function (directive) {
              return directive.name && directive.name.value === 'client';
            });
          }

          if (!isDefered && !isClient && context.fragmentMatcherFunction) {
            process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
          }
        }
      } else {
        var fragment = void 0;

        if ((0, _apolloUtilities.isInlineFragment)(selection)) {
          fragment = selection;
        } else {
          fragment = (fragmentMap || {})[selection.name.value];
          process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(fragment, 2) : (0, _tsInvariant.invariant)(fragment, "No fragment named " + selection.name.value + ".");
        }

        var matches = true;

        if (context.fragmentMatcherFunction && fragment.typeCondition) {
          var id = dataId || 'self';
          var idValue = (0, _apolloUtilities.toIdValue)({
            id: id,
            typename: undefined
          });
          var fakeContext = {
            store: new ObjectCache((_a = {}, _a[id] = result, _a)),
            cacheRedirects: {}
          };
          var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);

          if (!(0, _apolloUtilities.isProduction)() && match === 'heuristic') {
            process.env.NODE_ENV === "production" || _tsInvariant.invariant.error('WARNING: heuristic fragment matching going on!');
          }

          matches = !!match;
        }

        if (matches) {
          _this.writeSelectionSetToStore({
            result: result,
            selectionSet: fragment.selectionSet,
            dataId: dataId,
            context: context
          });
        }
      }
    });
    return store;
  };

  StoreWriter.prototype.writeFieldToStore = function (_a) {
    var _b;

    var field = _a.field,
        value = _a.value,
        dataId = _a.dataId,
        context = _a.context;
    var variables = context.variables,
        dataIdFromObject = context.dataIdFromObject,
        store = context.store;
    var storeValue;
    var storeObject;
    var storeFieldName = (0, _apolloUtilities.storeKeyNameFromField)(field, variables);

    if (!field.selectionSet || value === null) {
      storeValue = value != null && typeof value === 'object' ? {
        type: 'json',
        json: value
      } : value;
    } else if (Array.isArray(value)) {
      var generatedId = dataId + "." + storeFieldName;
      storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
    } else {
      var valueDataId = dataId + "." + storeFieldName;
      var generated = true;

      if (!isGeneratedId(valueDataId)) {
        valueDataId = '$' + valueDataId;
      }

      if (dataIdFromObject) {
        var semanticId = dataIdFromObject(value);
        process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!semanticId || !isGeneratedId(semanticId), 3) : (0, _tsInvariant.invariant)(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the "$" character.');

        if (semanticId || typeof semanticId === 'number' && semanticId === 0) {
          valueDataId = semanticId;
          generated = false;
        }
      }

      if (!isDataProcessed(valueDataId, field, context.processedData)) {
        this.writeSelectionSetToStore({
          dataId: valueDataId,
          result: value,
          selectionSet: field.selectionSet,
          context: context
        });
      }

      var typename = value.__typename;
      storeValue = (0, _apolloUtilities.toIdValue)({
        id: valueDataId,
        typename: typename
      }, generated);
      storeObject = store.get(dataId);
      var escapedId = storeObject && storeObject[storeFieldName];

      if (escapedId !== storeValue && (0, _apolloUtilities.isIdValue)(escapedId)) {
        var hadTypename = escapedId.typename !== undefined;
        var hasTypename = typename !== undefined;
        var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
        process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!generated || escapedId.generated || typenameChanged, 4) : (0, _tsInvariant.invariant)(!generated || escapedId.generated || typenameChanged, "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + escapedId.id + " for this object. The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
        process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!hadTypename || hasTypename, 5) : (0, _tsInvariant.invariant)(!hadTypename || hasTypename, "Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet that was trying to be written is:\n" + JSON.stringify(field));

        if (escapedId.generated) {
          if (typenameChanged) {
            if (!generated) {
              store.delete(escapedId.id);
            }
          } else {
            mergeWithGenerated(escapedId.id, storeValue.id, store);
          }
        }
      }
    }

    storeObject = store.get(dataId);

    if (!storeObject || !(0, _apolloUtilities.isEqual)(storeValue, storeObject[storeFieldName])) {
      store.set(dataId, (0, _tslib.__assign)({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));
    }
  };

  StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
    var _this = this;

    return value.map(function (item, index) {
      if (item === null) {
        return null;
      }

      var itemDataId = generatedId + "." + index;

      if (Array.isArray(item)) {
        return _this.processArrayValue(item, itemDataId, selectionSet, context);
      }

      var generated = true;

      if (context.dataIdFromObject) {
        var semanticId = context.dataIdFromObject(item);

        if (semanticId) {
          itemDataId = semanticId;
          generated = false;
        }
      }

      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
        _this.writeSelectionSetToStore({
          dataId: itemDataId,
          result: item,
          selectionSet: selectionSet,
          context: context
        });
      }

      return (0, _apolloUtilities.toIdValue)({
        id: itemDataId,
        typename: item.__typename
      }, generated);
    });
  };

  return StoreWriter;
}();

exports.StoreWriter = StoreWriter;

function isGeneratedId(id) {
  return id[0] === '$';
}

function mergeWithGenerated(generatedKey, realKey, cache) {
  if (generatedKey === realKey) {
    return false;
  }

  var generated = cache.get(generatedKey);
  var real = cache.get(realKey);
  var madeChanges = false;
  Object.keys(generated).forEach(function (key) {
    var value = generated[key];
    var realValue = real[key];

    if ((0, _apolloUtilities.isIdValue)(value) && isGeneratedId(value.id) && (0, _apolloUtilities.isIdValue)(realValue) && !(0, _apolloUtilities.isEqual)(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {
      madeChanges = true;
    }
  });
  cache.delete(generatedKey);
  var newRealValue = (0, _tslib.__assign)({}, generated, real);

  if ((0, _apolloUtilities.isEqual)(newRealValue, real)) {
    return madeChanges;
  }

  cache.set(realKey, newRealValue);
  return true;
}

function isDataProcessed(dataId, field, processedData) {
  if (!processedData) {
    return false;
  }

  if (processedData[dataId]) {
    if (processedData[dataId].indexOf(field) >= 0) {
      return true;
    } else {
      processedData[dataId].push(field);
    }
  } else {
    processedData[dataId] = [field];
  }

  return false;
}

var defaultConfig = {
  fragmentMatcher: new HeuristicFragmentMatcher(),
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  freezeResults: false
};

function defaultDataIdFromObject(result) {
  if (result.__typename) {
    if (result.id !== undefined) {
      return result.__typename + ":" + result.id;
    }

    if (result._id !== undefined) {
      return result.__typename + ":" + result._id;
    }
  }

  return null;
}

var hasOwn$1 = Object.prototype.hasOwnProperty;

var OptimisticCacheLayer = function (_super) {
  (0, _tslib.__extends)(OptimisticCacheLayer, _super);

  function OptimisticCacheLayer(optimisticId, parent, transaction) {
    var _this = _super.call(this, Object.create(null)) || this;

    _this.optimisticId = optimisticId;
    _this.parent = parent;
    _this.transaction = transaction;
    return _this;
  }

  OptimisticCacheLayer.prototype.toObject = function () {
    return (0, _tslib.__assign)({}, this.parent.toObject(), this.data);
  };

  OptimisticCacheLayer.prototype.get = function (dataId) {
    return hasOwn$1.call(this.data, dataId) ? this.data[dataId] : this.parent.get(dataId);
  };

  return OptimisticCacheLayer;
}(ObjectCache);

var InMemoryCache = function (_super) {
  (0, _tslib.__extends)(InMemoryCache, _super);

  function InMemoryCache(config) {
    if (config === void 0) {
      config = {};
    }

    var _this = _super.call(this) || this;

    _this.watches = new Set();
    _this.typenameDocumentCache = new Map();
    _this.cacheKeyRoot = new _optimism.KeyTrie(_apolloUtilities.canUseWeakMap);
    _this.silenceBroadcast = false;
    _this.config = (0, _tslib.__assign)({}, defaultConfig, config);

    if (_this.config.customResolvers) {
      process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');
      _this.config.cacheRedirects = _this.config.customResolvers;
    }

    if (_this.config.cacheResolvers) {
      process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');
      _this.config.cacheRedirects = _this.config.cacheResolvers;
    }

    _this.addTypename = !!_this.config.addTypename;
    _this.data = _this.config.resultCaching ? new DepTrackingCache() : new ObjectCache();
    _this.optimisticData = _this.data;
    _this.storeWriter = new StoreWriter();
    _this.storeReader = new StoreReader({
      cacheKeyRoot: _this.cacheKeyRoot,
      freezeResults: config.freezeResults
    });
    var cache = _this;
    var maybeBroadcastWatch = cache.maybeBroadcastWatch;
    _this.maybeBroadcastWatch = (0, _optimism.wrap)(function (c) {
      return maybeBroadcastWatch.call(_this, c);
    }, {
      makeCacheKey: function (c) {
        if (c.optimistic) {
          return;
        }

        if (c.previousResult) {
          return;
        }

        if (cache.data instanceof DepTrackingCache) {
          return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
        }
      }
    });
    return _this;
  }

  InMemoryCache.prototype.restore = function (data) {
    if (data) this.data.replace(data);
    return this;
  };

  InMemoryCache.prototype.extract = function (optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return (optimistic ? this.optimisticData : this.data).toObject();
  };

  InMemoryCache.prototype.read = function (options) {
    if (typeof options.rootId === 'string' && typeof this.data.get(options.rootId) === 'undefined') {
      return null;
    }

    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    return this.storeReader.readQueryFromStore({
      store: options.optimistic ? this.optimisticData : this.data,
      query: this.transformDocument(options.query),
      variables: options.variables,
      rootId: options.rootId,
      fragmentMatcherFunction: fragmentMatcherFunction,
      previousResult: options.previousResult,
      config: this.config
    }) || null;
  };

  InMemoryCache.prototype.write = function (write) {
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    this.storeWriter.writeResultToStore({
      dataId: write.dataId,
      result: write.result,
      variables: write.variables,
      document: this.transformDocument(write.query),
      store: this.data,
      dataIdFromObject: this.config.dataIdFromObject,
      fragmentMatcherFunction: fragmentMatcherFunction
    });
    this.broadcastWatches();
  };

  InMemoryCache.prototype.diff = function (query) {
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    return this.storeReader.diffQueryAgainstStore({
      store: query.optimistic ? this.optimisticData : this.data,
      query: this.transformDocument(query.query),
      variables: query.variables,
      returnPartialData: query.returnPartialData,
      previousResult: query.previousResult,
      fragmentMatcherFunction: fragmentMatcherFunction,
      config: this.config
    });
  };

  InMemoryCache.prototype.watch = function (watch) {
    var _this = this;

    this.watches.add(watch);
    return function () {
      _this.watches.delete(watch);
    };
  };

  InMemoryCache.prototype.evict = function (query) {
    throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(1) : new _tsInvariant.InvariantError("eviction is not implemented on InMemory Cache");
  };

  InMemoryCache.prototype.reset = function () {
    this.data.clear();
    this.broadcastWatches();
    return Promise.resolve();
  };

  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
    var toReapply = [];
    var removedCount = 0;
    var layer = this.optimisticData;

    while (layer instanceof OptimisticCacheLayer) {
      if (layer.optimisticId === idToRemove) {
        ++removedCount;
      } else {
        toReapply.push(layer);
      }

      layer = layer.parent;
    }

    if (removedCount > 0) {
      this.optimisticData = layer;

      while (toReapply.length > 0) {
        var layer_1 = toReapply.pop();
        this.performTransaction(layer_1.transaction, layer_1.optimisticId);
      }

      this.broadcastWatches();
    }
  };

  InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {
    var _a = this,
        data = _a.data,
        silenceBroadcast = _a.silenceBroadcast;

    this.silenceBroadcast = true;

    if (typeof optimisticId === 'string') {
      this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
    }

    try {
      transaction(this);
    } finally {
      this.silenceBroadcast = silenceBroadcast;
      this.data = data;
    }

    this.broadcastWatches();
  };

  InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
    return this.performTransaction(transaction, id);
  };

  InMemoryCache.prototype.transformDocument = function (document) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document);

      if (!result) {
        result = (0, _apolloUtilities.addTypenameToDocument)(document);
        this.typenameDocumentCache.set(document, result);
        this.typenameDocumentCache.set(result, result);
      }

      return result;
    }

    return document;
  };

  InMemoryCache.prototype.broadcastWatches = function () {
    var _this = this;

    if (!this.silenceBroadcast) {
      this.watches.forEach(function (c) {
        return _this.maybeBroadcastWatch(c);
      });
    }
  };

  InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
    c.callback(this.diff({
      query: c.query,
      variables: c.variables,
      previousResult: c.previousResult && c.previousResult(),
      optimistic: c.optimistic
    }));
  };

  return InMemoryCache;
}(_apolloCache.ApolloCache);


exports.InMemoryCache = InMemoryCache;

}).call(this,req('_process'))
},{"_process":307,"apollo-cache":7,"apollo-utilities":16,"optimism":243,"ts-invariant":259,"tslib":260}],7:[function(req,module,exports){
exports.__esModule = true;
exports.Cache = exports.ApolloCache = void 0;

var _apolloUtilities = req("apollo-utilities");

function queryFromPojo(obj) {
  var op = {
    kind: 'OperationDefinition',
    operation: 'query',
    name: {
      kind: 'Name',
      value: 'GeneratedClientQuery'
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: 'Document',
    definitions: [op]
  };
  return out;
}

function fragmentFromPojo(obj, typename) {
  var frag = {
    kind: 'FragmentDefinition',
    typeCondition: {
      kind: 'NamedType',
      name: {
        kind: 'Name',
        value: typename || '__FakeType'
      }
    },
    name: {
      kind: 'Name',
      value: 'GeneratedClientQuery'
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: 'Document',
    definitions: [frag]
  };
  return out;
}

function selectionSetFromObj(obj) {
  if (typeof obj === 'number' || typeof obj === 'boolean' || typeof obj === 'string' || typeof obj === 'undefined' || obj === null) {
    return null;
  }

  if (Array.isArray(obj)) {
    return selectionSetFromObj(obj[0]);
  }

  var selections = [];
  Object.keys(obj).forEach(function (key) {
    var nestedSelSet = selectionSetFromObj(obj[key]);
    var field = {
      kind: 'Field',
      name: {
        kind: 'Name',
        value: key
      },
      selectionSet: nestedSelSet || undefined
    };
    selections.push(field);
  });
  var selectionSet = {
    kind: 'SelectionSet',
    selections: selections
  };
  return selectionSet;
}

var justTypenameQuery = {
  kind: 'Document',
  definitions: [{
    kind: 'OperationDefinition',
    operation: 'query',
    name: null,
    variableDefinitions: null,
    directives: [],
    selectionSet: {
      kind: 'SelectionSet',
      selections: [{
        kind: 'Field',
        alias: null,
        name: {
          kind: 'Name',
          value: '__typename'
        },
        arguments: [],
        directives: [],
        selectionSet: null
      }]
    }
  }]
};

var ApolloCache = function () {
  function ApolloCache() {}

  ApolloCache.prototype.transformDocument = function (document) {
    return document;
  };

  ApolloCache.prototype.transformForLink = function (document) {
    return document;
  };

  ApolloCache.prototype.readQuery = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: options.query,
      variables: options.variables,
      optimistic: optimistic
    });
  };

  ApolloCache.prototype.readFragment = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: (0, _apolloUtilities.getFragmentQueryDocument)(options.fragment, options.fragmentName),
      variables: options.variables,
      rootId: options.id,
      optimistic: optimistic
    });
  };

  ApolloCache.prototype.writeQuery = function (options) {
    this.write({
      dataId: 'ROOT_QUERY',
      result: options.data,
      query: options.query,
      variables: options.variables
    });
  };

  ApolloCache.prototype.writeFragment = function (options) {
    this.write({
      dataId: options.id,
      result: options.data,
      variables: options.variables,
      query: (0, _apolloUtilities.getFragmentQueryDocument)(options.fragment, options.fragmentName)
    });
  };

  ApolloCache.prototype.writeData = function (_a) {
    var id = _a.id,
        data = _a.data;

    if (typeof id !== 'undefined') {
      var typenameResult = null;

      try {
        typenameResult = this.read({
          rootId: id,
          optimistic: false,
          query: justTypenameQuery
        });
      } catch (e) {}

      var __typename = typenameResult && typenameResult.__typename || '__ClientData';

      var dataToWrite = Object.assign({
        __typename: __typename
      }, data);
      this.writeFragment({
        id: id,
        fragment: fragmentFromPojo(dataToWrite, __typename),
        data: dataToWrite
      });
    } else {
      this.writeQuery({
        query: queryFromPojo(data),
        data: data
      });
    }
  };

  return ApolloCache;
}();

exports.ApolloCache = ApolloCache;
var Cache;
exports.Cache = Cache;

(function (Cache) {})(Cache || (exports.Cache = Cache = {}));

},{"apollo-utilities":16}],8:[function(req,module,exports){
(function (process){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "tslib", "apollo-utilities", "apollo-link", "symbol-observable", "ts-invariant", "graphql/language/visitor"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, req("tslib"), req("apollo-utilities"), req("apollo-link"), req("symbol-observable"), req("ts-invariant"), req("graphql/language/visitor"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.tslib, global.apolloUtilities, global.apolloLink, global.symbolObservable, global.tsInvariant, global.visitor);
    global.unknown = mod.exports;
  }
})(this, function (_exports, _tslib, _apolloUtilities, _apolloLink, _symbolObservable, _tsInvariant, _visitor) {

  _exports.__esModule = true;
  _exports.isApolloError = isApolloError;
  _exports.ObservableQuery = _exports.NetworkStatus = _exports.FetchType = _exports.ApolloError = _exports.ApolloClient = _exports.default = void 0;
  _symbolObservable = _interopreqDefault(_symbolObservable);

  function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var NetworkStatus;
  _exports.NetworkStatus = NetworkStatus;

  (function (NetworkStatus) {
    NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
    NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
    NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
    NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
    NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
    NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
    NetworkStatus[NetworkStatus["error"] = 8] = "error";
  })(NetworkStatus || (_exports.NetworkStatus = NetworkStatus = {}));

  function isNetworkRequestInFlight(networkStatus) {
    return networkStatus < 7;
  }

  var Observable = function (_super) {
    (0, _tslib.__extends)(Observable, _super);

    function Observable() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    Observable.prototype[_symbolObservable.default] = function () {
      return this;
    };

    Observable.prototype['@@observable'] = function () {
      return this;
    };

    return Observable;
  }(_apolloLink.Observable);

  function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
  }

  function isApolloError(err) {
    return err.hasOwnProperty('graphQLErrors');
  }

  var generateErrorMessage = function (err) {
    var message = '';

    if (isNonEmptyArray(err.graphQLErrors)) {
      err.graphQLErrors.forEach(function (graphQLError) {
        var errorMessage = graphQLError ? graphQLError.message : 'Error message not found.';
        message += "GraphQL error: " + errorMessage + "\n";
      });
    }

    if (err.networkError) {
      message += 'Network error: ' + err.networkError.message + '\n';
    }

    message = message.replace(/\n$/, '');
    return message;
  };

  var ApolloError = function (_super) {
    (0, _tslib.__extends)(ApolloError, _super);

    function ApolloError(_a) {
      var graphQLErrors = _a.graphQLErrors,
          networkError = _a.networkError,
          errorMessage = _a.errorMessage,
          extraInfo = _a.extraInfo;

      var _this = _super.call(this, errorMessage) || this;

      _this.graphQLErrors = graphQLErrors || [];
      _this.networkError = networkError || null;

      if (!errorMessage) {
        _this.message = generateErrorMessage(_this);
      } else {
        _this.message = errorMessage;
      }

      _this.extraInfo = extraInfo;
      _this.__proto__ = ApolloError.prototype;
      return _this;
    }

    return ApolloError;
  }(Error);

  _exports.ApolloError = ApolloError;
  var FetchType;
  _exports.FetchType = FetchType;

  (function (FetchType) {
    FetchType[FetchType["normal"] = 1] = "normal";
    FetchType[FetchType["refetch"] = 2] = "refetch";
    FetchType[FetchType["poll"] = 3] = "poll";
  })(FetchType || (_exports.FetchType = FetchType = {}));

  var hasError = function (storeValue, policy) {
    if (policy === void 0) {
      policy = 'none';
    }

    return storeValue && (storeValue.networkError || policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors));
  };

  var ObservableQuery = function (_super) {
    (0, _tslib.__extends)(ObservableQuery, _super);

    function ObservableQuery(_a) {
      var queryManager = _a.queryManager,
          options = _a.options,
          _b = _a.shouldSubscribe,
          shouldSubscribe = _b === void 0 ? true : _b;

      var _this = _super.call(this, function (observer) {
        return _this.onSubscribe(observer);
      }) || this;

      _this.observers = new Set();
      _this.subscriptions = new Set();
      _this.isTornDown = false;
      _this.options = options;
      _this.variables = options.variables || {};
      _this.queryId = queryManager.generateQueryId();
      _this.shouldSubscribe = shouldSubscribe;
      var opDef = (0, _apolloUtilities.getOperationDefinition)(options.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      _this.queryManager = queryManager;
      return _this;
    }

    ObservableQuery.prototype.result = function () {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var observer = {
          next: function (result) {
            resolve(result);

            _this.observers.delete(observer);

            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }

            setTimeout(function () {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };

        var subscription = _this.subscribe(observer);
      });
    };

    ObservableQuery.prototype.currentResult = function () {
      var result = this.getCurrentResult();

      if (result.data === undefined) {
        result.data = {};
      }

      return result;
    };

    ObservableQuery.prototype.getCurrentResult = function () {
      if (this.isTornDown) {
        var lastResult = this.lastResult;
        return {
          data: !this.lastError && lastResult && lastResult.data || void 0,
          error: this.lastError,
          loading: false,
          networkStatus: NetworkStatus.error
        };
      }

      var _a = this.queryManager.getCurrentQueryResult(this),
          data = _a.data,
          partial = _a.partial;

      var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
      var result;
      var fetchPolicy = this.options.fetchPolicy;
      var isNetworkFetchPolicy = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';

      if (queryStoreValue) {
        var networkStatus = queryStoreValue.networkStatus;

        if (hasError(queryStoreValue, this.options.errorPolicy)) {
          return {
            data: void 0,
            loading: false,
            networkStatus: networkStatus,
            error: new ApolloError({
              graphQLErrors: queryStoreValue.graphQLErrors,
              networkError: queryStoreValue.networkError
            })
          };
        }

        if (queryStoreValue.variables) {
          this.options.variables = (0, _tslib.__assign)({}, this.options.variables, queryStoreValue.variables);
          this.variables = this.options.variables;
        }

        result = {
          data: data,
          loading: isNetworkRequestInFlight(networkStatus),
          networkStatus: networkStatus
        };

        if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {
          result.errors = queryStoreValue.graphQLErrors;
        }
      } else {
        var loading = isNetworkFetchPolicy || partial && fetchPolicy !== 'cache-only';
        result = {
          data: data,
          loading: loading,
          networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready
        };
      }

      if (!partial) {
        this.updateLastResult((0, _tslib.__assign)({}, result, {
          stale: false
        }));
      }

      return (0, _tslib.__assign)({}, result, {
        partial: partial
      });
    };

    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
      var snapshot = this.lastResultSnapshot;
      return !(snapshot && newResult && snapshot.networkStatus === newResult.networkStatus && snapshot.stale === newResult.stale && (0, _apolloUtilities.isEqual)(snapshot.data, newResult.data));
    };

    ObservableQuery.prototype.getLastResult = function () {
      return this.lastResult;
    };

    ObservableQuery.prototype.getLastError = function () {
      return this.lastError;
    };

    ObservableQuery.prototype.resetLastResults = function () {
      delete this.lastResult;
      delete this.lastResultSnapshot;
      delete this.lastError;
      this.isTornDown = false;
    };

    ObservableQuery.prototype.resetQueryStoreErrors = function () {
      var queryStore = this.queryManager.queryStore.get(this.queryId);

      if (queryStore) {
        queryStore.networkError = null;
        queryStore.graphQLErrors = [];
      }
    };

    ObservableQuery.prototype.refetch = function (variables) {
      var fetchPolicy = this.options.fetchPolicy;

      if (fetchPolicy === 'cache-only') {
        return Promise.reject(process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(3) : new _tsInvariant.InvariantError('cache-only fetchPolicy option should not be used together with query refetch.'));
      }

      if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'cache-and-network') {
        fetchPolicy = 'network-only';
      }

      if (!(0, _apolloUtilities.isEqual)(this.variables, variables)) {
        this.variables = (0, _tslib.__assign)({}, this.variables, variables);
      }

      if (!(0, _apolloUtilities.isEqual)(this.options.variables, this.variables)) {
        this.options.variables = (0, _tslib.__assign)({}, this.options.variables, this.variables);
      }

      return this.queryManager.fetchQuery(this.queryId, (0, _tslib.__assign)({}, this.options, {
        fetchPolicy: fetchPolicy
      }), FetchType.refetch);
    };

    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
      var _this = this;

      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(fetchMoreOptions.updateQuery, 4) : (0, _tsInvariant.invariant)(fetchMoreOptions.updateQuery, 'updateQuery option is reqd. This function defines how to update the query data with the new results.');
      var combinedOptions = (0, _tslib.__assign)({}, fetchMoreOptions.query ? fetchMoreOptions : (0, _tslib.__assign)({}, this.options, fetchMoreOptions, {
        variables: (0, _tslib.__assign)({}, this.variables, fetchMoreOptions.variables)
      }), {
        fetchPolicy: 'network-only'
      });
      var qid = this.queryManager.generateQueryId();
      return this.queryManager.fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId).then(function (fetchMoreResult) {
        _this.updateQuery(function (previousResult) {
          return fetchMoreOptions.updateQuery(previousResult, {
            fetchMoreResult: fetchMoreResult.data,
            variables: combinedOptions.variables
          });
        });

        _this.queryManager.stopQuery(qid);

        return fetchMoreResult;
      }, function (error) {
        _this.queryManager.stopQuery(qid);

        throw error;
      });
    };

    ObservableQuery.prototype.subscribeToMore = function (options) {
      var _this = this;

      var subscription = this.queryManager.startGraphQLSubscription({
        query: options.document,
        variables: options.variables
      }).subscribe({
        next: function (subscriptionData) {
          var updateQuery = options.updateQuery;

          if (updateQuery) {
            _this.updateQuery(function (previous, _a) {
              var variables = _a.variables;
              return updateQuery(previous, {
                subscriptionData: subscriptionData,
                variables: variables
              });
            });
          }
        },
        error: function (err) {
          if (options.onError) {
            options.onError(err);
            return;
          }

          process.env.NODE_ENV === "production" || _tsInvariant.invariant.error('Unhandled GraphQL subscription error', err);
        }
      });
      this.subscriptions.add(subscription);
      return function () {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };

    ObservableQuery.prototype.setOptions = function (opts) {
      var oldFetchPolicy = this.options.fetchPolicy;
      this.options = (0, _tslib.__assign)({}, this.options, opts);

      if (opts.pollInterval) {
        this.startPolling(opts.pollInterval);
      } else if (opts.pollInterval === 0) {
        this.stopPolling();
      }

      var fetchPolicy = opts.fetchPolicy;
      return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' || oldFetchPolicy === 'standby' || fetchPolicy === 'network-only'), opts.fetchResults);
    };

    ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
      if (tryFetch === void 0) {
        tryFetch = false;
      }

      if (fetchResults === void 0) {
        fetchResults = true;
      }

      this.isTornDown = false;
      variables = variables || this.variables;

      if (!tryFetch && (0, _apolloUtilities.isEqual)(variables, this.variables)) {
        return this.observers.size && fetchResults ? this.result() : Promise.resolve();
      }

      this.variables = this.options.variables = variables;

      if (!this.observers.size) {
        return Promise.resolve();
      }

      return this.queryManager.fetchQuery(this.queryId, this.options);
    };

    ObservableQuery.prototype.updateQuery = function (mapFn) {
      var queryManager = this.queryManager;

      var _a = queryManager.getQueryWithPreviousResult(this.queryId),
          previousResult = _a.previousResult,
          variables = _a.variables,
          document = _a.document;

      var newResult = (0, _apolloUtilities.tryFunctionOrLogError)(function () {
        return mapFn(previousResult, {
          variables: variables
        });
      });

      if (newResult) {
        queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
        queryManager.broadcastQueries();
      }
    };

    ObservableQuery.prototype.stopPolling = function () {
      this.queryManager.stopPollingQuery(this.queryId);
      this.options.pollInterval = undefined;
    };

    ObservableQuery.prototype.startPolling = function (pollInterval) {
      assertNotCacheFirstOrOnly(this);
      this.options.pollInterval = pollInterval;
      this.queryManager.startPollingQuery(this.options, this.queryId);
    };

    ObservableQuery.prototype.updateLastResult = function (newResult) {
      var previousResult = this.lastResult;
      this.lastResult = newResult;
      this.lastResultSnapshot = this.queryManager.assumeImmutableResults ? newResult : (0, _apolloUtilities.cloneDeep)(newResult);
      return previousResult;
    };

    ObservableQuery.prototype.onSubscribe = function (observer) {
      var _this = this;

      try {
        var subObserver = observer._subscription._observer;

        if (subObserver && !subObserver.error) {
          subObserver.error = defaultSubscriptionObserverErrorCallback;
        }
      } catch (_a) {}

      var first = !this.observers.size;
      this.observers.add(observer);
      if (observer.next && this.lastResult) observer.next(this.lastResult);
      if (observer.error && this.lastError) observer.error(this.lastError);

      if (first) {
        this.setUpQuery();
      }

      return function () {
        if (_this.observers.delete(observer) && !_this.observers.size) {
          _this.tearDownQuery();
        }
      };
    };

    ObservableQuery.prototype.setUpQuery = function () {
      var _this = this;

      var _a = this,
          queryManager = _a.queryManager,
          queryId = _a.queryId;

      if (this.shouldSubscribe) {
        queryManager.addObservableQuery(queryId, this);
      }

      if (this.options.pollInterval) {
        assertNotCacheFirstOrOnly(this);
        queryManager.startPollingQuery(this.options, queryId);
      }

      var onError = function (error) {
        _this.updateLastResult((0, _tslib.__assign)({}, _this.lastResult, {
          errors: error.graphQLErrors,
          networkStatus: NetworkStatus.error,
          loading: false
        }));

        iterateObserversSafely(_this.observers, 'error', _this.lastError = error);
      };

      queryManager.observeQuery(queryId, this.options, {
        next: function (result) {
          if (_this.lastError || _this.isDifferentFromLastResult(result)) {
            var previousResult_1 = _this.updateLastResult(result);

            var _a = _this.options,
                query_1 = _a.query,
                variables = _a.variables,
                fetchPolicy_1 = _a.fetchPolicy;

            if (queryManager.transform(query_1).hasClientExports) {
              queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {
                var previousVariables = _this.variables;
                _this.variables = _this.options.variables = variables;

                if (!result.loading && previousResult_1 && fetchPolicy_1 !== 'cache-only' && queryManager.transform(query_1).serverQuery && !(0, _apolloUtilities.isEqual)(previousVariables, variables)) {
                  _this.refetch();
                } else {
                  iterateObserversSafely(_this.observers, 'next', result);
                }
              });
            } else {
              iterateObserversSafely(_this.observers, 'next', result);
            }
          }
        },
        error: onError
      }).catch(onError);
    };

    ObservableQuery.prototype.tearDownQuery = function () {
      var queryManager = this.queryManager;
      this.isTornDown = true;
      queryManager.stopPollingQuery(this.queryId);
      this.subscriptions.forEach(function (sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      queryManager.removeObservableQuery(this.queryId);
      queryManager.stopQuery(this.queryId);
      this.observers.clear();
    };

    return ObservableQuery;
  }(Observable);

  _exports.ObservableQuery = ObservableQuery;

  function defaultSubscriptionObserverErrorCallback(error) {
    process.env.NODE_ENV === "production" || _tsInvariant.invariant.error('Unhandled error', error.message, error.stack);
  }

  function iterateObserversSafely(observers, method, argument) {
    var observersWithMethod = [];
    observers.forEach(function (obs) {
      return obs[method] && observersWithMethod.push(obs);
    });
    observersWithMethod.forEach(function (obs) {
      return obs[method](argument);
    });
  }

  function assertNotCacheFirstOrOnly(obsQuery) {
    var fetchPolicy = obsQuery.options.fetchPolicy;
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 5) : (0, _tsInvariant.invariant)(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
  }

  var MutationStore = function () {
    function MutationStore() {
      this.store = {};
    }

    MutationStore.prototype.getStore = function () {
      return this.store;
    };

    MutationStore.prototype.get = function (mutationId) {
      return this.store[mutationId];
    };

    MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {
      this.store[mutationId] = {
        mutation: mutation,
        variables: variables || {},
        loading: true,
        error: null
      };
    };

    MutationStore.prototype.markMutationError = function (mutationId, error) {
      var mutation = this.store[mutationId];

      if (mutation) {
        mutation.loading = false;
        mutation.error = error;
      }
    };

    MutationStore.prototype.markMutationResult = function (mutationId) {
      var mutation = this.store[mutationId];

      if (mutation) {
        mutation.loading = false;
        mutation.error = null;
      }
    };

    MutationStore.prototype.reset = function () {
      this.store = {};
    };

    return MutationStore;
  }();

  var QueryStore = function () {
    function QueryStore() {
      this.store = {};
    }

    QueryStore.prototype.getStore = function () {
      return this.store;
    };

    QueryStore.prototype.get = function (queryId) {
      return this.store[queryId];
    };

    QueryStore.prototype.initQuery = function (query) {
      var previousQuery = this.store[query.queryId];
      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!previousQuery || previousQuery.document === query.document || (0, _apolloUtilities.isEqual)(previousQuery.document, query.document), 19) : (0, _tsInvariant.invariant)(!previousQuery || previousQuery.document === query.document || (0, _apolloUtilities.isEqual)(previousQuery.document, query.document), 'Internal Error: may not update existing query string in store');
      var isSetVariables = false;
      var previousVariables = null;

      if (query.storePreviousVariables && previousQuery && previousQuery.networkStatus !== NetworkStatus.loading) {
        if (!(0, _apolloUtilities.isEqual)(previousQuery.variables, query.variables)) {
          isSetVariables = true;
          previousVariables = previousQuery.variables;
        }
      }

      var networkStatus;

      if (isSetVariables) {
        networkStatus = NetworkStatus.setVariables;
      } else if (query.isPoll) {
        networkStatus = NetworkStatus.poll;
      } else if (query.isRefetch) {
        networkStatus = NetworkStatus.refetch;
      } else {
        networkStatus = NetworkStatus.loading;
      }

      var graphQLErrors = [];

      if (previousQuery && previousQuery.graphQLErrors) {
        graphQLErrors = previousQuery.graphQLErrors;
      }

      this.store[query.queryId] = {
        document: query.document,
        variables: query.variables,
        previousVariables: previousVariables,
        networkError: null,
        graphQLErrors: graphQLErrors,
        networkStatus: networkStatus,
        metadata: query.metadata
      };

      if (typeof query.fetchMoreForQueryId === 'string' && this.store[query.fetchMoreForQueryId]) {
        this.store[query.fetchMoreForQueryId].networkStatus = NetworkStatus.fetchMore;
      }
    };

    QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
      if (!this.store || !this.store[queryId]) return;
      this.store[queryId].networkError = null;
      this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
      this.store[queryId].previousVariables = null;
      this.store[queryId].networkStatus = NetworkStatus.ready;

      if (typeof fetchMoreForQueryId === 'string' && this.store[fetchMoreForQueryId]) {
        this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;
      }
    };

    QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
      if (!this.store || !this.store[queryId]) return;
      this.store[queryId].networkError = error;
      this.store[queryId].networkStatus = NetworkStatus.error;

      if (typeof fetchMoreForQueryId === 'string') {
        this.markQueryResultClient(fetchMoreForQueryId, true);
      }
    };

    QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
      var storeValue = this.store && this.store[queryId];

      if (storeValue) {
        storeValue.networkError = null;
        storeValue.previousVariables = null;

        if (complete) {
          storeValue.networkStatus = NetworkStatus.ready;
        }
      }
    };

    QueryStore.prototype.stopQuery = function (queryId) {
      delete this.store[queryId];
    };

    QueryStore.prototype.reset = function (observableQueryIds) {
      var _this = this;

      Object.keys(this.store).forEach(function (queryId) {
        if (observableQueryIds.indexOf(queryId) < 0) {
          _this.stopQuery(queryId);
        } else {
          _this.store[queryId].networkStatus = NetworkStatus.loading;
        }
      });
    };

    return QueryStore;
  }();

  function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  var LocalState = function () {
    function LocalState(_a) {
      var cache = _a.cache,
          client = _a.client,
          resolvers = _a.resolvers,
          fragmentMatcher = _a.fragmentMatcher;
      this.cache = cache;

      if (client) {
        this.client = client;
      }

      if (resolvers) {
        this.addResolvers(resolvers);
      }

      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }

    LocalState.prototype.addResolvers = function (resolvers) {
      var _this = this;

      this.resolvers = this.resolvers || {};

      if (Array.isArray(resolvers)) {
        resolvers.forEach(function (resolverGroup) {
          _this.resolvers = (0, _apolloUtilities.mergeDeep)(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = (0, _apolloUtilities.mergeDeep)(this.resolvers, resolvers);
      }
    };

    LocalState.prototype.setResolvers = function (resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };

    LocalState.prototype.getResolvers = function () {
      return this.resolvers || {};
    };

    LocalState.prototype.runResolvers = function (_a) {
      var document = _a.document,
          remoteResult = _a.remoteResult,
          context = _a.context,
          variables = _a.variables,
          _b = _a.onlyRunForcedResolvers,
          onlyRunForcedResolvers = _b === void 0 ? false : _b;
      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        return (0, _tslib.__generator)(this, function (_c) {
          if (document) {
            return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {
              return (0, _tslib.__assign)({}, remoteResult, {
                data: localResult.result
              });
            })];
          }

          return [2, remoteResult];
        });
      });
    };

    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };

    LocalState.prototype.getFragmentMatcher = function () {
      return this.fragmentMatcher;
    };

    LocalState.prototype.clientQuery = function (document) {
      if ((0, _apolloUtilities.hasDirectives)(['client'], document)) {
        if (this.resolvers) {
          return document;
        }

        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('Found @client directives in a query but no ApolloClient resolvers ' + 'were specified. This means ApolloClient local resolver handling ' + 'has been disabled, and @client directives will be passed through ' + 'to your link chain.');
      }

      return null;
    };

    LocalState.prototype.serverQuery = function (document) {
      return this.resolvers ? (0, _apolloUtilities.removeClientSetsFromDocument)(document) : document;
    };

    LocalState.prototype.prepareContext = function (context) {
      if (context === void 0) {
        context = {};
      }

      var cache = this.cache;
      var newContext = (0, _tslib.__assign)({}, context, {
        cache: cache,
        getCacheKey: function (obj) {
          if (cache.config) {
            return cache.config.dataIdFromObject(obj);
          } else {
            process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(false, 6) : (0, _tsInvariant.invariant)(false, 'To use context.getCacheKey, you need to use a cache that has ' + 'a configurable dataIdFromObject, like apollo-cache-inmemory.');
          }
        }
      });
      return newContext;
    };

    LocalState.prototype.addExportedVariables = function (document, variables, context) {
      if (variables === void 0) {
        variables = {};
      }

      if (context === void 0) {
        context = {};
      }

      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        return (0, _tslib.__generator)(this, function (_a) {
          if (document) {
            return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {
              return (0, _tslib.__assign)({}, variables, data.exportedVariables);
            })];
          }

          return [2, (0, _tslib.__assign)({}, variables)];
        });
      });
    };

    LocalState.prototype.shouldForceResolvers = function (document) {
      var forceResolvers = false;
      (0, _visitor.visit)(document, {
        Directive: {
          enter: function (node) {
            if (node.name.value === 'client' && node.arguments) {
              forceResolvers = node.arguments.some(function (arg) {
                return arg.name.value === 'always' && arg.value.kind === 'BooleanValue' && arg.value.value === true;
              });

              if (forceResolvers) {
                return _visitor.BREAK;
              }
            }
          }
        }
      });
      return forceResolvers;
    };

    LocalState.prototype.buildRootValueFromCache = function (document, variables) {
      return this.cache.diff({
        query: (0, _apolloUtilities.buildQueryFromSelectionSet)(document),
        variables: variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };

    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
      if (context === void 0) {
        context = {};
      }

      if (variables === void 0) {
        variables = {};
      }

      if (fragmentMatcher === void 0) {
        fragmentMatcher = function () {
          return true;
        };
      }

      if (onlyRunForcedResolvers === void 0) {
        onlyRunForcedResolvers = false;
      }

      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;

        return (0, _tslib.__generator)(this, function (_b) {
          mainDefinition = (0, _apolloUtilities.getMainDefinition)(document);
          fragments = (0, _apolloUtilities.getFragmentDefinitions)(document);
          fragmentMap = (0, _apolloUtilities.createFragmentMap)(fragments);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? capitalizeFirstLetter(definitionOperation) : 'Query';
          _a = this, cache = _a.cache, client = _a.client;
          execContext = {
            fragmentMap: fragmentMap,
            context: (0, _tslib.__assign)({}, context, {
              cache: cache,
              client: client
            }),
            variables: variables,
            fragmentMatcher: fragmentMatcher,
            defaultOperationType: defaultOperationType,
            exportedVariables: {},
            onlyRunForcedResolvers: onlyRunForcedResolvers
          };
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) {
            return {
              result: result,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };

    LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        var fragmentMap, context, variables, resultsToMerge, execute;

        var _this = this;

        return (0, _tslib.__generator)(this, function (_a) {
          fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];

          execute = function (selection) {
            return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
              var fragment, typeCondition;
              return (0, _tslib.__generator)(this, function (_a) {
                if (!(0, _apolloUtilities.shouldInclude)(selection, variables)) {
                  return [2];
                }

                if ((0, _apolloUtilities.isField)(selection)) {
                  return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                    var _a;

                    if (typeof fieldResult !== 'undefined') {
                      resultsToMerge.push((_a = {}, _a[(0, _apolloUtilities.resultKeyNameFromField)(selection)] = fieldResult, _a));
                    }
                  })];
                }

                if ((0, _apolloUtilities.isInlineFragment)(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(fragment, 7) : (0, _tsInvariant.invariant)(fragment, "No fragment named " + selection.name.value);
                }

                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;

                  if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }

                return [2];
              });
            });
          };

          return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
            return (0, _apolloUtilities.mergeDeepArray)(resultsToMerge);
          })];
        });
      });
    };

    LocalState.prototype.resolveField = function (field, rootValue, execContext) {
      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;

        var _this = this;

        return (0, _tslib.__generator)(this, function (_a) {
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = (0, _apolloUtilities.resultKeyNameFromField)(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);

          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];

            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];

              if (resolve) {
                resultPromise = Promise.resolve(resolve(rootValue, (0, _apolloUtilities.argumentsObjectFromField)(field, variables), execContext.context, {
                  field: field
                }));
              }
            }
          }

          return [2, resultPromise.then(function (result) {
            if (result === void 0) {
              result = defaultResult;
            }

            if (field.directives) {
              field.directives.forEach(function (directive) {
                if (directive.name.value === 'export' && directive.arguments) {
                  directive.arguments.forEach(function (arg) {
                    if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                      execContext.exportedVariables[arg.value.value] = result;
                    }
                  });
                }
              });
            }

            if (!field.selectionSet) {
              return result;
            }

            if (result == null) {
              return result;
            }

            if (Array.isArray(result)) {
              return _this.resolveSubSelectedArray(field, result, execContext);
            }

            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, result, execContext);
            }
          })];
        });
      });
    };

    LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
      var _this = this;

      return Promise.all(result.map(function (item) {
        if (item === null) {
          return null;
        }

        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, item, execContext);
        }

        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, item, execContext);
        }
      }));
    };

    return LocalState;
  }();

  function multiplex(inner) {
    var observers = new Set();
    var sub = null;
    return new Observable(function (observer) {
      observers.add(observer);
      sub = sub || inner.subscribe({
        next: function (value) {
          observers.forEach(function (obs) {
            return obs.next && obs.next(value);
          });
        },
        error: function (error) {
          observers.forEach(function (obs) {
            return obs.error && obs.error(error);
          });
        },
        complete: function () {
          observers.forEach(function (obs) {
            return obs.complete && obs.complete();
          });
        }
      });
      return function () {
        if (observers.delete(observer) && !observers.size && sub) {
          sub.unsubscribe();
          sub = null;
        }
      };
    });
  }

  function asyncMap(observable, mapFn) {
    return new Observable(function (observer) {
      var next = observer.next,
          error = observer.error,
          complete = observer.complete;
      var activeNextCount = 0;
      var completed = false;
      var handler = {
        next: function (value) {
          ++activeNextCount;
          new Promise(function (resolve) {
            resolve(mapFn(value));
          }).then(function (result) {
            --activeNextCount;
            next && next.call(observer, result);
            completed && handler.complete();
          }, function (e) {
            --activeNextCount;
            error && error.call(observer, e);
          });
        },
        error: function (e) {
          error && error.call(observer, e);
        },
        complete: function () {
          completed = true;

          if (!activeNextCount) {
            complete && complete.call(observer);
          }
        }
      };
      var sub = observable.subscribe(handler);
      return function () {
        return sub.unsubscribe();
      };
    });
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var QueryManager = function () {
    function QueryManager(_a) {
      var link = _a.link,
          _b = _a.queryDeduplication,
          queryDeduplication = _b === void 0 ? false : _b,
          store = _a.store,
          _c = _a.onBroadcast,
          onBroadcast = _c === void 0 ? function () {
        return undefined;
      } : _c,
          _d = _a.ssrMode,
          ssrMode = _d === void 0 ? false : _d,
          _e = _a.clientAwareness,
          clientAwareness = _e === void 0 ? {} : _e,
          localState = _a.localState,
          assumeImmutableResults = _a.assumeImmutableResults;
      this.mutationStore = new MutationStore();
      this.queryStore = new QueryStore();
      this.clientAwareness = {};
      this.idCounter = 1;
      this.queries = new Map();
      this.fetchQueryRejectFns = new Map();
      this.transformCache = new (_apolloUtilities.canUseWeakMap ? WeakMap : Map)();
      this.inFlightLinkObservables = new Map();
      this.pollingInfoByQueryId = new Map();
      this.link = link;
      this.queryDeduplication = queryDeduplication;
      this.dataStore = store;
      this.onBroadcast = onBroadcast;
      this.clientAwareness = clientAwareness;
      this.localState = localState || new LocalState({
        cache: store.getCache()
      });
      this.ssrMode = ssrMode;
      this.assumeImmutableResults = !!assumeImmutableResults;
    }

    QueryManager.prototype.stop = function () {
      var _this = this;

      this.queries.forEach(function (_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.fetchQueryRejectFns.forEach(function (reject) {
        reject(process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(8) : new _tsInvariant.InvariantError('QueryManager stopped while query was in flight'));
      });
    };

    QueryManager.prototype.mutate = function (_a) {
      var mutation = _a.mutation,
          variables = _a.variables,
          optimisticResponse = _a.optimisticResponse,
          updateQueriesByName = _a.updateQueries,
          _b = _a.refetchQueries,
          refetchQueries = _b === void 0 ? [] : _b,
          _c = _a.awaitRefetchQueries,
          awaitRefetchQueries = _c === void 0 ? false : _c,
          updateWithProxyFn = _a.update,
          _d = _a.errorPolicy,
          errorPolicy = _d === void 0 ? 'none' : _d,
          fetchPolicy = _a.fetchPolicy,
          _e = _a.context,
          context = _e === void 0 ? {} : _e;
      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        var mutationId, generateUpdateQueriesInfo, self;

        var _this = this;

        return (0, _tslib.__generator)(this, function (_f) {
          switch (_f.label) {
            case 0:
              process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(mutation, 9) : (0, _tsInvariant.invariant)(mutation, 'mutation option is reqd. You must specify your GraphQL document in the mutation option.');
              process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!fetchPolicy || fetchPolicy === 'no-cache', 10) : (0, _tsInvariant.invariant)(!fetchPolicy || fetchPolicy === 'no-cache', "fetchPolicy for mutations currently only supports the 'no-cache' policy");
              mutationId = this.generateQueryId();
              mutation = this.transform(mutation).document;
              this.setQuery(mutationId, function () {
                return {
                  document: mutation
                };
              });
              variables = this.getVariables(mutation, variables);
              if (!this.transform(mutation).hasClientExports) return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context)];

            case 1:
              variables = _f.sent();
              _f.label = 2;

            case 2:
              generateUpdateQueriesInfo = function () {
                var ret = {};

                if (updateQueriesByName) {
                  _this.queries.forEach(function (_a, queryId) {
                    var observableQuery = _a.observableQuery;

                    if (observableQuery) {
                      var queryName = observableQuery.queryName;

                      if (queryName && hasOwnProperty.call(updateQueriesByName, queryName)) {
                        ret[queryId] = {
                          updater: updateQueriesByName[queryName],
                          query: _this.queryStore.get(queryId)
                        };
                      }
                    }
                  });
                }

                return ret;
              };

              this.mutationStore.initMutation(mutationId, mutation, variables);
              this.dataStore.markMutationInit({
                mutationId: mutationId,
                document: mutation,
                variables: variables,
                updateQueries: generateUpdateQueriesInfo(),
                update: updateWithProxyFn,
                optimisticResponse: optimisticResponse
              });
              this.broadcastQueries();
              self = this;
              return [2, new Promise(function (resolve, reject) {
                var storeResult;
                var error;
                self.getObservableFromLink(mutation, (0, _tslib.__assign)({}, context, {
                  optimisticResponse: optimisticResponse
                }), variables, false).subscribe({
                  next: function (result) {
                    if ((0, _apolloUtilities.graphQLResultHasError)(result) && errorPolicy === 'none') {
                      error = new ApolloError({
                        graphQLErrors: result.errors
                      });
                      return;
                    }

                    self.mutationStore.markMutationResult(mutationId);

                    if (fetchPolicy !== 'no-cache') {
                      self.dataStore.markMutationResult({
                        mutationId: mutationId,
                        result: result,
                        document: mutation,
                        variables: variables,
                        updateQueries: generateUpdateQueriesInfo(),
                        update: updateWithProxyFn
                      });
                    }

                    storeResult = result;
                  },
                  error: function (err) {
                    self.mutationStore.markMutationError(mutationId, err);
                    self.dataStore.markMutationComplete({
                      mutationId: mutationId,
                      optimisticResponse: optimisticResponse
                    });
                    self.broadcastQueries();
                    self.setQuery(mutationId, function () {
                      return {
                        document: null
                      };
                    });
                    reject(new ApolloError({
                      networkError: err
                    }));
                  },
                  complete: function () {
                    if (error) {
                      self.mutationStore.markMutationError(mutationId, error);
                    }

                    self.dataStore.markMutationComplete({
                      mutationId: mutationId,
                      optimisticResponse: optimisticResponse
                    });
                    self.broadcastQueries();

                    if (error) {
                      reject(error);
                      return;
                    }

                    if (typeof refetchQueries === 'function') {
                      refetchQueries = refetchQueries(storeResult);
                    }

                    var refetchQueryPromises = [];

                    if (isNonEmptyArray(refetchQueries)) {
                      refetchQueries.forEach(function (refetchQuery) {
                        if (typeof refetchQuery === 'string') {
                          self.queries.forEach(function (_a) {
                            var observableQuery = _a.observableQuery;

                            if (observableQuery && observableQuery.queryName === refetchQuery) {
                              refetchQueryPromises.push(observableQuery.refetch());
                            }
                          });
                        } else {
                          var queryOptions = {
                            query: refetchQuery.query,
                            variables: refetchQuery.variables,
                            fetchPolicy: 'network-only'
                          };

                          if (refetchQuery.context) {
                            queryOptions.context = refetchQuery.context;
                          }

                          refetchQueryPromises.push(self.query(queryOptions));
                        }
                      });
                    }

                    Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {
                      self.setQuery(mutationId, function () {
                        return {
                          document: null
                        };
                      });

                      if (errorPolicy === 'ignore' && storeResult && (0, _apolloUtilities.graphQLResultHasError)(storeResult)) {
                        delete storeResult.errors;
                      }

                      resolve(storeResult);
                    });
                  }
                });
              })];
          }
        });
      });
    };

    QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
      return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
        var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;

        var _this = this;

        return (0, _tslib.__generator)(this, function (_e) {
          switch (_e.label) {
            case 0:
              _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;
              query = this.transform(options.query).document;
              variables = this.getVariables(query, options.variables);
              if (!this.transform(query).hasClientExports) return [3, 2];
              return [4, this.localState.addExportedVariables(query, variables, context)];

            case 1:
              variables = _e.sent();
              _e.label = 2;

            case 2:
              options = (0, _tslib.__assign)({}, options, {
                variables: variables
              });
              isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
              needToFetch = isNetworkOnly;

              if (!isNetworkOnly) {
                _d = this.dataStore.getCache().diff({
                  query: query,
                  variables: variables,
                  returnPartialData: true,
                  optimistic: false
                }), complete = _d.complete, result = _d.result;
                needToFetch = !complete || fetchPolicy === 'cache-and-network';
                storeResult = result;
              }

              shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
              if ((0, _apolloUtilities.hasDirectives)(['live'], query)) shouldFetch = true;
              requestId = this.idCounter++;
              cancel = fetchPolicy !== 'no-cache' ? this.updateQueryWatch(queryId, query, options) : undefined;
              this.setQuery(queryId, function () {
                return {
                  document: query,
                  lastRequestId: requestId,
                  invalidated: true,
                  cancel: cancel
                };
              });
              this.invalidate(fetchMoreForQueryId);
              this.queryStore.initQuery({
                queryId: queryId,
                document: query,
                storePreviousVariables: shouldFetch,
                variables: variables,
                isPoll: fetchType === FetchType.poll,
                isRefetch: fetchType === FetchType.refetch,
                metadata: metadata,
                fetchMoreForQueryId: fetchMoreForQueryId
              });
              this.broadcastQueries();

              if (shouldFetch) {
                networkResult = this.fetchRequest({
                  requestId: requestId,
                  queryId: queryId,
                  document: query,
                  options: options,
                  fetchMoreForQueryId: fetchMoreForQueryId
                }).catch(function (error) {
                  if (isApolloError(error)) {
                    throw error;
                  } else {
                    if (requestId >= _this.getQuery(queryId).lastRequestId) {
                      _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);

                      _this.invalidate(queryId);

                      _this.invalidate(fetchMoreForQueryId);

                      _this.broadcastQueries();
                    }

                    throw new ApolloError({
                      networkError: error
                    });
                  }
                });

                if (fetchPolicy !== 'cache-and-network') {
                  return [2, networkResult];
                }

                networkResult.catch(function () {});
              }

              this.queryStore.markQueryResultClient(queryId, !shouldFetch);
              this.invalidate(queryId);
              this.invalidate(fetchMoreForQueryId);

              if (this.transform(query).hasForcedResolvers) {
                return [2, this.localState.runResolvers({
                  document: query,
                  remoteResult: {
                    data: storeResult
                  },
                  context: context,
                  variables: variables,
                  onlyRunForcedResolvers: true
                }).then(function (result) {
                  _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);

                  _this.broadcastQueries();

                  return result;
                })];
              }

              this.broadcastQueries();
              return [2, {
                data: storeResult
              }];
          }
        });
      });
    };

    QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {
      var fetchPolicy = _a.fetchPolicy,
          variables = _a.variables,
          errorPolicy = _a.errorPolicy;

      if (fetchPolicy === 'no-cache') {
        this.setQuery(queryId, function () {
          return {
            newData: {
              result: result.data,
              complete: true
            }
          };
        });
      } else {
        this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
      }
    };

    QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
      var _this = this;

      function invoke(method, argument) {
        if (observer[method]) {
          try {
            observer[method](argument);
          } catch (e) {
            process.env.NODE_ENV === "production" || _tsInvariant.invariant.error(e);
          }
        } else if (method === 'error') {
          process.env.NODE_ENV === "production" || _tsInvariant.invariant.error(argument);
        }
      }

      return function (queryStoreValue, newData) {
        _this.invalidate(queryId, false);

        if (!queryStoreValue) return;

        var _a = _this.getQuery(queryId),
            observableQuery = _a.observableQuery,
            document = _a.document;

        var fetchPolicy = observableQuery ? observableQuery.options.fetchPolicy : options.fetchPolicy;
        if (fetchPolicy === 'standby') return;
        var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);
        var lastResult = observableQuery && observableQuery.getLastResult();
        var networkStatusChanged = !!(lastResult && lastResult.networkStatus !== queryStoreValue.networkStatus);
        var shouldNotifyIfLoading = options.returnPartialData || !newData && queryStoreValue.previousVariables || networkStatusChanged && options.notifyOnNetworkStatusChange || fetchPolicy === 'cache-only' || fetchPolicy === 'cache-and-network';

        if (loading && !shouldNotifyIfLoading) {
          return;
        }

        var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);
        var errorPolicy = observableQuery && observableQuery.options.errorPolicy || options.errorPolicy || 'none';

        if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {
          return invoke('error', new ApolloError({
            graphQLErrors: queryStoreValue.graphQLErrors,
            networkError: queryStoreValue.networkError
          }));
        }

        try {
          var data = void 0;
          var isMissing = void 0;

          if (newData) {
            if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {
              _this.setQuery(queryId, function () {
                return {
                  newData: null
                };
              });
            }

            data = newData.result;
            isMissing = !newData.complete;
          } else {
            var lastError = observableQuery && observableQuery.getLastError();
            var errorStatusChanged = errorPolicy !== 'none' && (lastError && lastError.graphQLErrors) !== queryStoreValue.graphQLErrors;

            if (lastResult && lastResult.data && !errorStatusChanged) {
              data = lastResult.data;
              isMissing = false;
            } else {
              var diffResult = _this.dataStore.getCache().diff({
                query: document,
                variables: queryStoreValue.previousVariables || queryStoreValue.variables,
                returnPartialData: true,
                optimistic: true
              });

              data = diffResult.result;
              isMissing = !diffResult.complete;
            }
          }

          var stale = isMissing && !(options.returnPartialData || fetchPolicy === 'cache-only');
          var resultFromStore = {
            data: stale ? lastResult && lastResult.data : data,
            loading: loading,
            networkStatus: queryStoreValue.networkStatus,
            stale: stale
          };

          if (errorPolicy === 'all' && hasGraphQLErrors) {
            resultFromStore.errors = queryStoreValue.graphQLErrors;
          }

          invoke('next', resultFromStore);
        } catch (networkError) {
          invoke('error', new ApolloError({
            networkError: networkError
          }));
        }
      };
    };

    QueryManager.prototype.transform = function (document) {
      var transformCache = this.transformCache;

      if (!transformCache.has(document)) {
        var cache = this.dataStore.getCache();
        var transformed = cache.transformDocument(document);
        var forLink = (0, _apolloUtilities.removeConnectionDirectiveFromDocument)(cache.transformForLink(transformed));
        var clientQuery = this.localState.clientQuery(transformed);
        var serverQuery = this.localState.serverQuery(forLink);
        var cacheEntry_1 = {
          document: transformed,
          hasClientExports: (0, _apolloUtilities.hasClientExports)(transformed),
          hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
          clientQuery: clientQuery,
          serverQuery: serverQuery,
          defaultVars: (0, _apolloUtilities.getDefaultValues)((0, _apolloUtilities.getOperationDefinition)(transformed))
        };

        var add = function (doc) {
          if (doc && !transformCache.has(doc)) {
            transformCache.set(doc, cacheEntry_1);
          }
        };

        add(document);
        add(transformed);
        add(clientQuery);
        add(serverQuery);
      }

      return transformCache.get(document);
    };

    QueryManager.prototype.getVariables = function (document, variables) {
      return (0, _tslib.__assign)({}, this.transform(document).defaultVars, variables);
    };

    QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
      if (shouldSubscribe === void 0) {
        shouldSubscribe = true;
      }

      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(options.fetchPolicy !== 'standby', 11) : (0, _tsInvariant.invariant)(options.fetchPolicy !== 'standby', 'client.watchQuery cannot be called with fetchPolicy set to "standby"');
      options.variables = this.getVariables(options.query, options.variables);

      if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
        options.notifyOnNetworkStatusChange = false;
      }

      var transformedOptions = (0, _tslib.__assign)({}, options);
      return new ObservableQuery({
        queryManager: this,
        options: transformedOptions,
        shouldSubscribe: shouldSubscribe
      });
    };

    QueryManager.prototype.query = function (options) {
      var _this = this;

      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(options.query, 12) : (0, _tsInvariant.invariant)(options.query, 'query option is reqd. You must specify your GraphQL document ' + 'in the query option.');
      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(options.query.kind === 'Document', 13) : (0, _tsInvariant.invariant)(options.query.kind === 'Document', 'You must wrap the query string in a "gql" tag.');
      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!options.returnPartialData, 14) : (0, _tsInvariant.invariant)(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');
      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(!options.pollInterval, 15) : (0, _tsInvariant.invariant)(!options.pollInterval, 'pollInterval option only supported on watchQuery.');
      return new Promise(function (resolve, reject) {
        var watchedQuery = _this.watchQuery(options, false);

        _this.fetchQueryRejectFns.set("query:" + watchedQuery.queryId, reject);

        watchedQuery.result().then(resolve, reject).then(function () {
          return _this.fetchQueryRejectFns.delete("query:" + watchedQuery.queryId);
        });
      });
    };

    QueryManager.prototype.generateQueryId = function () {
      return String(this.idCounter++);
    };

    QueryManager.prototype.stopQueryInStore = function (queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };

    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
      this.stopPollingQuery(queryId);
      this.queryStore.stopQuery(queryId);
      this.invalidate(queryId);
    };

    QueryManager.prototype.addQueryListener = function (queryId, listener) {
      this.setQuery(queryId, function (_a) {
        var listeners = _a.listeners;
        listeners.add(listener);
        return {
          invalidated: false
        };
      });
    };

    QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
      var _this = this;

      var cancel = this.getQuery(queryId).cancel;
      if (cancel) cancel();

      var previousResult = function () {
        var previousResult = null;

        var observableQuery = _this.getQuery(queryId).observableQuery;

        if (observableQuery) {
          var lastResult = observableQuery.getLastResult();

          if (lastResult) {
            previousResult = lastResult.data;
          }
        }

        return previousResult;
      };

      return this.dataStore.getCache().watch({
        query: document,
        variables: options.variables,
        optimistic: true,
        previousResult: previousResult,
        callback: function (newData) {
          _this.setQuery(queryId, function () {
            return {
              invalidated: true,
              newData: newData
            };
          });
        }
      });
    };

    QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
      this.setQuery(queryId, function () {
        return {
          observableQuery: observableQuery
        };
      });
    };

    QueryManager.prototype.removeObservableQuery = function (queryId) {
      var cancel = this.getQuery(queryId).cancel;
      this.setQuery(queryId, function () {
        return {
          observableQuery: null
        };
      });
      if (cancel) cancel();
    };

    QueryManager.prototype.clearStore = function () {
      this.fetchQueryRejectFns.forEach(function (reject) {
        reject(process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(16) : new _tsInvariant.InvariantError('Store reset while query was in flight (not completed in link chain)'));
      });
      var resetIds = [];
      this.queries.forEach(function (_a, queryId) {
        var observableQuery = _a.observableQuery;
        if (observableQuery) resetIds.push(queryId);
      });
      this.queryStore.reset(resetIds);
      this.mutationStore.reset();
      return this.dataStore.reset();
    };

    QueryManager.prototype.resetStore = function () {
      var _this = this;

      return this.clearStore().then(function () {
        return _this.reFetchObservableQueries();
      });
    };

    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
      var _this = this;

      if (includeStandby === void 0) {
        includeStandby = false;
      }

      var observableQueryPromises = [];
      this.queries.forEach(function (_a, queryId) {
        var observableQuery = _a.observableQuery;

        if (observableQuery) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();

          if (fetchPolicy !== 'cache-only' && (includeStandby || fetchPolicy !== 'standby')) {
            observableQueryPromises.push(observableQuery.refetch());
          }

          _this.setQuery(queryId, function () {
            return {
              newData: null
            };
          });

          _this.invalidate(queryId);
        }
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };

    QueryManager.prototype.observeQuery = function (queryId, options, observer) {
      this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));
      return this.fetchQuery(queryId, options);
    };

    QueryManager.prototype.startQuery = function (queryId, options, listener) {
      process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn("The QueryManager.startQuery method has been deprecated");
      this.addQueryListener(queryId, listener);
      this.fetchQuery(queryId, options).catch(function () {
        return undefined;
      });
      return queryId;
    };

    QueryManager.prototype.startGraphQLSubscription = function (_a) {
      var _this = this;

      var query = _a.query,
          fetchPolicy = _a.fetchPolicy,
          variables = _a.variables;
      query = this.transform(query).document;
      variables = this.getVariables(query, variables);

      var makeObservable = function (variables) {
        return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {
          if (!fetchPolicy || fetchPolicy !== 'no-cache') {
            _this.dataStore.markSubscriptionResult(result, query, variables);

            _this.broadcastQueries();
          }

          if ((0, _apolloUtilities.graphQLResultHasError)(result)) {
            throw new ApolloError({
              graphQLErrors: result.errors
            });
          }

          return result;
        });
      };

      if (this.transform(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);
        return new Observable(function (observer) {
          var sub = null;
          observablePromise_1.then(function (observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function () {
            return sub && sub.unsubscribe();
          };
        });
      }

      return makeObservable(variables);
    };

    QueryManager.prototype.stopQuery = function (queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };

    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };

    QueryManager.prototype.removeQuery = function (queryId) {
      this.fetchQueryRejectFns.delete("query:" + queryId);
      this.fetchQueryRejectFns.delete("fetchRequest:" + queryId);
      this.getQuery(queryId).subscriptions.forEach(function (x) {
        return x.unsubscribe();
      });
      this.queries.delete(queryId);
    };

    QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
      if (optimistic === void 0) {
        optimistic = true;
      }

      var _a = observableQuery.options,
          variables = _a.variables,
          query = _a.query,
          fetchPolicy = _a.fetchPolicy,
          returnPartialData = _a.returnPartialData;
      var lastResult = observableQuery.getLastResult();
      var newData = this.getQuery(observableQuery.queryId).newData;

      if (newData && newData.complete) {
        return {
          data: newData.result,
          partial: false
        };
      }

      if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {
        return {
          data: undefined,
          partial: false
        };
      }

      var _b = this.dataStore.getCache().diff({
        query: query,
        variables: variables,
        previousResult: lastResult ? lastResult.data : undefined,
        returnPartialData: true,
        optimistic: optimistic
      }),
          result = _b.result,
          complete = _b.complete;

      return {
        data: complete || returnPartialData ? result : void 0,
        partial: !complete
      };
    };

    QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
      var observableQuery;

      if (typeof queryIdOrObservable === 'string') {
        var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
        process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(foundObserveableQuery, 17) : (0, _tsInvariant.invariant)(foundObserveableQuery, "ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
        observableQuery = foundObserveableQuery;
      } else {
        observableQuery = queryIdOrObservable;
      }

      var _a = observableQuery.options,
          variables = _a.variables,
          query = _a.query;
      return {
        previousResult: this.getCurrentQueryResult(observableQuery, false).data,
        variables: variables,
        document: query
      };
    };

    QueryManager.prototype.broadcastQueries = function () {
      var _this = this;

      this.onBroadcast();
      this.queries.forEach(function (info, id) {
        if (info.invalidated) {
          info.listeners.forEach(function (listener) {
            if (listener) {
              listener(_this.queryStore.get(id), info.newData);
            }
          });
        }
      });
    };

    QueryManager.prototype.getLocalState = function () {
      return this.localState;
    };

    QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
      var _this = this;

      if (deduplication === void 0) {
        deduplication = this.queryDeduplication;
      }

      var observable;
      var serverQuery = this.transform(query).serverQuery;

      if (serverQuery) {
        var _a = this,
            inFlightLinkObservables_1 = _a.inFlightLinkObservables,
            link = _a.link;

        var operation = {
          query: serverQuery,
          variables: variables,
          operationName: (0, _apolloUtilities.getOperationName)(serverQuery) || void 0,
          context: this.prepareContext((0, _tslib.__assign)({}, context, {
            forceFetch: !deduplication
          }))
        };
        context = operation.context;

        if (deduplication) {
          var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
          inFlightLinkObservables_1.set(serverQuery, byVariables_1);
          var varJson_1 = JSON.stringify(variables);
          observable = byVariables_1.get(varJson_1);

          if (!observable) {
            byVariables_1.set(varJson_1, observable = multiplex((0, _apolloLink.execute)(link, operation)));

            var cleanup = function () {
              byVariables_1.delete(varJson_1);
              if (!byVariables_1.size) inFlightLinkObservables_1.delete(serverQuery);
              cleanupSub_1.unsubscribe();
            };

            var cleanupSub_1 = observable.subscribe({
              next: cleanup,
              error: cleanup,
              complete: cleanup
            });
          }
        } else {
          observable = multiplex((0, _apolloLink.execute)(link, operation));
        }
      } else {
        observable = Observable.of({
          data: {}
        });
        context = this.prepareContext(context);
      }

      var clientQuery = this.transform(query).clientQuery;

      if (clientQuery) {
        observable = asyncMap(observable, function (result) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result,
            context: context,
            variables: variables
          });
        });
      }

      return observable;
    };

    QueryManager.prototype.fetchRequest = function (_a) {
      var _this = this;

      var requestId = _a.requestId,
          queryId = _a.queryId,
          document = _a.document,
          options = _a.options,
          fetchMoreForQueryId = _a.fetchMoreForQueryId;
      var variables = options.variables,
          _b = options.errorPolicy,
          errorPolicy = _b === void 0 ? 'none' : _b,
          fetchPolicy = options.fetchPolicy;
      var resultFromStore;
      var errorsFromStore;
      return new Promise(function (resolve, reject) {
        var observable = _this.getObservableFromLink(document, options.context, variables);

        var fqrfId = "fetchRequest:" + queryId;

        _this.fetchQueryRejectFns.set(fqrfId, reject);

        var cleanup = function () {
          _this.fetchQueryRejectFns.delete(fqrfId);

          _this.setQuery(queryId, function (_a) {
            var subscriptions = _a.subscriptions;
            subscriptions.delete(subscription);
          });
        };

        var subscription = observable.map(function (result) {
          if (requestId >= _this.getQuery(queryId).lastRequestId) {
            _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);

            _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);

            _this.invalidate(queryId);

            _this.invalidate(fetchMoreForQueryId);

            _this.broadcastQueries();
          }

          if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {
            return reject(new ApolloError({
              graphQLErrors: result.errors
            }));
          }

          if (errorPolicy === 'all') {
            errorsFromStore = result.errors;
          }

          if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
            resultFromStore = result.data;
          } else {
            var _a = _this.dataStore.getCache().diff({
              variables: variables,
              query: document,
              optimistic: false,
              returnPartialData: true
            }),
                result_1 = _a.result,
                complete = _a.complete;

            if (complete || options.returnPartialData) {
              resultFromStore = result_1;
            }
          }
        }).subscribe({
          error: function (error) {
            cleanup();
            reject(error);
          },
          complete: function () {
            cleanup();
            resolve({
              data: resultFromStore,
              errors: errorsFromStore,
              loading: false,
              networkStatus: NetworkStatus.ready,
              stale: false
            });
          }
        });

        _this.setQuery(queryId, function (_a) {
          var subscriptions = _a.subscriptions;
          subscriptions.add(subscription);
        });
      });
    };

    QueryManager.prototype.getQuery = function (queryId) {
      return this.queries.get(queryId) || {
        listeners: new Set(),
        invalidated: false,
        document: null,
        newData: null,
        lastRequestId: 1,
        observableQuery: null,
        subscriptions: new Set()
      };
    };

    QueryManager.prototype.setQuery = function (queryId, updater) {
      var prev = this.getQuery(queryId);
      var newInfo = (0, _tslib.__assign)({}, prev, updater(prev));
      this.queries.set(queryId, newInfo);
    };

    QueryManager.prototype.invalidate = function (queryId, invalidated) {
      if (invalidated === void 0) {
        invalidated = true;
      }

      if (queryId) {
        this.setQuery(queryId, function () {
          return {
            invalidated: invalidated
          };
        });
      }
    };

    QueryManager.prototype.prepareContext = function (context) {
      if (context === void 0) {
        context = {};
      }

      var newContext = this.localState.prepareContext(context);
      return (0, _tslib.__assign)({}, newContext, {
        clientAwareness: this.clientAwareness
      });
    };

    QueryManager.prototype.checkInFlight = function (queryId) {
      var query = this.queryStore.get(queryId);
      return query && query.networkStatus !== NetworkStatus.ready && query.networkStatus !== NetworkStatus.error;
    };

    QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {
      var _this = this;

      var pollInterval = options.pollInterval;
      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(pollInterval, 18) : (0, _tsInvariant.invariant)(pollInterval, 'Attempted to start a polling query without a polling interval.');

      if (!this.ssrMode) {
        var info = this.pollingInfoByQueryId.get(queryId);

        if (!info) {
          this.pollingInfoByQueryId.set(queryId, info = {});
        }

        info.interval = pollInterval;
        info.options = (0, _tslib.__assign)({}, options, {
          fetchPolicy: 'network-only'
        });

        var maybeFetch_1 = function () {
          var info = _this.pollingInfoByQueryId.get(queryId);

          if (info) {
            if (_this.checkInFlight(queryId)) {
              poll_1();
            } else {
              _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);
            }
          }
        };

        var poll_1 = function () {
          var info = _this.pollingInfoByQueryId.get(queryId);

          if (info) {
            clearTimeout(info.timeout);
            info.timeout = setTimeout(maybeFetch_1, info.interval);
          }
        };

        if (listener) {
          this.addQueryListener(queryId, listener);
        }

        poll_1();
      }

      return queryId;
    };

    QueryManager.prototype.stopPollingQuery = function (queryId) {
      this.pollingInfoByQueryId.delete(queryId);
    };

    return QueryManager;
  }();

  var DataStore = function () {
    function DataStore(initialCache) {
      this.cache = initialCache;
    }

    DataStore.prototype.getCache = function () {
      return this.cache;
    };

    DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
      if (ignoreErrors === void 0) {
        ignoreErrors = false;
      }

      var writeWithErrors = !(0, _apolloUtilities.graphQLResultHasError)(result);

      if (ignoreErrors && (0, _apolloUtilities.graphQLResultHasError)(result) && result.data) {
        writeWithErrors = true;
      }

      if (!fetchMoreForQueryId && writeWithErrors) {
        this.cache.write({
          result: result.data,
          dataId: 'ROOT_QUERY',
          query: document,
          variables: variables
        });
      }
    };

    DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
      if (!(0, _apolloUtilities.graphQLResultHasError)(result)) {
        this.cache.write({
          result: result.data,
          dataId: 'ROOT_SUBSCRIPTION',
          query: document,
          variables: variables
        });
      }
    };

    DataStore.prototype.markMutationInit = function (mutation) {
      var _this = this;

      if (mutation.optimisticResponse) {
        var optimistic_1;

        if (typeof mutation.optimisticResponse === 'function') {
          optimistic_1 = mutation.optimisticResponse(mutation.variables);
        } else {
          optimistic_1 = mutation.optimisticResponse;
        }

        this.cache.recordOptimisticTransaction(function (c) {
          var orig = _this.cache;
          _this.cache = c;

          try {
            _this.markMutationResult({
              mutationId: mutation.mutationId,
              result: {
                data: optimistic_1
              },
              document: mutation.document,
              variables: mutation.variables,
              updateQueries: mutation.updateQueries,
              update: mutation.update
            });
          } finally {
            _this.cache = orig;
          }
        }, mutation.mutationId);
      }
    };

    DataStore.prototype.markMutationResult = function (mutation) {
      var _this = this;

      if (!(0, _apolloUtilities.graphQLResultHasError)(mutation.result)) {
        var cacheWrites_1 = [{
          result: mutation.result.data,
          dataId: 'ROOT_MUTATION',
          query: mutation.document,
          variables: mutation.variables
        }];
        var updateQueries_1 = mutation.updateQueries;

        if (updateQueries_1) {
          Object.keys(updateQueries_1).forEach(function (id) {
            var _a = updateQueries_1[id],
                query = _a.query,
                updater = _a.updater;

            var _b = _this.cache.diff({
              query: query.document,
              variables: query.variables,
              returnPartialData: true,
              optimistic: false
            }),
                currentQueryResult = _b.result,
                complete = _b.complete;

            if (complete) {
              var nextQueryResult = (0, _apolloUtilities.tryFunctionOrLogError)(function () {
                return updater(currentQueryResult, {
                  mutationResult: mutation.result,
                  queryName: (0, _apolloUtilities.getOperationName)(query.document) || undefined,
                  queryVariables: query.variables
                });
              });

              if (nextQueryResult) {
                cacheWrites_1.push({
                  result: nextQueryResult,
                  dataId: 'ROOT_QUERY',
                  query: query.document,
                  variables: query.variables
                });
              }
            }
          });
        }

        this.cache.performTransaction(function (c) {
          cacheWrites_1.forEach(function (write) {
            return c.write(write);
          });
          var update = mutation.update;

          if (update) {
            (0, _apolloUtilities.tryFunctionOrLogError)(function () {
              return update(c, mutation.result);
            });
          }
        });
      }
    };

    DataStore.prototype.markMutationComplete = function (_a) {
      var mutationId = _a.mutationId,
          optimisticResponse = _a.optimisticResponse;

      if (optimisticResponse) {
        this.cache.removeOptimistic(mutationId);
      }
    };

    DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
      this.cache.write({
        result: newResult,
        dataId: 'ROOT_QUERY',
        variables: variables,
        query: document
      });
    };

    DataStore.prototype.reset = function () {
      return this.cache.reset();
    };

    return DataStore;
  }();

  var version = "2.6.4";
  var hasSuggestedDevtools = false;

  var ApolloClient = function () {
    function ApolloClient(options) {
      var _this = this;

      this.defaultOptions = {};
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      var cache = options.cache,
          _a = options.ssrMode,
          ssrMode = _a === void 0 ? false : _a,
          _b = options.ssrForceFetchDelay,
          ssrForceFetchDelay = _b === void 0 ? 0 : _b,
          connectToDevTools = options.connectToDevTools,
          _c = options.queryDeduplication,
          queryDeduplication = _c === void 0 ? true : _c,
          defaultOptions = options.defaultOptions,
          _d = options.assumeImmutableResults,
          assumeImmutableResults = _d === void 0 ? false : _d,
          resolvers = options.resolvers,
          typeDefs = options.typeDefs,
          fragmentMatcher = options.fragmentMatcher,
          clientAwarenessName = options.name,
          clientAwarenessVersion = options.version;
      var link = options.link;

      if (!link && resolvers) {
        link = _apolloLink.ApolloLink.empty();
      }

      if (!link || !cache) {
        throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(1) : new _tsInvariant.InvariantError("In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\n" + "These options are part of the upgrade reqments when migrating from Apollo Client 1.x to Apollo Client 2.x.\n" + "For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup");
      }

      this.link = link;
      this.cache = cache;
      this.store = new DataStore(cache);
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions || {};
      this.typeDefs = typeDefs;

      if (ssrForceFetchDelay) {
        setTimeout(function () {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }

      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      var defaultConnectToDevTools = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && !window.__APOLLO_CLIENT__;

      if (typeof connectToDevTools === 'undefined' ? defaultConnectToDevTools : connectToDevTools && typeof window !== 'undefined') {
        window.__APOLLO_CLIENT__ = this;
      }

      if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {
        hasSuggestedDevtools = true;

        if (typeof window !== 'undefined' && window.document && window.top === window.self) {
          if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
            if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('Chrome') > -1) {
              console.debug('Download the Apollo DevTools ' + 'for a better development experience: ' + 'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
            }
          }
        }
      }

      this.version = version;
      this.localState = new LocalState({
        cache: cache,
        client: this,
        resolvers: resolvers,
        fragmentMatcher: fragmentMatcher
      });
      this.queryManager = new QueryManager({
        link: this.link,
        store: this.store,
        queryDeduplication: queryDeduplication,
        ssrMode: ssrMode,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults: assumeImmutableResults,
        onBroadcast: function () {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.queryStore.getStore(),
                mutations: _this.queryManager.mutationStore.getStore()
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        }
      });
    }

    ApolloClient.prototype.stop = function () {
      this.queryManager.stop();
    };

    ApolloClient.prototype.watchQuery = function (options) {
      if (this.defaultOptions.watchQuery) {
        options = (0, _tslib.__assign)({}, this.defaultOptions.watchQuery, options);
      }

      if (this.disableNetworkFetches && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {
        options = (0, _tslib.__assign)({}, options, {
          fetchPolicy: 'cache-first'
        });
      }

      return this.queryManager.watchQuery(options);
    };

    ApolloClient.prototype.query = function (options) {
      if (this.defaultOptions.query) {
        options = (0, _tslib.__assign)({}, this.defaultOptions.query, options);
      }

      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(options.fetchPolicy !== 'cache-and-network', 2) : (0, _tsInvariant.invariant)(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' + 'client.query can only return a single result. Please use client.watchQuery ' + 'to receive multiple results from the cache and the network, or consider ' + 'using a different fetchPolicy, such as cache-first or network-only.');

      if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
        options = (0, _tslib.__assign)({}, options, {
          fetchPolicy: 'cache-first'
        });
      }

      return this.queryManager.query(options);
    };

    ApolloClient.prototype.mutate = function (options) {
      if (this.defaultOptions.mutate) {
        options = (0, _tslib.__assign)({}, this.defaultOptions.mutate, options);
      }

      return this.queryManager.mutate(options);
    };

    ApolloClient.prototype.subscribe = function (options) {
      return this.queryManager.startGraphQLSubscription(options);
    };

    ApolloClient.prototype.readQuery = function (options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }

      return this.cache.readQuery(options, optimistic);
    };

    ApolloClient.prototype.readFragment = function (options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }

      return this.cache.readFragment(options, optimistic);
    };

    ApolloClient.prototype.writeQuery = function (options) {
      var result = this.cache.writeQuery(options);
      this.queryManager.broadcastQueries();
      return result;
    };

    ApolloClient.prototype.writeFragment = function (options) {
      var result = this.cache.writeFragment(options);
      this.queryManager.broadcastQueries();
      return result;
    };

    ApolloClient.prototype.writeData = function (options) {
      var result = this.cache.writeData(options);
      this.queryManager.broadcastQueries();
      return result;
    };

    ApolloClient.prototype.__actionHookForDevTools = function (cb) {
      this.devToolsHookCb = cb;
    };

    ApolloClient.prototype.__requestRaw = function (payload) {
      return (0, _apolloLink.execute)(this.link, payload);
    };

    ApolloClient.prototype.initQueryManager = function () {
      process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('Calling the initQueryManager method is no longer necessary, ' + 'and it will be removed from ApolloClient in version 3.0.');
      return this.queryManager;
    };

    ApolloClient.prototype.resetStore = function () {
      var _this = this;

      return Promise.resolve().then(function () {
        return _this.queryManager.clearStore();
      }).then(function () {
        return Promise.all(_this.resetStoreCallbacks.map(function (fn) {
          return fn();
        }));
      }).then(function () {
        return _this.reFetchObservableQueries();
      });
    };

    ApolloClient.prototype.clearStore = function () {
      var _this = this;

      return Promise.resolve().then(function () {
        return _this.queryManager.clearStore();
      }).then(function () {
        return Promise.all(_this.clearStoreCallbacks.map(function (fn) {
          return fn();
        }));
      });
    };

    ApolloClient.prototype.onResetStore = function (cb) {
      var _this = this;

      this.resetStoreCallbacks.push(cb);
      return function () {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {
          return c !== cb;
        });
      };
    };

    ApolloClient.prototype.onClearStore = function (cb) {
      var _this = this;

      this.clearStoreCallbacks.push(cb);
      return function () {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {
          return c !== cb;
        });
      };
    };

    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };

    ApolloClient.prototype.extract = function (optimistic) {
      return this.cache.extract(optimistic);
    };

    ApolloClient.prototype.restore = function (serializedState) {
      return this.cache.restore(serializedState);
    };

    ApolloClient.prototype.addResolvers = function (resolvers) {
      this.localState.addResolvers(resolvers);
    };

    ApolloClient.prototype.setResolvers = function (resolvers) {
      this.localState.setResolvers(resolvers);
    };

    ApolloClient.prototype.getResolvers = function () {
      return this.localState.getResolvers();
    };

    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };

    return ApolloClient;
  }();

  _exports.ApolloClient = ApolloClient;
  var _default = ApolloClient;

  _exports.default = _default;
});

}).call(this,req('_process'))
},{"_process":307,"apollo-link":13,"apollo-utilities":16,"graphql/language/visitor":225,"symbol-observable":257,"ts-invariant":259,"tslib":260}],9:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var apollo_link_1 = req("apollo-link");
function onError(errorHandler) {
    return new apollo_link_1.ApolloLink(function (operation, forward) {
        return new apollo_link_1.Observable(function (observer) {
            var sub;
            var retriedSub;
            var retriedResult;
            try {
                sub = forward(operation).subscribe({
                    next: function (result) {
                        if (result.errors) {
                            retriedResult = errorHandler({
                                graphQLErrors: result.errors,
                                response: result,
                                operation: operation,
                                forward: forward,
                            });
                            if (retriedResult) {
                                retriedSub = retriedResult.subscribe({
                                    next: observer.next.bind(observer),
                                    error: observer.error.bind(observer),
                                    complete: observer.complete.bind(observer),
                                });
                                return;
                            }
                        }
                        observer.next(result);
                    },
                    error: function (networkError) {
                        retriedResult = errorHandler({
                            operation: operation,
                            networkError: networkError,
                            graphQLErrors: networkError &&
                                networkError.result &&
                                networkError.result.errors,
                            forward: forward,
                        });
                        if (retriedResult) {
                            retriedSub = retriedResult.subscribe({
                                next: observer.next.bind(observer),
                                error: observer.error.bind(observer),
                                complete: observer.complete.bind(observer),
                            });
                            return;
                        }
                        observer.error(networkError);
                    },
                    complete: function () {
                        if (!retriedResult) {
                            observer.complete.bind(observer)();
                        }
                    },
                });
            }
            catch (e) {
                errorHandler({ networkError: e, operation: operation, forward: forward });
                observer.error(e);
            }
            return function () {
                if (sub)
                    sub.unsubscribe();
                if (retriedSub)
                    sub.unsubscribe();
            };
        });
    });
}
exports.onError = onError;
var ErrorLink = (function (_super) {
    tslib_1.__extends(ErrorLink, _super);
    function ErrorLink(errorHandler) {
        var _this = _super.call(this) || this;
        _this.link = onError(errorHandler);
        return _this;
    }
    ErrorLink.prototype.request = function (operation, forward) {
        return this.link.request(operation, forward);
    };
    return ErrorLink;
}(apollo_link_1.ApolloLink));
exports.ErrorLink = ErrorLink;

},{"apollo-link":13,"tslib":260}],10:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var printer_1 = req("graphql/language/printer");
var ts_invariant_1 = req("ts-invariant");
var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false,
};
var defaultHeaders = {
    accept: '*/*',
    'content-type': 'application/json',
};
var defaultOptions = {
    method: 'POST',
};
exports.fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions,
};
exports.throwServerError = function (response, result, message) {
    var error = new Error(message);
    error.name = 'ServerError';
    error.response = response;
    error.statusCode = response.status;
    error.result = result;
    throw error;
};
exports.parseAndCheckHttpResponse = function (operations) { return function (response) {
    return (response
        .text()
        .then(function (bodyText) {
        try {
            return JSON.parse(bodyText);
        }
        catch (err) {
            var parseError = err;
            parseError.name = 'ServerParseError';
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            return Promise.reject(parseError);
        }
    })
        .then(function (result) {
        if (response.status >= 300) {
            exports.throwServerError(response, result, "Response not successful: Received status code " + response.status);
        }
        if (!Array.isArray(result) &&
            !result.hasOwnProperty('data') &&
            !result.hasOwnProperty('errors')) {
            exports.throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations)
                ? operations.map(function (op) { return op.operationName; })
                : operations.operationName) + "'.");
        }
        return result;
    }));
}; };
exports.checkFetcher = function (fetcher) {
    if (!fetcher && typeof fetch === 'undefined') {
        var library = 'unfetch';
        if (typeof window === 'undefined')
            library = 'node-fetch';
        throw new ts_invariant_1.InvariantError("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
    }
};
exports.createSignalIfSupported = function () {
    if (typeof AbortController === 'undefined')
        return { controller: false, signal: false };
    var controller = new AbortController();
    var signal = controller.signal;
    return { controller: controller, signal: signal };
};
exports.selectHttpOptionsAndBody = function (operation, fallbackConfig) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
    }
    var options = tslib_1.__assign({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
    var http = fallbackConfig.http;
    configs.forEach(function (config) {
        options = tslib_1.__assign({}, options, config.options, { headers: tslib_1.__assign({}, options.headers, config.headers) });
        if (config.credentials)
            options.credentials = config.credentials;
        http = tslib_1.__assign({}, http, config.http);
    });
    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName: operationName, variables: variables };
    if (http.includeExtensions)
        body.extensions = extensions;
    if (http.includeQuery)
        body.query = printer_1.print(query);
    return {
        options: options,
        body: body,
    };
};
exports.serializeFetchParameter = function (p, label) {
    var serialized;
    try {
        serialized = JSON.stringify(p);
    }
    catch (e) {
        var parseError = new ts_invariant_1.InvariantError("Network request failed. " + label + " is not serializable: " + e.message);
        parseError.parseError = e;
        throw parseError;
    }
    return serialized;
};
exports.selectURI = function (operation, fallbackURI) {
    var context = operation.getContext();
    var contextURI = context.uri;
    if (contextURI) {
        return contextURI;
    }
    else if (typeof fallbackURI === 'function') {
        return fallbackURI(operation);
    }
    else {
        return fallbackURI || '/graphql';
    }
};

},{"graphql/language/printer":222,"ts-invariant":259,"tslib":260}],11:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var apollo_link_1 = req("apollo-link");
var apollo_link_http_common_1 = req("apollo-link-http-common");
exports.createHttpLink = function (linkOptions) {
    if (linkOptions === void 0) { linkOptions = {}; }
    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = tslib_1.__rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]);
    apollo_link_http_common_1.checkFetcher(fetcher);
    if (!fetcher) {
        fetcher = fetch;
    }
    var linkConfig = {
        http: { includeExtensions: includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers,
    };
    return new apollo_link_1.ApolloLink(function (operation) {
        var chosenURI = apollo_link_http_common_1.selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
            if (name_1) {
                clientAwarenessHeaders['apollographql-client-name'] = name_1;
            }
            if (version) {
                clientAwarenessHeaders['apollographql-client-version'] = version;
            }
        }
        var contextHeaders = tslib_1.__assign({}, clientAwarenessHeaders, context.headers);
        var contextConfig = {
            http: context.http,
            options: context.fetchOptions,
            credentials: context.credentials,
            headers: contextHeaders,
        };
        var _b = apollo_link_http_common_1.selectHttpOptionsAndBody(operation, apollo_link_http_common_1.fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
        var controller;
        if (!options.signal) {
            var _c = apollo_link_http_common_1.createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
            controller = _controller;
            if (controller)
                options.signal = signal;
        }
        var definitionIsMutation = function (d) {
            return d.kind === 'OperationDefinition' && d.operation === 'mutation';
        };
        if (useGETForQueries &&
            !operation.query.definitions.some(definitionIsMutation)) {
            options.method = 'GET';
        }
        if (options.method === 'GET') {
            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
            if (parseError) {
                return apollo_link_1.fromError(parseError);
            }
            chosenURI = newURI;
        }
        else {
            try {
                options.body = apollo_link_http_common_1.serializeFetchParameter(body, 'Payload');
            }
            catch (parseError) {
                return apollo_link_1.fromError(parseError);
            }
        }
        return new apollo_link_1.Observable(function (observer) {
            fetcher(chosenURI, options)
                .then(function (response) {
                operation.setContext({ response: response });
                return response;
            })
                .then(apollo_link_http_common_1.parseAndCheckHttpResponse(operation))
                .then(function (result) {
                observer.next(result);
                observer.complete();
                return result;
            })
                .catch(function (err) {
                if (err.name === 'AbortError')
                    return;
                if (err.result && err.result.errors && err.result.data) {
                    observer.next(err.result);
                }
                observer.error(err);
            });
            return function () {
                if (controller)
                    controller.abort();
            };
        });
    });
};
function rewriteURIForGET(chosenURI, body) {
    var queryParams = [];
    var addQueryParam = function (key, value) {
        queryParams.push(key + "=" + encodeURIComponent(value));
    };
    if ('query' in body) {
        addQueryParam('query', body.query);
    }
    if (body.operationName) {
        addQueryParam('operationName', body.operationName);
    }
    if (body.variables) {
        var serializedVariables = void 0;
        try {
            serializedVariables = apollo_link_http_common_1.serializeFetchParameter(body.variables, 'Variables map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('variables', serializedVariables);
    }
    if (body.extensions) {
        var serializedExtensions = void 0;
        try {
            serializedExtensions = apollo_link_http_common_1.serializeFetchParameter(body.extensions, 'Extensions map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('extensions', serializedExtensions);
    }
    var fragment = '', preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf('#');
    if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
    return { newURI: newURI };
}
var HttpLink = (function (_super) {
    tslib_1.__extends(HttpLink, _super);
    function HttpLink(opts) {
        return _super.call(this, exports.createHttpLink(opts).request) || this;
    }
    return HttpLink;
}(apollo_link_1.ApolloLink));
exports.HttpLink = HttpLink;

},{"apollo-link":13,"apollo-link-http-common":10,"tslib":260}],12:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
tslib_1.__exportStar(req("./httpLink"), exports);

},{"./httpLink":11,"tslib":260}],13:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
tslib_1.__exportStar(req("./link"), exports);
var linkUtils_1 = req("./linkUtils");
exports.createOperation = linkUtils_1.createOperation;
exports.makePromise = linkUtils_1.makePromise;
exports.toPromise = linkUtils_1.toPromise;
exports.fromPromise = linkUtils_1.fromPromise;
exports.fromError = linkUtils_1.fromError;
exports.getOperationName = linkUtils_1.getOperationName;
var zen_observable_ts_1 = tslib_1.__importDefault(req("zen-observable-ts"));
exports.Observable = zen_observable_ts_1.default;

},{"./link":14,"./linkUtils":15,"tslib":260,"zen-observable-ts":262}],14:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var zen_observable_ts_1 = tslib_1.__importDefault(req("zen-observable-ts"));
var ts_invariant_1 = req("ts-invariant");
var linkUtils_1 = req("./linkUtils");
function passthrough(op, forward) {
    return forward ? forward(op) : zen_observable_ts_1.default.of();
}
function toLink(handler) {
    return typeof handler === 'function' ? new ApolloLink(handler) : handler;
}
function empty() {
    return new ApolloLink(function () { return zen_observable_ts_1.default.of(); });
}
exports.empty = empty;
function from(links) {
    if (links.length === 0)
        return empty();
    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
}
exports.from = from;
function split(test, left, right) {
    var leftLink = toLink(left);
    var rightLink = toLink(right || new ApolloLink(passthrough));
    if (linkUtils_1.isTerminating(leftLink) && linkUtils_1.isTerminating(rightLink)) {
        return new ApolloLink(function (operation) {
            return test(operation)
                ? leftLink.request(operation) || zen_observable_ts_1.default.of()
                : rightLink.request(operation) || zen_observable_ts_1.default.of();
        });
    }
    else {
        return new ApolloLink(function (operation, forward) {
            return test(operation)
                ? leftLink.request(operation, forward) || zen_observable_ts_1.default.of()
                : rightLink.request(operation, forward) || zen_observable_ts_1.default.of();
        });
    }
}
exports.split = split;
exports.concat = function (first, second) {
    var firstLink = toLink(first);
    if (linkUtils_1.isTerminating(firstLink)) {
        ts_invariant_1.invariant.warn(new linkUtils_1.LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
        return firstLink;
    }
    var nextLink = toLink(second);
    if (linkUtils_1.isTerminating(nextLink)) {
        return new ApolloLink(function (operation) {
            return firstLink.request(operation, function (op) { return nextLink.request(op) || zen_observable_ts_1.default.of(); }) || zen_observable_ts_1.default.of();
        });
    }
    else {
        return new ApolloLink(function (operation, forward) {
            return (firstLink.request(operation, function (op) {
                return nextLink.request(op, forward) || zen_observable_ts_1.default.of();
            }) || zen_observable_ts_1.default.of());
        });
    }
};
var ApolloLink = (function () {
    function ApolloLink(request) {
        if (request)
            this.request = request;
    }
    ApolloLink.prototype.split = function (test, left, right) {
        return this.concat(split(test, left, right || new ApolloLink(passthrough)));
    };
    ApolloLink.prototype.concat = function (next) {
        return exports.concat(this, next);
    };
    ApolloLink.prototype.request = function (operation, forward) {
        throw new ts_invariant_1.InvariantError('request is not implemented');
    };
    ApolloLink.empty = empty;
    ApolloLink.from = from;
    ApolloLink.split = split;
    ApolloLink.execute = execute;
    return ApolloLink;
}());
exports.ApolloLink = ApolloLink;
function execute(link, operation) {
    return (link.request(linkUtils_1.createOperation(operation.context, linkUtils_1.transformOperation(linkUtils_1.validateOperation(operation)))) || zen_observable_ts_1.default.of());
}
exports.execute = execute;

},{"./linkUtils":15,"ts-invariant":259,"tslib":260,"zen-observable-ts":262}],15:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var zen_observable_ts_1 = tslib_1.__importDefault(req("zen-observable-ts"));
var apollo_utilities_1 = req("apollo-utilities");
exports.getOperationName = apollo_utilities_1.getOperationName;
var ts_invariant_1 = req("ts-invariant");
function validateOperation(operation) {
    var OPERATION_FIELDS = [
        'query',
        'operationName',
        'variables',
        'extensions',
        'context',
    ];
    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
            throw new ts_invariant_1.InvariantError("illegal argument: " + key);
        }
    }
    return operation;
}
exports.validateOperation = validateOperation;
var LinkError = (function (_super) {
    tslib_1.__extends(LinkError, _super);
    function LinkError(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
    }
    return LinkError;
}(Error));
exports.LinkError = LinkError;
function isTerminating(link) {
    return link.request.length <= 1;
}
exports.isTerminating = isTerminating;
function toPromise(observable) {
    var completed = false;
    return new Promise(function (resolve, reject) {
        observable.subscribe({
            next: function (data) {
                if (completed) {
                    ts_invariant_1.invariant.warn("Promise Wrapper does not support multiple results from Observable");
                }
                else {
                    completed = true;
                    resolve(data);
                }
            },
            error: reject,
        });
    });
}
exports.toPromise = toPromise;
exports.makePromise = toPromise;
function fromPromise(promise) {
    return new zen_observable_ts_1.default(function (observer) {
        promise
            .then(function (value) {
            observer.next(value);
            observer.complete();
        })
            .catch(observer.error.bind(observer));
    });
}
exports.fromPromise = fromPromise;
function fromError(errorValue) {
    return new zen_observable_ts_1.default(function (observer) {
        observer.error(errorValue);
    });
}
exports.fromError = fromError;
function transformOperation(operation) {
    var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query,
    };
    if (!transformedOperation.operationName) {
        transformedOperation.operationName =
            typeof transformedOperation.query !== 'string'
                ? apollo_utilities_1.getOperationName(transformedOperation.query)
                : '';
    }
    return transformedOperation;
}
exports.transformOperation = transformOperation;
function createOperation(starting, operation) {
    var context = tslib_1.__assign({}, starting);
    var setContext = function (next) {
        if (typeof next === 'function') {
            context = tslib_1.__assign({}, context, next(context));
        }
        else {
            context = tslib_1.__assign({}, context, next);
        }
    };
    var getContext = function () { return (tslib_1.__assign({}, context)); };
    Object.defineProperty(operation, 'setContext', {
        enumerable: false,
        value: setContext,
    });
    Object.defineProperty(operation, 'getContext', {
        enumerable: false,
        value: getContext,
    });
    Object.defineProperty(operation, 'toKey', {
        enumerable: false,
        value: function () { return getKey(operation); },
    });
    return operation;
}
exports.createOperation = createOperation;
function getKey(operation) {
    var query = operation.query, variables = operation.variables, operationName = operation.operationName;
    return JSON.stringify([operationName, query, variables]);
}
exports.getKey = getKey;

},{"apollo-utilities":16,"ts-invariant":259,"tslib":260,"zen-observable-ts":262}],16:[function(req,module,exports){
(function (process){
exports.__esModule = true;
exports.addTypenameToDocument = addTypenameToDocument;
exports.argumentsObjectFromField = argumentsObjectFromField;
exports.assign = assign;
exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
exports.checkDocument = checkDocument;
exports.cloneDeep = cloneDeep;
exports.createFragmentMap = createFragmentMap;
exports.getDefaultValues = getDefaultValues;
exports.getDirectiveInfoFromField = getDirectiveInfoFromField;
exports.getDirectiveNames = getDirectiveNames;
exports.getDirectivesFromDocument = getDirectivesFromDocument;
exports.getEnv = getEnv;
exports.getFragmentDefinition = getFragmentDefinition;
exports.getFragmentDefinitions = getFragmentDefinitions;
exports.getFragmentQueryDocument = getFragmentQueryDocument;
exports.getInclusionDirectives = getInclusionDirectives;
exports.getMainDefinition = getMainDefinition;
exports.getMutationDefinition = getMutationDefinition;
exports.getOperationDefinition = getOperationDefinition;
exports.getOperationDefinitionOrDie = getOperationDefinitionOrDie;
exports.getOperationName = getOperationName;
exports.getQueryDefinition = getQueryDefinition;
exports.getStoreKeyName = getStoreKeyName;
exports.graphQLResultHasError = graphQLResultHasError;
exports.hasClientExports = hasClientExports;
exports.hasDirectives = hasDirectives;
exports.isDevelopment = isDevelopment;
exports.isEnv = isEnv;
exports.isField = isField;
exports.isIdValue = isIdValue;
exports.isInlineFragment = isInlineFragment;
exports.isJsonValue = isJsonValue;
exports.isNumberValue = isNumberValue;
exports.isProduction = isProduction;
exports.isScalarValue = isScalarValue;
exports.isTest = isTest;
exports.maybeDeepFreeze = maybeDeepFreeze;
exports.mergeDeep = mergeDeep;
exports.mergeDeepArray = mergeDeepArray;
exports.removeArgumentsFromDocument = removeArgumentsFromDocument;
exports.removeClientSetsFromDocument = removeClientSetsFromDocument;
exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
exports.removeDirectivesFromDocument = removeDirectivesFromDocument;
exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
exports.resultKeyNameFromField = resultKeyNameFromField;
exports.shouldInclude = shouldInclude;
exports.storeKeyNameFromField = storeKeyNameFromField;
exports.stripSymbols = stripSymbols;
exports.toIdValue = toIdValue;
exports.tryFunctionOrLogError = tryFunctionOrLogError;
exports.valueFromNode = valueFromNode;
exports.valueToObjectRepresentation = valueToObjectRepresentation;
exports.variablesInOperation = variablesInOperation;
exports.warnOnceInDevelopment = warnOnceInDevelopment;
exports.canUseWeakMap = exports.isEqual = void 0;

var _visitor = req("graphql/language/visitor");

var _tsInvariant = req("ts-invariant");

var _tslib = req("tslib");

var _fastJsonStableStringify = _interopreqDefault(req("fast-json-stable-stringify"));

var _equality = req("@wry/equality");

exports.isEqual = _equality.equal;

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isScalarValue(value) {
  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;
}

function isNumberValue(value) {
  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;
}

function isStringValue(value) {
  return value.kind === 'StringValue';
}

function isBooleanValue(value) {
  return value.kind === 'BooleanValue';
}

function isIntValue(value) {
  return value.kind === 'IntValue';
}

function isFloatValue(value) {
  return value.kind === 'FloatValue';
}

function isVariable(value) {
  return value.kind === 'Variable';
}

function isObjectValue(value) {
  return value.kind === 'ObjectValue';
}

function isListValue(value) {
  return value.kind === 'ListValue';
}

function isEnumValue(value) {
  return value.kind === 'EnumValue';
}

function isNullValue(value) {
  return value.kind === 'NullValue';
}

function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function (obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function (listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(17) : new _tsInvariant.InvariantError("The inline argument \"" + name.value + "\" of kind \"" + value.kind + "\"" + 'is not supported. Use variables instead of inline arguments to ' + 'overcome this limitation.');
  }
}

function storeKeyNameFromField(field, variables) {
  var directivesObj = null;

  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function (directive) {
      directivesObj[directive.name.value] = {};

      if (directive.arguments) {
        directive.arguments.forEach(function (_a) {
          var name = _a.name,
              value = _a.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }

  var argObj = null;

  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function (_a) {
      var name = _a.name,
          value = _a.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }

  return getStoreKeyName(field.name.value, argObj, directivesObj);
}

var KNOWN_DIRECTIVES = ['connection', 'include', 'skip', 'client', 'rest', 'export'];

function getStoreKeyName(fieldName, args, directives) {
  if (directives && directives['connection'] && directives['connection']['key']) {
    if (directives['connection']['filter'] && directives['connection']['filter'].length > 0) {
      var filterKeys = directives['connection']['filter'] ? directives['connection']['filter'] : [];
      filterKeys.sort();
      var queryArgs_1 = args;
      var filteredArgs_1 = {};
      filterKeys.forEach(function (key) {
        filteredArgs_1[key] = queryArgs_1[key];
      });
      return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
    } else {
      return directives['connection']['key'];
    }
  }

  var completeFieldName = fieldName;

  if (args) {
    var stringifiedArgs = (0, _fastJsonStableStringify.default)(args);
    completeFieldName += "(" + stringifiedArgs + ")";
  }

  if (directives) {
    Object.keys(directives).forEach(function (key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;

      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
      } else {
        completeFieldName += "@" + key;
      }
    });
  }

  return completeFieldName;
}

function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function (_a) {
      var name = _a.name,
          value = _a.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }

  return null;
}

function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}

function isField(selection) {
  return selection.kind === 'Field';
}

function isInlineFragment(selection) {
  return selection.kind === 'InlineFragment';
}

function isIdValue(idObject) {
  return idObject && idObject.type === 'id' && typeof idObject.generated === 'boolean';
}

function toIdValue(idConfig, generated) {
  if (generated === void 0) {
    generated = false;
  }

  return (0, _tslib.__assign)({
    type: 'id',
    generated: generated
  }, typeof idConfig === 'string' ? {
    id: idConfig,
    typename: undefined
  } : idConfig);
}

function isJsonValue(jsonObject) {
  return jsonObject != null && typeof jsonObject === 'object' && jsonObject.type === 'json';
}

function defaultValueFromVariable(node) {
  throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(18) : new _tsInvariant.InvariantError("Variable nodes are not supported by valueFromNode");
}

function valueFromNode(node, onVariable) {
  if (onVariable === void 0) {
    onVariable = defaultValueFromVariable;
  }

  switch (node.kind) {
    case 'Variable':
      return onVariable(node);

    case 'NullValue':
      return null;

    case 'IntValue':
      return parseInt(node.value, 10);

    case 'FloatValue':
      return parseFloat(node.value);

    case 'ListValue':
      return node.values.map(function (v) {
        return valueFromNode(v, onVariable);
      });

    case 'ObjectValue':
      {
        var value = {};

        for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {
          var field = _a[_i];
          value[field.name.value] = valueFromNode(field.value, onVariable);
        }

        return value;
      }

    default:
      return node.value;
  }
}

function getDirectiveInfoFromField(field, variables) {
  if (field.directives && field.directives.length) {
    var directiveObj_1 = {};
    field.directives.forEach(function (directive) {
      directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);
    });
    return directiveObj_1;
  }

  return null;
}

function shouldInclude(selection, variables) {
  if (variables === void 0) {
    variables = {};
  }

  return getInclusionDirectives(selection.directives).every(function (_a) {
    var directive = _a.directive,
        ifArgument = _a.ifArgument;
    var evaledValue = false;

    if (ifArgument.value.kind === 'Variable') {
      evaledValue = variables[ifArgument.value.name.value];
      process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(evaledValue !== void 0, 3) : (0, _tsInvariant.invariant)(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.");
    } else {
      evaledValue = ifArgument.value.value;
    }

    return directive.name.value === 'skip' ? !evaledValue : evaledValue;
  });
}

function getDirectiveNames(doc) {
  var names = [];
  (0, _visitor.visit)(doc, {
    Directive: function (node) {
      names.push(node.name.value);
    }
  });
  return names;
}

function hasDirectives(names, doc) {
  return getDirectiveNames(doc).some(function (name) {
    return names.indexOf(name) > -1;
  });
}

function hasClientExports(document) {
  return document && hasDirectives(['client'], document) && hasDirectives(['export'], document);
}

function isInclusionDirective(_a) {
  var value = _a.name.value;
  return value === 'skip' || value === 'include';
}

function getInclusionDirectives(directives) {
  return directives ? directives.filter(isInclusionDirective).map(function (directive) {
    var directiveArguments = directive.arguments;
    var directiveName = directive.name.value;
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(directiveArguments && directiveArguments.length === 1, 4) : (0, _tsInvariant.invariant)(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.");
    var ifArgument = directiveArguments[0];
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(ifArgument.name && ifArgument.name.value === 'if', 5) : (0, _tsInvariant.invariant)(ifArgument.name && ifArgument.name.value === 'if', "Invalid argument for the @" + directiveName + " directive.");
    var ifValue = ifArgument.value;
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(ifValue && (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 6) : (0, _tsInvariant.invariant)(ifValue && (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
    return {
      directive: directive,
      ifArgument: ifArgument
    };
  }) : [];
}

function getFragmentQueryDocument(document, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document.definitions.forEach(function (definition) {
    if (definition.kind === 'OperationDefinition') {
      throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(1) : new _tsInvariant.InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : '') + ". " + 'No operations are allowed when using a fragment as a query. Only fragments are allowed.');
    }

    if (definition.kind === 'FragmentDefinition') {
      fragments.push(definition);
    }
  });

  if (typeof actualFragmentName === 'undefined') {
    process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(fragments.length === 1, 2) : (0, _tsInvariant.invariant)(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
    actualFragmentName = fragments[0].name.value;
  }

  var query = (0, _tslib.__assign)({}, document, {
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections: [{
          kind: 'FragmentSpread',
          name: {
            kind: 'Name',
            value: actualFragmentName
          }
        }]
      }
    }].concat(document.definitions)
  });
  return query;
}

function assign(target) {
  var sources = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }

  sources.forEach(function (source) {
    if (typeof source === 'undefined' || source === null) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
}

function getMutationDefinition(doc) {
  checkDocument(doc);
  var mutationDef = doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition' && definition.operation === 'mutation';
  })[0];
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(mutationDef, 7) : (0, _tsInvariant.invariant)(mutationDef, 'Must contain a mutation definition.');
  return mutationDef;
}

function checkDocument(doc) {
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(doc && doc.kind === 'Document', 8) : (0, _tsInvariant.invariant)(doc && doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
  var operations = doc.definitions.filter(function (d) {
    return d.kind !== 'FragmentDefinition';
  }).map(function (definition) {
    if (definition.kind !== 'OperationDefinition') {
      throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(9) : new _tsInvariant.InvariantError("Schema type definitions not allowed in queries. Found: \"" + definition.kind + "\"");
    }

    return definition;
  });
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(operations.length <= 1, 10) : (0, _tsInvariant.invariant)(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations");
  return doc;
}

function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition';
  })[0];
}

function getOperationDefinitionOrDie(document) {
  var def = getOperationDefinition(document);
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(def, 11) : (0, _tsInvariant.invariant)(def, "GraphQL document is missing an operation");
  return def;
}

function getOperationName(doc) {
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition' && definition.name;
  }).map(function (x) {
    return x.name.value;
  })[0] || null;
}

function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'FragmentDefinition';
  });
}

function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(queryDef && queryDef.operation === 'query', 12) : (0, _tsInvariant.invariant)(queryDef && queryDef.operation === 'query', 'Must contain a query definition.');
  return queryDef;
}

function getFragmentDefinition(doc) {
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(doc.kind === 'Document', 13) : (0, _tsInvariant.invariant)(doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(doc.definitions.length <= 1, 14) : (0, _tsInvariant.invariant)(doc.definitions.length <= 1, 'Fragment must have exactly one definition.');
  var fragmentDef = doc.definitions[0];
  process.env.NODE_ENV === "production" ? (0, _tsInvariant.invariant)(fragmentDef.kind === 'FragmentDefinition', 15) : (0, _tsInvariant.invariant)(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.');
  return fragmentDef;
}

function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;

  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
    var definition = _a[_i];

    if (definition.kind === 'OperationDefinition') {
      var operation = definition.operation;

      if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {
        return definition;
      }
    }

    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }

  if (fragmentDefinition) {
    return fragmentDefinition;
  }

  throw process.env.NODE_ENV === "production" ? new _tsInvariant.InvariantError(16) : new _tsInvariant.InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');
}

function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }

  var symTable = {};
  fragments.forEach(function (fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}

function getDefaultValues(definition) {
  if (definition && definition.variableDefinitions && definition.variableDefinitions.length) {
    var defaultValues = definition.variableDefinitions.filter(function (_a) {
      var defaultValue = _a.defaultValue;
      return defaultValue;
    }).map(function (_a) {
      var variable = _a.variable,
          defaultValue = _a.defaultValue;
      var defaultValueObj = {};
      valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);
      return defaultValueObj;
    });
    return assign.apply(void 0, [{}].concat(defaultValues));
  }

  return {};
}

function variablesInOperation(operation) {
  var names = new Set();

  if (operation.variableDefinitions) {
    for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {
      var definition = _a[_i];
      names.add(definition.variable.name.value);
    }
  }

  return names;
}

function filterInPlace(array, test, context) {
  var target = 0;
  array.forEach(function (elem, i) {
    if (test.call(this, elem, i, array)) {
      array[target++] = elem;
    }
  }, context);
  array.length = target;
  return array;
}

var TYPENAME_FIELD = {
  kind: 'Field',
  name: {
    kind: 'Name',
    value: '__typename'
  }
};

function isEmpty(op, fragments) {
  return op.selectionSet.selections.every(function (selection) {
    return selection.kind === 'FragmentSpread' && isEmpty(fragments[selection.name.value], fragments);
  });
}

function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}

function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function (dir) {
      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
    });
  };
}

function removeDirectivesFromDocument(directives, doc) {
  var variablesInUse = Object.create(null);
  var variablesToRemove = [];
  var fragmentSpreadsInUse = Object.create(null);
  var fragmentSpreadsToRemove = [];
  var modifiedDoc = nullIfDocIsEmpty((0, _visitor.visit)(doc, {
    Variable: {
      enter: function (node, _key, parent) {
        if (parent.kind !== 'VariableDefinition') {
          variablesInUse[node.name.value] = true;
        }
      }
    },
    Field: {
      enter: function (node) {
        if (directives && node.directives) {
          var shouldRemoveField = directives.some(function (directive) {
            return directive.remove;
          });

          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
            if (node.arguments) {
              node.arguments.forEach(function (arg) {
                if (arg.value.kind === 'Variable') {
                  variablesToRemove.push({
                    name: arg.value.name.value
                  });
                }
              });
            }

            if (node.selectionSet) {
              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                fragmentSpreadsToRemove.push({
                  name: frag.name.value
                });
              });
            }

            return null;
          }
        }
      }
    },
    FragmentSpread: {
      enter: function (node) {
        fragmentSpreadsInUse[node.name.value] = true;
      }
    },
    Directive: {
      enter: function (node) {
        if (getDirectiveMatcher(directives)(node)) {
          return null;
        }
      }
    }
  }));

  if (modifiedDoc && filterInPlace(variablesToRemove, function (v) {
    return !variablesInUse[v.name];
  }).length) {
    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
  }

  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function (fs) {
    return !fragmentSpreadsInUse[fs.name];
  }).length) {
    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
  }

  return modifiedDoc;
}

function addTypenameToDocument(doc) {
  return (0, _visitor.visit)(checkDocument(doc), {
    SelectionSet: {
      enter: function (node, _key, parent) {
        if (parent && parent.kind === 'OperationDefinition') {
          return;
        }

        var selections = node.selections;

        if (!selections) {
          return;
        }

        var skip = selections.some(function (selection) {
          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);
        });

        if (skip) {
          return;
        }

        var field = parent;

        if (isField(field) && field.directives && field.directives.some(function (d) {
          return d.name.value === 'export';
        })) {
          return;
        }

        return (0, _tslib.__assign)({}, node, {
          selections: selections.concat([TYPENAME_FIELD])
        });
      }
    }
  });
}

var connectionRemoveConfig = {
  test: function (directive) {
    var willRemove = directive.name.value === 'connection';

    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function (arg) {
        return arg.name.value === 'key';
      })) {
        process.env.NODE_ENV === "production" || _tsInvariant.invariant.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');
      }
    }

    return willRemove;
  }
};

function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}

function hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {
  if (nestedCheck === void 0) {
    nestedCheck = true;
  }

  return selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {
    return hasDirectivesInSelection(directives, selection, nestedCheck);
  });
}

function hasDirectivesInSelection(directives, selection, nestedCheck) {
  if (nestedCheck === void 0) {
    nestedCheck = true;
  }

  if (!isField(selection)) {
    return true;
  }

  if (!selection.directives) {
    return false;
  }

  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);
}

function getDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var parentPath;
  return nullIfDocIsEmpty((0, _visitor.visit)(doc, {
    SelectionSet: {
      enter: function (node, _key, _parent, path) {
        var currentPath = path.join('-');

        if (!parentPath || currentPath === parentPath || !currentPath.startsWith(parentPath)) {
          if (node.selections) {
            var selectionsWithDirectives = node.selections.filter(function (selection) {
              return hasDirectivesInSelection(directives, selection);
            });

            if (hasDirectivesInSelectionSet(directives, node, false)) {
              parentPath = currentPath;
            }

            return (0, _tslib.__assign)({}, node, {
              selections: selectionsWithDirectives
            });
          } else {
            return null;
          }
        }
      }
    }
  }));
}

function getArgumentMatcher(config) {
  return function argumentMatcher(argument) {
    return config.some(function (aConfig) {
      return argument.value && argument.value.kind === 'Variable' && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}

function removeArgumentsFromDocument(config, doc) {
  var argMatcher = getArgumentMatcher(config);
  return nullIfDocIsEmpty((0, _visitor.visit)(doc, {
    OperationDefinition: {
      enter: function (node) {
        return (0, _tslib.__assign)({}, node, {
          variableDefinitions: node.variableDefinitions.filter(function (varDef) {
            return !config.some(function (arg) {
              return arg.name === varDef.variable.name.value;
            });
          })
        });
      }
    },
    Field: {
      enter: function (node) {
        var shouldRemoveField = config.some(function (argConfig) {
          return argConfig.remove;
        });

        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          node.arguments.forEach(function (arg) {
            if (argMatcher(arg)) {
              argMatchCount_1 += 1;
            }
          });

          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function (node) {
        if (argMatcher(node)) {
          return null;
        }
      }
    }
  }));
}

function removeFragmentSpreadFromDocument(config, doc) {
  function enter(node) {
    if (config.some(function (def) {
      return def.name === node.name.value;
    })) {
      return null;
    }
  }

  return nullIfDocIsEmpty((0, _visitor.visit)(doc, {
    FragmentSpread: {
      enter: enter
    },
    FragmentDefinition: {
      enter: enter
    }
  }));
}

function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
  var allFragments = [];
  selectionSet.selections.forEach(function (selection) {
    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) {
        return allFragments.push(frag);
      });
    } else if (selection.kind === 'FragmentSpread') {
      allFragments.push(selection);
    }
  });
  return allFragments;
}

function buildQueryFromSelectionSet(document) {
  var definition = getMainDefinition(document);
  var definitionOperation = definition.operation;

  if (definitionOperation === 'query') {
    return document;
  }

  var modifiedDoc = (0, _visitor.visit)(document, {
    OperationDefinition: {
      enter: function (node) {
        return (0, _tslib.__assign)({}, node, {
          operation: 'query'
        });
      }
    }
  });
  return modifiedDoc;
}

function removeClientSetsFromDocument(document) {
  checkDocument(document);
  var modifiedDoc = removeDirectivesFromDocument([{
    test: function (directive) {
      return directive.name.value === 'client';
    },
    remove: true
  }], document);

  if (modifiedDoc) {
    modifiedDoc = (0, _visitor.visit)(modifiedDoc, {
      FragmentDefinition: {
        enter: function (node) {
          if (node.selectionSet) {
            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
              return isField(selection) && selection.name.value === '__typename';
            });

            if (isTypenameOnly) {
              return null;
            }
          }
        }
      }
    });
  }

  return modifiedDoc;
}

var canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' && navigator.product === 'ReactNative');
exports.canUseWeakMap = canUseWeakMap;
var toString = Object.prototype.toString;

function cloneDeep(value) {
  return cloneDeepHelper(value, new Map());
}

function cloneDeepHelper(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]":
      {
        if (seen.has(val)) return seen.get(val);
        var copy_1 = val.slice(0);
        seen.set(val, copy_1);
        copy_1.forEach(function (child, i) {
          copy_1[i] = cloneDeepHelper(child, seen);
        });
        return copy_1;
      }

    case "[object Object]":
      {
        if (seen.has(val)) return seen.get(val);
        var copy_2 = Object.create(Object.getPrototypeOf(val));
        seen.set(val, copy_2);
        Object.keys(val).forEach(function (key) {
          copy_2[key] = cloneDeepHelper(val[key], seen);
        });
        return copy_2;
      }

    default:
      return val;
  }
}

function getEnv() {
  if (typeof process !== 'undefined' && process.env.NODE_ENV) {
    return process.env.NODE_ENV;
  }

  return 'development';
}

function isEnv(env) {
  return getEnv() === env;
}

function isProduction() {
  return isEnv('production') === true;
}

function isDevelopment() {
  return isEnv('development') === true;
}

function isTest() {
  return isEnv('test') === true;
}

function tryFunctionOrLogError(f) {
  try {
    return f();
  } catch (e) {
    if (console.error) {
      console.error(e);
    }
  }
}

function graphQLResultHasError(result) {
  return result.errors && result.errors.length;
}

function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
}

function maybeDeepFreeze(obj) {
  if (isDevelopment() || isTest()) {
    var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';

    if (!symbolIsPolyfilled) {
      return deepFreeze(obj);
    }
  }

  return obj;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

function mergeDeep() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  return mergeDeepArray(sources);
}

function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;

  if (count > 1) {
    var pastCopies = [];
    target = shallowCopyForMerge(target, pastCopies);

    for (var i = 1; i < count; ++i) {
      target = mergeHelper(target, sources[i], pastCopies);
    }
  }

  return target;
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function mergeHelper(target, source, pastCopies) {
  if (isObject(source) && isObject(target)) {
    if (Object.isExtensible && !Object.isExtensible(target)) {
      target = shallowCopyForMerge(target, pastCopies);
    }

    Object.keys(source).forEach(function (sourceKey) {
      var sourceValue = source[sourceKey];

      if (hasOwnProperty.call(target, sourceKey)) {
        var targetValue = target[sourceKey];

        if (sourceValue !== targetValue) {
          target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);
        }
      } else {
        target[sourceKey] = sourceValue;
      }
    });
    return target;
  }

  return source;
}

function shallowCopyForMerge(value, pastCopies) {
  if (value !== null && typeof value === 'object' && pastCopies.indexOf(value) < 0) {
    if (Array.isArray(value)) {
      value = value.slice(0);
    } else {
      value = (0, _tslib.__assign)({
        __proto__: Object.getPrototypeOf(value)
      }, value);
    }

    pastCopies.push(value);
  }

  return value;
}

var haveWarned = Object.create({});

function warnOnceInDevelopment(msg, type) {
  if (type === void 0) {
    type = 'warn';
  }

  if (!isProduction() && !haveWarned[msg]) {
    if (!isTest()) {
      haveWarned[msg] = true;
    }

    if (type === 'error') {
      console.error(msg);
    } else {
      console.warn(msg);
    }
  }
}

function stripSymbols(data) {
  return JSON.parse(JSON.stringify(data));
}

}).call(this,req('_process'))
},{"@wry/equality":4,"_process":307,"fast-json-stable-stringify":202,"graphql/language/visitor":225,"ts-invariant":259,"tslib":260}],17:[function(req,module,exports){
/*!
 * aead.js - aead for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/aead');

},{"./js/aead":82}],18:[function(req,module,exports){
/*!
 * aes.js - aes for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/aes');

},{"./js/aes":83}],19:[function(req,module,exports){
(function (Buffer){
/*!
 * bcrypt.js - bcrypt for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on joyent/node-bcrypt-pbkdf:
 *   Copyright (c) 2016, Joyent Inc
 *   https://github.com/joyent/node-bcrypt-pbkdf
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Bcrypt
 *   http://www.usenix.org/events/usenix99/provos/provos_html/node1.html
 *   https://hackernoon.com/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd
 *   https://github.com/openbsd/src/blob/master/lib/libc/crypt/bcrypt.c
 *   https://github.com/openssh/openssh-portable
 *   https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/bcrypt_pbkdf.c
 *   https://github.com/openssh/openssh-portable/blob/master/openbsd-compat/blowfish.c
 *   https://github.com/joyent/node-bcrypt-pbkdf/blob/master/index.js
 */

'use strict';

const assert = req('bsert');
const SHA512 = req('./sha512');
const Blowfish = req('./js/ciphers/blowfish');

/*
 * Constants
 */

const CIPHERTEXT192 = Buffer.from('OrpheanBeholderScryDoubt', 'binary');
const BCRYPT_BLOCKS192 = 6;
const BCRYPT_SIZE192 = 24;
const BCRYPT_SALT192 = 16;
const BCRYPT_HASH192 = 23;

const CIPHERTEXT256 = Buffer.from('OxychromaticBlowfishSwatDynamite', 'binary');
const BCRYPT_BLOCKS256 = 8;
const BCRYPT_SIZE256 = 32;

const NUL = Buffer.alloc(1, 0x00);

/*
 * Bcrypt
 */

function hash192(pass, salt, rounds) {
  if (typeof pass === 'string')
    pass = Buffer.from(pass, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(Buffer.isBuffer(pass));
  assert(Buffer.isBuffer(salt));
  assert((rounds >>> 0) === rounds);

  if (rounds < 4 || rounds > 31)
    throw new RangeError('Invalid rounds.');

  return _hash192(pass, salt, rounds, Buffer.alloc(BCRYPT_SIZE192));
}

function derive(pass, salt, rounds, minor = 'b') {
  if (typeof pass === 'string')
    pass = Buffer.from(pass, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  assert(Buffer.isBuffer(pass));
  assert(Buffer.isBuffer(salt));
  assert((rounds >>> 0) === rounds);
  assert(typeof minor === 'string');

  if (salt.length !== BCRYPT_SALT192)
    throw new RangeError('Invalid salt length.');

  switch (minor) {
    case 'a':
      pass = Buffer.concat([pass, NUL]);
      pass = pass.slice(0, pass.length & 0xff);
      break;
    case 'b':
      if (pass.length > 72)
        pass = pass.slice(0, 73);
      else
        pass = Buffer.concat([pass, NUL]);
      break;
    default:
      throw new Error('Invalid minor version.');
  }

  return hash192(pass, salt, rounds).slice(0, BCRYPT_HASH192);
}

function generate(pass, salt, rounds, minor = 'b') {
  if (typeof salt === 'string') {
    const [i, data] = decode64(salt, 0, BCRYPT_SALT192);

    if (i !== salt.length || data == null)
      throw new Error('Invalid salt string.');

    salt = data;
  }

  const hash = derive(pass, salt, rounds, minor);

  return encode(minor, rounds, salt, hash);
}

function verify(pass, record) {
  const [minor, rounds, salt, expect] = decode(record);
  const hash = derive(pass, salt, rounds, minor);

  let res = 0;

  for (let i = 0; i < BCRYPT_HASH192; i++)
    res |= hash[i] ^ expect[i];

  return ((res - 1) >>> 31) !== 0;
}

/*
 * PBKDF
 */

function hash256(pass, salt, rounds) {
  if (typeof pass === 'string')
    pass = Buffer.from(pass, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(Buffer.isBuffer(pass));
  assert(Buffer.isBuffer(salt));
  assert((rounds >>> 0) === rounds);

  if (rounds < 4 || rounds > 31)
    throw new RangeError('Invalid rounds.');

  return _hash256(pass, salt, rounds, Buffer.alloc(BCRYPT_SIZE256));
}

function pbkdf(pass, salt, rounds, size) {
  if (typeof pass === 'string')
    pass = Buffer.from(pass, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(Buffer.isBuffer(pass));
  assert(Buffer.isBuffer(salt));
  assert((rounds >>> 0) === rounds);
  assert((size >>> 0) === size);

  const out = Buffer.alloc(BCRYPT_SIZE256);
  const tmpout = Buffer.alloc(BCRYPT_SIZE256);
  const countsalt = Buffer.alloc(salt.length + 4);
  const key = Buffer.alloc(size);

  if (rounds < 1
      || pass.length === 0
      || salt.length === 0
      || size === 0
      || size > out.length ** 2
      || salt.length > (1 << 20)) {
    throw new Error('Invalid bcrypt parameters.');
  }

  const stride = ((size + out.length - 1) / out.length) >>> 0;
  const amount = ((size + stride - 1) / stride) >>> 0;

  salt.copy(countsalt, 0);

  const sha2pass = SHA512.digest(pass);

  let sha2salt = Buffer.alloc(0);
  let keylen = size;
  let amt = amount;

  for (let count = 1; keylen > 0; count++) {
    countsalt[salt.length + 0] = count >>> 24;
    countsalt[salt.length + 1] = count >>> 16;
    countsalt[salt.length + 2] = count >>> 8;
    countsalt[salt.length + 3] = count;

    sha2salt = SHA512.digest(countsalt);

    _hash256(sha2pass, sha2salt, 6, tmpout);

    tmpout.copy(out, 0);

    for (let i = 1; i < rounds; i++) {
      sha2salt = SHA512.digest(tmpout);

      _hash256(sha2pass, sha2salt, 6, tmpout);

      for (let j = 0; j < out.length; j++)
        out[j] ^= tmpout[j];
    }

    amt = Math.min(amt, keylen);

    let i = 0;

    for (; i < amt; i++) {
      const dest = i * stride + (count - 1);

      if (dest >= size)
        break;

      key[dest] = out[i];
    }

    keylen -= i;
  }

  return key;
}

/*
 * Hashing
 */

function _hash192(pass, salt, rounds, out) {
  const state = new Blowfish();
  const cdata = new Uint32Array(BCRYPT_BLOCKS192);

  state.init(pass, salt);

  const r = 2 ** rounds;

  for (let i = 0; i < r; i++) {
    state.expand0state(pass);
    state.expand0state(salt);
  }

  for (let i = 0; i < BCRYPT_BLOCKS192; i++)
    cdata[i] = state.stream2word(CIPHERTEXT192);

  for (let i = 0; i < 64; i++)
    state.enc(cdata);

  for (let i = 0; i < BCRYPT_BLOCKS192; i++) {
    out[4 * i + 0] = cdata[i] >>> 24;
    out[4 * i + 1] = cdata[i] >>> 16;
    out[4 * i + 2] = cdata[i] >>> 8;
    out[4 * i + 3] = cdata[i];
  }

  return out;
}

function _hash256(pass, salt, rounds, out) {
  const state = new Blowfish();
  const cdata = new Uint32Array(BCRYPT_BLOCKS256);

  state.init(pass, salt);

  const r = 2 ** rounds;

  for (let i = 0; i < r; i++) {
    state.expand0state(salt);
    state.expand0state(pass);
  }

  for (let i = 0; i < BCRYPT_BLOCKS256; i++)
    cdata[i] = state.stream2word(CIPHERTEXT256);

  for (let i = 0; i < 64; i++)
    state.enc(cdata);

  for (let i = 0; i < BCRYPT_BLOCKS256; i++) {
    out[4 * i + 3] = cdata[i] >>> 24;
    out[4 * i + 2] = cdata[i] >>> 16;
    out[4 * i + 1] = cdata[i] >>> 8;
    out[4 * i + 0] = cdata[i];
  }

  return out;
}

/*
 * Encoding
 */

function encode(minor, rounds, salt, hash) {
  assert(typeof minor === 'string');
  assert((rounds >>> 0) === rounds);
  assert(Buffer.isBuffer(salt));
  assert(Buffer.isBuffer(hash));
  assert(minor === 'a' || minor === 'b');
  assert(rounds >= 4 && rounds <= 31);
  assert(salt.length === BCRYPT_SALT192);
  assert(hash.length === BCRYPT_HASH192);

  let logr = rounds.toString(10);

  if (rounds < 10)
    logr = '0' + logr;

  return `$2${minor}$${logr}$${encode64(salt)}${encode64(hash)}`;
}

function decode(str) {
  assert(typeof str === 'string');

  if (str.length < 46)
    throw new Error('Invalid bcrypt string.');

  if (str[0] !== '$' || str[1] !== '2')
    throw new Error('Invalid major version.');

  const minor = str[2];

  switch (minor) {
    case 'a':
    case 'b':
      break;
    default:
      throw new Error('Invalid minor version.');
  }

  if (str[3] !== '$')
    throw new Error('Invalid bcrypt string.');

  const p = str.charCodeAt(4) - 0x30;
  const q = str.charCodeAt(5) - 0x30;

  if (p < 0 || p > 9 || q < 0 || q > 9)
    throw new Error('Invalid bcrypt string.');

  const rounds = p * 10 + q;

  if (rounds < 4 || rounds > 31)
    throw new Error('Invalid log rounds.');

  if (str[6] !== '$')
    throw new Error('Invalid bcrypt string.');

  let i = 7;
  let salt, hash;

  [i, salt] = decode64(str, i, BCRYPT_SALT192);

  if (salt == null)
    throw new Error('Invalid salt.');

  [i, hash] = decode64(str, i, BCRYPT_HASH192);

  if (hash == null)
    throw new Error('Invalid hash.');

  if (i !== str.length)
    throw new Error('Invalid bcrypt string.');

  return [minor, rounds, salt, hash];
}

/*
 * Base64
 */

const CHARSET =
  './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,
  54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1,
  -1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
  17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1,
  -1, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1
];

function encode64(data) {
  assert(Buffer.isBuffer(data));

  let p = 0;
  let s = '';
  let a, b;

  while (p < data.length) {
    a = data[p++];
    s += CHARSET[(a >>> 2)];
    a = (a & 3) << 4;

    if (p >= data.length) {
      s += CHARSET[a];
      break;
    }

    b = data[p++];
    a |= (b >>> 4) & 15;
    s += CHARSET[a];
    a = (b & 0x0f) << 2;

    if (p >= data.length) {
      s += CHARSET[a];
      break;
    }

    b = data[p++];
    a |= (b >>> 6) & 3;
    s += CHARSET[a];
    s += CHARSET[b & 63];
  }

  return s;
}

function decode64(s, i, len) {
  assert(typeof s === 'string');
  assert((i >>> 0) === i);
  assert((len >>> 0) === len);

  const data = Buffer.alloc(len);

  let p = 0;
  let a, b, c, d;

  while (p < len) {
    a = unbase64(s, i++);

    if (a === -1)
      return [i, null];

    b = unbase64(s, i++);

    if (b === -1)
      return [i, null];

    data[p++] = (a << 2) | ((b & 48) >>> 4);

    if (p >= len)
      break;

    c = unbase64(s, i++);

    if (c === -1)
      return [i, null];

    data[p++] = ((b & 15) << 4) | ((c & 60) >>> 2);

    if (p >= len)
      break;

    d = unbase64(s, i++);

    if (d === -1)
      return [i, null];

    data[p++] = ((c & 3) << 6) | d;
  }

  return [i, data];
}

function unbase64(s, i) {
  if (i >= s.length)
    return -1;

  const ch = s.charCodeAt(i);

  if (ch & 0xff80)
    return -1;

  return TABLE[ch];
}

/*
 * Expose
 */

exports.native = 0;
exports.hash192 = hash192;
exports.derive = derive;
exports.generate = generate;
exports.verify = verify;
exports.hash256 = hash256;
exports.pbkdf = pbkdf;

}).call(this,req("buffer").Buffer)
},{"./js/ciphers/blowfish":93,"./sha512":181,"bsert":190,"buffer":303}],20:[function(req,module,exports){
/*!
 * bcrypto.js - crypto for bcoin
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

exports.AEAD = req('./aead');
exports.aes = req('./aes');
exports.bcrypt = req('./bcrypt');
exports.BLAKE2b = req('./blake2b');
exports.BLAKE2b160 = req('./blake2b160');
exports.BLAKE2b256 = req('./blake2b256');
exports.BLAKE2b384 = req('./blake2b384');
exports.BLAKE2b512 = req('./blake2b512');
exports.BLAKE2s = req('./blake2s');
exports.BLAKE2s128 = req('./blake2s128');
exports.BLAKE2s160 = req('./blake2s160');
exports.BLAKE2s224 = req('./blake2s224');
exports.BLAKE2s256 = req('./blake2s256');
exports.BN = req('./bn');
exports.box = req('./box');
exports.ChaCha20 = req('./chacha20');
exports.cipher = req('./cipher');
exports.cleanse = req('./cleanse');
exports.CSHAKE = req('./cshake');
exports.CSHAKE128 = req('./cshake128');
exports.CSHAKE256 = req('./cshake256');
exports.CtrDRBG = req('./ctr-drbg');
exports.dsa = req('./dsa');
exports.dsaies = req('./dsaies');
exports.eb2k = req('./eb2k');
exports.ecies = req('./ecies');
exports.ed25519 = req('./ed25519');
exports.ed448 = req('./ed448');
exports.encoding = req('./encoding');
exports.GOST94 = req('./gost94');
exports.Hash160 = req('./hash160');
exports.Hash256 = req('./hash256');
exports.HashDRBG = req('./hash-drbg');
exports.HKDF = req('./hkdf');
exports.HmacDRBG = req('./hmac-drbg');
exports.Keccak = req('./keccak');
exports.Keccak224 = req('./keccak224');
exports.Keccak256 = req('./keccak256');
exports.Keccak384 = req('./keccak384');
exports.Keccak512 = req('./keccak512');
exports.KMAC = req('./kmac');
exports.KMAC128 = req('./kmac128');
exports.KMAC256 = req('./kmac256');
exports.MD2 = req('./md2');
exports.MD4 = req('./md4');
exports.MD5 = req('./md5');
exports.MD5SHA1 = req('./md5sha1');
exports.merkle = req('./merkle');
exports.mrkl = req('./mrkl');
exports.murmur3 = req('./murmur3');
exports.p192 = req('./p192');
exports.p224 = req('./p224');
exports.p256 = req('./p256');
exports.p384 = req('./p384');
exports.p521 = req('./p521');
exports.pbkdf2 = req('./pbkdf2');
exports.pgp = req('./pgp');
exports.Poly1305 = req('./poly1305');
exports.random = req('./random');
exports.RC4 = req('./rc4');
exports.RIPEMD160 = req('./ripemd160');
exports.rsa = req('./rsa');
exports.rsaies = req('./rsaies');
exports.safe = req('./safe');
exports.Salsa20 = req('./salsa20');
exports.scrypt = req('./scrypt');
exports.secp256k1 = req('./secp256k1');
exports.secretbox = req('./secretbox');
exports.ssh = req('./ssh');
exports.SHA1 = req('./sha1');
exports.SHA224 = req('./sha224');
exports.SHA256 = req('./sha256');
exports.SHA384 = req('./sha384');
exports.SHA512 = req('./sha512');
exports.SHA3 = req('./sha3');
exports.SHA3_224 = req('./sha3-224');
exports.SHA3_256 = req('./sha3-256');
exports.SHA3_384 = req('./sha3-384');
exports.SHA3_512 = req('./sha3-512');
exports.SHAKE = req('./shake');
exports.SHAKE128 = req('./shake128');
exports.SHAKE256 = req('./shake256');
exports.siphash = req('./siphash');
exports.Whirlpool = req('./whirlpool');
exports.x25519 = req('./x25519');
exports.x448 = req('./x448');

exports.version = '4.1.0';
exports.native = exports.SHA256.native;

},{"./aead":17,"./aes":18,"./bcrypt":19,"./blake2b":21,"./blake2b160":22,"./blake2b256":23,"./blake2b384":24,"./blake2b512":25,"./blake2s":26,"./blake2s128":27,"./blake2s160":28,"./blake2s224":29,"./blake2s256":30,"./bn":31,"./box":32,"./chacha20":33,"./cipher":34,"./cleanse":35,"./cshake":36,"./cshake128":37,"./cshake256":38,"./ctr-drbg":39,"./dsa":40,"./dsaies":41,"./eb2k":42,"./ecies":43,"./ed25519":44,"./ed448":45,"./encoding":53,"./gost94":65,"./hash-drbg":66,"./hash160":67,"./hash256":68,"./hkdf":69,"./hmac-drbg":70,"./keccak":139,"./keccak224":140,"./keccak256":141,"./keccak384":142,"./keccak512":143,"./kmac":144,"./kmac128":145,"./kmac256":146,"./md2":147,"./md4":148,"./md5":149,"./md5sha1":150,"./merkle":151,"./mrkl":152,"./murmur3":153,"./p192":154,"./p224":155,"./p256":156,"./p384":157,"./p521":158,"./pbkdf2":159,"./pgp":160,"./poly1305":161,"./random":162,"./rc4":163,"./ripemd160":164,"./rsa":165,"./rsaies":166,"./safe":167,"./salsa20":168,"./scrypt":169,"./secp256k1":170,"./secretbox":171,"./sha1":172,"./sha224":173,"./sha256":174,"./sha3":179,"./sha3-224":175,"./sha3-256":176,"./sha3-384":177,"./sha3-512":178,"./sha384":180,"./sha512":181,"./shake":182,"./shake128":183,"./shake256":184,"./siphash":185,"./ssh":186,"./whirlpool":187,"./x25519":188,"./x448":189}],21:[function(req,module,exports){
/*!
 * blake2b.js - blake2b for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/blake2b');

},{"./js/blake2b":86}],22:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2b160.js - BLAKE2b implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2b = req('./blake2b');

/**
 * BLAKE2b160
 */

class BLAKE2b160 extends BLAKE2b {
  /**
   * Create a BLAKE2b160 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(20, key);
  }

  static hash() {
    return new BLAKE2b160();
  }

  static hmac() {
    return super.hmac(20);
  }

  static digest(data, key = null) {
    return super.digest(data, 20, key);
  }

  static root(left, right) {
    return super.root(left, right, 20);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 20);
  }

  static mac(data, key) {
    return super.mac(data, key, 20);
  }
}

/*
 * Static
 */

BLAKE2b160.native = BLAKE2b.native;
BLAKE2b160.id = 'BLAKE2B160';
BLAKE2b160.size = 20;
BLAKE2b160.bits = 160;
BLAKE2b160.blockSize = 128;
BLAKE2b160.zero = Buffer.alloc(20, 0x00);
BLAKE2b160.ctx = new BLAKE2b160();

/*
 * Expose
 */

module.exports = BLAKE2b160;

}).call(this,req("buffer").Buffer)
},{"./blake2b":21,"buffer":303}],23:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2b256.js - BLAKE2b implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2b = req('./blake2b');

/**
 * BLAKE2b256
 */

class BLAKE2b256 extends BLAKE2b {
  /**
   * Create a BLAKE2b256 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(32, key);
  }

  static hash() {
    return new BLAKE2b256();
  }

  static hmac() {
    return super.hmac(32);
  }

  static digest(data, key = null) {
    return super.digest(data, 32, key);
  }

  static root(left, right) {
    return super.root(left, right, 32);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 32);
  }

  static mac(data, key) {
    return super.mac(data, key, 32);
  }
}

/*
 * Static
 */

BLAKE2b256.native = BLAKE2b.native;
BLAKE2b256.id = 'BLAKE2B256';
BLAKE2b256.size = 32;
BLAKE2b256.bits = 256;
BLAKE2b256.blockSize = 128;
BLAKE2b256.zero = Buffer.alloc(32, 0x00);
BLAKE2b256.ctx = new BLAKE2b256();

/*
 * Expose
 */

module.exports = BLAKE2b256;

}).call(this,req("buffer").Buffer)
},{"./blake2b":21,"buffer":303}],24:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2b384.js - BLAKE2b implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2b = req('./blake2b');

/**
 * BLAKE2b384
 */

class BLAKE2b384 extends BLAKE2b {
  /**
   * Create a BLAKE2b384 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(48, key);
  }

  static hash() {
    return new BLAKE2b384();
  }

  static hmac() {
    return super.hmac(48);
  }

  static digest(data, key = null) {
    return super.digest(data, 48, key);
  }

  static root(left, right) {
    return super.root(left, right, 48);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 48);
  }

  static mac(data, key) {
    return super.mac(data, key, 48);
  }
}

/*
 * Static
 */

BLAKE2b384.native = BLAKE2b.native;
BLAKE2b384.id = 'BLAKE2B384';
BLAKE2b384.size = 48;
BLAKE2b384.bits = 384;
BLAKE2b384.blockSize = 128;
BLAKE2b384.zero = Buffer.alloc(48, 0x00);
BLAKE2b384.ctx = new BLAKE2b384();

/*
 * Expose
 */

module.exports = BLAKE2b384;

}).call(this,req("buffer").Buffer)
},{"./blake2b":21,"buffer":303}],25:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2b512.js - BLAKE2b implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2b = req('./blake2b');

/**
 * BLAKE2b512
 */

class BLAKE2b512 extends BLAKE2b {
  /**
   * Create a BLAKE2b512 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(64, key);
  }

  static hash() {
    return new BLAKE2b512();
  }

  static hmac() {
    return super.hmac(64);
  }

  static digest(data, key = null) {
    return super.digest(data, 64, key);
  }

  static root(left, right) {
    return super.root(left, right, 64);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 64);
  }

  static mac(data, key) {
    return super.mac(data, key, 64);
  }
}

/*
 * Static
 */

BLAKE2b512.native = BLAKE2b.native;
BLAKE2b512.id = 'BLAKE2B512';
BLAKE2b512.size = 64;
BLAKE2b512.bits = 512;
BLAKE2b512.blockSize = 128;
BLAKE2b512.zero = Buffer.alloc(64, 0x00);
BLAKE2b512.ctx = new BLAKE2b512();

/*
 * Expose
 */

module.exports = BLAKE2b512;

}).call(this,req("buffer").Buffer)
},{"./blake2b":21,"buffer":303}],26:[function(req,module,exports){
/*!
 * blake2s.js - blake2s for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/blake2s');

},{"./js/blake2s":87}],27:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2s128.js - BLAKE2s implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2s = req('./blake2s');

/**
 * BLAKE2s128
 */

class BLAKE2s128 extends BLAKE2s {
  /**
   * Create a BLAKE2s128 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(16, key);
  }

  static hash() {
    return new BLAKE2s128();
  }

  static hmac() {
    return super.hmac(16);
  }

  static digest(data, key = null) {
    return super.digest(data, 16, key);
  }

  static root(left, right) {
    return super.root(left, right, 16);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 16);
  }

  static mac(data, key) {
    return super.mac(data, key, 16);
  }
}

/*
 * Static
 */

BLAKE2s128.native = BLAKE2s.native;
BLAKE2s128.id = 'BLAKE2S128';
BLAKE2s128.size = 16;
BLAKE2s128.bits = 128;
BLAKE2s128.blockSize = 64;
BLAKE2s128.zero = Buffer.alloc(16, 0x00);
BLAKE2s128.ctx = new BLAKE2s128();

/*
 * Expose
 */

module.exports = BLAKE2s128;

}).call(this,req("buffer").Buffer)
},{"./blake2s":26,"buffer":303}],28:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2s160.js - BLAKE2s implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2s = req('./blake2s');

/**
 * BLAKE2s160
 */

class BLAKE2s160 extends BLAKE2s {
  /**
   * Create a BLAKE2s160 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(20, key);
  }

  static hash() {
    return new BLAKE2s160();
  }

  static hmac() {
    return super.hmac(20);
  }

  static digest(data, key = null) {
    return super.digest(data, 20, key);
  }

  static root(left, right) {
    return super.root(left, right, 20);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 20);
  }

  static mac(data, key) {
    return super.mac(data, key, 20);
  }
}

/*
 * Static
 */

BLAKE2s160.native = BLAKE2s.native;
BLAKE2s160.id = 'BLAKE2S160';
BLAKE2s160.size = 20;
BLAKE2s160.bits = 160;
BLAKE2s160.blockSize = 64;
BLAKE2s160.zero = Buffer.alloc(20, 0x00);
BLAKE2s160.ctx = new BLAKE2s160();

/*
 * Expose
 */

module.exports = BLAKE2s160;

}).call(this,req("buffer").Buffer)
},{"./blake2s":26,"buffer":303}],29:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2s224.js - BLAKE2s implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2s = req('./blake2s');

/**
 * BLAKE2s224
 */

class BLAKE2s224 extends BLAKE2s {
  /**
   * Create a BLAKE2s224 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(28, key);
  }

  static hash() {
    return new BLAKE2s224();
  }

  static hmac() {
    return super.hmac(28);
  }

  static digest(data, key = null) {
    return super.digest(data, 28, key);
  }

  static root(left, right) {
    return super.root(left, right, 28);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 28);
  }

  static mac(data, key) {
    return super.mac(data, key, 28);
  }
}

/*
 * Static
 */

BLAKE2s224.native = BLAKE2s.native;
BLAKE2s224.id = 'BLAKE2S224';
BLAKE2s224.size = 28;
BLAKE2s224.bits = 224;
BLAKE2s224.blockSize = 64;
BLAKE2s224.zero = Buffer.alloc(28, 0x00);
BLAKE2s224.ctx = new BLAKE2s224();

/*
 * Expose
 */

module.exports = BLAKE2s224;

}).call(this,req("buffer").Buffer)
},{"./blake2s":26,"buffer":303}],30:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2s256.js - BLAKE2s implementation for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const BLAKE2s = req('./blake2s');

/**
 * BLAKE2s256
 */

class BLAKE2s256 extends BLAKE2s {
  /**
   * Create a BLAKE2s256 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key = null) {
    return super.init(32, key);
  }

  static hash() {
    return new BLAKE2s256();
  }

  static hmac() {
    return super.hmac(32);
  }

  static digest(data, key = null) {
    return super.digest(data, 32, key);
  }

  static root(left, right) {
    return super.root(left, right, 32);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 32);
  }

  static mac(data, key) {
    return super.mac(data, key, 32);
  }
}

/*
 * Static
 */

BLAKE2s256.native = BLAKE2s.native;
BLAKE2s256.id = 'BLAKE2S256';
BLAKE2s256.size = 32;
BLAKE2s256.bits = 256;
BLAKE2s256.blockSize = 64;
BLAKE2s256.zero = Buffer.alloc(32, 0x00);
BLAKE2s256.ctx = new BLAKE2s256();

/*
 * Expose
 */

module.exports = BLAKE2s256;

}).call(this,req("buffer").Buffer)
},{"./blake2s":26,"buffer":303}],31:[function(req,module,exports){
/*!
 * bn.js - big numbers for bcoin
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/bn.js');

},{"./js/bn.js":88}],32:[function(req,module,exports){
(function (Buffer){
/*!
 * box.js - nacl secretbox for bcrypto (crypto_secretbox_xsalsa20poly1305)
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://nacl.cr.yp.to/secretbox.html
 *   https://github.com/golang/crypto/blob/master/nacl/box/box.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/box_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/example_test.go
 */

'use strict';

const assert = req('assert');
const box = req('./secretbox');
const random = req('./random');
const x25519 = req('./x25519');

/*
 * Box
 */

// In the future, could be implemented as:
//
// function seal(msg, pub, priv = null) {
//   return ecies.encrypt(x25519, null, msg, pub, priv);
// }
//
// function open(msg, priv) {
//   return ecies.decrypt(x25519, null, msg, priv);
// }

function seal(msg, pub, priv = null) {
  if (priv == null)
    priv = x25519.privateKeyGenerate();

  const ourPub = x25519.publicKeyCreate(priv);
  const secret = x25519.derive(pub, priv);
  const key = box.derive(secret);
  const nonce = random.randomBytes(24);
  const sealed = box.seal(msg, key, nonce);

  return Buffer.concat([ourPub, nonce, sealed]);
}

function open(msg, priv) {
  assert(Buffer.isBuffer(msg));

  if (msg.length < 32 + 24)
    throw new Error('Invalid secret box size.');

  const theirPub = msg.slice(0, 32);
  const nonce = msg.slice(32, 32 + 24);
  const sealed = msg.slice(32 + 24);
  const secret = x25519.derive(theirPub, priv);
  const key = box.derive(secret);

  return box.open(sealed, key, nonce);
}

/*
 * Expose
 */

exports.native = 0;
exports.seal = seal;
exports.open = open;

}).call(this,req("buffer").Buffer)
},{"./random":162,"./secretbox":171,"./x25519":188,"assert":298,"buffer":303}],33:[function(req,module,exports){
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/chacha20');

},{"./js/chacha20":90}],34:[function(req,module,exports){
/*!
 * cipher.js - cipher for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/cipher');

},{"./js/cipher":91}],35:[function(req,module,exports){
/*!
 * cleanse.js - cleanse for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/cleanse');

},{"./js/cleanse":102}],36:[function(req,module,exports){
(function (Buffer){
/*!
 * cshake.js - cSHAKE implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://keccak.team/specifications.html
 *   https://www.nist.gov/node/1131611
 *   https://doi.org/10.6028/NIST.SP.800-185
 *   https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.inc
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.c
 *   https://github.com/XKCP/XKCP/blob/8f447eb/tests/UnitTests/testSP800-185.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */

'use strict';

const assert = req('bsert');
const Keccak = req('./keccak');
const HMAC = req('./internal/hmac');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const ZEROES = Buffer.alloc(200, 0x00);

/*
 * CSHAKE
 */

class CSHAKE extends Keccak {
  constructor() {
    super();
    this.pad = 0x04;
    this.rate = 1088;
  }

  init(bits = 256, name = null, pers = null) {
    if (name == null)
      name = EMPTY;

    if (pers == null)
      pers = EMPTY;

    assert((bits >>> 0) === bits);
    assert(bits === 128 || bits === 256);
    assert(Buffer.isBuffer(name));
    assert(Buffer.isBuffer(pers));

    super.init(bits);

    if (name.length === 0 && pers.length === 0) {
      this.pad = 0x1f;
    } else {
      const rate = 1600 - bits * 2;
      const size = rate / 8;

      this.bytePad([name, pers], size);
      this.rate = rate;
      this.pad = 0x04;
    }

    return this;
  }

  final(len) {
    return super.final(this.pad, len);
  }

  bytePad(items, w) {
    assert(Array.isArray(items));
    assert((w >>> 0) === w);
    assert(w > 0);

    let z = this.leftEncode(w);

    for (const x of items)
      z += this.encodeString(x);

    const left = w - (z % w);

    if (left === w)
      return z;

    z += this.zeroPad(left);

    return z;
  }

  encodeString(s) {
    assert(Buffer.isBuffer(s));

    const n = this.leftEncode(s.length * 8);

    this.update(s);

    return n + s.length;
  }

  zeroPad(size) {
    assert((size >>> 0) === size);
    assert(size <= 200);

    const buf = ZEROES.slice(0, size);

    this.update(buf);

    return buf.length;
  }

  leftEncode(x) {
    assert((x >>> 0) === x);
    assert(x >= 0 && x < 22040);

    let v = x;
    let n = 0;

    while (v && n < 4) {
      n += 1;
      v >>>= 8;
    }

    if (n === 0)
      n = 1;

    const buf = Buffer.allocUnsafe(n + 1);

    for (let i = 1; i <= n; i++)
      buf[i] = x >>> (8 * (n - i));

    buf[0] = n;

    this.update(buf);

    return buf.length;
  }

  rightEncode(x) {
    assert((x >>> 0) === x);
    assert(x >= 0 && x < 22040);

    let v = x;
    let n = 0;

    while (v && n < 4) {
      n += 1;
      v >>>= 8;
    }

    if (n === 0)
      n = 1;

    const buf = Buffer.allocUnsafe(n + 1);

    for (let i = 1; i <= n; i++)
      buf[i - 1] = x >>> (8 * (n - i));

    buf[n] = n;

    this.update(buf);

    return buf.length;
  }

  static hash() {
    return new CSHAKE();
  }

  static hmac(bits = 256, name, pers, len) {
    assert((bits >>> 0) === bits);
    assert(bits === 128 || bits === 256);
    const bs = (1600 - bits * 2) / 8;
    return new HMAC(CSHAKE, bs, [bits, name, pers], [len]);
  }

  static digest(data, bits = 256, name, pers, len) {
    return CSHAKE.ctx.init(bits, name, pers).update(data).final(len);
  }

  static root(left, right, bits = 256, name, pers, len) {
    if (len == null)
      len = 0;

    if (len === 0) {
      assert((bits >>> 0) === bits);
      len = bits >>> 3;
    }

    assert((len >>> 0) === len);
    assert(Buffer.isBuffer(left) && left.length === len);
    assert(Buffer.isBuffer(right) && right.length === len);

    const ctx = CSHAKE.ctx;

    ctx.init(bits, name, pers);
    ctx.update(left);
    ctx.update(right);

    return ctx.final(len);
  }

  static multi(x, y, z, bits = 256, name, pers, len) {
    const ctx = CSHAKE.ctx;
    ctx.init(bits, name, pers);
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final(len);
  }

  static mac(data, key, bits = 256, name, pers, len) {
    return CSHAKE.hmac(bits, name, pers, len).init(key).update(data).final();
  }
}

/*
 * Static
 */

CSHAKE.native = Keccak.native;
CSHAKE.id = 'CSHAKE256';
CSHAKE.size = 32;
CSHAKE.bits = 256;
CSHAKE.blockSize = 136;
CSHAKE.zero = Buffer.alloc(32, 0x00);
CSHAKE.ctx = new CSHAKE();

/*
 * Expose
 */

module.exports = CSHAKE;

}).call(this,req("buffer").Buffer)
},{"./internal/hmac":76,"./keccak":139,"bsert":190,"buffer":303}],37:[function(req,module,exports){
(function (Buffer){
/*!
 * cshake128.js - CSHAKE128 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const CSHAKE = req('./cshake');

/**
 * CSHAKE128
 */

class CSHAKE128 extends CSHAKE {
  /**
   * Create a CSHAKE128 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(name, pers) {
    return super.init(128, name, pers);
  }

  static hash() {
    return new CSHAKE128();
  }

  static hmac(name, pers, len) {
    return super.hmac(128, name, pers, len);
  }

  static digest(data, name, pers, len) {
    return super.digest(data, 128, name, pers, len);
  }

  static root(left, right, name, pers, len) {
    return super.root(left, right, 128, name, pers, len);
  }

  static multi(x, y, z, name, pers, len) {
    return super.multi(x, y, z, 128, name, pers, len);
  }

  static mac(data, key, name, pers, len) {
    return super.mac(data, key, 128, name, pers, len);
  }
}

/*
 * Static
 */

CSHAKE128.native = CSHAKE.native;
CSHAKE128.id = 'CSHAKE128';
CSHAKE128.size = 16;
CSHAKE128.bits = 128;
CSHAKE128.blockSize = 168;
CSHAKE128.zero = Buffer.alloc(16, 0x00);
CSHAKE128.ctx = new CSHAKE128();

/*
 * Expose
 */

module.exports = CSHAKE128;

}).call(this,req("buffer").Buffer)
},{"./cshake":36,"buffer":303}],38:[function(req,module,exports){
(function (Buffer){
/*!
 * cshake256.js - CSHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const CSHAKE = req('./cshake');

/**
 * CSHAKE256
 */

class CSHAKE256 extends CSHAKE {
  /**
   * Create a CSHAKE256 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(name, pers) {
    return super.init(256, name, pers);
  }

  static hash() {
    return new CSHAKE256();
  }

  static hmac(name, pers, len) {
    return super.hmac(256, name, pers, len);
  }

  static digest(data, name, pers, len) {
    return super.digest(data, 256, name, pers, len);
  }

  static root(left, right, name, pers, len) {
    return super.root(left, right, 256, name, pers, len);
  }

  static multi(x, y, z, name, pers, len) {
    return super.multi(x, y, z, 256, name, pers, len);
  }

  static mac(data, key, name, pers, len) {
    return super.mac(data, key, 256, name, pers, len);
  }
}

/*
 * Static
 */

CSHAKE256.native = CSHAKE.native;
CSHAKE256.id = 'CSHAKE256';
CSHAKE256.size = 32;
CSHAKE256.bits = 256;
CSHAKE256.blockSize = 136;
CSHAKE256.zero = Buffer.alloc(32, 0x00);
CSHAKE256.ctx = new CSHAKE256();

/*
 * Expose
 */

module.exports = CSHAKE256;

}).call(this,req("buffer").Buffer)
},{"./cshake":36,"buffer":303}],39:[function(req,module,exports){
(function (Buffer){
/*!
 * ctr-drbg.js - ctr-drbg implementation for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on google/boringssl:
 *   https://github.com/google/boringssl
 *
 * Resources:
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/google/boringssl/blob/master/crypto/fipsmodule/rand/ctrdrbg.c
 *   https://github.com/google/boringssl/blob/master/crypto/fipsmodule/rand/internal.h
 *   https://github.com/openssl/openssl/blob/master/crypto/rand/drbg_lib.c
 *   https://github.com/cryptocoinjs/drbg.js/blob/master/ctr.js
 *   https://github.com/netroby/jdk9-dev/blob/master/jdk/src/java.base/share/classes/sun/security/provider/CtrDrbg.java
 */

'use strict';

const assert = req('bsert');
const cipher = req('./cipher');
const {Cipher} = cipher;

/*
 * Constants
 */

const MAX_GENERATE_LENGTH = 65536;
const RESEED_INTERVAL = 0x1000000000000;

/**
 * CtrDRBG
 */

class CtrDRBG {
  constructor(name, entropy, nonce, pers, derivation = true) {
    assert(derivation == null || typeof derivation === 'boolean');

    const [id, keySize, blkSize] = get(name);

    this.id = id;
    this.ctr = new CTR(id);
    this.keySize = keySize;
    this.blkSize = blkSize;
    this.entSize = keySize + blkSize;
    this.slab = Buffer.alloc(this.entSize);
    this.K = this.slab.slice(0, this.keySize);
    this.V = this.slab.slice(this.keySize);
    this.derivation = Boolean(derivation);
    this.rounds = 0;

    if (entropy)
      this.init(entropy, nonce, pers);
  }

  init(entropy, nonce = null, pers = null) {
    if (nonce == null)
      nonce = Buffer.alloc(0);

    if (pers == null)
      pers = Buffer.alloc(0);

    assert(Buffer.isBuffer(entropy));
    assert(Buffer.isBuffer(nonce));
    assert(Buffer.isBuffer(pers));

    let seed;

    if (this.derivation) {
      seed = this.derive(entropy, nonce, pers);
    } else {
      if (entropy.length + nonce.length > this.entSize)
        throw new Error('Entropy is too long.');

      if (pers.length > this.entSize)
        throw new Error('Personalization string is too long.');

      seed = Buffer.alloc(this.entSize, 0x00);

      entropy.copy(seed, 0);
      nonce.copy(seed, entropy.length);

      for (let i = 0; i < pers.length; i++)
        seed[i] ^= pers[i];
    }

    this.slab.fill(0x00);
    this.ctr.init(this.K, this.V);
    this.update(seed);
    this.rounds = 1;

    return this;
  }

  reseed(entropy, add = null) {
    if (add == null)
      add = Buffer.alloc(0);

    assert(Buffer.isBuffer(entropy));
    assert(Buffer.isBuffer(add));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    let seed;

    if (this.derivation) {
      seed = this.derive(entropy, add);
    } else {
      if (add.length > this.entSize)
        throw new Error('Additional data is too long.');

      seed = Buffer.alloc(this.entSize, 0x00);

      entropy.copy(seed, 0);

      for (let i = 0; i < add.length; i++)
        seed[i] ^= add[i];
    }

    this.update(seed);
    this.rounds = 1;

    return this;
  }

  generate(len, add = null) {
    assert((len >>> 0) === len);
    assert(!add || Buffer.isBuffer(add));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    if (this.rounds > RESEED_INTERVAL)
      throw new Error('Reseed is reqd.');

    if (len > MAX_GENERATE_LENGTH)
      throw new Error('Requested length is too long.');

    if (add && add.length !== 0) {
      if (this.derivation)
        add = this.derive(add);

      this.update(add);
    }

    const blocks = Math.ceil(len / this.blkSize);
    const out = Buffer.allocUnsafe(blocks * this.blkSize);

    for (let i = 0; i < blocks; i++)
      this.ctr.encrypt(out, i * this.blkSize);

    this.update(add);
    this.rounds += 1;

    return out.slice(0, len);
  }

  randomBytes(size) {
    return this.generate(size);
  }

  /*
   * Helpers
   */

  update(seed = null) {
    if (seed == null)
      seed = Buffer.alloc(0);

    assert(Buffer.isBuffer(seed));

    if (seed.length > this.entSize)
      throw new Error('Seed is too long.');

    this.slab.fill(0x00);

    for (let i = 0; i < this.entSize; i += this.blkSize)
      this.ctr.encrypt(this.slab, i);

    for (let i = 0; i < seed.length; i++)
      this.slab[i] ^= seed[i];

    this.ctr.init(this.K, this.V);

    return this;
  }

  serialize(...input) {
    const N = this.entSize;

    let L = 0;

    for (const item of input)
      L += item.length;

    let size = this.blkSize + 4 + 4 + L + 1;

    if (size % this.blkSize)
      size += this.blkSize - (size % this.blkSize);

    assert((size % this.blkSize) === 0);

    // S = IV || (L || N || input || 0x80 || 0x00...)
    const S = Buffer.alloc(size, 0x00);

    let pos = this.blkSize;

    S[pos++] = L >>> 24;
    S[pos++] = L >>> 16;
    S[pos++] = L >>> 8;
    S[pos++] = L;

    S[pos++] = N >>> 24;
    S[pos++] = N >>> 16;
    S[pos++] = N >>> 8;
    S[pos++] = N;

    for (const item of input)
      pos += item.copy(S, pos);

    S[pos++] = 0x80;

    assert(pos === this.blkSize + 4 + 4 + L + 1);

    return S;
  }

  derive(...input) {
    const S = this.serialize(...input);
    const N = S.length / this.blkSize;
    const K = Buffer.alloc(this.keySize);
    const blocks = Math.ceil(this.entSize / this.blkSize);
    const slab = Buffer.alloc(blocks * this.blkSize);

    for (let i = 0; i < K.length; i++)
      K[i] = i;

    const ctx = new Cipher(this.id).init(K);

    for (let i = 0; i < blocks; i++) {
      let chain = Buffer.alloc(this.blkSize, 0x00);

      S[0] = i >>> 24;
      S[1] = i >>> 16;
      S[2] = i >>> 8;
      S[3] = i;

      // chain = BCC(K, IV || S)
      for (let j = 0; j < N; j++) {
        for (let k = 0; k < chain.length; k++)
          chain[k] ^= S[j * this.blkSize + k];

        chain = ctx.update(chain);
      }

      chain.copy(slab, i * this.blkSize);
    }

    const k = slab.slice(0, this.keySize);

    ctx.init(k);

    let x = slab.slice(this.keySize, this.entSize);

    for (let i = 0; i < blocks; i++) {
      x = ctx.update(x);
      x.copy(slab, i * this.blkSize);
    }

    return slab.slice(0, this.entSize);
  }
}

/*
 * Static
 */

CtrDRBG.native = 0;

/*
 * CTR
 */

class CTR {
  constructor(name) {
    this.ctx = new Cipher(name);
    this.ctr = null;
  }

  init(key, iv) {
    this.ctx.init(key);
    this.ctr = Buffer.from(iv);
    return this;
  }

  increment() {
    for (let i = this.ctr.length - 1; i >= 0; i--) {
      this.ctr[i] += 1;

      if (this.ctr[i] !== 0x00)
        break;
    }
  }

  encrypt(output, opos) {
    this.increment();
    this.ctx.update(this.ctr).copy(output, opos);
    return this;
  }
}

/*
 * Helpers
 */

function get(name) {
  assert(typeof name === 'string');

  switch (name) {
    case 'AES-128':
      return ['AES-128-ECB', 16, 16];
    case 'AES-192':
      return ['AES-192-ECB', 24, 16];
    case 'AES-256':
      return ['AES-256-ECB', 32, 16];
    default:
      throw new Error(`Unsupported cipher: ${name}.`);
  }
}

/*
 * Expose
 */

module.exports = CtrDRBG;

}).call(this,req("buffer").Buffer)
},{"./cipher":34,"bsert":190,"buffer":303}],40:[function(req,module,exports){
/*!
 * dsa.js - DSA for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/dsa');

},{"./js/dsa":104}],41:[function(req,module,exports){
(function (Buffer){
/*!
 * dsaies.js - dsaies for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme
 *   https://nacl.cr.yp.to/secretbox.html
 */

'use strict';

const assert = req('bsert');
const dsa = req('./dsa');
const random = req('./random');
const box = req('./secretbox');
const {padLeft} = req('./encoding/util');

/*
 * DSAIES
 */

const DSAIES = {
  encrypt(kdf, msg, pub, priv = null) {
    assert(kdf != null);
    assert(Buffer.isBuffer(msg));
    assert(pub instanceof dsa.DSAKey);
    assert(priv == null || (priv instanceof dsa.DSAPrivateKey));

    if (priv == null)
      priv = dsa.privateKeyCreate(pub);

    const klen = (pub.bits() + 7) >>> 3;
    const ourPub = dsa.publicKeyCreate(priv);
    const secret = dsa.derive(pub, priv);
    const key = box.derive(secret, kdf);
    const nonce = random.randomBytes(24);
    const ourY = padLeft(ourPub.y, klen);
    const sealed = box.seal(msg, key, nonce);

    return Buffer.concat([ourY, nonce, sealed]);
  },

  decrypt(kdf, msg, priv) {
    assert(kdf != null);
    assert(Buffer.isBuffer(msg));
    assert(priv instanceof dsa.DSAPrivateKey);

    const klen = (priv.bits() + 7) >>> 3;

    if (msg.length < klen + 24)
      throw new Error('Invalid ciphertext.');

    const theirY = msg.slice(0, klen);

    const theirPub = new dsa.DSAPublicKey(
      priv.p,
      priv.q,
      priv.g,
      theirY
    );

    const nonce = msg.slice(klen, klen + 24);
    const sealed = msg.slice(klen + 24);
    const secret = dsa.derive(theirPub, priv);
    const key = box.derive(secret, kdf);

    return box.open(sealed, key, nonce);
  }
};

/*
 * Expose
 */

module.exports = DSAIES;

}).call(this,req("buffer").Buffer)
},{"./dsa":40,"./encoding/util":63,"./random":162,"./secretbox":171,"bsert":190,"buffer":303}],42:[function(req,module,exports){
(function (Buffer){
/*!
 * eb2k.js - EVP_BytesToKey for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on crypto-browserify/EVP_BytesToKey:
 *   Copyright (c) 2017, crypto-browserify contributors
 *   https://github.com/crypto-browserify/EVP_BytesToKey
 *
 * Resources:
 *   https://github.com/openssl/openssl/blob/2e9d61e/crypto/evp/evp_key.c
 *   https://github.com/crypto-browserify/EVP_BytesToKey/blob/master/index.js
 *   https://github.com/openssl/openssl/blob/master/crypto/evp/evp_key.c
 */

'use strict';

const assert = req('bsert');
const MD5 = req('./md5');

/*
 * EB2K
 */

function derive(passwd, salt, keyLen, ivLen) {
  if (typeof passwd === 'string')
    passwd = Buffer.from(passwd, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  if (ivLen == null)
    ivLen = 0;

  assert(Buffer.isBuffer(passwd));
  assert(Buffer.isBuffer(salt));
  assert((keyLen >>> 0) === keyLen);
  assert((ivLen >>> 0) === ivLen);

  if (salt.length > 8)
    salt = salt.slice(0, 8);

  if (salt.length !== 0 && salt.length !== 8)
    throw new RangeError('Salt must be at least 8 bytes.');

  const key = Buffer.alloc(keyLen);
  const iv = Buffer.alloc(ivLen);

  let prev = Buffer.alloc(0);

  while (keyLen > 0 || ivLen > 0) {
    let used = 0;

    prev = MD5.multi(prev, passwd, salt);

    if (keyLen > 0) {
      const keyStart = key.length - keyLen;
      used = Math.min(keyLen, prev.length);
      prev.copy(key, keyStart, 0, used);
      keyLen -= used;
    }

    if (used < prev.length && ivLen > 0) {
      const ivStart = iv.length - ivLen;
      const length = Math.min(ivLen, prev.length - used);
      prev.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }

  prev.fill(0x00);

  return [key, iv];
}

/*
 * Expose
 */

exports.native = 0;
exports.derive = derive;

}).call(this,req("buffer").Buffer)
},{"./md5":149,"bsert":190,"buffer":303}],43:[function(req,module,exports){
(function (Buffer){
/*!
 * ecies.js - ecies for javascript (crypto_secretbox_xsalsa20poly1305)
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme
 *   https://nacl.cr.yp.to/secretbox.html
 */

'use strict';

const assert = req('bsert');
const box = req('./secretbox');
const random = req('./random');

/*
 * ECIES
 */

const ECIES = {
  encrypt(curve, kdf, msg, pub, priv = null) {
    assert(curve && typeof curve.id === 'string');

    if (priv == null)
      priv = curve.privateKeyGenerate();

    const ourPub = curve.publicKeyCreate(priv);
    const secret = curve.derive(pub, priv);
    const key = box.derive(secret, kdf);
    const nonce = random.randomBytes(24);
    const sealed = box.seal(msg, key, nonce);

    return Buffer.concat([ourPub, nonce, sealed]);
  },

  decrypt(curve, kdf, msg, priv) {
    assert(curve && typeof curve.id === 'string');
    assert(Buffer.isBuffer(msg));

    const klen = curve.type === 'short'
      ? 1 + curve.size
      : curve.size;

    if (msg.length < klen + 24)
      throw new Error('Invalid ciphertext.');

    const theirPub = msg.slice(0, klen);
    const nonce = msg.slice(klen, klen + 24);
    const sealed = msg.slice(klen + 24);
    const secret = curve.derive(theirPub, priv);
    const key = box.derive(secret, kdf);

    return box.open(sealed, key, nonce);
  }
};

/*
 * Expose
 */

module.exports = ECIES;

}).call(this,req("buffer").Buffer)
},{"./random":162,"./secretbox":171,"bsert":190,"buffer":303}],44:[function(req,module,exports){
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/ed25519');

},{"./js/ed25519":106}],45:[function(req,module,exports){
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/ed448');

},{"./js/ed448":107}],46:[function(req,module,exports){
(function (Buffer){
/*!
 * asn1.js - ASN1 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/asn1.js:
 *   Copyright Fedor Indutny, 2013.
 *   https://github.com/indutny/asn1.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One
 *   https://en.wikipedia.org/wiki/X.690#BER_encoding
 *   https://en.wikipedia.org/wiki/X.690#DER_encoding
 *   http://luca.ntop.org/Teaching/Appunti/asn1.html
 *   ftp://ftp.rsasecurity.com/pub/pkcs/ascii/layman.asc
 *   https://tools.ietf.org/html/rfc2560
 *   https://tools.ietf.org/html/rfc5280
 *   https://github.com/indutny/asn1.js/blob/master/rfc/2560/index.js
 *   https://github.com/indutny/asn1.js/blob/master/rfc/5280/index.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/base/node.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/encoders/der.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/decoders/der.js
 *   https://github.com/openssl/openssl/blob/master/include/openssl/asn1.h
 *   https://github.com/golang/go/blob/master/src/encoding/asn1/asn1.go
 *   https://github.com/golang/go/blob/master/src/encoding/asn1/marshal.go
 */

/* eslint no-prototype-builtins: "off" */

'use strict';

const assert = req('bsert');
const bio = req('bufio');
const objects = req('../internal/objects');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const ZERO = Buffer.alloc(1, 0x00);
const EMPTY_OID = new Uint32Array(2);
const MIN_TIME = -62167219200; // 0000-01-01T00:00:00.000Z
const MAX_TIME = 253402300799; // 9999-12-31T23:59:59.000Z
const MIN_OFFSET = -43200; // UTC-12:00
const MAX_OFFSET = 50400; // UTC+14:00

// Missing types:
//   EOC: 0
//   OBJDESC: 7
//   EXTERNAL: 8
//   REAL: 9
//   EMBED: 11
//   ROID: 13
//   VIDEOSTRING: 21
//   GRAPHSTRING: 25
//   ISO64STRING: 26
//   UNISTRING: 28
//   CHARSTRING: 29
//   BMPSTRING: 30

const types = {
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTSTRING: 4,
  NULL: 5,
  OID: 6,
  ENUM: 10,
  UTF8STRING: 12,
  SEQUENCE: 16,
  SET: 17,
  NUMSTRING: 18,
  PRINTSTRING: 19,
  T61STRING: 20,
  IA5STRING: 22,
  UTCTIME: 23,
  GENTIME: 24,
  GENSTRING: 27
};

const typesByVal = {
  1: 'BOOLEAN',
  2: 'INTEGER',
  3: 'BITSTRING',
  4: 'OCTSTRING',
  5: 'NULL',
  6: 'OID',
  10: 'ENUM',
  12: 'UTF8STRING',
  16: 'SEQUENCE',
  17: 'SET',
  18: 'NUMSTRING',
  19: 'PRINTSTRING',
  20: 'T61STRING',
  22: 'IA5STRING',
  23: 'UTCTIME',
  24: 'GENTIME',
  27: 'GENSTRING'
};

const classes = {
  UNIVERSAL: 0,
  APPLICATION: 1,
  CONTEXT: 2,
  PRIVATE: 3
};

const classesByVal = {
  0: 'UNIVERSAL',
  1: 'APPLICATION',
  2: 'CONTEXT',
  3: 'PRIVATE'
};

const TARGET = 0xff;
const OPTIONAL = 1 << 8;
const MODE = 0xff << 9;
const NORMAL = 0 << 9;
const EXPLICIT = 1 << 9;
const IMPLICIT = 2 << 9;

/**
 * Node
 */

class Node extends bio.Struct {
  constructor() {
    super();
    this.flags = 0;
  }

  get mode() {
    return this.flags & MODE;
  }

  set mode(value) {
    this.flags &= ~MODE;
    this.flags |= value;
  }

  get opt() {
    return (this.flags & OPTIONAL) !== 0;
  }

  set opt(value) {
    if (value)
      this.flags |= OPTIONAL;
    else
      this.flags &= ~OPTIONAL;
  }

  get target() {
    return this.flags & TARGET;
  }

  set target(value) {
    this.flags &= ~TARGET;
    this.flags |= value;
  }

  get isRaw() {
    return false;
  }

  explicit(target) {
    assert((target >>> 0) === target);
    this.mode = EXPLICIT;
    this.target = target;
    return this;
  }

  implicit(target) {
    assert((target >>> 0) === target);
    this.mode = IMPLICIT;
    this.target = target;
    return this;
  }

  optional(value = true) {
    assert(typeof value === 'boolean');
    this.opt = value;
    return this;
  }

  clean() {
    return false;
  }

  getBodySize(extra) {
    return 0;
  }

  writeBody(bw, extra) {
    return bw;
  }

  readBody(br, extra) {
    return this;
  }

  encodeBody(extra) {
    const size = this.getBodySize();
    const bw = bio.write(size);
    this.writeBody(bw, extra);
    return bw.render();
  }

  decodeBody(data, extra) {
    const br = bio.read(data);
    return this.readBody(br, extra);
  }

  set() {
    return this;
  }

  from(options, ...extra) {
    if (options == null)
      return this;

    return this.set(options, ...extra);
  }

  error(str) {
    if (this.opt)
      return this;

    const err = new Error(str);

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, this.error);

    throw err;
  }

  getSize(extra) {
    if (this.opt && this.clean())
      return 0;

    const body = this.getBodySize(extra);

    let size = 0;

    size += sizeHeader(body);
    size += body;

    if (this.mode === EXPLICIT)
      size += sizeHeader(size);

    return size;
  }

  write(bw, extra) {
    if (this.opt && this.clean())
      return bw;

    const body = this.getBodySize();

    switch (this.mode) {
      case EXPLICIT: {
        const size = sizeHeader(body) + body;
        writeHeader(bw, this.target, classes.CONTEXT, false, size);
        // fall through
      }
      case NORMAL: {
        const primitive = this.type !== types.SEQUENCE
                       && this.type !== types.SET;
        writeHeader(bw, this.type, classes.UNIVERSAL, primitive, body);
        break;
      }
      case IMPLICIT: {
        const primitive = this.type !== types.SEQUENCE
                       && this.type !== types.SET;
        writeHeader(bw, this.target, classes.CONTEXT, primitive, body);
        break;
      }
      default: {
        throw new assert.AssertionError('Invalid mode.');
      }
    }

    return this.writeBody(bw, extra);
  }

  read(br, extra) {
    switch (this.mode) {
      case EXPLICIT: {
        const hdr = peekHeader(br, this.opt);

        if (!hdr)
          return this;

        if (hdr.cls !== classes.CONTEXT)
          return this.error(`Unexpected class: ${hdr.cls}.`);

        if (hdr.primitive)
          return this.error('Unexpected primitive flag.');

        if (hdr.type !== this.target)
          return this.error(`Unexpected type: ${hdr.type}.`);

        br.seek(hdr.len);
        br = br.readChild(hdr.size);

        // Fall through.
      }

      case NORMAL: {
        const hdr = peekHeader(br, this.opt);

        if (!hdr)
          return this;

        if (hdr.cls !== classes.UNIVERSAL)
          return this.error(`Unexpected class: ${hdr.cls}.`);

        const primitive = this.type !== types.SEQUENCE
                       && this.type !== types.SET;

        if (hdr.primitive !== primitive)
          return this.error('Unexpected primitive flag.');

        if (hdr.type !== this.type)
          return this.error(`Unexpected type: ${hdr.type}.`);

        if (this.isRaw) {
          const size = hdr.len + hdr.size;

          this.raw = br.readBytes(size);

          br.seek(-size);
        }

        br.seek(hdr.len);

        const child = br.readChild(hdr.size);

        return this.readBody(child, extra);
      }

      case IMPLICIT: {
        const hdr = peekHeader(br, this.opt);

        if (!hdr)
          return this;

        if (hdr.cls !== classes.CONTEXT)
          return this.error(`Unexpected class: ${hdr.cls}.`);

        const primitive = this.type !== types.SEQUENCE
                       && this.type !== types.SET;

        if (hdr.primitive !== primitive)
          return this.error('Unexpected primitive flag.');

        if (hdr.type !== this.target)
          return this.error(`Unexpected type: ${hdr.type}.`);

        br.seek(hdr.len);

        const child = br.readChild(hdr.size);

        return this.readBody(child, extra);
      }

      default: {
        throw new assert.AssertionError('Invalid mode.');
      }
    }
  }

  fromArray(value) {
    return this;
  }

  fromNumber(num) {
    return this;
  }

  fromPEM(num) {
    return this;
  }

  static decodeBody(value) {
    return new this().decodeBody(value);
  }

  static fromArray(value) {
    return new this().fromArray(value);
  }

  static fromNumber(num) {
    return new this().fromNumber(num);
  }

  static fromPEM(str) {
    return new this().fromPEM(str);
  }
}

/**
 * Sequence
 */

class Sequence extends Node {
  constructor(...options) {
    super();
    this.raw = null;
    this.from(...options);
  }

  get type() {
    return types.SEQUENCE;
  }
};

/**
 * Set
 */

class Set extends Node {
  constructor(...options) {
    super();
    this.raw = null;
    this.from(...options);
  }

  get type() {
    return types.SET;
  }
};

/**
 * Any
 */

class Any extends Node {
  constructor(...options) {
    super();
    this.node = new Null();
    this.raw = null;
    this.from(...options);
  }

  get isRaw() {
    return true;
  }

  explicit(target) {
    throw new Error('Cannot set explicit on any.');
  }

  implicit(target) {
    throw new Error('Cannot set implicit on any.');
  }

  get type() {
    return this.node.type;
  }

  getSize(extra) {
    this.node.flags = this.flags;
    return this.node.getSize(extra);
  }

  write(bw, extra) {
    assert(bw);
    assert(this.mode === NORMAL);
    this.node.flags = this.flags;
    this.node.write(bw, extra);
    return bw;
  }

  read(br, extra) {
    assert(br);
    assert(this.mode === NORMAL);

    const hdr = peekHeader(br, this.opt);

    if (!hdr) {
      this.node.flags = this.flags;
      return this;
    }

    const Node = typeToClass(hdr.type);

    this.node = new Node();
    this.node.flags = this.flags;
    this.node.read(br, extra);

    return this;
  }

  getBodySize(extra) {
    this.node.flags = this.flags;
    return this.node.getBodySize(extra);
  }

  writeBody(bw, extra) {
    this.node.flags = this.flags;
    this.node.writeBody(bw, extra);
    return bw;
  }

  readBody(br, extra) {
    this.node.flags = this.flags;
    this.node.readBody(br, extra);
    return this;
  }

  set(node) {
    if (node == null)
      node = new Null();

    assert(node instanceof Node);

    this.node = node;
    this.node.flags = this.flags;

    return this;
  }

  clean() {
    return this.node.type === types.NULL;
  }

  format() {
    return {
      type: this.constructor.name,
      node: this.node
    };
  }
}

/**
 * Choice
 */

class Choice extends Node {
  constructor(node, ...options) {
    super();
    assert(node instanceof Node);
    this.node = node;
    this.from(...options);
  }

  get type() {
    return this.node.type;
  }

  choices() {
    throw new Error('Unimplemented.');
  }

  getSize(extra) {
    return this.node.getSize(extra);
  }

  write(bw, extra) {
    assert(bw);
    this.node.flags = this.flags;
    this.node.write(bw, extra);
    return bw;
  }

  read(br, extra) {
    assert(br);

    const choices = this.choices();

    assert(Array.isArray(choices));
    assert(choices.length >= 1);

    const hdr = peekHeader(br, this.opt);

    if (!hdr)
      return this;

    if (choices.indexOf(hdr.type) === -1)
      throw new Error(`Could not satisfy choice for: ${hdr.type}.`);

    const Node = typeToClass(hdr.type);
    const el = new Node();
    el.flags = this.flags;

    this.node = el.read(br, extra);

    return this;
  }

  getBodySize(extra) {
    return this.node.getBodySize(extra);
  }

  writeBody(bw, extra) {
    this.node.writeBody(bw, extra);
    return bw;
  }

  readBody(br, extra) {
    this.node.readBody(br, extra);
    return this;
  }

  set(...options) {
    return this.node.set(...options);
  }

  clean() {
    return this.node.clean();
  }

  format() {
    return {
      type: this.constructor.name,
      node: this.node
    };
  }
}

/**
 * String
 */

const Str = class String extends Node {
  constructor(...options) {
    super();
    this.value = '';
    this.from(...options);
  }

  get encoding() {
    return 'binary';
  }

  getBodySize() {
    return Buffer.byteLength(this.value, this.encoding);
  }

  writeBody(bw) {
    bw.writeString(this.value, this.encoding);
    return bw;
  }

  readBody(br) {
    const str = br.readString(br.left(), this.encoding);

    switch (this.type) {
      case types.NUMSTRING: {
        if (!isNumString(str))
          throw new Error('Invalid num string.');
        break;
      }

      case types.PRINTSTRING: {
        if (!isPrintString(str))
          throw new Error('Invalid print string.');
        break;
      }

      case types.IA5STRING: {
        if (!isIA5String(str))
          throw new Error('Invalid print string.');
        break;
      }
    }

    this.value = str;

    return this;
  }

  set(value) {
    if (value == null)
      value = '';

    assert(typeof value === 'string');

    this.value = value;

    return this;
  }

  clean() {
    return this.value.length === 0;
  }

  format() {
    return `<${this.constructor.name}: ${this.value}>`;
  }
};

/**
 * Boolean
 */

const Bool = class Boolean extends Node {
  constructor(...options) {
    super();
    this.value = false;
    this.from(...options);
  }

  get type() {
    return types.BOOLEAN;
  }

  getBodySize() {
    return 1;
  }

  writeBody(bw) {
    bw.writeU8(this.value ? 0xff : 0x00);
    return bw;
  }

  readBody(br) {
    if (br.left() !== 1)
      throw new Error('Non-minimal boolean.');

    const value = br.readU8();

    if (value !== 0x00 && value !== 0xff)
      throw new Error('Invalid boolean.');

    this.value = value === 0xff;

    return this;
  }

  set(value) {
    if (value == null)
      value = false;

    assert(typeof value === 'boolean');

    this.value = value;

    return this;
  }

  clean() {
    return this.value === false;
  }

  format() {
    return `<${this.constructor.name}: ${this.value}>`;
  }
};

/**
 * Integer
 */

class Integer extends Node {
  constructor(...options) {
    super();
    this.value = ZERO;
    this.negative = false;
    this.from(...options);
  }

  get type() {
    return types.INTEGER;
  }

  getBodySize() {
    const b = this.value;

    if (b.length === 0)
      return 1;

    let pad = 0;
    let size = 0;

    if (!this.negative && b[0] > 127) {
      pad = 1;
    } else if (this.negative) {
      if (b[0] > 128) {
        pad = 1;
      } else if (b[0] === 128) {
        pad = 0;
        for (let i = 1; i < b.length; i++)
          pad |= b[i];
        pad = pad ? 1 : 0;
      }
    }

    size += pad;
    size += b.length;

    return size;
  }

  writeBody(bw) {
    const b = this.value;

    if (b.length === 0) {
      bw.writeU8(0x00);
      return bw;
    }

    let pad = 0;
    let pb = 0;

    if (!this.negative && b[0] > 127) {
      pad = 1;
      pb = 0;
    } else if (this.negative) {
      pb = 0xff;
      if (b[0] > 128) {
        pad = 1;
      } else if (b[0] === 128) {
        pad = 0;
        for (let i = 1; i < b.length; i++)
          pad |= b[i];
        pb = pad !== 0 ? 0xff : 0;
        pad = pb & 1;
      }
    }

    if (pad)
      bw.writeU8(pb);

    const start = bw.offset;

    bw.writeBytes(b);

    if (pb)
      twosComplement(bw.data, start, bw.offset);

    return this;
  }

  readBody(br, strict = false) {
    let p = br.readBytes(br.left());

    if (p.length === 0)
      throw new Error('Zero length integer.');

    if (strict) {
      // This line throws on a number of root certs.
      if (p[0] === 0x00 && (p[1] & 0x80) === 0)
        throw new Error('Non-minimal integer.');

      if (p[0] === 0xff && (p[1] & 0x80) === 0x80)
        throw new Error('Non-minimal integer.');
    }

    const neg = p[0] & 0x80;

    if (p.length === 1) {
      if (neg)
        p[0] = (p[0] ^ 0xff) + 1;

      this.negative = neg !== 0;
      this.value = p;

      return this;
    }

    let pad = 0;

    if (p[0] === 0x00) {
      pad = 1;
    } else if (p[0] === 0xff) {
      for (let i = 1; i < p.length; i++)
        pad |= p[i];
      pad = pad !== 0 ? 1 : 0;
    }

    if (pad && neg === (p[1] & 0x80))
      throw new Error('Invalid integer padding.');

    if (pad)
      p = p.slice(1);

    if (neg)
      twosComplement(p, 0, p.length);

    this.negative = neg !== 0;
    this.value = trimLeft(p);

    return this;
  }

  set(value, negative) {
    if (typeof value === 'number')
      return this.fromNumber(value);

    if (value == null)
      value = ZERO;

    assert(Buffer.isBuffer(value));

    this.value = trimLeft(value);
    this.negative = false;

    if (negative != null) {
      assert(typeof negative === 'boolean');
      this.negative = negative;
    }

    return this;
  }

  clean() {
    return !this.negative && this.value.equals(ZERO);
  }

  formatValue() {
    return this.value.toString('hex');
  }

  toNumber() {
    let num = bio.readUBE(this.value, 0, this.value.length);

    if (this.negative)
      num = -num;

    return num;
  }

  fromNumber(num) {
    assert(Number.isSafeInteger(num));

    const buf = Buffer.allocUnsafe(8);

    let neg = false;

    if (num < 0) {
      neg = true;
      num = -num;
    }

    bio.writeU64BE(buf, num, 0);

    this.value = trimLeft(buf);
    this.negative = neg;

    return this;
  }

  format() {
    const name = this.constructor.name;

    if (this.value.length <= 6)
      return `<${name}: ${this.toNumber()}>`;

    const sign = this.negative ? '-' : '';
    const hex = this.value.toString('hex');

    return `<${name}: ${sign}0x${hex}>`;
  }
}

/**
 * Unsigned
 */

class Unsigned extends Integer {
  constructor(...options) {
    super(...options);
  }

  getBodySize() {
    assert(!this.negative);
    return super.getBodySize();
  }

  writeBody(bw) {
    assert(!this.negative);
    return super.writeBody(bw);
  }

  readBody(br, strict = false) {
    super.readBody(br, strict);
    assert(!this.negative);
    return this;
  }

  set(value) {
    return super.set(value);
  }

  toNumber() {
    assert(!this.negative);
    return super.toNumber();
  }

  fromNumber(num) {
    super.fromNumber(num);
    assert(!this.negative);
    return this;
  }
}

/**
 * BitString
 */

class BitString extends Node {
  constructor(...options) {
    super();
    this.bits = 0;
    this.value = EMPTY;
    this.from(...options);
  }

  get type() {
    return types.BITSTRING;
  }

  getBodySize() {
    return 1 + this.value.length;
  }

  writeBody(bw) {
    const prefix = (8 - (this.bits & 7)) & 7;
    bw.writeU8(prefix);
    bw.writeBytes(this.value);
    return bw;
  }

  readBody(br) {
    const data = br.readBytes(br.left());

    if (data.length === 0)
      throw new Error('Zero length bit string.');

    const padding = data[0];

    if (padding > 7
        || (data.length === 1 && padding > 0)
        || (data[data.length - 1] & ((1 << padding) - 1)) !== 0) {
      throw new Error('Invalid padding bits.');
    }

    this.bits = (data.length - 1) * 8 - padding;
    this.value = data.slice(1);

    return this;
  }

  rightAlign() {
    const data = this.value;
    const shift = 8 - (this.bits & 7);

    if (shift === 8 || data.length === 0)
      return data;

    const out = Buffer.allocUnsafe(data.length);
    out[0] = data[0] >>> shift;

    for (let i = 1; i < data.length; i++) {
      out[i] = data[i - 1] << (8 - shift);
      out[i] |= data[i] >>> shift;
    }

    return out;
  }

  getBit(i) {
    assert((i >>> 0) === i);

    if (i < 0 || i > this.bits)
      return 0;

    const x = i >>> 3;
    const y = 7 - (i & 7);

    return (this.value[x] >>> y) & 1;
  }

  setBit(i, val) {
    assert((i >>> 0) === i);

    if (i < 0 || i > this.bits)
      return this;

    const x = i >>> 3;
    const y = 7 - (i & 7);

    if (val)
      this.value[x] |= 1 << y;
    else
      this.value[x] &= ~(1 << y);

    return this;
  }

  set(value) {
    if (value == null)
      value = EMPTY;

    if (typeof value === 'number') {
      assert((value >>> 0) === value);
      this.bits = value;
      this.value = Buffer.alloc((value + 7) >>> 3);
    } else {
      assert(Buffer.isBuffer(value));
      this.bits = value.length * 8;
      this.value = value;
    }

    return this;
  }

  clean() {
    return this.bits === 0 && this.value.length === 0;
  }

  format() {
    let value = this.rightAlign();

    if (value.length > 32)
      value = value.slice(0, 32);

    return `<${this.constructor.name}: ${this.bits}:${value.toString('hex')}>`;
  }
}

/**
 * OctString
 */

class OctString extends Node {
  constructor(...options) {
    super();
    this.value = EMPTY;
    this.from(...options);
  }

  get type() {
    return types.OCTSTRING;
  }

  getBodySize() {
    return this.value.length;
  }

  writeBody(bw) {
    bw.writeBytes(this.value);
    return bw;
  }

  readBody(br) {
    this.value = br.readBytes(br.left());
    return this;
  }

  set(value) {
    if (value == null)
      value = EMPTY;

    assert(Buffer.isBuffer(value));

    this.value = value;

    return this;
  }

  clean() {
    return this.value.length === 0;
  }

  format() {
    let value = this.value;

    if (value.length > 32)
      value = value.slice(0, 32);

    return `<${this.constructor.name}: ${value.toString('hex')}>`;
  }
}

/**
 * Null
 */

class Null extends Node {
  constructor(...options) {
    super();
    this.from(...options);
  }

  get type() {
    return types.NULL;
  }

  getBodySize() {
    return 0;
  }

  writeBody(bw) {
    return bw;
  }

  readBody(br) {
    if (br.left() !== 0)
      throw new Error('Non-minimal NULL.');

    return this;
  }

  clean() {
    return true;
  }

  format() {
    return `<${this.constructor.name}>`;
  }
}

/**
 * OID
 */

class OID extends Node {
  constructor(...options) {
    super();
    this.value = EMPTY_OID;
    this.from(...options);
  }

  get type() {
    return types.OID;
  }

  getBodySize() {
    const oid = this.value;

    if (oid.length < 2 || oid[0] > 2 || (oid[0] < 2 && oid[1] >= 40))
      throw new Error('Invalid OID.');

    let size = sizeBase128(oid[0] * 40 + oid[1]);

    for (let i = 2; i < oid.length; i++)
      size += sizeBase128(oid[i]);

    return size;
  }

  writeBody(bw) {
    const oid = this.value;
    const data = bw.data;

    if (oid.length < 2 || oid[0] > 2 || (oid[0] < 2 && oid[1] >= 40))
      throw new Error('Invalid OID.');

    let off = bw.offset;

    off = writeBase128(data, oid[0] * 40 + oid[1], off);

    for (let i = 2; i < oid.length; i++)
      off = writeBase128(data, oid[i], off);

    bw.offset = off;

    return bw;
  }

  readBody(br) {
    const data = br.readBytes(br.left(), true);

    if (data.length === 0)
      throw new Error('Zero length OID.');

    const s = new Uint32Array(data.length + 1);

    let [v, off] = readBase128(data, 0);

    if (v < 80) {
      s[0] = (v / 40) >>> 0;
      s[1] = v % 40;
    } else {
      s[0] = 2;
      s[1] = v - 80;
    }

    let i = 2;

    for (; off < data.length; i++) {
      [v, off] = readBase128(data, off);
      s[i] = v;
    }

    this.value = s.subarray(0, i);

    return this;
  }

  equals(oid) {
    assert(oid instanceof OID);
    return isEqual(this.value, oid.value);
  }

  set(value) {
    if (value == null)
      value = EMPTY_OID;

    if (typeof value === 'string')
      return this.fromString(value);

    if (Array.isArray(value))
      return this.fromArray(value);

    assert(value instanceof Uint32Array);

    this.value = value;

    return this;
  }

  clean() {
    return isEqual(this.value, EMPTY_OID);
  }

  toArray() {
    const arr = [];

    for (let i = 0; i < this.value.length; i++)
      arr.push(this.value[i]);

    return arr;
  }

  fromArray(arr) {
    assert(Array.isArray(arr));

    const out = new Uint32Array(arr.length);

    for (let i = 0; i < arr.length; i++) {
      const val = arr[i];
      assert((val >>> 0) === val);
      out[i] = val;
    }

    this.value = out;

    return this;
  }

  toString() {
    let str = '';

    for (let i = 0; i < this.value.length; i++) {
      if (i > 0)
        str += '.';

      str += this.value[i].toString(10);
    }

    return str;
  }

  fromString(str) {
    assert(typeof str === 'string');

    if (objects.attrs.hasOwnProperty(str))
      str = objects.attrs[str];
    else if (objects.keyAlgs.hasOwnProperty(str))
      str = objects.keyAlgs[str];
    else if (objects.hashes.hasOwnProperty(str))
      str = objects.hashes[str];
    else if (objects.curves.hasOwnProperty(str))
      str = objects.curves[str];

    const parts = str.split('.');
    const out = new Uint32Array(parts.length);

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      out[i] = parseU32(part);
    }

    this.value = out;

    return this;
  }

  getAttributeName() {
    return objects.attrsByVal[this.toString()] || null;
  }

  getSignatureAlgorithmName() {
    return objects.sigAlgsByVal[this.toString()] || null;
  }

  getSignatureHash() {
    return objects.sigToHash[this.toString()] || null;
  }

  getSignatureHashName() {
    const oid = this.getSignatureHash();

    if (!oid)
      return null;

    return objects.hashesByVal[oid] || null;
  }

  getKeyAlgorithmName() {
    return objects.keyAlgsByVal[this.toString()] || null;
  }

  getHashName() {
    return objects.hashesByVal[this.toString()] || null;
  }

  getCurveName() {
    return objects.curvesByVal[this.toString()] || null;
  }

  format() {
    const oid = this.toString();
    const name = objects.attrsByVal[oid]
              || objects.sigAlgsByVal[oid]
              || objects.keyAlgsByVal[oid]
              || objects.hashesByVal[oid]
              || objects.curvesByVal[oid]
              || 'UNKNOWN';

    const str = `${oid} (${name})`;

    return `<${this.constructor.name}: ${str}>`;
  }
}

/**
 * Enum
 */

class Enum extends Integer {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.ENUM;
  }
}

/**
 * Utf8String
 */

class Utf8String extends Str {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.UTF8STRING;
  }

  get encoding() {
    return 'utf8';
  }
}

/**
 * RawSequence
 */

class RawSequence extends Node {
  constructor(...options) {
    super();
    this.value = EMPTY;
    this.from(...options);
  }

  get type() {
    return types.SEQUENCE;
  }

  getBodySize() {
    return this.value.length;
  }

  writeBody(bw) {
    bw.writeBytes(this.value);
    return bw;
  }

  readBody(br) {
    this.value = br.readBytes(br.left());
    return this;
  }

  set(value) {
    if (value == null)
      value = EMPTY;

    if (Array.isArray(value))
      return this.fromArray(value);

    assert(Buffer.isBuffer(value));

    this.value = value;

    return this;
  }

  clean() {
    return this.value.length === 0;
  }

  *children() {
    const br = bio.read(this.value);

    while (br.left())
      yield Any.read(br).node;
  }

  toArray() {
    const out = [];

    for (const el of this.children())
      out.push(el);

    return out;
  }

  fromArray(value) {
    assert(Array.isArray(value));

    let size = 0;

    for (const el of value) {
      assert(el instanceof Node);
      size += el.getSize();
    }

    const bw = bio.write(size);

    for (const el of value)
      el.write(bw);

    this.value = bw.render();

    return this;
  }

  format() {
    return this.toArray();
  }
}

/**
 * RawSet
 */

class RawSet extends RawSequence {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.SET;
  }
}

/**
 * NumString
 */

class NumString extends Str {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.NUMSTRING;
  }
}

/**
 * PrintString
 */

class PrintString extends Str {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.PRINTSTRING;
  }
}

/**
 * T61String
 */

class T61String extends Str {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.T61STRING;
  }
}

/**
 * IA5String
 */

class IA5String extends Str {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.IA5STRING;
  }
}

/**
 * Time
 */

class Time extends Node {
  constructor(...options) {
    super();
    this.value = 0;
    this.offset = 0;
    this.from(...options);
  }

  set(value, offset) {
    if (value == null)
      value = 0;

    if (offset == null)
      offset = 0;

    if (typeof value === 'string')
      return this.fromString(value);

    assert(isTime(value));
    assert(isOffset(offset));

    this.value = value;
    this.offset = offset;

    return this;
  }

  clean() {
    return this.value === 0 && this.offset === 0;
  }

  unix() {
    return this.value - this.offset;
  }

  toString() {
    const date = new Date(this.value * 1000);
    const str = date.toISOString().slice(0, -5);
    return str + serializeOffset(this.offset);
  }

  fromString(str) {
    assert(typeof str === 'string');

    const ms = Date.parse(str);

    if (ms !== ms)
      throw new Error('Invalid date string.');

    const time = Math.floor(ms / 1000);

    if (!isTime(time))
      throw new Error('Invalid time.');

    this.value = time;
    this.offset = 0;

    return this;
  }

  format() {
    const name = this.constructor.name;
    const value = this.value;

    let off = this.offset.toString(10);

    if (this.offset >= 0)
      off = '+' + off;

    return `<${name}: ${value}${off} (${this.toString()})>`;
  }
}

/**
 * UTCTime
 */

class UTCTime extends Time {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.UTCTIME;
  }

  getBodySize() {
    return this.offset === 0 ? 13 : 17;
  }

  writeBody(bw) {
    assert(isTime(this.value));

    const date = new Date(this.value * 1000);

    let str = '';

    str += two(date.getUTCFullYear() % 100);
    str += two(date.getUTCMonth() + 1);
    str += two(date.getUTCDate());
    str += two(date.getUTCHours());
    str += two(date.getUTCMinutes());
    str += two(date.getUTCSeconds());
    str += serializeOffset(this.offset);

    bw.writeString(str, 'binary');

    return bw;
  }

  readBody(br) {
    const size = br.left();

    if (size !== 13 && size !== 17)
      throw new Error('Invalid UTCTIME.');

    const str = br.readString(size, 'binary');
    const year = parseU32(str.substring(0, 2));
    const mon = parseU32(str.substring(2, 4));
    const day = parseU32(str.substring(4, 6));
    const hour = parseU32(str.substring(6, 8));
    const min = parseU32(str.substring(8, 10));
    const sec = parseU32(str.substring(10, 12));

    this.value = toSeconds(year, mon, day, hour, min, sec, true);
    this.offset = parseOffset(str.substring(12));

    return this;
  }
}

/**
 * GenTime
 */

class GenTime extends Time {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.GENTIME;
  }

  getBodySize() {
    return this.offset === 0 ? 15 : 19;
  }

  writeBody(bw) {
    assert(isTime(this.value));

    const date = new Date(this.value * 1000);

    let str = '';
    str += date.getUTCFullYear().toString(10);
    str += two(date.getUTCMonth() + 1);
    str += two(date.getUTCDate());
    str += two(date.getUTCHours());
    str += two(date.getUTCMinutes());
    str += two(date.getUTCSeconds());
    str += serializeOffset(this.offset);

    bw.writeString(str, 'binary');

    return bw;
  }

  readBody(br) {
    const size = br.left();

    if (size !== 15 && size !== 19)
      throw new Error('Invalid GENTIME.');

    const str = br.readString(size, 'binary');
    const year = parseU32(str.substring(0, 4));
    const mon = parseU32(str.substring(4, 6));
    const day = parseU32(str.substring(6, 8));
    const hour = parseU32(str.substring(8, 10));
    const min = parseU32(str.substring(10, 12));
    const sec = parseU32(str.substring(12, 14));

    this.value = toSeconds(year, mon, day, hour, min, sec, false);
    this.offset = parseOffset(str.substring(14));

    return this;
  }
}

/**
 * GenString
 */

class GenString extends Str {
  constructor(...options) {
    super(...options);
  }

  get type() {
    return types.GENSTRING;
  }
}

/**
 * API
 */

function typeToClass(type) {
  assert((type >>> 0) === type);

  switch (type) {
    case types.BOOLEAN:
      return Bool;
    case types.INTEGER:
      return Integer;
    case types.BITSTRING:
      return BitString;
    case types.OCTSTRING:
      return OctString;
    case types.NULL:
      return Null;
    case types.OID:
      return OID;
    case types.ENUM:
      return Enum;
    case types.UTF8STRING:
      return Utf8String;
    case types.SEQUENCE:
      return RawSequence;
    case types.SET:
      return RawSet;
    case types.NUMSTRING:
      return NumString;
    case types.PRINTSTRING:
      return PrintString;
    case types.T61STRING:
      return T61String;
    case types.IA5STRING:
      return IA5String;
    case types.UTCTIME:
      return UTCTime;
    case types.GENTIME:
      return GenTime;
    case types.GENSTRING:
      return GenString;
    default:
      throw new Error(`Unknown type: ${type}.`);
  }
}

/*
 * Helpers
 */

function sizeHeader(size) {
  assert((size >>> 0) === size);

  if (size <= 0x7f)
    return 1 + 1;

  if (size <= 0xff)
    return 1 + 1 + 1;

  if (size <= 0xffff)
    return 1 + 1 + 2;

  assert(size <= 0xffffff);

  return 1 + 1 + 3;
}

function writeHeader(bw, type, cls, primitive, size) {
  assert(bw);
  assert((type >>> 0) === type);
  assert((cls >>> 0) === cls);
  assert(typeof primitive === 'boolean');
  assert((size >>> 0) === size);

  if (!primitive)
    type |= 0x20;

  type |= cls << 6;

  // Short form.
  if (size <= 0x7f) {
    bw.writeU8(type);
    bw.writeU8(size);

    return bw;
  }

  // Long form (1 byte).
  if (size <= 0xff) {
    bw.writeU8(type);
    bw.writeU8(0x80 | 1);
    bw.writeU8(size);

    return bw;
  }

  // Long form (2 bytes).
  if (size <= 0xffff) {
    bw.writeU8(type);
    bw.writeU8(0x80 | 2);
    bw.writeU16BE(size);

    return bw;
  }

  assert(size <= 0xffffff);

  // Long form (3 bytes).
  bw.writeU8(type);
  bw.writeU8(0x80 | 3);
  bw.writeU24BE(size);

  return bw;
}

function readHeader(br) {
  const start = br.offset;
  const field = br.readU8();
  const cls = field >>> 6;
  const primitive = (field & 0x20) === 0;

  let type = field & 0x1f;

  if (type === 0x1f) {
    [type, br.offset] = readBase128(br.data, br.offset);

    if (type < 0x1f)
      throw new Error('Non-minimal type.');
  }

  switch (cls) {
    case classes.UNIVERSAL:
    case classes.CONTEXT:
      break;
    default:
      throw new Error('Unknown class.');
  }

  const size = readSize(br);
  const len = br.offset - start;

  return {
    type,
    cls,
    primitive,
    size,
    len
  };
}

function peekHeader(br, optional) {
  const offset = br.offset;

  let hdr = null;
  let err = null;

  try {
    hdr = readHeader(br);
  } catch (e) {
    err = e;
  }

  br.offset = offset;

  if (!optional && !hdr)
    throw err;

  return hdr;
}

function readSize(br) {
  const field = br.readU8();
  const bytes = field & 0x7f;

  // Definite form
  if ((field & 0x80) === 0) {
    // Short form
    return bytes;
  }

  // Indefinite form.
  if (bytes === 0)
    throw new Error('Indefinite length.');

  let len = 0;

  for (let i = 0; i < bytes; i++) {
    const ch = br.readU8();

    if (len >= (1 << 23))
      throw new Error('Length too large.');

    len *= 0x100;
    len += ch;

    if (len === 0)
      throw new Error('Unexpected leading zeroes.');
  }

  if (len < 0x80)
    throw new Error('Non-minimal length.');

  return len;
}

function sizeBase128(n) {
  assert((n >>> 0) === n);

  if (n === 0)
    return 1;

  let len = 0;

  while (n > 0) {
    len += 1;
    n >>>= 7;
  }

  return len;
}

function writeBase128(data, n, off) {
  assert(Buffer.isBuffer(data));
  assert((n >>> 0) === n);
  assert((off >>> 0) === off);

  const l = sizeBase128(n);

  for (let i = l - 1; i >= 0; i--) {
    let o = n >>> (i * 7);

    o &= 0x7f;

    if (i !== 0)
      o |= 0x80;

    if (off >= data.length)
      throw new bio.EncodingError(off, 'Out of bounds write');

    data[off] = o;
    off += 1;
  }

  return off;
}

function readBase128(data, off) {
  assert(Buffer.isBuffer(data));
  assert((off >>> 0) === off);

  let shifted = 0;
  let num = 0;

  for (; off < data.length; shifted++) {
    if (shifted === 5)
      throw new Error('Base128 integer too large.');

    const b = data[off];

    num *= 128;
    num += b & 0x7f;

    off += 1;

    if ((b & 0x80) === 0) {
      if (num > 0xffffffff)
        throw new Error('Base128 integer too large.');

      return [num, off];
    }
  }

  throw new Error('Base128 integer too short.');
}

function two(num) {
  if (num < 10)
    return '0' + num.toString(10);
  return num.toString(10);
}

function isNumString(str) {
  assert(typeof str === 'string');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch >= 0x30 && ch <= 0x39)
      continue;

    if (ch === 0x20)
      continue;

    return false;
  }

  return true;
}

function isPrintString(str) {
  assert(typeof str === 'string');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    // 0 - 9
    if (ch >= 0x30 && ch <= 0x39)
      continue;

    // A - Z
    if (ch >= 0x41 && ch <= 0x5a)
      continue;

    // a - z
    if (ch >= 0x61 && ch <= 0x7a)
      continue;

    switch (ch) {
      case 0x20: // ' '
      case 0x26: // & - nonstandard
      case 0x27: // '
      case 0x28: // (
      case 0x29: // )
      case 0x2a: // * - nonstandard
      case 0x2b: // +
      case 0x2c: // ,
      case 0x2d: // -
      case 0x2e: // .
      case 0x2f: // /
      case 0x3a: // :
      case 0x3d: // =
      case 0x3f: // ?
        continue;
    }

    return false;
  }

  return true;
}

function isIA5String(str) {
  assert(typeof str === 'string');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch >= 0x80)
      return false;
  }

  return true;
}

function parseU32(str) {
  assert(typeof str === 'string');

  let word = 0;

  if (str.length === 0 || str.length > 10)
    throw new Error('Invalid integer.');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i) - 0x30;

    if (ch < 0 || ch > 9)
      throw new Error('Invalid integer.');

    word *= 10;
    word += ch;

    if (word > 0xffffffff)
      throw new Error('Invalid integer.');
  }

  return word;
}

function isEqual(a, b) {
  assert(a instanceof Uint32Array);
  assert(b instanceof Uint32Array);

  if (a.length !== b.length)
    return false;

  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i])
      return false;
  }

  return true;
}

function trimLeft(buf) {
  assert(Buffer.isBuffer(buf));

  if (buf.length === 0)
    return Buffer.from([0x00]);

  if (buf[0] !== 0x00)
    return buf;

  for (let i = 1; i < buf.length; i++) {
    if (buf[i] !== 0x00)
      return buf.slice(i);
  }

  return buf.slice(-1);
}

function twosComplement(num, start, end) {
  assert(Buffer.isBuffer(num));
  assert((start >>> 0) === start);
  assert((end >>> 0) === end);
  assert(start <= end);

  let carry = 1;

  for (let i = end - 1; i >= start; i--) {
    carry += num[i] ^ 0xff;
    num[i] = carry & 0xff;
    carry >>>= 8;
  }

  return num;
}

function isTime(time) {
  if (!Number.isSafeInteger(time))
    return false;

  // ASN.1 time ranges from;
  //   0000-01-01T00:00:00.000Z
  // to:
  //   9999-12-31T00:59:59.000Z
  if (time < MIN_TIME || time > MAX_TIME)
    return false;

  return true;
}

function toSeconds(year, mon, day, hour, min, sec, utc) {
  assert((year >>> 0) === year);
  assert((mon >>> 0) === mon);
  assert((day >>> 0) === day);
  assert((hour >>> 0) === hour);
  assert((min >>> 0) === min);
  assert((sec >>> 0) === sec);
  assert(typeof utc === 'boolean');

  if (utc) {
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  }

  // Highest valid date:
  //   new Date(8640000000000000)
  if (year > 275760)
    throw new Error('Invalid year.');

  if (mon < 1 || mon > 12 || day < 1 || day > 32)
    throw new Error('Invalid month or day.');

  if (hour > 23 || min > 59 || sec > 59)
    throw new Error('Invalid hours, minutes, or seconds.');

  const ms = Date.UTC(year, mon - 1, day, hour, min, sec, 0);

  assert(ms === ms);

  const time = ms / 1000;

  assert(isTime(time));

  return time;
}

function isOffset(offset) {
  if (!Number.isSafeInteger(offset))
    return false;

  // UTC timezones range from -12:00 to +14:00.
  if (offset < MIN_OFFSET || offset > MAX_OFFSET)
    return false;

  return true;
}

function serializeOffset(offset) {
  assert(isOffset(offset));

  if (offset === 0)
    return 'Z';

  let str = '';

  if (offset < 0) {
    str += '-';
    offset = -offset;
  } else {
    str += '+';
  }

  const minutes = (offset / 60) >>> 0;
  const hour = (minutes / 60) >>> 0;
  const min = minutes % 60;

  str += two(hour);
  str += two(min);

  return str;
}

function parseOffset(str) {
  assert(typeof str === 'string');

  if (str.length === 0)
    throw new Error('Invalid time offset.');

  const zone = str[0];

  switch (zone) {
    case 'Z': {
      if (str.length !== 1)
        throw new Error('Non-minimal time offset.');

      return 0;
    }
    case '+':
    case '-': {
      if (str.length !== 5)
        throw new Error('Non-minimal time offset.');

      const hour = parseU32(str.substring(1, 3));
      const min = parseU32(str.substring(3, 5));
      const minutes = hour * 60 + min;

      let offset = minutes * 60;

      if (zone === '-')
        offset = -offset;

      if (!isOffset(offset))
        throw new Error('Not a time zone.');

      return offset;
    }
  }

  throw new Error('Invalid time offset.');
}

/*
 * Expose
 */

exports.EMPTY = EMPTY;
exports.ZERO = ZERO;
exports.EMPTY_OID = EMPTY_OID;

exports.types = types;
exports.typesByVal = typesByVal;
exports.classes = classes;
exports.classesByVal = classesByVal;
exports.objects = objects;

exports.TARGET = TARGET;
exports.OPTIONAL = OPTIONAL;
exports.MODE = MODE;
exports.NORMAL = NORMAL;
exports.EXPLICIT = EXPLICIT;
exports.IMPLICIT = IMPLICIT;

exports.Node = Node;
exports.Sequence = Sequence;
exports.Set = Set;
exports.Any = Any;
exports.Choice = Choice;
exports.Str = Str;
exports.String = Str;
exports.Bool = Bool;
exports.Boolean = Bool;
exports.Integer = Integer;
exports.Unsigned = Unsigned;
exports.BitString = BitString;
exports.OctString = OctString;
exports.Null = Null;
exports.OID = OID;
exports.Enum = Enum;
exports.Utf8String = Utf8String;
exports.RawSequence = RawSequence;
exports.RawSet = RawSet;
exports.NumString = NumString;
exports.PrintString = PrintString;
exports.T61String = T61String;
exports.IA5String = IA5String;
exports.Time = Time;
exports.UTCTime = UTCTime;
exports.GenTime = GenTime;
exports.GenString = GenString;

exports.typeToClass = typeToClass;

}).call(this,req("buffer").Buffer)
},{"../internal/objects":78,"bsert":190,"buffer":303,"bufio":191}],47:[function(req,module,exports){
(function (Buffer){
/*!
 * base16.js - base16 for javascript
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */

'use strict';

const assert = req('bsert');
const isBrowser = Buffer.alloc(0)._isBuffer;

/*
 * Base16
 */

function encode(data, size) {
  assert(Buffer.isBuffer(data));
  assert(size == null || (size >>> 0) === size);

  let str = data.toString('hex');

  if (size != null) {
    size *= 2;

    if (str.length > size)
      throw new RangeError('Data length exceeds requested size.');

    while (str.length < size)
      str = '00' + str;
  }

  return str;
}

function encodeLE(data, size) {
  const str = encode(data, size);

  let out = '';

  for (let i = str.length - 2; i >= 0; i -= 2)
    out += str[i] + str[i + 1];

  return out;
}

function decode(str, size) {
  assert(typeof str === 'string');
  assert(size == null || (size >>> 0) === size);

  if (str.length & 1)
    throw new Error('Invalid hex string.');

  if (size != null && str.length !== size * 2)
    throw new RangeError('String length differs from expected size.');

  const data = Buffer.from(str, 'hex');

  if (str.length !== data.length * 2)
    throw new Error('Invalid hex string.');

  if (isBrowser && data.length > 0) {
    // Browserify may parse hex as:
    //
    //   parseInt(str.substring(i, i + 2), 16)
    //
    // This causes problems with error cases.
    //
    // For example:
    //
    //   parseInt('6x', 16) === 6
    //
    // This means our final byte with an
    // invalid character will be `06` and
    // it does not affect the length of
    // the buffer. We can check for this
    // below.
    //
    // This differs from node. Node will
    // discard the entire byte regardless
    // of which character is invalid.
    //
    // https://github.com/nodejs/node/blob/524dd46/src/string_bytes.cc#L247
    // https://github.com/feross/buffer/blob/b651e3a/index.js#L806
    if ((data[data.length - 1] >>> 4) === 0) {
      if (!/[0-9a-f]$/i.test(str))
        throw new Error('Invalid hex string.');
    }
  }

  return data;
}

function decodeLE(str, size) {
  const data = decode(str, size);

  for (let i = data.length - 1, j = 0; i > j; i--, j++)
    [data[i], data[j]] = [data[j], data[i]];

  return data;
}

function test(str, size) {
  assert(typeof str === 'string');
  assert(size == null || (size >>> 0) === size);

  // Note: We cannot use byteLength to validate since the
  // calculation is a simple division by 2 without parsing.
  //
  // https://github.com/nodejs/node/blob/524dd46/lib/buffer.js#L540
  // https://github.com/feross/buffer/blob/b651e3a/index.js#L415
  if (str.length & 1)
    return false;

  if (size != null && str.length !== size * 2)
    return false;

  return /^[0-9a-f]*$/i.test(str);
}

/*
 * Expose
 */

exports.encode = encode;
exports.encodeLE = encodeLE;
exports.decode = decode;
exports.decodeLE = decodeLE;
exports.test = test;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],48:[function(req,module,exports){
(function (Buffer){
/*!
 * base32.js - base32 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 *   https://github.com/bitcoin/bitcoin/blob/11d486d/src/utilstrencodings.cpp#L230
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const CHARSET = 'abcdefghijklmnopqrstuvwxyz234567';
const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1
];

const CHARSET_HEX = '0123456789abcdefghijklmnopqrstuv';
const TABLE_HEX = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
  25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
  25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1
];

const PADDING = [0, 6, 4, 3, 1];

/**
 * Encode a base32 string.
 * @param {Buffer} data
 * @param {Boolean} [pad=false]
 * @returns {String}
 */

function encode(data, pad = false) {
  return _encode(data, CHARSET, pad);
}

/**
 * Encode a base32hex string.
 * @param {Buffer} data
 * @param {Boolean} [pad=false]
 * @returns {String}
 */

function encodeHex(data, pad = false) {
  return _encode(data, CHARSET_HEX, pad);
}

/**
 * Encode a base32 string.
 * @private
 * @param {Buffer} data
 * @param {String} charset
 * @param {Boolean} [pad=false]
 * @returns {String}
 */

function _encode(data, charset, pad) {
  assert(Buffer.isBuffer(data));
  assert(typeof pad === 'boolean');

  let str = '';
  let mode = 0;
  let left = 0;

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];

    switch (mode) {
      case 0:
        str += charset[ch >>> 3];
        left = (ch & 7) << 2;
        mode = 1;
        break;
      case 1:
        str += charset[left | (ch >>> 6)];
        str += charset[(ch >>> 1) & 31];
        left = (ch & 1) << 4;
        mode = 2;
        break;
      case 2:
        str += charset[left | (ch >>> 4)];
        left = (ch & 15) << 1;
        mode = 3;
        break;
      case 3:
        str += charset[left | (ch >>> 7)];
        str += charset[(ch >>> 2) & 31];
        left = (ch & 3) << 3;
        mode = 4;
        break;
      case 4:
        str += charset[left | (ch >>> 5)];
        str += charset[ch & 31];
        mode = 0;
        break;
    }
  }

  if (mode > 0) {
    str += charset[left];
    if (pad) {
      for (let i = 0; i < PADDING[mode]; i++)
        str += '=';
    }
  }

  return str;
}

/**
 * Decode a base32 string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function decode(str, unpad = false) {
  return _decode(str, TABLE, unpad);
}

/**
 * Decode a base32hex string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function decodeHex(str, unpad = false) {
  return _decode(str, TABLE_HEX, unpad);
}

/**
 * Decode a base32 string.
 * @private
 * @param {String} str
 * @param {Array} table
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function _decode(str, table, unpad) {
  assert(typeof str === 'string');
  assert(typeof unpad === 'boolean');

  const data = Buffer.allocUnsafe((str.length * 5 + 7) / 8 | 0);

  let mode = 0;
  let left = 0;
  let j = 0;
  let i = 0;

  for (; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    const v = (ch & 0xff80) ? -1 : table[ch];

    if (v === -1)
      break;

    switch (mode) {
      case 0:
        left = v;
        mode = 1;
        break;
      case 1:
        data[j++] = (left << 3) | (v >>> 2);
        left = v & 3;
        mode = 2;
        break;
      case 2:
        left = left << 5 | v;
        mode = 3;
        break;
      case 3:
        data[j++] = (left << 1) | (v >>> 4);
        left = v & 15;
        mode = 4;
        break;
      case 4:
        data[j++] = (left << 4) | (v >>> 1);
        left = v & 1;
        mode = 5;
        break;
      case 5:
        left = left << 5 | v;
        mode = 6;
        break;
      case 6:
        data[j++] = (left << 2) | (v >>> 3);
        left = v & 7;
        mode = 7;
        break;
      case 7:
        data[j++] = (left << 5) | v;
        left = 0;
        mode = 0;
        break;
    }
  }

  if (mode === 1 || mode === 3 || mode === 6)
    throw new Error('Invalid base32 string.');

  if (left > 0)
    throw new Error('Invalid base32 string.');

  if (str.length !== i + (-mode & 7) * unpad)
    throw new Error('Invalid base32 string.');

  for (; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch !== 0x3d)
      throw new Error('Invalid base32 string.');
  }

  return data.slice(0, j);
}

/**
 * Test a base32 string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function test(str, unpad = false) {
  assert(typeof str === 'string');
  assert(typeof unpad === 'boolean');

  try {
    decode(str, unpad);
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Test a base32 hex string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function testHex(str, unpad = false) {
  assert(typeof str === 'string');
  assert(typeof unpad === 'boolean');

  try {
    decodeHex(str, unpad);
    return true;
  } catch (e) {
    return false;
  }
}

/*
 * Expose
 */

exports.encode = encode;
exports.encodeHex = encodeHex;
exports.decode = decode;
exports.decodeHex = decodeHex;
exports.test = test;
exports.testHex = testHex;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],49:[function(req,module,exports){
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('../js/base58');

},{"../js/base58":84}],50:[function(req,module,exports){
(function (Buffer){
/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */

'use strict';

const assert = req('bsert');

/*
 * Base64
 */

function encode(data) {
  assert(Buffer.isBuffer(data));
  return data.toString('base64');
}

function decode(str) {
  assert(typeof str === 'string');

  if (/[\-_]/.test(str))
    throw new Error('Invalid base64 string.');

  const data = Buffer.from(str, 'base64');

  if (str.length !== size64(data.length))
    throw new Error('Invalid base64 string.');

  return data;
}

function test(str) {
  assert(typeof str === 'string');

  // The only way to get an accurate string
  // size for base64 is by allocating a buffer.
  // Note that browserify _does_ allocate a
  // buffer to calculate base64 decoded size.
  //
  // https://github.com/nodejs/node/blob/524dd4/lib/buffer.js#L477
  // https://github.com/nodejs/node/blob/524dd4/src/node_buffer.cc#L250
  // https://github.com/nodejs/node/blob/524dd4/src/string_bytes.cc#L457
  // https://github.com/feross/buffer/blob/b651e3a/index.js#L415
  try {
    decode(str);
    return true;
  } catch (e) {
    return false;
  }
}

function encodeURL(data) {
  const raw = encode(data);

  const str = raw
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');

  return str;
}

function decodeURL(str) {
  assert(typeof str === 'string');

  if (/[=\+\/]/.test(str))
    throw new Error('Invalid base64-url string.');

  const raw = pad64(str)
    .replace(/\-/g, '+')
    .replace(/_/g, '/');

  return decode(raw);
}

function testURL(str) {
  assert(typeof str === 'string');

  try {
    decodeURL(str);
    return true;
  } catch (e) {
    return false;
  }
}

/*
 * Helpers
 */

function pad64(str) {
  switch (str.length & 3) {
    case 2:
      str += '==';
      break;
    case 3:
      str += '=';
      break;
  }
  return str;
}

function size64(size) {
  const expect = ((4 * size / 3) + 3) & ~3;
  return expect >>> 0;
}

/*
 * Expose
 */

exports.encode = encode;
exports.decode = decode;
exports.test = test;
exports.encodeURL = encodeURL;
exports.decodeURL = decodeURL;
exports.testURL = testURL;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],51:[function(req,module,exports){
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('../js/bech32');

},{"../js/bech32":85}],52:[function(req,module,exports){
/*!
 * cash32.js - cashaddr for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('../js/cash32');

},{"../js/cash32":89}],53:[function(req,module,exports){
/*!
 * index.js - encoding for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

exports.asn1 = req('./asn1');
exports.base16 = req('./base16');
exports.base32 = req('./base32');
exports.base58 = req('./base58');
exports.base64 = req('./base64');
exports.bech32 = req('./bech32');
exports.cash32 = req('./cash32');
exports.lines = req('./lines');
exports.openssl = req('./openssl');
exports.pem = req('./pem');
exports.pemcrypt = req('./pemcrypt');
exports.pkcs1 = req('./pkcs1');
exports.pkcs5 = req('./pkcs5');
exports.pkcs8 = req('./pkcs8');
exports.rfc3279 = req('./rfc3279');
exports.sec1 = req('./sec1');
exports.util = req('./util');
exports.x509 = req('./x509');

},{"./asn1":46,"./base16":47,"./base32":48,"./base58":49,"./base64":50,"./bech32":51,"./cash32":52,"./lines":54,"./openssl":55,"./pem":56,"./pemcrypt":57,"./pkcs1":58,"./pkcs5":59,"./pkcs8":60,"./rfc3279":61,"./sec1":62,"./util":63,"./x509":64}],54:[function(req,module,exports){
/*!
 * lines.js - line reader for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

/* eslint spaced-comment: "off" */

'use strict';

const assert = req('bsert');

/*
 * Lines
 */

function *lines(str) {
  assert(typeof str === 'string');

  let i = 0;
  let j = 0;
  let n = 0;

  if (str.length > 0) {
    if (str.charCodeAt(0) === 0xfeff) {
      i += 1;
      j += 1;
    }
  }

  for (; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    switch (ch) {
      case 0x0d /*'\r'*/:
      case 0x0a /*'\n'*/:
      case 0x85 /*NEL*/: {
        if (j !== i) {
          const line = trimSpace(str.substring(j, i));

          if (line.length > 0)
            yield [n, line];
        }

        if (ch === 0x0d && i + 1 < str.length) {
          if (str.charCodeAt(i + 1) === 0x0a)
            i += 1;
        }

        j = i + 1;
        n += 1;

        break;
      }
    }
  }

  if (j !== i) {
    const line = trimSpace(str.substring(j, i));

    if (line.length > 0)
      yield [n, line];
  }
}

/*
 * Helpers
 */

function trimSpace(str) {
  assert(typeof str === 'string');

  for (let i = str.length - 1; i >= 0; i--) {
    const ch = str.charCodeAt(i);

    switch (ch) {
      case 0x09 /*'\t'*/:
      case 0x0b /*'\v'*/:
      case 0x0c /*'\f'*/:
      case 0x20 /*' '*/:
      case 0xa0 /*nbsp*/:
        continue;
    }

    return str.substring(0, i + 1);
  }

  return str;
}

/*
 * Expose
 */

module.exports = lines;

},{"bsert":190}],55:[function(req,module,exports){
/*!
 * openssl.js - openssl-specific encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://www.openssl.org/docs/man1.1.0/apps/dsa.html
 *   https://superuser.com/questions/478966/dsa-private-key-format
 *   https://github.com/dlitz/pycrypto/blob/master/lib/Crypto/PublicKey/DSA.py
 *   https://github.com/openssl/openssl/blob/master/crypto/dsa/dsa_asn1.c
 */

'use strict';

const asn1 = req('./asn1');
const pem = req('./pem');

/**
 * DSAParams
 */

// DSSParams_OpenSSL ::= SEQUENCE {
//   p INTEGER,
//   q INTEGER,
//   g INTEGER
// }

class DSAParams extends asn1.Sequence {
  constructor(p, q, g) {
    super();
    this.p = new asn1.Unsigned(p);
    this.q = new asn1.Unsigned(q);
    this.g = new asn1.Unsigned(g);
  }

  getBodySize() {
    let size = 0;
    size += this.p.getSize();
    size += this.q.getSize();
    size += this.g.getSize();
    return size;
  }

  writeBody(bw) {
    this.p.write(bw);
    this.q.write(bw);
    this.g.write(bw);
    return bw;
  }

  readBody(br) {
    this.p.read(br);
    this.q.read(br);
    this.g.read(br);
    return this;
  }

  clean() {
    return this.p.clean()
        && this.q.clean()
        && this.g.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'DSA PARAMETERS');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'DSA PARAMETERS');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      p: this.p,
      q: this.q,
      g: this.g
    };
  }
}

/**
 * DSAPublicKey
 */

// DSSPublicKey_OpenSSL ::= SEQUENCE {
//   y INTEGER,
//   p INTEGER,
//   q INTEGER,
//   g INTEGER
// }

class DSAPublicKey extends asn1.Sequence {
  constructor(y, p, q, g) {
    super();
    this.y = new asn1.Unsigned(y);
    this.p = new asn1.Unsigned(p);
    this.q = new asn1.Unsigned(q);
    this.g = new asn1.Unsigned(g);
  }

  getBodySize() {
    let size = 0;
    size += this.y.getSize();
    size += this.p.getSize();
    size += this.q.getSize();
    size += this.g.getSize();
    return size;
  }

  writeBody(bw) {
    this.y.write(bw);
    this.p.write(bw);
    this.q.write(bw);
    this.g.write(bw);
    return bw;
  }

  readBody(br) {
    this.y.read(br);
    this.p.read(br);
    this.q.read(br);
    this.g.read(br);
    return this;
  }

  clean() {
    return this.y.clean()
        && this.p.clean()
        && this.q.clean()
        && this.g.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'DSA PUBLIC KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'DSA PUBLIC KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      y: this.y,
      p: this.p,
      q: this.q,
      g: this.g
    };
  }
}

/**
 * DSAPrivateKey
 */

// DSSPrivatKey_OpenSSL ::= SEQUENCE {
//   version INTEGER,
//   p INTEGER,
//   q INTEGER,
//   g INTEGER,
//   y INTEGER,
//   x INTEGER
// }

class DSAPrivateKey extends asn1.Sequence {
  constructor(version, p, q, g, y, x) {
    super();
    this.version = new asn1.Unsigned(version);
    this.p = new asn1.Unsigned(p);
    this.q = new asn1.Unsigned(q);
    this.g = new asn1.Unsigned(g);
    this.y = new asn1.Unsigned(y);
    this.x = new asn1.Unsigned(x);
  }

  getBodySize() {
    let size = 0;
    size += this.version.getSize();
    size += this.p.getSize();
    size += this.q.getSize();
    size += this.g.getSize();
    size += this.y.getSize();
    size += this.x.getSize();
    return size;
  }

  writeBody(bw) {
    this.version.write(bw);
    this.p.write(bw);
    this.q.write(bw);
    this.g.write(bw);
    this.y.write(bw);
    this.x.write(bw);
    return bw;
  }

  readBody(br) {
    this.version.read(br);
    this.p.read(br);
    this.q.read(br);
    this.g.read(br);
    this.y.read(br);
    this.x.read(br);
    return this;
  }

  clean() {
    return this.p.clean()
        && this.q.clean()
        && this.g.clean()
        && this.y.clean()
        && this.x.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'DSA PRIVATE KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'DSA PRIVATE KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      p: this.p,
      q: this.q,
      g: this.g,
      y: this.y,
      x: this.x
    };
  }
}

/*
 * Expose
 */

exports.DSAParams = DSAParams;
exports.DSAPublicKey = DSAPublicKey;
exports.DSAPrivateKey = DSAPrivateKey;

},{"./asn1":46,"./pem":56}],56:[function(req,module,exports){
(function (Buffer){
/*!
 * pem.js - PEM for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail
 *   https://tools.ietf.org/html/rfc1421
 *   https://tools.ietf.org/html/rfc1422
 *   https://tools.ietf.org/html/rfc1423
 *   https://tools.ietf.org/html/rfc1424
 *   https://tools.ietf.org/html/rfc4880
 *   https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem
 *   https://github.com/crypto-browserify/EVP_BytesToKey/blob/master/index.js
 *   https://github.com/openssl/openssl/blob/master/include/openssl/pem.h
 *   https://github.com/openssl/openssl/blob/master/crypto/pem/pem_lib.c
 *   https://github.com/openssl/openssl/blob/master/crypto/evp/evp_key.c
 *   https://github.com/openssl/openssl/blob/master/crypto/pem/pem_pkey.c
 */

/* eslint spaced-comment: "off" */

'use strict';

const assert = req('bsert');
const base64 = req('./base64');
const lines = req('./lines');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);

/**
 * PEMBlock
 */

class PEMBlock {
  constructor(type, data) {
    if (type == null)
      type = 'PRIVACY-ENHANCED MESSAGE';

    if (data == null)
      data = EMPTY;

    assert(typeof type === 'string');
    assert(Buffer.isBuffer(data));

    this.type = type;
    this.headers = new Map();
    this.data = data;
  }

  toString(armor) {
    return encode(this.type, this.headers, this.data, armor);
  }

  fromString(str, armor) {
    const iter = decode(str, armor);
    const it = iter.next();

    if (it.done)
      throw new Error('No PEM data found.');

    const block = it.value;

    this.type = block.type;
    this.headers = block.headers;
    this.data = block.data;

    return this;
  }

  getProcType() {
    const hdr = this.headers.get('Proc-Type');

    if (!hdr)
      return null;

    return ProcType.fromString(hdr);
  }

  setProcType(version, state) {
    assert(version != null && state);
    const proc = new ProcType(version, state);
    this.headers.set('Proc-Type', proc.toString());
    return this;
  }

  unsetProcType() {
    this.headers.delete('Proc-Type');
    return this;
  }

  getDEKInfo() {
    const hdr = this.headers.get('DEK-Info');

    if (!hdr)
      return null;

    return DEKInfo.fromString(hdr);
  }

  setDEKInfo(name, iv) {
    assert(name);
    const info = new DEKInfo(name, iv);
    this.headers.set('DEK-Info', info.toString());
    return this;
  }

  unsetDEKInfo() {
    this.headers.delete('DEK-Info');
    return this;
  }

  isEncrypted() {
    let type;

    try {
      type = this.getProcType();
    } catch (e) {
      return false;
    }

    if (!type)
      return false;

    return type.version === 4
        && type.state === 'ENCRYPTED';
  }

  static fromString(str, armor) {
    return new this().fromString(str, armor);
  }
}

/**
 * ProcType
 */

class ProcType {
  constructor(version, state) {
    if (version == null)
      version = 0;

    if (state == null)
      state = 'NONE';

    assert((version >>> 0) === version);
    assert(typeof state === 'string');

    this.version = version;
    this.state = state.toUpperCase();
  }

  toString() {
    return `${this.version},${this.state}`;
  }

  fromString(str) {
    assert(typeof str === 'string');

    const parts = str.split(',', 3);

    if (parts.length !== 2)
      throw new Error('Invalid Proc-Type.');

    this.version = parseU32(parts[0]);
    this.state = parts[1].toUpperCase();

    return this;
  }

  static fromString(str) {
    return new this().fromString(str);
  }
}

/**
 * DEKInfo
 */

class DEKInfo {
  constructor(name, iv) {
    if (name == null)
      name = 'AES-128-ECB';

    if (iv == null)
      iv = EMPTY;

    assert(typeof name === 'string');
    assert(Buffer.isBuffer(iv));

    this.name = name.toUpperCase();
    this.iv = iv;
  }

  toString() {
    const name = this.name;

    if (this.iv.length === 0)
      return name;

    const iv = this.iv.toString('hex');

    return `${name},${iv.toUpperCase()}`;
  }

  fromString(str) {
    assert(typeof str === 'string');

    const parts = str.split(',', 3);

    if (parts.length < 1 || parts.length > 2)
      throw new Error('Invalid DEK-Info.');

    const name = parts[0];

    if (name.length === 0)
      throw new Error('Invalid DEK-Info name.');

    this.name = name.toUpperCase();
    this.iv = EMPTY;

    if (parts.length > 1) {
      const hex = parts[1];
      const iv = Buffer.from(hex, 'hex');

      if (iv.length !== (hex.length >>> 1))
        throw new Error('Invalid DEK-Info IV.');

      this.iv = iv;
    }

    return this;
  }

  static fromString(str) {
    return new this().fromString(str);
  }
}

/*
 * PEM
 */

function encode(type, headers, data, armor = false) {
  assert(typeof type === 'string');
  assert(headers instanceof Map);
  assert(Buffer.isBuffer(data));
  assert(typeof armor === 'boolean');

  let str = '';

  str += `-----BEGIN ${type}-----\n`;

  if (headers.size > 0) {
    for (const [key, value] of headers)
      str += `${key}: ${value}\n`;

    str += '\n';
  }

  const s = base64.encode(data);

  for (let i = 0; i < s.length; i += 64)
    str += s.substring(i, i + 64) + '\n';

  if (armor) {
    const crc = crc24(data);

    str += `=${base64.encode(crc)}\n`;
  }

  str += `-----END ${type}-----\n`;

  return str;
}

function *decode(str, armor = false) {
  assert(typeof str === 'string');
  assert(typeof armor === 'boolean');

  let chunk = '';
  let block = null;
  let crc = null;

  for (const [, line] of lines(str)) {
    const index = line.indexOf(':');

    if (index !== -1) {
      if (!block)
        throw new Error('PEM parse error (misplaced header).');

      const key = line.substring(0, index).trim();
      const value = line.substring(index + 1).trim();

      block.headers.set(key, value);

      continue;
    }

    if (line.length >= 15 && line.substring(0, 5) === '-----') {
      if (line.slice(-5) !== '-----')
        throw new Error('PEM parse error (invalid preamble).');

      const preamble = line.slice(5, -5);

      if (preamble.substring(0, 6) === 'BEGIN ') {
        if (block)
          throw new Error('PEM parse error (un-ended block).');

        const type = preamble.substring(6).trim();

        block = new PEMBlock();
        block.type = type;

        continue;
      }

      if (preamble.substring(0, 4) === 'END ') {
        if (!block)
          throw new Error('PEM parse error (unexpected end).');

        const type = preamble.substring(4).trim();

        if (block.type !== type)
          throw new Error('PEM parse error (type mismatch).');

        block.data = base64.decode(chunk);

        if (crc && !crc24(block.data).equals(crc))
          throw new Error('PEM parse error (invalid armor checksum).');

        yield block;

        chunk = '';
        block = null;
        crc = null;

        continue;
      }

      throw new Error('PEM parse error (unknown preamble).');
    }

    if (!block)
      throw new Error('PEM parse error (unexpected data).');

    if (line.length === 5 && line.charCodeAt(0) === 0x3d /*'='*/) {
      if (!armor)
        continue;

      if (crc)
        throw new Error('PEM parse error (unexpected armor checksum).');

      crc = base64.decode(line.substring(1));

      continue;
    }

    if (line.length > 96)
      throw new Error('PEM parse error (line too long).');

    chunk += line.replace(/[\t\v ]/g, '');
  }

  if (block || crc)
    throw new Error('PEM parse error (un-ended block).');

  if (chunk.length !== 0)
    throw new Error('PEM parse error (trailing data).');
}

function toPEM(data, type, armor) {
  assert(Buffer.isBuffer(data));
  assert(typeof type === 'string');

  const block = new PEMBlock();
  block.type = type;
  block.data = data;

  return block.toString(armor);
}

function fromPEM(str, type, armor) {
  assert(typeof str === 'string');
  assert(typeof type === 'string');

  const block = PEMBlock.fromString(str, armor);

  if (block.type !== type)
    throw new Error('PEM type mismatch.');

  return block.data;
}

/*
 * Helpers
 */

function crc24(data) {
  assert(Buffer.isBuffer(data));

  let crc = 0xb704ce;

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];

    crc ^= ch << 16;

    for (let j = 0; j < 8; j++) {
      crc <<= 1;

      if (crc & 0x1000000)
        crc ^= 0x1864cfb;
    }
  }

  crc &= 0xffffff;

  const buf = Buffer.allocUnsafe(3);

  buf[2] = crc;
  crc >>>= 8;
  buf[1] = crc;
  crc >>>= 8;
  buf[0] = crc;

  return buf;
}

function parseU32(str) {
  assert(typeof str === 'string');

  if (str.length < 1 || str.length > 10)
    throw new Error('Invalid integer.');

  let word = 0;

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch < 0x30 || ch > 0x39)
      throw new Error('Invalid integer.');

    word *= 10;
    word += ch - 0x30;

    if (i > 0 && word === 0)
      throw new Error('Invalid integer.');

    if (word > 0xffffffff)
      throw new Error('Invalid integer.');
  }

  return word;
}

/*
 * Expose
 */

exports.PEMBlock = PEMBlock;
exports.ProcType = ProcType;
exports.DEKInfo = DEKInfo;
exports.encode = encode;
exports.decode = decode;
exports.toPEM = toPEM;
exports.fromPEM = fromPEM;

}).call(this,req("buffer").Buffer)
},{"./base64":50,"./lines":54,"bsert":190,"buffer":303}],57:[function(req,module,exports){
/*!
 * pemcrypt.js - PEM encryption for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc1421
 */

'use strict';

const assert = req('bsert');
const {PEMBlock} = req('./pem');
const cipher = req('../cipher');
const random = req('../random');
const eb2k = req('../eb2k');

/**
 * Encrypt a block.
 * @param {PEMBlock} block
 * @param {String} name
 * @param {String} passwd
 * @returns {PEMBlock}
 */

function encrypt(block, name, passwd) {
  assert(block instanceof PEMBlock);
  assert(typeof name === 'string');
  assert(typeof passwd === 'string');

  if (block.isEncrypted())
    throw new Error('PEM block is already encrypted.');

  const {keySize, ivSize} = cipher.get(name);
  const iv = random.randomBytes(ivSize);
  const [key] = eb2k.derive(passwd, iv, keySize, ivSize);

  block.data = cipher.encrypt(name, key, iv, block.data);

  block.setProcType(4, 'ENCRYPTED');
  block.setDEKInfo(name, iv);

  return block;
}

/**
 * Decrypt a block.
 * @param {PEMBlock} block
 * @param {String} passwd
 * @returns {PEMBlock}
 */

function decrypt(block, passwd) {
  assert(block instanceof PEMBlock);
  assert(typeof passwd === 'string');

  if (!block.isEncrypted())
    throw new Error('PEM block is not encrypted.');

  const info = block.getDEKInfo();

  if (!info)
    throw new Error('DEK-Info not found.');

  const {keySize, ivSize} = cipher.get(info.name);
  const [key] = eb2k.derive(passwd, info.iv, keySize, ivSize);

  block.data = cipher.decrypt(info.name, key, info.iv, block.data);

  block.unsetProcType();
  block.unsetDEKInfo();

  return block;
}

/*
 * Expose
 */

exports.encrypt = encrypt;
exports.decrypt = decrypt;

},{"../cipher":34,"../eb2k":42,"../random":162,"./pem":56,"bsert":190}],58:[function(req,module,exports){
/*!
 * pkcs1.js - PKCS1 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PKCS_1
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017#appendix-A.1.1
 *   https://tools.ietf.org/html/rfc8017#appendix-A.1.2
 *   https://github.com/golang/go/blob/master/src/crypto/x509/pkcs1.go
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_asn1.c
 */

'use strict';

const asn1 = req('./asn1');
const pem = req('./pem');

/**
 * RSAPublicKey
 */

// RSAPublicKey ::= SEQUENCE {
//     modulus           INTEGER,  -- n
//     publicExponent    INTEGER   -- e
// }

class RSAPublicKey extends asn1.Sequence {
  constructor(n, e) {
    super();
    this.n = new asn1.Unsigned(n);
    this.e = new asn1.Unsigned(e);
  }

  getBodySize() {
    let size = 0;
    size += this.n.getSize();
    size += this.e.getSize();
    return size;
  }

  writeBody(bw) {
    this.n.write(bw);
    this.e.write(bw);
    return bw;
  }

  readBody(br) {
    this.n.read(br);
    this.e.read(br);
    return this;
  }

  clean() {
    return this.n.clean() && this.e.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'RSA PUBLIC KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'RSA PUBLIC KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      n: this.n,
      e: this.e
    };
  }
}

/**
 * RSAPrivateKey
 */

// RSAPrivateKey ::= SEQUENCE {
//   version           Version,
//   modulus           INTEGER,  -- n
//   publicExponent    INTEGER,  -- e
//   privateExponent   INTEGER,  -- d
//   prime1            INTEGER,  -- p
//   prime2            INTEGER,  -- q
//   exponent1         INTEGER,  -- d mod (p-1)
//   exponent2         INTEGER,  -- d mod (q-1)
//   coefficient       INTEGER,  -- (inverse of q) mod p
//   otherPrimeInfos   OtherPrimeInfos OPTIONAL
// }

class RSAPrivateKey extends asn1.Sequence {
  constructor(version, n, e, d, p, q, dp, dq, qi) {
    super();
    this.version = new asn1.Unsigned(version);
    this.n = new asn1.Unsigned(n);
    this.e = new asn1.Unsigned(e);
    this.d = new asn1.Unsigned(d);
    this.p = new asn1.Unsigned(p);
    this.q = new asn1.Unsigned(q);
    this.dp = new asn1.Unsigned(dp);
    this.dq = new asn1.Unsigned(dq);
    this.qi = new asn1.Unsigned(qi);
  }

  getBodySize() {
    let size = 0;
    size += this.version.getSize();
    size += this.n.getSize();
    size += this.e.getSize();
    size += this.d.getSize();
    size += this.p.getSize();
    size += this.q.getSize();
    size += this.dp.getSize();
    size += this.dq.getSize();
    size += this.qi.getSize();
    return size;
  }

  writeBody(bw) {
    this.version.write(bw);
    this.n.write(bw);
    this.e.write(bw);
    this.d.write(bw);
    this.p.write(bw);
    this.q.write(bw);
    this.dp.write(bw);
    this.dq.write(bw);
    this.qi.write(bw);
    return bw;
  }

  readBody(br) {
    this.version.read(br);
    this.n.read(br);
    this.e.read(br);
    this.d.read(br);
    this.p.read(br);
    this.q.read(br);
    this.dp.read(br);
    this.dq.read(br);
    this.qi.read(br);
    return this;
  }

  clean() {
    return this.n.clean()
        && this.e.clean()
        && this.d.clean()
        && this.p.clean()
        && this.q.clean()
        && this.dp.clean()
        && this.dq.clean()
        && this.qi.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'RSA PRIVATE KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'RSA PRIVATE KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      n: this.n,
      e: this.e,
      d: this.d,
      p: this.p,
      q: this.q,
      dp: this.dp,
      dq: this.dq,
      qi: this.qi
    };
  }
}

/*
 * Expose
 */

exports.RSAPublicKey = RSAPublicKey;
exports.RSAPrivateKey = RSAPrivateKey;

},{"./asn1":46,"./pem":56}],59:[function(req,module,exports){
(function (Buffer){
/*!
 * pkcs5.js - PKCS5 padding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PKCS
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc8018
 */

'use strict';

const assert = req('bsert');

/*
 * PKCS5
 */

const pkcs5 = {
  pad(pt, size) {
    assert(Buffer.isBuffer(pt));
    assert((size >>> 0) === size);
    assert(size > 0 && size < 256);

    const left = size - (pt.length % size);
    const out = Buffer.allocUnsafe(pt.length + left);
    pt.copy(out, 0);

    for (let i = pt.length; i < out.length; i++)
      out[i] = left;

    return out;
  },

  unpad(pt, size) {
    assert(Buffer.isBuffer(pt));
    assert((size >>> 0) === size);
    assert(size > 0 && size < 256);

    if (pt.length < size || (pt.length % size) !== 0)
      throw new Error('Invalid padding.');

    const left = pt[pt.length - 1];

    if (left === 0 || left > size)
      throw new Error('Invalid padding.');

    for (let i = pt.length - left; i < pt.length; i++) {
      if (pt[i] !== left)
        throw new Error('Invalid padding.');
    }

    return pt.slice(0, -left);
  }
};

/*
 * Expose
 */

module.exports = pkcs5;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],60:[function(req,module,exports){
/*!
 * pkcs8.js - PKCS8 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PKCS_8
 *   https://tools.ietf.org/html/rfc5208
 *   https://tools.ietf.org/html/rfc5958
 *   https://github.com/golang/go/blob/master/src/crypto/x509/pkcs8.go
 */

'use strict';

const asn1 = req('./asn1');
const pem = req('./pem');
const x509 = req('./x509');

/**
 * PublicKeyInfo
 */

// PublicKeyInfo ::= SEQUENCE {
//   algorithm       AlgorithmIdentifier,
//   PublicKey       BIT STRING
// }

class PublicKeyInfo extends asn1.Sequence {
  constructor(algorithm, identifier, publicKey) {
    super();
    this.algorithm = new x509.AlgorithmIdentifier(algorithm, identifier);
    this.publicKey = new asn1.BitString(publicKey);
  }

  getBodySize() {
    let size = 0;
    size += this.algorithm.getSize();
    size += this.publicKey.getSize();
    return size;
  }

  writeBody(bw) {
    this.algorithm.write(bw);
    this.publicKey.write(bw);
    return bw;
  }

  readBody(br) {
    this.algorithm.read(br);
    this.publicKey.read(br);
    return this;
  }

  clean() {
    return this.algorithm.clean()
        && this.publicKey.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'PUBLIC KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'PUBLIC KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      publicKey: this.publicKey
    };
  }
}

/**
 * PrivateKeyInfo
 */

// PrivateKeyInfo ::= SEQUENCE {
//   version         Version,
//   algorithm       AlgorithmIdentifier,
//   PrivateKey      OCTET STRING
// }
//
// PrivateKeyInfo ::= SEQUENCE {
//    version Version,
//    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
//    privateKey PrivateKey,
//    attributes [0] Attributes OPTIONAL
// }
//
// Version ::= INTEGER {v1(0)} (v1,...)
//
// PrivateKey ::= OCTET STRING

class PrivateKeyInfo extends asn1.Sequence {
  constructor(version, algorithm, parameters, privateKey) {
    super();
    this.version = new asn1.Unsigned(version);
    this.algorithm = new x509.AlgorithmIdentifier(algorithm, parameters);
    this.privateKey = new asn1.OctString(privateKey);
  }

  get isRaw() {
    return true;
  }

  getBodySize() {
    let size = 0;
    size += this.version.getSize();
    size += this.algorithm.getSize();
    size += this.privateKey.getSize();
    return size;
  }

  writeBody(bw) {
    this.version.write(bw);
    this.algorithm.write(bw);
    this.privateKey.write(bw);
    return bw;
  }

  readBody(br) {
    this.version.read(br);
    this.algorithm.read(br);
    this.privateKey.read(br);
    return this;
  }

  clean() {
    return this.version.clean()
        && this.algorithm.clean()
        && this.privateKey.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'PRIVATE KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'PRIVATE KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      algorithm: this.algorithm,
      privateKey: this.privateKey
    };
  }
}

/**
 * EncryptedPrivateKeyInfo
 */

// EncryptedPrivateKeyInfo ::= SEQUENCE {
//   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
//   encryptedData        EncryptedData
// }
//
// EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
//
// EncryptedData ::= OCTET STRING

class EncryptedPrivateKeyInfo extends asn1.Sequence {
  constructor(algorithm, identifier, data) {
    super();
    this.algorithm =
      new x509.AlgorithmIdentifier(algorithm, identifier);
    this.data = new asn1.OctString(data);
  }

  getBodySize() {
    let size = 0;
    size += this.algorithm.getSize();
    size += this.data.getSize();
    return size;
  }

  writeBody(bw) {
    this.algorithm.write(bw);
    this.data.write(bw);
    return bw;
  }

  readBody(br) {
    this.algorithm.read(br);
    this.data.read(br);
    return this;
  }

  clean() {
    return this.algorithm.clean()
        && this.data.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'ENCRYPTED PRIVATE KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'ENCRYPTED PRIVATE KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      data: this.data
    };
  }
}

/*
 * Expose
 */

exports.PublicKeyInfo = PublicKeyInfo;
exports.PrivateKeyInfo = PrivateKeyInfo;
exports.EncryptedPrivateKeyInfo = EncryptedPrivateKeyInfo;

},{"./asn1":46,"./pem":56,"./x509":64}],61:[function(req,module,exports){
/*!
 * rfc3279.js - rfc3279 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc3279
 *   https://tools.ietf.org/html/rfc5912
 */

'use strict';

const asn1 = req('./asn1');
const pem = req('./pem');

/**
 * DSA Parms
 */

// Dss-Parms  ::=  SEQUENCE  {
//     p             INTEGER,
//     q             INTEGER,
//     g             INTEGER  }

class DSAParams extends asn1.Sequence {
  constructor(p, q, g) {
    super();
    this.p = new asn1.Unsigned(p);
    this.q = new asn1.Unsigned(q);
    this.g = new asn1.Unsigned(g);
  }

  getBodySize() {
    let size = 0;
    size += this.p.getSize();
    size += this.q.getSize();
    size += this.g.getSize();
    return size;
  }

  writeBody(bw) {
    this.p.write(bw);
    this.q.write(bw);
    this.g.write(bw);
    return bw;
  }

  readBody(br) {
    this.p.read(br);
    this.q.read(br);
    this.g.read(br);
    return this;
  }

  clean() {
    return this.p.clean() && this.q.clean() && this.g.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'DSA PARAMETERS');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'DSA PARAMETERS');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      p: this.p,
      q: this.q,
      g: this.g
    };
  }
}

/**
 * DSA Public Key
 */

// DSAPublicKey ::= INTEGER -- public key, Y

class DSAPublicKey extends asn1.Unsigned {
  constructor(y) {
    super(y);
  }

  get y() {
    return this.value;
  }

  set y(value) {
    this.value = value;
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'DSA PUBLIC KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'DSA PUBLIC KEY');
    return this.decode(data);
  }
}

/**
 * DSA Signature
 */

class DSASignature extends asn1.Sequence {
  constructor(r, s) {
    super();
    this.r = new asn1.Unsigned(r);
    this.s = new asn1.Unsigned(s);
  }

  getBodySize() {
    let size = 0;
    size += this.r.getSize();
    size += this.s.getSize();
    return size;
  }

  writeBody(bw) {
    this.r.write(bw);
    this.s.write(bw);
    return bw;
  }

  readBody(br) {
    this.r.read(br);
    this.s.read(br);
    return this;
  }

  clean() {
    return this.r.clean() && this.s.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'DSA SIGNATURE');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'DSA SIGNATURE');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      r: this.r,
      s: this.s
    };
  }
}

/*
 * Expose
 */

exports.DSAParams = DSAParams;
exports.DSAPublicKey = DSAPublicKey;
exports.DSASignature = DSASignature;

},{"./asn1":46,"./pem":56}],62:[function(req,module,exports){
/*!
 * sec1.js - SEC1 encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   http://www.secg.org/sec1-v2.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/ec/ec_asn1.c
 *   https://github.com/golang/go/blob/master/src/crypto/x509/sec1.go
 */

'use strict';

const asn1 = req('./asn1');
const pem = req('./pem');

/**
 * ECPrivateKey
 */

// ECPrivateKey ::= SEQUENCE {
//   version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
//   privateKey OCTET STRING,
//   parameters [0] ECDomainParameters {{ SECGCurveNames }} OPTIONAL,
//   publicKey [1] BIT STRING OPTIONAL
// }

// ECDomainParameters{ECDOMAIN:IOSet} ::= CHOICE {
//   specified SpecifiedECDomain,
//   named ECDOMAIN.&id({IOSet}),
//   implicitCA NULL
// }

// ECDOMAIN ::= CLASS {
//   &id OBJECT IDENTIFIER UNIQUE
// }

// Golang seems to be using this instead:
// ECPrivateKey ::= SEQUENCE {
//   version       INTEGER { ecPrivkeyVer1(1) },
//   privateKey    OCTET STRING,
//   parameters    [0] EXPLICIT ECDomainParameters OPTIONAL,
//   publicKey     [1] EXPLICIT BIT STRING OPTIONAL
// }

class ECPrivateKey extends asn1.Sequence {
  constructor(version, privateKey, namedCurveOID, publicKey) {
    super();
    this.version = new asn1.Unsigned(version);
    this.privateKey = new asn1.OctString(privateKey);
    this.namedCurveOID = new asn1.OID(namedCurveOID).explicit(0).optional();
    this.publicKey = new asn1.BitString(publicKey).explicit(1).optional();
  }

  getBodySize() {
    let size = 0;
    size += this.version.getSize();
    size += this.privateKey.getSize();
    size += this.namedCurveOID.getSize();
    size += this.publicKey.getSize();
    return size;
  }

  writeBody(bw) {
    this.version.write(bw);
    this.privateKey.write(bw);
    this.namedCurveOID.write(bw);
    this.publicKey.write(bw);
    return bw;
  }

  readBody(br) {
    this.version.read(br);
    this.privateKey.read(br);
    this.namedCurveOID.read(br);
    this.publicKey.read(br);
    return this;
  }

  clean() {
    return this.version.clean()
        && this.privateKey.clean()
        && this.namedCurveOID.clean()
        && this.publicKey.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'EC PRIVATE KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'EC PRIVATE KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      privateKey: this.privateKey,
      namedCurveOID: this.namedCurveOID,
      publicKey: this.publicKey
    };
  }
}

/**
 * ECDSA Signature
 */

// ECDSA-Signature ::= CHOICE {
//   two-ints-plus ECDSA-Sig-Value,
//   point-int [0] ECDSA-Full-R,
//   ... -- Future representations may be added
// }

// ECDSA-Full-R ::= SEQUENCE {
//   r ECPoint,
//   s INTEGER
// }

// ECPoint ::= OCTET STRING

// ECDSA-Sig-Value ::= SEQUENCE {
//   r INTEGER,
//   s INTEGER,
//   a INTEGER OPTIONAL,
//   y CHOICE { b BOOLEAN, f FieldElement } OPTIONAL
// }

class ECDSASignature extends asn1.Sequence {
  constructor(r, s) {
    super();
    this.r = new asn1.Unsigned(r);
    this.s = new asn1.Unsigned(s);
  }

  getBodySize() {
    let size = 0;
    size += this.r.getSize();
    size += this.s.getSize();
    return size;
  }

  writeBody(bw) {
    this.r.write(bw);
    this.s.write(bw);
    return bw;
  }

  readBody(br) {
    this.r.read(br);
    this.s.read(br);
    return this;
  }

  clean() {
    return this.r.clean() && this.s.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'EC SIGNATURE');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'EC SIGNATURE');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      r: this.r,
      s: this.s
    };
  }
}

/*
 * Expose
 */

exports.ECPrivateKey = ECPrivateKey;
exports.ECDSASignature = ECDSASignature;

},{"./asn1":46,"./pem":56}],63:[function(req,module,exports){
(function (Buffer){
/*!
 * util.js - encoding utils for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const ZERO = Buffer.alloc(1, 0x00);
const cache = [];

/*
 * Util
 */

function countLeft(data) {
  assert(Buffer.isBuffer(data));

  let i = 0;

  for (; i < data.length; i++) {
    if (data[i] !== 0x00)
      break;
  }

  let bits = (data.length - i) * 8;

  if (bits === 0)
    return 0;

  bits -= 8;

  let oct = data[i];

  while (oct) {
    bits += 1;
    oct >>>= 1;
  }

  return bits;
}

function countRight(data) {
  assert(Buffer.isBuffer(data));

  let i = data.length - 1;

  for (; i >= 0; i--) {
    if (data[i] !== 0x00)
      break;
  }

  let bits = (i + 1) * 8;

  if (bits === 0)
    return 0;

  bits -= 8;

  let oct = data[i];

  while (oct) {
    bits += 1;
    oct >>>= 1;
  }

  return bits;
}

function compareLeft(x, y) {
  assert(Buffer.isBuffer(x));
  assert(Buffer.isBuffer(y));

  let xp = 0;
  let xl = x.length;
  let yp = 0;
  let yl = y.length;

  while (xl > 0 && x[xp] === 0)
    xp++, xl--;

  while (yl > 0 && y[yp] === 0)
    yp++, yl--;

  if (xl < yl)
    return -1;

  if (xl > yl)
    return 1;

  for (let i = 0; i < xl; i++) {
    if (x[xp + i] < y[yp + i])
      return -1;

    if (x[xp + i] > y[yp + i])
      return 1;
  }

  return 0;
}

function compareRight(x, y) {
  assert(Buffer.isBuffer(x));
  assert(Buffer.isBuffer(y));

  let xl = x.length;
  let yl = y.length;

  while (xl > 0 && x[xl - 1] === 0)
    xl--;

  while (yl > 0 && y[yl - 1] === 0)
    yl--;

  if (xl < yl)
    return -1;

  if (xl > yl)
    return 1;

  for (let i = xl - 1; i >= 0; i--) {
    if (x[i] < y[i])
      return -1;

    if (x[i] > y[i])
      return 1;
  }

  return 0;
}

function trimLeft(data) {
  if (data == null)
    return ZERO;

  assert(Buffer.isBuffer(data));

  let i = 0;

  for (; i < data.length; i++) {
    if (data[i] !== 0x00)
      break;
  }

  if (i !== 0)
    data = data.slice(i);

  if (data.length === 0)
    return ZERO;

  return data;
}

function trimRight(data) {
  if (data == null)
    return ZERO;

  assert(Buffer.isBuffer(data));

  let i = data.length - 1;

  for (; i >= 0; i--) {
    if (data[i] !== 0x00)
      break;
  }

  if (i + 1 !== data.length)
    data = data.slice(0, i + 1);

  if (data.length === 0)
    return ZERO;

  return data;
}

function padLeft(data, size) {
  if (data == null)
    return getZero(size);

  assert(Buffer.isBuffer(data));
  assert((size >>> 0) === size);

  if (data.length > size)
    data = trimLeft(data);

  if (data.length > size)
    throw new RangeError(`Buffer expected to be ${size} bytes in size.`);

  if (data.length === size)
    return data;

  const out = Buffer.allocUnsafe(size);
  const pos = size - data.length;

  out.fill(0x00, 0, pos);
  data.copy(out, pos);

  return out;
}

function padRight(data, size) {
  if (data == null)
    return getZero(size);

  assert(Buffer.isBuffer(data));
  assert((size >>> 0) === size);

  if (data.length > size)
    data = trimRight(data);

  if (data.length > size)
    throw new RangeError(`Buffer expected to be ${size} bytes in size.`);

  if (data.length === size)
    return data;

  const out = Buffer.allocUnsafe(size);

  data.copy(out, 0);
  out.fill(0x00, data.length, size);

  return out;
}

/*
 * Helpers
 */

function getZero(size) {
  assert((size >>> 0) === size);
  assert(size <= 128);

  while (cache.length <= size)
    cache.push(null);

  let zero = cache[size];

  if (!zero) {
    zero = Buffer.alloc(size, 0x00);
    cache[size] = zero;
  }

  return zero;
}

/*
 * Expose
 */

exports.countLeft = countLeft;
exports.countRight = countRight;
exports.compareLeft = compareLeft;
exports.compareRight = compareRight;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.padLeft = padLeft;
exports.padRight = padRight;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],64:[function(req,module,exports){
/*!
 * x509.js - X509 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/asn1.js:
 *   Copyright Fedor Indutny, 2013.
 *   https://github.com/indutny/asn1.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/X.509
 *   https://tools.ietf.org/html/rfc4158
 *   https://www.ietf.org/rfc/rfc2560.txt
 *   https://www.ietf.org/rfc/rfc5280.txt
 *   https://github.com/indutny/asn1.js/blob/master/rfc/2560/index.js
 *   https://github.com/indutny/asn1.js/blob/master/rfc/5280/index.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/base/node.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/encoders/der.js
 *   https://github.com/indutny/asn1.js/blob/master/lib/asn1/decoders/der.js
 */

'use strict';

const assert = req('bsert');
const asn1 = req('./asn1');
const pem = req('./pem');
const {types} = asn1;

/**
 * Certificate
 */

// Certificate  ::=  SEQUENCE  {
//      tbsCertificate       TBSCertificate,
//      signatureAlgorithm   AlgorithmIdentifier,
//      signature            BIT STRING  }

class Certificate extends asn1.Sequence {
  constructor() {
    super();
    this.tbsCertificate = new TBSCertificate();
    this.signatureAlgorithm = new AlgorithmIdentifier();
    this.signature = new asn1.BitString();
  }

  get isRaw() {
    return true;
  }

  getBodySize() {
    let size = 0;
    size += this.tbsCertificate.getSize();
    size += this.signatureAlgorithm.getSize();
    size += this.signature.getSize();
    return size;
  }

  writeBody(bw) {
    this.tbsCertificate.write(bw);
    this.signatureAlgorithm.write(bw);
    this.signature.write(bw);
    return bw;
  }

  readBody(br) {
    this.tbsCertificate.read(br);
    this.signatureAlgorithm.read(br);
    this.signature.read(br);
    return this;
  }

  clean() {
    return this.tbsCertificate.clean()
        && this.signatureAlgorithm.clean()
        && this.signature.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'CERTIFICATE');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'CERTIFICATE');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      tbsCertificate: this.tbsCertificate,
      signatureAlgorithm: this.signatureAlgorithm,
      signature: this.signature
    };
  }
}

/**
 * TBSCertificate
 */

// TBSCertificate  ::=  SEQUENCE  {
//      version         [0]  Version DEFAULT v1,
//      serialNumber         CertificateSerialNumber,
//      signature            AlgorithmIdentifier,
//      issuer               Name,
//      validity             Validity,
//      subject              Name,
//      subjectPublicKeyInfo SubjectPublicKeyInfo,
//      issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
//      subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
//      extensions      [3]  Extensions OPTIONAL }
//
// Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }

class TBSCertificate extends asn1.Sequence {
  constructor() {
    super();
    this.version = new asn1.Unsigned().explicit(0).optional();
    this.serialNumber = new asn1.Integer();
    this.signature = new AlgorithmIdentifier();
    this.issuer = new RDNSequence();
    this.validity = new Validity();
    this.subject = new RDNSequence();
    this.subjectPublicKeyInfo = new SubjectPublicKeyInfo();
    this.issuerUniqueID = new asn1.BitString().implicit(1).optional();
    this.subjectUniqueID = new asn1.BitString().implicit(2).optional();
    this.extensions = new Extensions().explicit(3).optional();
  }

  get isRaw() {
    return true;
  }

  getBodySize() {
    let size = 0;
    size += this.version.getSize();
    size += this.serialNumber.getSize();
    size += this.signature.getSize();
    size += this.issuer.getSize();
    size += this.validity.getSize();
    size += this.subject.getSize();
    size += this.subjectPublicKeyInfo.getSize();
    size += this.issuerUniqueID.getSize();
    size += this.subjectUniqueID.getSize();
    size += this.extensions.getSize();
    return size;
  }

  writeBody(bw) {
    this.version.write(bw);
    this.serialNumber.write(bw);
    this.signature.write(bw);
    this.issuer.write(bw);
    this.validity.write(bw);
    this.subject.write(bw);
    this.subjectPublicKeyInfo.write(bw);
    this.issuerUniqueID.write(bw);
    this.subjectUniqueID.write(bw);
    this.extensions.write(bw);
    return bw;
  }

  readBody(br) {
    this.version.read(br);
    this.serialNumber.read(br);
    this.signature.read(br);
    this.issuer.read(br);
    this.validity.read(br);
    this.subject.read(br);
    this.subjectPublicKeyInfo.read(br);
    this.issuerUniqueID.read(br);
    this.subjectUniqueID.read(br);
    this.extensions.read(br);
    return this;
  }

  clean() {
    return this.version.clean()
        && this.serialNumber.clean()
        && this.signature.clean()
        && this.issuer.clean()
        && this.validity.clean()
        && this.subject.clean()
        && this.subjectPublicKeyInfo.clean()
        && this.issuerUniqueID.clean()
        && this.subjectUniqueID.clean()
        && this.extensions.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'TBS CERTIFICATE');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'TBS CERTIFICATE');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      version: this.version,
      serialNumber: this.serialNumber,
      signature: this.signature,
      issuer: this.issuer,
      validity: this.validity,
      subject: this.subject,
      subjectPublicKeyInfo: this.subjectPublicKeyInfo,
      issuerUniqueID: this.issuerUniqueID,
      subjectUniqueID: this.subjectUniqueID,
      extensions: this.extensions
    };
  }
}

/**
 * AlgorithmIdentifier
 */

// AlgorithmIdentifier  ::=  SEQUENCE  {
//      algorithm               OBJECT IDENTIFIER,
//      parameters              ANY DEFINED BY algorithm OPTIONAL  }

class AlgorithmIdentifier extends asn1.Sequence {
  constructor(algorithm, parameters) {
    super();

    this.algorithm = new asn1.OID(algorithm);
    this.parameters = new asn1.Any(parameters).optional();
  }

  getBodySize() {
    let size = 0;
    size += this.algorithm.getSize();
    size += this.parameters.getSize();
    return size;
  }

  writeBody(bw) {
    this.algorithm.write(bw);
    this.parameters.write(bw);
    return bw;
  }

  readBody(br) {
    this.algorithm.read(br);
    this.parameters.read(br);
    return this;
  }

  clean() {
    return this.algorithm.clean()
        && this.parameters.clean();
  }

  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      parameters: this.parameters
    };
  }
}

/**
 * RDNSequence
 */

// Name ::= CHOICE { -- only one possibility for now --
//      rdnSequence  RDNSequence }
//
// RDNSequence ::= SEQUENCE OF RelativeDistinguishedName

class RDNSequence extends asn1.Sequence {
  constructor() {
    super();
    this.names = [];
  }

  getBodySize() {
    let size = 0;

    for (const rdn of this.names)
      size += rdn.getSize();

    return size;
  }

  writeBody(bw) {
    for (const rdn of this.names)
      rdn.write(bw);
    return bw;
  }

  readBody(br) {
    while (br.left()) {
      const rdn = RDN.read(br);
      this.names.push(rdn);
    }

    return this;
  }

  clean() {
    return this.names.length === 0;
  }

  format() {
    return {
      type: this.constructor.name,
      names: this.names
    };
  }
}

/**
 * RDN
 */

// RelativeDistinguishedName ::=
//      SET SIZE (1..MAX) OF AttributeTypeAndValue
//

class RDN extends asn1.Set {
  constructor(id, value) {
    super();
    this.attributes = [new Attribute(id, value)];
  }

  getBodySize() {
    let size = 0;

    assert(this.attributes.length >= 1);

    for (const attr of this.attributes)
      size += attr.getSize();

    return size;
  }

  writeBody(bw) {
    assert(this.attributes.length >= 1);

    for (const attr of this.attributes)
      attr.write(bw);

    return bw;
  }

  readBody(br) {
    this.attributes[0].read(br);

    while (br.left()) {
      const attr = Attribute.read(br);
      this.attributes.push(attr);
    }

    return this;
  }

  clean() {
    return this.attributes.length === 1 && this.attributes[0].clean();
  }

  format() {
    return {
      type: this.constructor.name,
      attributes: this.attributes
    };
  }
}

/**
 * Attribute
 */

// AttributeTypeAndValue ::= SEQUENCE {
//      type     AttributeType,
//      value    AttributeValue }
//
// AttributeType ::= OBJECT IDENTIFIER
//
// AttributeValue ::= ANY -- DEFINED BY AttributeType

class Attribute extends asn1.Sequence {
  constructor(id, value) {
    super();

    this.id = new asn1.OID(id);
    this.value = new asn1.Any(value);
  }

  getBodySize() {
    let size = 0;
    size += this.id.getSize();
    size += this.value.getSize();
    return size;
  }

  writeBody(bw) {
    this.id.write(bw);
    this.value.write(bw);
    return bw;
  }

  readBody(br) {
    this.id.read(br);
    this.value.read(br);
    return this;
  }

  clean() {
    return this.id.clean()
        && this.value.clean();
  }

  format() {
    return {
      type: this.constructor.name,
      id: this.id,
      value: this.value
    };
  }
}

/**
 * Validity
 */

// Validity ::= SEQUENCE {
//      notBefore      Time,
//      notAfter       Time  }

class Validity extends asn1.Sequence {
  constructor() {
    super();
    this.notBefore = new Time();
    this.notAfter = new Time();
  }

  getBodySize() {
    let size = 0;
    size += this.notBefore.getSize();
    size += this.notAfter.getSize();
    return size;
  }

  writeBody(bw) {
    this.notBefore.write(bw);
    this.notAfter.write(bw);
    return bw;
  }

  readBody(br) {
    this.notBefore.read(br);
    this.notAfter.read(br);
    return this;
  }

  clean() {
    return this.notBefore.clean()
        && this.notAfter.clean();
  }

  format() {
    return {
      type: this.constructor.name,
      notBefore: this.notBefore,
      notAfter: this.notAfter
    };
  }
}

/**
 * Time
 */

// Time ::= CHOICE {
//      utcTime        UTCTime,
//      generalTime    GeneralizedTime }

class Time extends asn1.Choice {
  constructor(options) {
    super(new asn1.UTCTime(), options);
  }

  choices() {
    return [
      types.UTCTIME,
      types.GENTIME
    ];
  }
}

// SubjectPublicKeyInfo  ::=  SEQUENCE  {
//      algorithm            AlgorithmIdentifier,
//      subjectPublicKey     BIT STRING  }

class SubjectPublicKeyInfo extends asn1.Sequence {
  constructor(algorithm, parameters, publicKey) {
    super();
    this.algorithm = new AlgorithmIdentifier(algorithm, parameters);
    this.publicKey = new asn1.BitString(publicKey);
  }

  get isRaw() {
    return true;
  }

  getBodySize() {
    let size = 0;
    size += this.algorithm.getSize();
    size += this.publicKey.getSize();
    return size;
  }

  writeBody(bw) {
    this.algorithm.write(bw);
    this.publicKey.write(bw);
    return bw;
  }

  readBody(br) {
    this.algorithm.read(br);
    this.publicKey.read(br);
    return this;
  }

  clean() {
    return this.algorithm.clean()
        && this.publicKey.clean();
  }

  toPEM() {
    return pem.toPEM(this.encode(), 'PUBLIC KEY');
  }

  fromPEM(str) {
    const data = pem.fromPEM(str, 'PUBLIC KEY');
    return this.decode(data);
  }

  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      publicKey: this.publicKey
    };
  }
}

/**
 * Extensions
 */

class Extensions extends asn1.Sequence {
  constructor() {
    super();
    this.extensions = [];
  }

  getBodySize() {
    let size = 0;

    for (const ext of this.extensions)
      size += ext.getSize();

    return size;
  }

  writeBody(bw) {
    for (const ext of this.extensions)
      ext.write(bw);
    return bw;
  }

  readBody(br) {
    for (const ext of this.extensions)
      ext.read(br);
    return this;
  }

  clean() {
    return this.extensions.length === 0;
  }

  format() {
    return {
      type: this.constructor.name,
      extensions: this.extensions
    };
  }
}

/**
 * Extension
 */

// Extension  ::=  SEQUENCE  {
//      extnID      OBJECT IDENTIFIER,
//      critical    BOOLEAN DEFAULT FALSE,
//      extnValue   OCTET STRING }

class Extension extends asn1.Sequence {
  constructor() {
    super();
    this.extnID = new asn1.OID();
    this.critical = new asn1.Bool().optional();
    this.extnValue = new asn1.OctString();
  }

  getBodySize() {
    let size = 0;
    size += this.extnID.getSize();
    size += this.critical.getSize();
    size += this.extnValue.getSize();
    return size;
  }

  writeBody(bw) {
    this.extnID.write(bw);
    this.critical.write(bw);
    this.extnValue.write(bw);
    return bw;
  }

  readBody(br) {
    this.extnID.read(br);
    this.critical.read(br);
    this.extnValue.read(br);
    return this;
  }

  clean() {
    return this.extnID.clean()
        && this.critical.clean()
        && this.extnValue.clean();
  }

  format() {
    return {
      type: this.constructor.name,
      extnID: this.extnID,
      critical: this.critical,
      extnValue: this.extnValue
    };
  }
}

/**
 * DigestInfo
 */

// See: https://www.ietf.org/rfc/rfc3447.txt
// Section 9.2
//
// DigestInfo ::= SEQUENCE {
//   digestAlgorithm AlgorithmIdentifier,
//   digest OCTET STRING
// }

class DigestInfo extends asn1.Sequence {
  constructor(algorithm, digest) {
    super();
    this.algorithm = new AlgorithmIdentifier(algorithm);
    this.algorithm.parameters.optional(false);
    this.digest = new asn1.OctString(digest);
  }

  getBodySize() {
    let size = 0;
    size += this.algorithm.getSize();
    size += this.digest.getSize();
    return size;
  }

  writeBody(bw) {
    this.algorithm.write(bw);
    this.digest.write(bw);
    return bw;
  }

  readBody(br) {
    this.algorithm.read(br);
    this.digest.read(br);
    return this;
  }

  clean() {
    return this.algorithm.clean()
        && this.digest.clean();
  }

  format() {
    return {
      type: this.constructor.name,
      algorithm: this.algorithm,
      digest: this.digest
    };
  }
}

/*
 * Expose
 */

exports.Certificate = Certificate;
exports.TBSCertificate = TBSCertificate;
exports.AlgorithmIdentifier = AlgorithmIdentifier;
exports.RDNSequence = RDNSequence;
exports.RDN = RDN;
exports.Attribute = Attribute;
exports.Validity = Validity;
exports.Time = Time;
exports.SubjectPublicKeyInfo = SubjectPublicKeyInfo;
exports.Extensions = Extensions;
exports.Extension = Extension;
exports.DigestInfo = DigestInfo;

},{"./asn1":46,"./pem":56,"bsert":190}],65:[function(req,module,exports){
(function (Buffer){
/*!
 * gost94.js - GOST94 implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/GOST_(hash_function)
 *   https://tools.ietf.org/html/rfc4357
 *   https://tools.ietf.org/html/rfc5831
 *   https://github.com/RustCrypto/hashes/blob/master/gost94/src/gost94.rs
 */

'use strict';

const assert = req('bsert');
const HMAC = req('./internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const PADDING = Buffer.alloc(32, 0x00);
const DESC = Buffer.alloc(32, 0x00);

const C = Buffer.from([
  0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
  0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
  0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff,
  0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff
]);

const S_CRYPTOPRO = [
  Buffer.from([10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15]),
  Buffer.from([5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8]),
  Buffer.from([7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13]),
  Buffer.from([4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3]),
  Buffer.from([7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5]),
  Buffer.from([7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3]),
  Buffer.from([13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11]),
  Buffer.from([1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12])
];

const S_TEST = [
  Buffer.from([4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3]),
  Buffer.from([14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9]),
  Buffer.from([5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11]),
  Buffer.from([7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3]),
  Buffer.from([6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2]),
  Buffer.from([4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14]),
  Buffer.from([13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12]),
  Buffer.from([1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12])
];

const S_S2015 = [
  Buffer.from([12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1]),
  Buffer.from([6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 11, 13, 0, 15]),
  Buffer.from([11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0]),
  Buffer.from([12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11]),
  Buffer.from([7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12]),
  Buffer.from([5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0]),
  Buffer.from([8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7]),
  Buffer.from([1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2])
];

/**
 * GOST94
 */

class GOST94 {
  constructor() {
    this.S = S_CRYPTOPRO;
    this.state = Buffer.allocUnsafe(32);
    this.sigma = Buffer.allocUnsafe(32);
    this.block = Buffer.allocUnsafe(32);
    this.size = FINALIZED;
  }

  init(box) {
    if (box == null)
      box = S_CRYPTOPRO;

    assert(Array.isArray(box) && box.length === 8);

    this.S = box;
    this.state.fill(0x00);
    this.sigma.fill(0x00);
    this.size = 0;

    return this;
  }

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  final() {
    return this._final(Buffer.allocUnsafe(32));
  }

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 31;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 32 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 32)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 32) {
      this.transform(data, off);
      off += 32;
      len -= 32;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const bits = this.size * 8;
    const pos = this.size & 31;

    if (pos !== 0)
      this._update(PADDING, 32 - pos);

    const hi = (bits * (1 / 0x100000000)) >>> 0;
    const lo = bits >>> 0;

    writeU32(DESC, lo, 0);
    writeU32(DESC, hi, 4);

    this.F(DESC);
    this.F(this.sigma);

    this.state.copy(out, 0);

    this.state.fill(0x00);
    this.sigma.fill(0x00);
    this.block.fill(0x00);
    DESC.fill(0x00, 0, 8);

    this.size = FINALIZED;

    return out;
  }

  transform(chunk, pos) {
    const m = chunk.slice(pos, pos + 32);

    this.F(m);
    this.sum(m);
  }

  shuffle(m, s) {
    const res = Buffer.allocUnsafe(32);
    s.copy(res, 0);

    for (let i = 0; i < 12; i++)
      psi(res);

    XM(res, m);
    psi(res);
    XM(this.state, res);

    for (let i = 0; i < 61; i++)
      psi(this.state);
  }

  F(m) {
    const s = Buffer.allocUnsafe(32);

    this.state.copy(s, 0);

    let k, u, v;

    k = P(X(this.state, m));
    encrypt(s, 0, k, this.S);

    u = A(this.state);
    v = A(A(m));
    k = P(X(u, v));
    encrypt(s, 8, k, this.S);

    u = A(u);
    XM(u, C);
    v = A(A(v));
    k = P(X(u, v));
    encrypt(s, 16, k, this.S);

    u = A(u);
    v = A(A(v));
    k = P(X(u, v));
    encrypt(s, 24, k, this.S);

    this.shuffle(m, s);
  }

  sum(m) {
    let c = 0;

    for (let i = 0; i < 32; i++) {
      c += this.sigma[i] + m[i];
      this.sigma[i] = c;
      c >>>= 8;
    }
  }

  static hash() {
    return new GOST94();
  }

  static hmac(box) {
    return new HMAC(GOST94, 32, [box]);
  }

  static digest(data, box) {
    return GOST94.ctx.init(box).update(data).final();
  }

  static root(left, right, box) {
    assert(Buffer.isBuffer(left) && left.length === 32);
    assert(Buffer.isBuffer(right) && right.length === 32);
    return GOST94.ctx.init(box).update(left).update(right).final();
  }

  static multi(x, y, z, box) {
    const ctx = GOST94.ctx;
    ctx.init(box);
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key, box) {
    return GOST94.hmac(box).init(key).update(data).final();
  }
}

/*
 * Static
 */

GOST94.native = 0;
GOST94.id = 'GOST94';
GOST94.size = 32;
GOST94.bits = 256;
GOST94.blockSize = 32;
GOST94.zero = Buffer.alloc(32, 0x00);
GOST94.ctx = new GOST94();

GOST94.CRYPTOPRO = S_CRYPTOPRO;
GOST94.TEST = S_TEST;
GOST94.S2015 = S_S2015;

/*
 * Helpers
 */

function sbox(a, S) {
  let v = 0;

  for (let i = 0; i < 8; i++) {
    const shft = 4 * i;
    const k = (a & (15 << shft)) >>> shft;
    v += S[i][k] << shft;
  }

  return v >>> 0;
}

function G(a, k, S) {
  return rotl32(sbox((a + k) >>> 0, S), 11);
}

function encrypt(msg, pos, key, sbox) {
  const k = new Uint32Array(8);

  let a = readU32(msg, pos + 0);
  let b = readU32(msg, pos + 4);

  for (let i = 0; i < 8; i++)
    k[i] = readU32(key, i * 4);

  for (let x = 0; x < 3; x++) {
    for (let i = 0; i < 8; i++) {
      const t = b ^ G(a, k[i], sbox);
      b = a;
      a = t;
    }
  }

  for (let i = 7; i >= 0; i--) {
    const t = b ^ G(a, k[i], sbox);
    b = a;
    a = t;
  }

  writeU32(msg, b, pos + 0);
  writeU32(msg, a, pos + 4);
}

function X(a, b) {
  const out = Buffer.allocUnsafe(32);

  for (let i = 0; i < 32; i++)
    out[i] = a[i] ^ b[i];

  return out;
}

function XM(a, b) {
  for (let i = 0; i < 32; i++)
    a[i] ^= b[i];
}

function A(x) {
  const out = Buffer.allocUnsafe(32);

  x.copy(out, 0, 8, 32);

  for (let i = 0; i < 8; i++)
    out[24 + i] = x[i] ^ x[i + 8];

  return out;
}

function P(y) {
  const out = Buffer.allocUnsafe(32);

  for (let i = 0; i < 4; i++) {
    for (let k = 0; k < 8; k++)
      out[i + 4 * k] = y[8 * i + k];
  }

  return out;
}

function psi(block) {
  const out = Buffer.allocUnsafe(32);

  block.copy(out, 0, 2, 32);
  block.copy(out, 30, 0, 2);

  out[30] ^= block[2];
  out[31] ^= block[3];

  out[30] ^= block[4];
  out[31] ^= block[5];

  out[30] ^= block[6];
  out[31] ^= block[7];

  out[30] ^= block[24];
  out[31] ^= block[25];

  out[30] ^= block[30];
  out[31] ^= block[31];

  out.copy(block, 0);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = GOST94;

}).call(this,req("buffer").Buffer)
},{"./internal/hmac":76,"bsert":190,"buffer":303}],66:[function(req,module,exports){
(function (Buffer){
/*!
 * hash-drbg.js - hash-drbg implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on cryptocoinjs/drbg.js:
 *   Copyright (c) 2016 Kirill Fomichev
 *   https://github.com/cryptocoinjs/drbg.js
 *
 * Resources:
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/cryptocoinjs/drbg.js/blob/master/hash.js
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const RESEED_INTERVAL = 0x1000000000000;
const ONE = Buffer.from([0x01]);
const TWO = Buffer.from([0x02]);
const THREE = Buffer.from([0x03]);

/**
 * HashDRBG
 */

class HashDRBG {
  constructor(hash, entropy, nonce, pers) {
    assert(hash && typeof hash.id === 'string');

    this.hash = hash;
    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;
    this.seedLen = hash.size <= 32 ? 55 : 111;

    this.V = Buffer.allocUnsafe(this.seedLen);
    this.C = Buffer.allocUnsafe(this.seedLen);
    this.len = Buffer.allocUnsafe(8);
    this.rounds = 0;

    if (entropy)
      this.init(entropy, nonce, pers);
  }

  init(entropy, nonce = null, pers = null) {
    assert(Buffer.isBuffer(entropy));
    assert(!nonce || Buffer.isBuffer(nonce));
    assert(!pers || Buffer.isBuffer(pers));

    const seed = concat(entropy, nonce, pers);

    if (seed.length < this.minEntropy)
      throw new Error('Not enough entropy.');

    this.V = this.derive(seed, this.seedLen, null);
    this.C = this.derive(this.V, this.seedLen, 0x00);
    this.rounds = 1;

    return this;
  }

  reseed(entropy, add = null) {
    assert(Buffer.isBuffer(entropy));
    assert(!add || Buffer.isBuffer(add));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    const seed = concat(this.V, entropy, add);

    if (seed.length < this.minEntropy)
      throw new Error('Not enough entropy.');

    this.V = this.derive(seed, this.seedLen, 0x01);
    this.C = this.derive(this.V, this.seedLen, 0x00);
    this.rounds = 1;

    return this;
  }

  generate(len, add = null) {
    assert((len >>> 0) === len);
    assert(!add || Buffer.isBuffer(add));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    if (this.rounds > RESEED_INTERVAL)
      throw new Error('Reseed is reqd.');

    if (add && add.length !== 0)
      this.sum(this.V, this.hash.multi(TWO, this.V, add));

    const data = Buffer.from(this.V);
    const blocks = Math.ceil(len / this.hash.size);
    const out = Buffer.allocUnsafe(blocks * this.hash.size);

    for (let i = 0; i < blocks; i++) {
      this.hash.digest(data).copy(out, i * this.hash.size);
      this.sum(data, ONE);
    }

    this.update();
    this.rounds += 1;

    return out.slice(0, len);
  }

  randomBytes(size) {
    return this.generate(size);
  }

  /*
   * Helpers
   */

  update() {
    const H = this.hash.multi(THREE, this.V);
    const hi = (this.rounds / 0x100000000) >>> 0;
    const lo = this.rounds >>> 0;

    this.len[0] = hi >>> 24;
    this.len[1] = hi >>> 16;
    this.len[2] = hi >>> 8;
    this.len[3] = hi;
    this.len[4] = lo >>> 24;
    this.len[5] = lo >>> 16;
    this.len[6] = lo >>> 8;
    this.len[7] = lo;

    this.sum(this.V, H, this.C, this.len);

    return this;
  }

  derive(input, len, prepend = null) {
    assert(Buffer.isBuffer(input));
    assert((len >>> 0) === len);

    const p = prepend != null ? 1 : 0;
    const data = Buffer.allocUnsafe(5 + p + input.length);

    data[0] = 0x01;
    data[1] = len >>> 21;
    data[2] = len >>> 13;
    data[3] = len >>> 5;
    data[4] = (len & 0x1f) << 3;

    if (p)
      data[5] = prepend;

    input.copy(data, 5 + p);

    const blocks = Math.ceil(len / this.hash.size);
    const out = Buffer.allocUnsafe(blocks * this.hash.size);

    for (let i = 0; i < blocks; i++) {
      this.hash.digest(data).copy(out, i * this.hash.size);
      data[0] += 1;
    }

    return out.slice(0, len);
  }

  sum(dst, ...args) {
    for (const buf of args) {
      let i = buf.length - 1;
      let j = dst.length - 1;
      let carry = 0;

      while (i >= 0) {
        carry += buf[i] + dst[j];
        dst[j] = carry & 0xff;
        carry >>>= 8;
        i -= 1;
        j -= 1;
      }

      while (carry > 0 && j >= 0) {
        carry += dst[j];
        dst[j] = carry & 0xff;
        carry >>>= 8;
        j -= 1;
      }
    }

    return dst;
  }
}

/*
 * Static
 */

HashDRBG.native = 0;

/*
 * Helpers
 */

function concat(a, b = null, c = null) {
  if (!b && !c)
    return a;

  let s = a.length;
  let p = 0;

  if (b)
    s += b.length;

  if (c)
    s += c.length;

  const d = Buffer.allocUnsafe(s);

  p += a.copy(d, p);

  if (b)
    p += b.copy(d, p);

  if (c)
    c.copy(d, p);

  return d;
}

/*
 * Expose
 */

module.exports = HashDRBG;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],67:[function(req,module,exports){
/*!
 * hash160.js - hash160 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/hash160');

},{"./js/hash160":109}],68:[function(req,module,exports){
/*!
 * hash256.js - hash256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/hash256');

},{"./js/hash256":110}],69:[function(req,module,exports){
(function (Buffer){
/*!
 * hkdf.js - hkdf for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HKDF
 *   https://tools.ietf.org/html/rfc5869
 */

'use strict';

const assert = req('bsert');

/**
 * HKDF
 */

class HKDF {
  constructor(hash, ikm, salt, info) {
    assert(hash && typeof hash.id === 'string');

    this.hash = hash;
    this.size = hash.size;
    this.prk = null;
    this.state = null;
    this.slab = null;
    this.save = 0;

    if (ikm || salt || info)
      this.init(ikm, salt, info);
  }

  init(ikm, salt, info) {
    if (ikm == null)
      ikm = Buffer.alloc(0);

    if (salt == null)
      salt = Buffer.alloc(this.size, 0x00);

    this.prk = this.hash.mac(ikm, salt);
    this.reset(info);

    return this;
  }

  set(prk, info) {
    assert(Buffer.isBuffer(prk));
    assert(prk.length === this.size);

    this.prk = prk;
    this.reset(info);

    return this;
  }

  reset(info) {
    if (info == null)
      info = Buffer.alloc(0);

    assert(Buffer.isBuffer(info));

    // state = prev || info || counter
    const state = Buffer.allocUnsafe(this.size + info.length + 1);

    state.fill(0x00, 0, this.size);

    info.copy(state, this.size);

    state[state.length - 1] = 0;

    this.state = state;
    this.slab = Buffer.allocUnsafe(this.size);
    this.save = 0;

    return this;
  }

  generate(len) {
    assert((len >>> 0) === len);

    if (!this.prk || !this.state || !this.slab)
      throw new Error('HKDF is not initialized.');

    const left = (255 - this.state[this.state.length - 1]) * this.size;

    if (len > this.save + left)
      throw new Error('Too many bytes requested.');

    const blocks = Math.ceil(Math.max(0, len - this.save) / this.size);
    const okm = Buffer.allocUnsafe(this.save + blocks * this.size);

    this.slab.copy(okm, 0, 0, this.save);

    for (let i = 0; i < blocks; i++) {
      let state = this.state;

      if (state[state.length - 1] === 0)
        state = state.slice(this.size);

      assert(state[state.length - 1] !== 255);

      state[state.length - 1] += 1;

      const mac = this.hash.mac(state, this.prk);

      mac.copy(this.state, 0);
      mac.copy(okm, this.save + i * this.size);
    }

    this.save = okm.copy(this.slab, 0, len);

    return okm.slice(0, len);
  }

  randomBytes(size) {
    return this.generate(size);
  }

  static extract(hash, ikm, salt) {
    assert(hash && typeof hash.id === 'string');

    if (ikm == null)
      ikm = Buffer.alloc(0);

    if (salt == null)
      salt = Buffer.alloc(hash.size, 0x00);

    return hash.mac(ikm, salt);
  }

  static expand(hash, prk, info, len) {
    const hkdf = new HKDF(hash);
    return hkdf.set(prk, info)
               .generate(len);
  }

  static derive(hash, ikm, salt, info, len) {
    const hkdf = new HKDF(hash);
    return hkdf.init(ikm, salt, info)
               .generate(len);
  }
}

/*
 * Static
 */

HKDF.native = 0;

/*
 * Expose
 */

module.exports = HKDF;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],70:[function(req,module,exports){
(function (Buffer){
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const RESEED_INTERVAL = 0x1000000000000;
const ZERO = Buffer.from([0x00]);
const ONE = Buffer.from([0x01]);

/**
 * HmacDRBG
 */

class HmacDRBG {
  constructor(hash, entropy, nonce, pers) {
    assert(hash && typeof hash.id === 'string');

    this.hash = hash;
    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;

    this.K = Buffer.allocUnsafe(hash.size);
    this.V = Buffer.allocUnsafe(hash.size);
    this.rounds = 0;

    if (entropy)
      this.init(entropy, nonce, pers);
  }

  init(entropy, nonce = null, pers = null) {
    assert(Buffer.isBuffer(entropy));
    assert(!nonce || Buffer.isBuffer(nonce));
    assert(!pers || Buffer.isBuffer(pers));

    for (let i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }

    const seed = concat(entropy, nonce, pers);

    if (seed.length < this.minEntropy)
      throw new Error('Not enough entropy.');

    this.update(seed);
    this.rounds = 1;

    return this;
  }

  reseed(entropy, add = null) {
    assert(Buffer.isBuffer(entropy));
    assert(!add || Buffer.isBuffer(add));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    const seed = concat(entropy, add);

    if (seed.length < this.minEntropy)
     throw new Error('Not enough entropy.');

    this.update(seed);
    this.rounds = 1;

    return this;
  }

  generate(len, add = null) {
    assert((len >>> 0) === len);
    assert(!add || Buffer.isBuffer(add));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    if (this.rounds > RESEED_INTERVAL)
      throw new Error('Reseed is reqd.');

    if (add && add.length === 0)
      add = null;

    if (add)
      this.update(add);

    const blocks = Math.ceil(len / this.hash.size);
    const out = Buffer.allocUnsafe(blocks * this.hash.size);

    for (let i = 0; i < blocks; i++) {
      this.V = this.mac(this.V);
      this.V.copy(out, i * this.hash.size);
    }

    this.update(add);
    this.rounds += 1;

    return out.slice(0, len);
  }

  randomBytes(size) {
    return this.generate(size);
  }

  /*
   * Helpers
   */

  mac(data) {
    return this.hash.mac(data, this.K);
  }

  hmac() {
    return this.hash.hmac().init(this.K);
  }

  update(seed = null) {
    assert(!seed || Buffer.isBuffer(seed));

    const kmac = this.hmac();

    kmac.update(this.V);
    kmac.update(ZERO);

    if (seed)
      kmac.update(seed);

    this.K = kmac.final();
    this.V = this.mac(this.V);

    if (seed) {
      const kmac = this.hmac();

      kmac.update(this.V);
      kmac.update(ONE);
      kmac.update(seed);

      this.K = kmac.final();
      this.V = this.mac(this.V);
    }

    return this;
  }
}

/*
 * Static
 */

HmacDRBG.native = 0;

/*
 * Helpers
 */

function concat(a, b = null, c = null) {
  if (!b && !c)
    return a;

  let s = a.length;
  let p = 0;

  if (b)
    s += b.length;

  if (c)
    s += c.length;

  const d = Buffer.allocUnsafe(s);

  p += a.copy(d, p);

  if (b)
    p += b.copy(d, p);

  if (c)
    c.copy(d, p);

  return d;
}

/*
 * Expose
 */

module.exports = HmacDRBG;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],71:[function(req,module,exports){
(function (Buffer){
/*!
 * asn1-mini.js - miniature asn1 implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const EOF = -1;
const INT = 0x02;
const BIT = 0x03;
const OCT = 0x04;
const NULL = 0x05;
const OID = 0x06;
const SEQ = 0x30;

const DSA_OID = Buffer.from('2a8648ce380401', 'hex');
const RSA_OID = Buffer.from('2a864886f70d010101', 'hex');
const ECDSA_OID = Buffer.from('2a8648ce3d0201', 'hex');
const EDDSA_OID = Buffer.from('2b06010401da47040c01', 'hex');

const EMPTY = Buffer.alloc(0);
const ZERO = Buffer.alloc(1, 0x00);

/*
 * Encoding
 */

function encodeSEC1(pki) {
  assert(pki && typeof pki === 'object');

  const items = [
    encodeByte(pki.version),
    encodeOct(pki.key)
  ];

  if (pki.oid)
    items.push(encodeExplicit(encodeOID(pki.oid), 0));

  if (pki.pub)
    items.push(encodeExplicit(encodeBit(pki.pub), 1));

  return encodeSeq(items);
}

function encodePKCS8(pki) {
  assert(pki && typeof pki === 'object');
  return encodeSeq([
    encodeByte(pki.version),
    encodeAlgorithm(pki.algorithm),
    encodeOct(pki.key)
  ]);
}

function encodeSPKI(spki) {
  assert(spki && typeof spki === 'object');
  return encodeSeq([
    encodeAlgorithm(spki.algorithm),
    encodeBit(spki.key)
  ]);
}

function encodeAlgorithm(algorithm) {
  assert(algorithm && typeof algorithm === 'object');

  let params = EMPTY;

  if (algorithm.type !== NULL)
    params = encodeNode(algorithm.params, algorithm.type);

  return encodeSeq([
    encodeOID(algorithm.oid),
    params
  ]);
}

function encodeParams(p, q, g) {
  return Buffer.concat([
    encodeInt(p),
    encodeInt(q),
    encodeInt(g)
  ]);
}

function encodeInt(data) {
  assert(Buffer.isBuffer(data));

  if (data.length === 0)
    data = ZERO;

  let i = 0;

  for (; i < data.length; i++) {
    if (data[i] !== 0x00)
      break;
  }

  if (i === data.length)
    return encodeNode(ZERO, INT);

  data = data.slice(i);

  if (data[0] & 0x80)
    data = Buffer.concat([ZERO, data]);

  return encodeNode(data, INT);
}

function encodeByte(num) {
  assert((num & 0xff) === num);
  return encodeInt(Buffer.from([num]));
}

function encodeBit(data) {
  assert(Buffer.isBuffer(data));
  return encodeNode(Buffer.concat([ZERO, data]), BIT);
}

function encodeOct(data) {
  return encodeNode(data, OCT);
}

function encodeOID(data) {
  return encodeNode(data, OID);
}

function encodeSeq(items) {
  assert(Array.isArray(items));
  return encodeNode(Buffer.concat(items), SEQ);
}

function encodeNode(data, type) {
  assert(Buffer.isBuffer(data));
  assert((type & 0xff) === type);

  let size = 0;
  let bytes = 0;

  size += 1;
  size += 1;

  if (data.length >= 0x80) {
    let len = data.length;

    while (len) {
      size += 1;
      bytes += 1;
      len >>>= 8;
    }
  }

  size += data.length;

  const out = Buffer.allocUnsafe(size);

  let pos = 0;

  out[pos] = type;
  pos += 1;

  if (bytes) {
    out[pos] = 0x80 | bytes;
    pos += 1;

    let len = data.length;

    for (let i = bytes - 1; i >= 0; i--) {
      out[pos + i] = len;
      len >>>= 8;
    }

    pos += bytes;
  } else {
    out[pos] = data.length;
    pos += 1;
  }

  data.copy(out, pos);

  return out;
}

function encodeExplicit(data, type) {
  assert((type & 0xff) === type);
  return encodeNode(data, 0xa0 | type);
}

/*
 * Decoding
 */

function decodeSEC1(raw) {
  return readSEC1(raw, 0)[0];
}

function decodePKCS8(raw) {
  return readPKCS8(raw, 0)[0];
}

function decodeSPKI(raw) {
  return readSPKI(raw, 0)[0];
}

function decodeAlgorithm(raw) {
  return readAlgorithm(raw, 0)[0];
}

function decodeParams(raw) {
  return readParams(raw, 0)[0];
}

function decodeInt(raw) {
  return readInt(raw, 0)[0];
}

function decodeOct(raw) {
  return readOct(raw, 0)[0];
}

function readSEC1(raw, pos) {
  [raw, pos] = readSeq(raw, pos);

  const end = pos;

  pos = 0;

  let version, key, oidr, pubr;

  let oid = null;
  let pub = null;

  [version, pos] = readByte(raw, pos);
  [key, pos] = readOct(raw, pos);
  [oidr, pos] = readExplicit(raw, pos, 0);

  if (oidr) {
    try {
      [oid] = readOID(oidr, 0);
    } catch (e) {
      ;
    }
  }

  [pubr, pos] = readExplicit(raw, pos, 1);

  if (pubr)
    [pub] = readBit(pubr, 0);

  return [{ version, key, oid, pub }, end];
}

function readPKCS8(raw, pos) {
  [raw, pos] = readSeq(raw, pos);

  const end = pos;

  pos = 0;

  let version, algorithm, key;

  [version, pos] = readByte(raw, pos);
  [algorithm, pos] = readAlgorithm(raw, pos);
  [key, pos] = readOct(raw, pos);

  return [{ version, algorithm, key }, end];
}

function readSPKI(raw, pos) {
  [raw, pos] = readSeq(raw, pos);

  const end = pos;

  pos = 0;

  let algorithm, key;

  [algorithm, pos] = readAlgorithm(raw, pos);
  [key, pos] = readBit(raw, pos);

  return [{ algorithm, key }, end];
}

function readAlgorithm(raw, pos) {
  [raw, pos] = readSeq(raw, pos);

  const end = pos;

  pos = 0;

  let oid;

  [oid, pos] = readOID(raw, pos);

  let type = pos < raw.length ? raw[pos] : EOF;
  let params = EMPTY;

  switch (type) {
    case EOF:
      type = NULL;
      break;
    case NULL:
      pos += 1;
      assert(pos < raw.length);
      assert(raw[pos] === 0x00);
      break;
    default:
      [params] = readNode(raw, pos, type);
      break;
  }

  return [{ oid, type, params }, end];
}

function readParams(raw, pos) {
  let p, q, g;

  [p, pos] = readInt(raw, pos);
  [q, pos] = readInt(raw, pos);
  [g, pos] = readInt(raw, pos);

  return [[p, q, g], pos];
}

function readInt(data, pos) {
  [data, pos] = readNode(data, pos, INT);

  assert(data.length > 0);

  let i = 0;

  for (; i < data.length; i++) {
    if (data[i] !== 0x00)
      break;
  }

  if (i === data.length)
    return [ZERO, pos];

  if (i === 0 && (data[0] & 0x80))
    throw new Error('Integer is negative.');

  return [data.slice(i), pos];
}

function readByte(data, pos) {
  [data, pos] = readInt(data, pos);
  assert(data.length === 1);
  return [data[0], pos];
}

function readBit(data, pos) {
  [data, pos] = readNode(data, pos, BIT);

  assert(data.length > 0);
  assert(data[0] === 0x00);

  return [data.slice(1), pos];
}

function readOct(data, pos) {
  return readNode(data, pos, OCT);
}

function readOID(data, pos) {
  return readNode(data, pos, OID);
}

function readSeq(data, pos) {
  return readNode(data, pos, SEQ);
}

function readNode(data, pos, type) {
  assert(Buffer.isBuffer(data));
  assert((pos >>> 0) === pos);
  assert(pos < data.length);
  assert((type & 0xff) === type);

  assert(data[pos] === type);
  pos += 1;

  let len;
  [len, pos] = readSize(data, pos);

  assert(pos + len <= data.length);

  const body = data.slice(pos, pos + len);

  pos += len;

  return [body, pos];
}

function readExplicit(data, pos, type) {
  assert(Buffer.isBuffer(data));
  assert((pos >>> 0) === pos);
  assert(pos < data.length);
  assert((type & 0xff) === type);

  try {
    return readNode(data, pos, 0xa0 | type);
  } catch (e) {
    return [null, pos];
  }
}

function readSize(data, pos) {
  assert(Buffer.isBuffer(data));
  assert((pos >>> 0) === pos);
  assert(pos < data.length);

  const field = data[pos];
  const bytes = field & 0x7f;

  pos += 1;

  // Definite form
  if ((field & 0x80) === 0) {
    // Short form
    return [bytes, pos];
  }

  // Indefinite form.
  if (bytes === 0)
    throw new Error('Indefinite length.');

  let len = 0;

  for (let i = 0; i < bytes; i++) {
    assert(pos < data.length);

    const ch = data[pos];

    pos += 1;

    if (len >= (1 << 23))
      throw new Error('Length too large.');

    len *= 0x100;
    len += ch;

    if (len === 0)
      throw new Error('Unexpected leading zeroes.');
  }

  if (len < 0x80)
    throw new Error('Non-minimal length.');

  return [len, pos];
}

// Make eslint happy.
readExplicit;

/*
 * Expose
 */

exports.INT = INT;
exports.BIT = BIT;
exports.OCT = OCT;
exports.NULL = NULL;
exports.OID = OID;
exports.SEQ = SEQ;

exports.DSA_OID = DSA_OID;
exports.RSA_OID = RSA_OID;
exports.ECDSA_OID = ECDSA_OID;
exports.EDDSA_OID = EDDSA_OID;

exports.encodeSEC1 = encodeSEC1;
exports.encodePKCS8 = encodePKCS8;
exports.encodeSPKI = encodeSPKI;
exports.encodeAlgorithm = encodeAlgorithm;
exports.encodeParams = encodeParams;
exports.encodeInt = encodeInt;
exports.encodeOct = encodeOct;
exports.decodeSEC1 = decodeSEC1;
exports.decodePKCS8 = decodePKCS8;
exports.decodeSPKI = decodeSPKI;
exports.decodeAlgorithm = decodeAlgorithm;
exports.decodeParams = decodeParams;
exports.decodeInt = decodeInt;
exports.decodeOct = decodeOct;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],72:[function(req,module,exports){
/*!
 * ciphers.js - cipher list for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

/* eslint no-prototype-builtins: "off" */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const ciphers = {
  'AES-128': [16, 16],
  'AES-192': [16, 24],
  'AES-256': [16, 32],
  'BF': [8, 16], // 4 - 56/72 bytes, pgp default is 16
  'CAMELLIA-128': [16, 16],
  'CAMELLIA-192': [16, 24],
  'CAMELLIA-256': [16, 32],
  'CAST5': [8, 16],
  'DES': [8, 8],
  'DES-EDE': [8, 16],
  'DES-EDE3': [8, 24],
  'IDEA': [8, 16],
  'RC2-64': [8, 8], // 1 - 128 bytes, default is 8
  'TWOFISH-128': [16, 16],
  'TWOFISH-192': [16, 24],
  'TWOFISH-256': [16, 32]
};

/**
 * CipherInfo
 */

class CipherInfo {
  constructor(name, algorithm, mode, blockSize, keySize, ivSize) {
    this.name = name;
    this.algorithm = algorithm;
    this.mode = mode;
    this.blockSize = blockSize;
    this.keySize = keySize;
    this.ivSize = ivSize;
  }
}

/*
 * Ciphers
 */

function parse(name) {
  assert(typeof name === 'string');

  const len = name.length;

  if (len < 1 || len > 64)
    throw new Error('Invalid cipher name.');

  let suffix = null;
  let mode = null;
  let algorithm = null;

  if (len >= 6)
    suffix = name.substring(len - 4);

  switch (suffix) {
    case '-ECB':
      mode = 'ECB';
      break;
    case '-CBC':
      mode = 'CBC';
      break;
    case '-CTR':
      mode = 'CTR';
      break;
    case '-CFB':
      mode = 'CFB';
      break;
    case '-OFB':
      mode = 'OFB';
      break;
    case '-GCM':
      mode = 'GCM';
      break;
    default:
      suffix = null;
      break;
  }

  if (suffix)
    algorithm = name.substring(0, len - 4);
  else
    algorithm = name;

  if (!ciphers.hasOwnProperty(algorithm))
    throw new Error(`Unknown cipher: ${name}.`);

  if (mode === 'GCM') {
    const size = ciphers[algorithm][0];

    if (size !== 16)
      throw new Error(`Unsupported mode: ${mode}-${size * 8}.`);
  }

  return [name, algorithm, mode];
}

function info(cipher) {
  const [name, algorithm, mode] = parse(cipher);
  const [blockSize, keySize] = ciphers[algorithm];

  let ivSize = blockSize;

  if (!mode || mode === 'ECB')
    ivSize = 0;

  return new CipherInfo(
    name,
    algorithm,
    mode,
    blockSize,
    keySize,
    ivSize
  );
}

function get(cipher) {
  const c = info(cipher);

  if (!c.mode)
    throw new Error('No mode provided for cipher name.');

  return c;
}

function has(cipher) {
  assert(typeof cipher === 'string');

  try {
    const mode = parse(cipher)[2];
    return mode != null;
  } catch (e) {
    return false;
  }
}

/*
 * Expose
 */

exports.info = info;
exports.get = get;
exports.has = has;

},{"bsert":190}],73:[function(req,module,exports){
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

exports.custom = 'inspect';

},{}],74:[function(req,module,exports){
/*!
 * dsakey.js - DSA keys for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7517
 *   https://tools.ietf.org/html/rfc7518
 *   https://mozilla.github.io/id-specs/docs/formats/keys/
 */

'use strict';

const assert = req('bsert');
const base64 = req('../encoding/base64');
const {countLeft, trimLeft} = req('../encoding/util');
const {custom} = req('./custom');

/*
 * Constants
 */

const DEFAULT_BITS = 2048;
const MIN_BITS = 512;
const MAX_BITS = 10000;

/**
 * DSA Params
 */

class DSAParams {
  constructor(p, q, g) {
    this.p = trimLeft(p);
    this.q = trimLeft(q);
    this.g = trimLeft(g);
  }

  setP(p) {
    this.p = trimLeft(p);
    return this;
  }

  setQ(q) {
    this.q = trimLeft(q);
    return this;
  }

  setG(g) {
    this.g = trimLeft(g);
    return this;
  }

  L() {
    return countLeft(this.p);
  }

  N() {
    return countLeft(this.q);
  }

  bits() {
    return this.L();
  }

  size() {
    return (this.N() + 7) >>> 3;
  }

  toParams() {
    return this;
  }

  toJSON() {
    return {
      kty: 'DSA',
      p: base64.encodeURL(this.p),
      q: base64.encodeURL(this.q),
      g: base64.encodeURL(this.g),
      ext: true
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(json.kty === 'DSA');

    this.p = base64.decodeURL(json.p);
    this.q = base64.decodeURL(json.q);
    this.g = base64.decodeURL(json.g);

    return this;
  }

  [custom]() {
    return this.format();
  }

  format() {
    return {
      bits: this.bits(),
      size: this.size(),
      pbits: countLeft(this.p),
      qbits: countLeft(this.q),
      gbits: countLeft(this.g),
      p: this.p.toString('hex'),
      q: this.q.toString('hex'),
      g: this.g.toString('hex')
    };
  }

  static fromJSON(json) {
    return new this().fromJSON(json);
  }
}

/**
 * DSA Key
 */

class DSAKey extends DSAParams {
  constructor(p, q, g, y) {
    super(p, q, g);
    this.y = trimLeft(y);
  }

  setParams(params) {
    return this.fromParams(params);
  }

  setY(y) {
    this.y = trimLeft(y);
    return this;
  }

  toParams() {
    return new DSAParams(this.p, this.q, this.g);
  }

  fromParams(params) {
    assert(params instanceof DSAParams);
    this.p = params.p;
    this.q = params.q;
    this.g = params.g;
    return this;
  }

  toPublic() {
    return this;
  }

  toJSON() {
    return {
      kty: 'DSA',
      p: base64.encodeURL(this.p),
      q: base64.encodeURL(this.q),
      g: base64.encodeURL(this.g),
      y: base64.encodeURL(this.y),
      ext: true
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(json.kty === 'DSA');

    this.p = base64.decodeURL(json.p);
    this.q = base64.decodeURL(json.q);
    this.g = base64.decodeURL(json.g);
    this.y = base64.decodeURL(json.y);

    return this;
  }

  static fromParams(params) {
    return new this().fromParams(params);
  }
}

/**
 * DSA Public Key
 */

class DSAPublicKey extends DSAKey {
  constructor(p, q, g, y) {
    super(p, q, g, y);
  }

  format() {
    return {
      bits: this.bits(),
      size: this.size(),
      pbits: countLeft(this.p),
      qbits: countLeft(this.q),
      gbits: countLeft(this.g),
      ybits: countLeft(this.y),
      p: this.p.toString('hex'),
      q: this.q.toString('hex'),
      g: this.g.toString('hex'),
      y: this.y.toString('hex')
    };
  }
}

/**
 * DSA Public Key
 */

class DSAPrivateKey extends DSAKey {
  constructor(p, q, g, y, x) {
    super(p, q, g, y);
    this.x = trimLeft(x);
  }

  setX(x) {
    this.x = trimLeft(x);
    return this;
  }

  toPublic() {
    const key = new DSAPublicKey();
    key.p = this.p;
    key.q = this.q;
    key.g = this.g;
    key.y = this.y;
    return key;
  }

  toJSON() {
    return {
      kty: 'DSA',
      p: base64.encodeURL(this.p),
      q: base64.encodeURL(this.q),
      g: base64.encodeURL(this.g),
      y: base64.encodeURL(this.y),
      x: base64.encodeURL(this.x),
      ext: true
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(json.kty === 'DSA');

    this.p = base64.decodeURL(json.p);
    this.q = base64.decodeURL(json.q);
    this.g = base64.decodeURL(json.g);

    if (json.y != null)
      this.y = base64.decodeURL(json.y);

    this.x = base64.decodeURL(json.x);

    return this;
  }

  format() {
    return {
      bits: this.bits(),
      size: this.size(),
      pbits: countLeft(this.p),
      qbits: countLeft(this.q),
      gbits: countLeft(this.g),
      ybits: countLeft(this.y),
      xbits: countLeft(this.x),
      p: this.p.toString('hex'),
      q: this.q.toString('hex'),
      g: this.g.toString('hex'),
      y: this.y.toString('hex'),
      x: this.x.toString('hex')
    };
  }
}

/*
 * Expose
 */

exports.DEFAULT_BITS = DEFAULT_BITS;
exports.MIN_BITS = MIN_BITS;
exports.MAX_BITS = MAX_BITS;

exports.DSAKey = DSAKey;
exports.DSAParams = DSAParams;
exports.DSAPublicKey = DSAPublicKey;
exports.DSAPrivateKey = DSAPrivateKey;

},{"../encoding/base64":50,"../encoding/util":63,"./custom":73,"bsert":190}],75:[function(req,module,exports){
(function (Buffer){
/*!
 * eckey.js - jwk ec keys for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7517
 *   https://tools.ietf.org/html/rfc7518
 *   https://tools.ietf.org/html/rfc8037
 *   https://tools.ietf.org/html/draft-jones-webauthn-secp256k1-00
 *   https://tools.ietf.org/html/draft-ietf-jose-cfrg-curves-06#appendix-A.1
 *   https://tools.ietf.org/html/draft-ietf-jose-cfrg-curves-06#appendix-A.6
 */

'use strict';

const assert = req('bsert');
const base64 = req('../encoding/base64');
const {padLeft, padRight} = req('../encoding/util');

/*
 * JWK
 */

function privateKeyExportJWK(curve, key) {
  assert(curve && typeof curve.publicKeyCreate === 'function');

  const pub = curve.publicKeyCreate(key, false);
  const json = publicKeyExportJWK(curve, pub);

  if (curve.type !== 'short') {
    return {
      kty: 'OKP',
      crv: json.crv,
      x: json.x,
      d: base64.encodeURL(key),
      ext: true
    };
  }

  return {
    kty: 'EC',
    crv: json.crv,
    x: json.x,
    y: json.y,
    d: base64.encodeURL(key),
    ext: true
  };
}

function privateKeyImportJWK(curve, json) {
  assert(curve && typeof curve.privateKeyVerify === 'function');
  assert(json && typeof json === 'object');

  if (json.kty !== getKTY(curve))
    throw new Error('Invalid key type.');

  if (json.crv != null && fromCurve(json.crv) !== curve.id)
    throw new Error('Invalid curve name.');

  let key = base64.decodeURL(json.d);

  if (curve.type === 'short')
    key = padLeft(key, curve.size);
  else
    key = padRight(key, curve.size);

  if (!curve.privateKeyVerify(key))
    throw new Error('Invalid private key.');

  return key;
}

function publicKeyExportJWK(curve, key) {
  assert(curve && typeof curve.publicKeyExport === 'function');

  const pub = curve.publicKeyExport(key);

  if (curve.type !== 'short') {
    // Note: The RFC says to use only `x`
    // as the coordinate name even though
    // in reality it should probably be
    // `u` or `y`.
    return {
      kty: 'OKP',
      crv: toCurve(curve.id),
      x: base64.encodeURL(pub),
      ext: true
    };
  }

  const x = pub.slice(0, curve.size);
  const y = pub.slice(curve.size, curve.size * 2);

  return {
    kty: 'EC',
    crv: toCurve(curve.id),
    x: base64.encodeURL(x),
    y: base64.encodeURL(y),
    ext: true
  };
}

function publicKeyImportJWK(curve, json, compress) {
  assert(curve && typeof curve.publicKeyImport === 'function');
  assert(json && typeof json === 'object');

  if (json.kty !== getKTY(curve))
    throw new Error('Invalid key type.');

  if (json.crv != null && fromCurve(json.crv) !== curve.id)
    throw new Error('Invalid curve name.');

  if (curve.type !== 'short') {
    const x = padRight(base64.decodeURL(json.x), curve.size);
    return curve.publicKeyImport(x);
  }

  const x = padLeft(base64.decodeURL(json.x), curve.size);
  const y = padLeft(base64.decodeURL(json.y), curve.size);
  const pub = Buffer.concat([x, y]);

  return curve.publicKeyImport(pub, compress);
}

/*
 * Helpers
 */

function getKTY(curve) {
  return curve.type === 'short' ? 'EC' : 'OKP';
}

function toCurve(id) {
  assert(typeof id === 'string');

  switch (id) {
    case 'P192':
      return 'P-192';
    case 'P224':
      return 'P-224';
    case 'P256':
      return 'P-256';
    case 'P384':
      return 'P-384';
    case 'P521':
      return 'P-521';
    case 'SECP256K1':
      return 'P-256K';
    case 'ED25519':
      return 'Ed25519';
    case 'ED448':
      return 'Ed448';
    default:
      return id;
  }
}

function fromCurve(crv) {
  assert(typeof crv === 'string');

  switch (crv) {
    case 'P-192':
      return 'P192';
    case 'P-224':
      return 'P224';
    case 'P-256':
      return 'P256';
    case 'P-384':
      return 'P384';
    case 'P-521':
      return 'P521';
    case 'P-256K':
      return 'SECP256K1';
    case 'Ed25519':
      return 'ED25519';
    case 'Ed448':
      return 'ED448';
    default:
      return crv;
  }
}

/*
 * Expose
 */

exports.privateKeyExportJWK = privateKeyExportJWK;
exports.privateKeyImportJWK = privateKeyImportJWK;
exports.publicKeyExportJWK = publicKeyExportJWK;
exports.publicKeyImportJWK = publicKeyImportJWK;

}).call(this,req("buffer").Buffer)
},{"../encoding/base64":50,"../encoding/util":63,"bsert":190,"buffer":303}],76:[function(req,module,exports){
(function (Buffer){
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */

'use strict';

const assert = req('bsert');

/**
 * HMAC
 */

class HMAC {
  /**
   * Create an HMAC.
   * @param {Function} Hash
   * @param {Number} size
   * @param {Array} [x=[]]
   * @param {Array} [y=[]]
   */

  constructor(Hash, size, x = [], y = []) {
    assert(typeof Hash === 'function');
    assert((size >>> 0) === size);
    assert(Array.isArray(x));
    assert(Array.isArray(y));

    this.hash = Hash;
    this.size = size;
    this.x = x;
    this.y = y;

    this.inner = new Hash();
    this.outer = new Hash();
  }

  /**
   * Initialize HMAC context.
   * @param {Buffer} data
   */

  init(key) {
    assert(Buffer.isBuffer(key));

    // Shorten key
    if (key.length > this.size) {
      const Hash = this.hash;
      const h = new Hash();

      h.init(...this.x);
      h.update(key);

      key = h.final(...this.y);

      assert(key.length <= this.size);
    }

    // Pad key
    const pad = Buffer.allocUnsafe(this.size);

    for (let i = 0; i < key.length; i++)
      pad[i] = key[i] ^ 0x36;

    for (let i = key.length; i < pad.length; i++)
      pad[i] = 0x36;

    this.inner.init(...this.x);
    this.inner.update(pad);

    for (let i = 0; i < key.length; i++)
      pad[i] = key[i] ^ 0x5c;

    for (let i = key.length; i < pad.length; i++)
      pad[i] = 0x5c;

    this.outer.init(...this.x);
    this.outer.update(pad);

    return this;
  }

  /**
   * Update HMAC context.
   * @param {Buffer} data
   */

  update(data) {
    this.inner.update(data);
    return this;
  }

  /**
   * Finalize HMAC context.
   * @returns {Buffer}
   */

  final() {
    this.outer.update(this.inner.final(...this.y));
    return this.outer.final(...this.y);
  }
}

/*
 * Expose
 */

module.exports = HMAC;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],77:[function(req,module,exports){
(function (Buffer){
/*!
 * mont.js - key agreement wrapper for ed25519/ed448
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7748
 */

'use strict';

const assert = req('bsert');
const eckey = req('./eckey');
const asn1 = req('./asn1-mini');

/**
 * Mont
 */

class Mont {
  constructor(name, bits, size, oid, ed) {
    assert(typeof name === 'string');
    assert((bits >>> 0) === bits);
    assert((size >>> 0) === size);
    assert(typeof oid === 'string');
    assert(ed && typeof ed === 'object');

    this.id = name;
    this.type = 'mont';
    this.oid = Buffer.from(oid, 'hex');
    this.ed = ed;
    this.bits = bits;
    this.size = size;
    this.native = ed.native;
  }

  privateKeyGenerate() {
    return this.ed.scalarGenerate();
  }

  privateKeyVerify(key) {
    assert(Buffer.isBuffer(key));
    return key.length === this.size;
  }

  privateKeyExport(key) {
    if (!this.privateKeyVerify(key))
      throw new Error('Invalid private key.');

    return asn1.encodeOct(key);
  }

  privateKeyImport(raw) {
    const key = asn1.decodeOct(raw);

    if (!this.privateKeyVerify(key))
      throw new Error('Invalid private key.');

    return key;
  }

  privateKeyExportPKCS8(key) {
    return asn1.encodePKCS8({
      version: 0,
      algorithm: {
        oid: this.oid,
        type: asn1.NULL,
        params: null
      },
      key: this.privateKeyExport(key)
    });
  }

  privateKeyImportPKCS8(raw) {
    const pki = asn1.decodePKCS8(raw);

    assert(pki.version === 0 || pki.version === 1);
    assert(pki.algorithm.oid.equals(this.oid));
    assert(pki.algorithm.type === asn1.NULL);

    return this.privateKeyImport(pki.key);
  }

  privateKeyExportJWK(key) {
    return eckey.privateKeyExportJWK(this, key);
  }

  privateKeyImportJWK(json) {
    return eckey.privateKeyImportJWK(this, json);
  }

  publicKeyCreate(key) {
    const scalar = this.ed.scalarClamp(key);
    const pub = this.ed.publicKeyFromScalar(scalar);
    return this.ed.publicKeyConvert(pub);
  }

  _scalarBaseMul(key) {
    // Exposed for testing only.
    if (this.ed.x) {
      const scalar = this.ed.x.decodeScalar(key);
      const point = this.ed.x.g.mul(scalar);
      return point.encode();
    }

    return this.publicKeyCreate(key);
  }

  publicKeyVerify(key) {
    assert(Buffer.isBuffer(key));
    return key.length === this.size;
  }

  publicKeyExport(key) {
    if (!this.publicKeyVerify(key))
      throw new Error('Invalid public key.');

    return Buffer.from(key);
  }

  publicKeyImport(raw) {
    if (!this.publicKeyVerify(raw))
      throw new Error('Invalid public key.');

    return Buffer.from(raw);
  }

  publicKeyExportSPKI(key) {
    return asn1.encodeSPKI({
      algorithm: {
        oid: this.oid,
        type: asn1.NULL,
        params: null
      },
      key: this.publicKeyExport(key)
    });
  }

  publicKeyImportSPKI(raw) {
    const spki = asn1.decodeSPKI(raw);

    assert(spki.algorithm.oid.equals(this.oid));
    assert(spki.algorithm.type === asn1.NULL);

    return this.publicKeyImport(spki.key);
  }

  publicKeyExportJWK(key) {
    return eckey.publicKeyExportJWK(this, key);
  }

  publicKeyImportJWK(json) {
    return eckey.publicKeyImportJWK(this, json, false);
  }

  derive(pub, priv) {
    return this.ed.exchangeWithScalar(pub, priv);
  }
}

/*
 * Expose
 */

module.exports = Mont;

}).call(this,req("buffer").Buffer)
},{"./asn1-mini":71,"./eckey":75,"bsert":190,"buffer":303}],78:[function(req,module,exports){
/*!
 * objects.js - OIDs encoding for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://www.ietf.org/rfc/rfc2459.txt
 *   https://tools.ietf.org/html/rfc3279
 *   http://oid-info.com/get/1.2.840.10040.4
 *   http://oid-info.com/get/1.2.840.113549.1.1
 *   http://oid-info.com/get/1.2.840.10045.4.3
 *   https://tools.ietf.org/html/draft-jivsov-openpgp-sha3-01
 *   https://github.com/golang/go/blob/master/src/crypto/x509/x509.go
 *   https://github.com/golang/go/blob/master/src/crypto/x509/pkix/pkix.go
 *   https://tools.ietf.org/html/draft-josefsson-pkix-eddsa-01
 *   https://tools.ietf.org/html/rfc5480
 *   https://tools.ietf.org/html/draft-josefsson-pkix-newcurves-00
 *   https://tools.ietf.org/id/draft-ietf-curdle-pkix-06.html
 *   https://tools.ietf.org/html/rfc7693
 */

'use strict';

const NONE = '0.0';

const attrs = {
  COUNTRY: '2.5.4.6',
  ORGANIZATION: '2.5.4.10',
  ORGANIZATIONALUNIT: '2.5.4.11',
  COMMONNAME: '2.5.4.3',
  SERIALNUMBER: '2.5.4.5',
  LOCALITY: '2.5.4.7',
  PROVINCE: '2.5.4.8',
  STREETADDRESS: '2.5.4.9',
  POSTALCODE: '2.5.4.17'
};

const attrsByVal = {
  [attrs.COUNTRY]: 'COUNTRY',
  [attrs.ORGANIZATION]: 'ORGANIZATION',
  [attrs.ORGANIZATIONALUNIT]: 'ORGANIZATIONALUNIT',
  [attrs.COMMONNAME]: 'COMMONNAME',
  [attrs.SERIALNUMBER]: 'SERIALNUMBER',
  [attrs.LOCALITY]: 'LOCALITY',
  [attrs.PROVINCE]: 'PROVINCE',
  [attrs.STREETADDRESS]: 'STREETADDRESS',
  [attrs.POSTALCODE]: 'POSTALCODE'
};

const keyAlgs = {
  DSA: '1.2.840.10040.4.1',
  DSA2: '1.2.840.10040.4.2',
  RSA: '1.2.840.113549.1.1.1',
  ECDSA: '1.2.840.10045.2.1',
  EDDSA: '1.3.6.1.4.1.11591.4.12.1'
};

const keyAlgsByVal = {
  [keyAlgs.DSA]: 'DSA',
  [keyAlgs.DSA2]: 'DSA',
  [keyAlgs.RSA]: 'RSA',
  [keyAlgs.ECDSA]: 'ECDSA',
  [keyAlgs.EDDSA]: 'EDDSA'
};

const hashes = {
  BLAKE2B160: '1.3.6.1.4.1.1722.12.2.1.5',
  BLAKE2B256: '1.3.6.1.4.1.1722.12.2.1.8',
  BLAKE2B384: '1.3.6.1.4.1.1722.12.2.1.12',
  BLAKE2B512: '1.3.6.1.4.1.1722.12.2.1.16',
  BLAKE2S128: '1.3.6.1.4.1.1722.12.2.2.4',
  BLAKE2S160: '1.3.6.1.4.1.1722.12.2.2.5',
  BLAKE2S224: '1.3.6.1.4.1.1722.12.2.2.7',
  BLAKE2S256: '1.3.6.1.4.1.1722.12.2.2.8',
  GOST94: '1.2.643.2.2.20',
  MD2: '1.2.840.113549.2.2',
  MD4: '1.2.840.113549.2.4',
  MD5: '1.2.840.113549.2.5',
  MDC2: '1.3.14.3.2.19',
  RIPEMD160: '1.0.10118.3.0.49',
  RIPEMD1602: '1.3.36.3.2.1',
  SHA1: '1.3.14.3.2.26',
  SHA224: '2.16.840.1.101.3.4.2.4',
  SHA256: '2.16.840.1.101.3.4.2.1',
  SHA384: '2.16.840.1.101.3.4.2.2',
  SHA512: '2.16.840.1.101.3.4.2.3',
  SHA3_224: '2.16.840.1.101.3.4.2.7',
  SHA3_256: '2.16.840.1.101.3.4.2.8',
  SHA3_384: '2.16.840.1.101.3.4.2.9',
  SHA3_512: '2.16.840.1.101.3.4.2.10',
  SHAKE128: '2.16.840.1.101.3.4.2.11',
  SHAKE256: '2.16.840.1.101.3.4.2.12',
  SM3: '1.0.10118.3.0.65',
  WHIRLPOOL: '1.0.10118.3.0.55'
};

const hashesByVal = {
  [hashes.BLAKE2B160]: 'BLAKE2B160',
  [hashes.BLAKE2B256]: 'BLAKE2B256',
  [hashes.BLAKE2B384]: 'BLAKE2B384',
  [hashes.BLAKE2B512]: 'BLAKE2B512',
  [hashes.BLAKE2S128]: 'BLAKE2S128',
  [hashes.BLAKE2S160]: 'BLAKE2S160',
  [hashes.BLAKE2S224]: 'BLAKE2S224',
  [hashes.BLAKE2S256]: 'BLAKE2S256',
  [hashes.GOST94]: 'GOST94',
  [hashes.MD2]: 'MD2',
  [hashes.MD4]: 'MD4',
  [hashes.MD5]: 'MD5',
  [hashes.MDC2]: 'MDC2',
  [hashes.RIPEMD160]: 'RIPEMD160',
  [hashes.RIPEMD1602]: 'RIPEMD160',
  [hashes.SHA1]: 'SHA1',
  [hashes.SHA224]: 'SHA224',
  [hashes.SHA256]: 'SHA256',
  [hashes.SHA384]: 'SHA384',
  [hashes.SHA512]: 'SHA512',
  [hashes.SHA3_224]: 'SHA3_224',
  [hashes.SHA3_256]: 'SHA3_256',
  [hashes.SHA3_384]: 'SHA3_384',
  [hashes.SHA3_512]: 'SHA3_512',
  [hashes.SHAKE128]: 'SHAKE128',
  [hashes.SHAKE256]: 'SHAKE256',
  [hashes.SM3]: 'SM3',
  [hashes.WHIRLPOOL]: 'WHIRLPOOL'
};

const curves = {
  P192: '1.2.840.10045.3.1.1',
  P224: '1.3.132.0.33',
  P256: '1.2.840.10045.3.1.7',
  P384: '1.3.132.0.34',
  P521: '1.3.132.0.35',
  SECP256K1: '1.3.132.0.10',
  X25519: '1.3.101.110',
  X255192: '1.3.6.1.4.1.11591.7',
  X448: '1.3.101.111',
  X4482: '1.3.6.1.4.1.11591.8',
  ED25519: '1.3.101.112',
  ED448: '1.3.101.113'
};

const curvesByVal = {
  [curves.P192]: 'P192',
  [curves.P224]: 'P224',
  [curves.P256]: 'P256',
  [curves.P384]: 'P384',
  [curves.P521]: 'P521',
  [curves.SECP256K1]: 'SECP256K1',
  [curves.X25519]: 'X25519',
  [curves.X255192]: 'X255192',
  [curves.X448]: 'X448',
  [curves.X4482]: 'X448',
  [curves.ED25519]: 'ED25519',
  [curves.ED448]: 'ED448'
};

const sigAlgs = {
  DSASHA1: '1.2.840.10040.4.3',
  RSAMD2: '1.2.840.113549.1.1.2',
  RSAMD4: '1.2.840.113549.1.1.3',
  RSAMD5: '1.2.840.113549.1.1.4',
  RSASHA1: '1.2.840.113549.1.1.5',
  RSAPSS: '1.2.840.113549.1.1.10',
  RSASHA256: '1.2.840.113549.1.1.11',
  RSASHA384: '1.2.840.113549.1.1.12',
  RSASHA512: '1.2.840.113549.1.1.13',
  RSASHA224: '1.2.840.113549.1.1.14',
  MGF1: '1.2.840.113549.1.1.8',
  RSASHA1MS: '1.3.14.3.2.29',
  RSASHA3_256: '2.16.840.1.101.3.4.2.8',
  RSASHA3_384: '2.16.840.1.101.3.4.2.9',
  RSASHA3_512: '2.16.840.1.101.3.4.2.10',
  ECDSASHA1: '1.2.840.10045.4.1',
  ECDSASHA224: '1.2.840.10045.4.3.1',
  ECDSASHA256: '1.2.840.10045.4.3.2',
  ECDSASHA384: '1.2.840.10045.4.3.3',
  ECDSASHA512: '1.2.840.10045.4.3.4',
  EDDSA: '1.3.6.1.4.1.11591.4.12.2'
};

const sigAlgsByVal = {
  [sigAlgs.DSASHA1]: 'DSASHA1',
  [sigAlgs.RSAMD2]: 'RSAMD2',
  [sigAlgs.RSAMD4]: 'RSAMD4',
  [sigAlgs.RSAMD5]: 'RSAMD5',
  [sigAlgs.RSASHA1]: 'RSASHA1',
  [sigAlgs.RSAPSS]: 'RSAPSS',
  [sigAlgs.RSASHA256]: 'RSASHA256',
  [sigAlgs.RSASHA384]: 'RSASHA384',
  [sigAlgs.RSASHA512]: 'RSASHA512',
  [sigAlgs.MGF1]: 'MGF1',
  [sigAlgs.RSASHA1MS]: 'RSASHA1',
  [sigAlgs.RSASHA3_256]: 'RSASHA3_256',
  [sigAlgs.RSASHA3_384]: 'RSASHA3_384',
  [sigAlgs.RSASHA3_512]: 'RSASHA3_512',
  [sigAlgs.ECDSASHA1]: 'ECDSASHA1',
  [sigAlgs.ECDSASHA224]: 'ECDSASHA224',
  [sigAlgs.ECDSASHA384]: 'ECDSASHA384',
  [sigAlgs.ECDSASHA512]: 'ECDSASHA512',
  [sigAlgs.EDDSA]: 'EDDSA'
};

const sigToHash = {
  [sigAlgs.DSASHA1]: hashes.SHA1,
  [sigAlgs.RSAMD2]: hashes.MD2,
  [sigAlgs.RSAMD4]: hashes.MD4,
  [sigAlgs.RSAMD5]: hashes.MD5,
  [sigAlgs.RSASHA1]: hashes.SHA1,
  [sigAlgs.RSAPSS]: null,
  [sigAlgs.RSASHA256]: hashes.SHA256,
  [sigAlgs.RSASHA384]: hashes.SHA384,
  [sigAlgs.RSASHA512]: hashes.SHA512,
  [sigAlgs.MGF1]: null,
  [sigAlgs.RSASHA1MS]: hashes.SHA1,
  [sigAlgs.RSASHA3_256]: hashes.SHA3_256,
  [sigAlgs.RSASHA3_384]: hashes.SHA3_384,
  [sigAlgs.RSASHA3_512]: hashes.SHA3_512,
  [sigAlgs.ECDSASHA1]: hashes.SHA1,
  [sigAlgs.ECDSASHA224]: hashes.SHA224,
  [sigAlgs.ECDSASHA384]: hashes.SHA384,
  [sigAlgs.ECDSASHA512]: hashes.SHA512,
  [sigAlgs.EDDSA]: null
};

/*
 * Expose
 */

exports.NONE = NONE;
exports.attrs = attrs;
exports.attrsByVal = attrsByVal;
exports.keyAlgs = keyAlgs;
exports.keyAlgsByVal = keyAlgsByVal;
exports.hashes = hashes;
exports.hashesByVal = hashesByVal;
exports.curves = curves;
exports.curvesByVal = curvesByVal;
exports.sigAlgs = sigAlgs;
exports.sigAlgsByVal = sigAlgsByVal;
exports.sigToHash = sigToHash;

},{}],79:[function(req,module,exports){
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */

'use strict';

const assert = req('bsert');
const BN = req('../bn.js');
const random = req('../random');

/*
 * Constants
 */

const smallPrimes = new Uint8Array([
   3,  5,  7,
  11, 13, 17,
  19, 23, 29,
  31, 37, 41,
  43, 47, 53
]);

const smallPrimesProduct = new BN('16294579238595022365', 10);

const primeBitMaskLo = 0
  | (1 << 2)
  | (1 << 3)
  | (1 << 5)
  | (1 << 7)
  | (1 << 11)
  | (1 << 13)
  | (1 << 17)
  | (1 << 19)
  | (1 << 23)
  | (1 << 29)
  | (1 << 31);

const primeBitMaskHi = 0
  | (1 << (37 - 32))
  | (1 << (41 - 32))
  | (1 << (43 - 32))
  | (1 << (47 - 32))
  | (1 << (53 - 32))
  | (1 << (59 - 32))
  | (1 << (61 - 32));

const primesA = new BN(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37);
const primesB = new BN(29 * 31 * 41 * 43 * 47 * 53);

// https://github.com/golang/go/blob/aadaec5/src/crypto/rand/util.go#L31
function randomPrime(bits, reps = 20, rng = random) {
  assert((bits >>> 0) === bits);
  assert((reps >>> 0) === reps);
  assert(bits >= 2);
  assert(rng && typeof rng.randomBytes === 'function');

  let b = bits % 8;

  if (b === 0)
    b = 8;

  const len = (bits + 7) >>> 3;

  for (;;) {
    const bytes = rng.randomBytes(len);

    bytes[0] &= (1 << b) - 1;

    if (b >= 2) {
      bytes[0] |= 3 << (b - 2);
    } else {
      bytes[0] |= 1;
      if (bytes.length > 1)
        bytes[1] |= 0x80;
    }

    bytes[bytes.length - 1] |= 1;

    const p = new BN(bytes);
    const mod = p.mod(smallPrimesProduct);

next:
    for (let delta = 0; delta < (1 << 20); delta += 2) {
      const m = mod.addn(delta);

      for (let i = 0; i < smallPrimes.length; i++) {
        const prime = smallPrimes[i];
        if (m.modrn(prime) === 0 && (bits > 6 || m.cmpn(prime) !== 0))
          continue next;
      }

      if (delta > 0)
        p.iaddn(delta);

      break;
    }

    if (p.bitLength() !== bits)
      continue;

    if (!probablyPrime(p, reps, rng))
      continue;

    return p;
  }
}

// https://github.com/golang/go/blob/aadaec5/src/math/big/prime.go#L26
function probablyPrime(x, reps, rng = random) {
  assert(x instanceof BN);

  if (x.isNeg() || x.isZero())
    return false;

  if (x.cmpn(64) < 0) {
    const w = x.andln(0xff);

    if (w > 31)
      return (primeBitMaskHi & (1 << (w - 32))) !== 0;

    return (primeBitMaskLo & (1 << w)) !== 0;
  }

  if (!x.isOdd())
    return false;

  const ra = x.mod(primesA).toNumber();
  const rb = x.mod(primesB).toNumber();

  if (ra % 3 === 0
      || ra % 5 === 0
      || ra % 7 === 0
      || ra % 11 === 0
      || ra % 13 === 0
      || ra % 17 === 0
      || ra % 19 === 0
      || ra % 23 === 0
      || ra % 37 === 0
      || rb % 29 === 0
      || rb % 31 === 0
      || rb % 41 === 0
      || rb % 43 === 0
      || rb % 47 === 0
      || rb % 53 === 0) {
    return false;
  }

  if (!x.isPrime(rng, reps))
    return false;

  return true;
}

/*
 * Expose
 */

exports.randomPrime = randomPrime;
exports.probablyPrime = probablyPrime;

},{"../bn.js":31,"../random":162,"bsert":190}],80:[function(req,module,exports){
(function (Buffer){
/*!
 * rsakey.js - RSA keys for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7517
 *   https://tools.ietf.org/html/rfc7518
 */

'use strict';

const assert = req('bsert');
const base64 = req('../encoding/base64');
const {countLeft, trimLeft} = req('../encoding/util');
const {custom} = req('./custom');

/*
 * Constants
 */

const DEFAULT_BITS = 2048;
const DEFAULT_EXP = 65537;
const MIN_BITS = 512;
const MAX_BITS = 16384;
const MIN_EXP = 3;
const MAX_EXP = (2 ** 33) - 1;
const MIN_EXP_BITS = 2;
const MAX_EXP_BITS = 33;
const ZERO = Buffer.alloc(1, 0x00);

/**
 * RSAKey
 */

class RSAKey {
  constructor() {
    this.n = ZERO; // modulus
    this.e = ZERO; // public exponent
  }

  setN(n) {
    this.n = trimLeft(n);
    return this;
  }

  setE(e) {
    if (typeof e === 'number')
      e = toU64(e);

    this.e = trimLeft(e);

    return this;
  }

  bits() {
    return countLeft(this.n);
  }

  size() {
    return (this.bits() + 7) >>> 3;
  }

  pad(sig) {
    assert(Buffer.isBuffer(sig));

    const bits = this.bits();

    if (bits < MIN_BITS || bits > MAX_BITS)
      return sig;

    const size = (bits + 7) >>> 3;

    if (sig.length >= size)
      return sig;

    const out = Buffer.allocUnsafe(size);
    const pos = size - sig.length;

    out.fill(0x00, 0, pos);
    sig.copy(out, pos);

    return out;
  }

  toPublic() {
    return this;
  }

  toJSON() {
    return {
      kty: 'RSA',
      n: base64.encodeURL(this.n),
      e: base64.encodeURL(this.e),
      ext: true
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(json.kty === 'RSA');

    this.n = base64.decodeURL(json.n);
    this.e = base64.decodeURL(json.e);

    return this;
  }

  [custom]() {
    return this.format();
  }

  format() {
    return {
      bits: this.bits(),
      n: this.n.toString('hex'),
      e: this.e.toString('hex')
    };
  }

  static fromJSON(json) {
    return new this().fromJSON(json);
  }
}

/**
 * RSAPublicKey
 */

class RSAPublicKey extends RSAKey {
  constructor(n, e) {
    super();
    this.n = trimLeft(n); // modulus
    this.e = trimLeft(e); // public exponent
  }
}

/**
 * RSAPrivateKey
 */

class RSAPrivateKey extends RSAKey {
  constructor(n, e, d, p, q, dp, dq, qi) {
    super();
    this.n = trimLeft(n); // modulus
    this.e = trimLeft(e); // public exponent
    this.d = trimLeft(d); // private exponent
    this.p = trimLeft(p); // prime1
    this.q = trimLeft(q); // prime2
    this.dp = trimLeft(dp); // exponent1
    this.dq = trimLeft(dq); // exponent2
    this.qi = trimLeft(qi); // coefficient
  }

  setD(d) {
    this.d = trimLeft(d);
    return this;
  }

  setP(p) {
    this.p = trimLeft(p);
    return this;
  }

  setQ(q) {
    this.q = trimLeft(q);
    return this;
  }

  setDP(dp) {
    this.dp = trimLeft(dp);
    return this;
  }

  setDQ(dq) {
    this.dq = trimLeft(dq);
    return this;
  }

  setQI(qi) {
    this.qi = trimLeft(qi);
    return this;
  }

  toPublic() {
    const key = new RSAPublicKey();
    key.n = this.n;
    key.e = this.e;
    return key;
  }

  toJSON() {
    return {
      kty: 'RSA',
      n: base64.encodeURL(this.n),
      e: base64.encodeURL(this.e),
      d: base64.encodeURL(this.d),
      p: base64.encodeURL(this.p),
      q: base64.encodeURL(this.q),
      dp: base64.encodeURL(this.dp),
      dq: base64.encodeURL(this.dq),
      qi: base64.encodeURL(this.qi),
      ext: true
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(json.kty === 'RSA');

    if (json.n != null)
      this.n = base64.decodeURL(json.n);

    if (json.e != null)
      this.e = base64.decodeURL(json.e);

    if (json.d != null)
      this.d = base64.decodeURL(json.d);

    if (json.p != null)
      this.p = base64.decodeURL(json.p);

    if (json.q != null)
      this.q = base64.decodeURL(json.q);

    if (json.dp != null)
      this.dp = base64.decodeURL(json.dp);

    if (json.dq != null)
      this.dq = base64.decodeURL(json.dq);

    if (json.qi != null)
      this.qi = base64.decodeURL(json.qi);

    return this;
  }

  format() {
    return {
      bits: this.bits(),
      n: this.n.toString('hex'),
      e: this.e.toString('hex'),
      d: this.d.toString('hex'),
      p: this.p.toString('hex'),
      q: this.q.toString('hex'),
      dp: this.dp.toString('hex'),
      dq: this.dq.toString('hex'),
      qi: this.qi.toString('hex')
    };
  }
}

/*
 * Helpers
 */

function toU64(n) {
  assert(Number.isSafeInteger(n) && n >= 0);

  const hi = (n * (1 / 0x100000000)) >>> 0;
  const lo = n >>> 0;

  const b = Buffer.allocUnsafe(8);
  b[0] = 0;
  b[1] = 0;
  b[2] = hi >>> 8;
  b[3] = hi;
  b[4] = lo >>> 24;
  b[5] = lo >>> 16;
  b[6] = lo >>> 8;
  b[7] = lo;

  return b;
}

/*
 * Expose
 */

exports.DEFAULT_BITS = DEFAULT_BITS;
exports.DEFAULT_EXP = DEFAULT_EXP;
exports.MIN_BITS = MIN_BITS;
exports.MAX_BITS = MAX_BITS;
exports.MIN_EXP = MIN_EXP;
exports.MAX_EXP = MAX_EXP;
exports.MIN_EXP_BITS = MIN_EXP_BITS;
exports.MAX_EXP_BITS = MAX_EXP_BITS;

exports.RSAKey = RSAKey;
exports.RSAPublicKey = RSAPublicKey;
exports.RSAPrivateKey = RSAPrivateKey;

}).call(this,req("buffer").Buffer)
},{"../encoding/base64":50,"../encoding/util":63,"./custom":73,"bsert":190,"buffer":303}],81:[function(req,module,exports){
(function (Buffer){
/*!
 * signature.js - signatures for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Parts of this software are based on bitcoin-core/secp256k1:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/bitcoin-core/secp256k1
 *
 * Resources:
 *   https://github.com/indutny/elliptic/blob/master/lib/elliptic/ec/signature.js
 *   https://github.com/bitcoin-core/secp256k1/blob/master/src/ecdsa_impl.h
 *   https://github.com/bitcoin-core/secp256k1/blob/master/contrib/lax_der_parsing.c
 */

'use strict';

const assert = req('bsert');
const {trimLeft, padLeft} = req('../encoding/util');

/**
 * Signature
 */

class Signature {
  constructor(size = 0, r, s) {
    this.r = padLeft(r, size);
    this.s = padLeft(s, size);
    this.param = 0;
  }

  setR(r, size) {
    this.r = padLeft(r, size);
    return this;
  }

  setS(s, size) {
    this.s = padLeft(s, size);
    return this;
  }

  encode(size) {
    assert((size >>> 0) === size);
    assert(size < 0x7d);
    assert(this.r.length === size);
    assert(this.s.length === size);

    const raw = Buffer.allocUnsafe(size * 2);

    this.r.copy(raw, 0);
    this.s.copy(raw, size);

    return raw;
  }

  decode(data, size) {
    assert(Buffer.isBuffer(data));
    assert((size >>> 0) === size);
    assert(data.length === size * 2);

    this.r = data.slice(0, size);
    this.s = data.slice(size, size * 2);

    return this;
  }

  toDER(size) {
    assert((size >>> 0) === size);
    assert(size < 0x7d);
    assert(this.r.length === size);
    assert(this.s.length === size);

    const r = encodeInt(this.r);
    const s = encodeInt(this.s);

    const seq = 2 + r.length + 2 + s.length;
    const wide = seq >= 0x80 ? 1 : 0;
    const len = 2 + wide + seq;
    const buf = Buffer.allocUnsafe(len);

    let p = 0;

    buf[p++] = 0x30;

    if (wide)
      buf[p++] = 0x81;

    buf[p++] = seq;
    buf[p++] = 0x02;
    buf[p++] = r.length;

    p += r.copy(buf, p);

    buf[p++] = 0x02;
    buf[p++] = s.length;

    p += s.copy(buf, p);

    assert(p === len);

    return buf;
  }

  fromDER(data, size) {
    assert(Buffer.isBuffer(data));
    assert((size >>> 0) === size);

    let len = 0;
    let pos = 0;
    let rlen = 0;
    let slen = 0;
    let r = null;
    let s = null;

    // Sequence tag byte.
    assert(pos + 1 <= data.length);
    assert(data[pos] === 0x30);
    pos += 1;

    // Sequence length bytes.
    assert(pos + 1 <= data.length);
    len = data[pos];
    pos += 1;

    if (len & 0x80) {
      len -= 0x80;
      assert(pos + len <= data.length);
      pos += len;
    }

    // Integer tag byte for R.
    assert(pos + 1 <= data.length);
    assert(data[pos] === 0x02);
    pos += 1;

    // Integer length for R.
    assert(pos + 1 <= data.length);
    len = data[pos];
    pos += 1;

    if (len & 0x80) {
      len -= 0x80;

      assert(pos + len <= data.length);

      while (len > 0 && data[pos] === 0x00) {
        len -= 1;
        pos += 1;
      }

      assert(len <= 6);

      while (len > 0) {
        rlen *= 0x100;
        rlen += data[pos];
        len -= 1;
        pos += 1;
      }
    } else {
      rlen = len;
    }

    // Ignore leading zeroes in R.
    assert(pos + rlen <= data.length);

    while (rlen > 0 && data[pos] === 0x00) {
      rlen -= 1;
      pos += 1;
    }

    if (rlen > size)
      r = Buffer.alloc(size, 0x00);
    else
      r = data.slice(pos, pos + rlen);

    pos += rlen;

    // Integer tag byte for S.
    assert(pos + 1 <= data.length);
    assert(data[pos] === 0x02);
    pos += 1;

    // Integer length for S.
    assert(pos + 1 <= data.length);
    len = data[pos];
    pos += 1;

    if (len & 0x80) {
      len -= 0x80;

      assert(pos + len <= data.length);

      while (len > 0 && data[pos] === 0x00) {
        len -= 1;
        pos += 1;
      }

      assert(len <= 6);

      while (len > 0) {
        slen *= 0x100;
        slen += data[pos];
        len -= 1;
        pos += 1;
      }
    } else {
      slen = len;
    }

    // Ignore leading zeroes in S.
    assert(pos + slen <= data.length);

    while (slen > 0 && data[pos] === 0x00) {
      slen -= 1;
      pos += 1;
    }

    if (slen > size)
      s = Buffer.alloc(size, 0x00);
    else
      s = data.slice(pos, pos + slen);

    pos += slen;

    this.r = padLeft(r, size);
    this.s = padLeft(s, size);

    return this;
  }

  static decode(data, size) {
    return new this().decode(data, size);
  }

  static fromDER(data, size) {
    return new this().fromDER(data, size);
  }

  static toRS(raw, size) {
    const sig = Signature.fromDER(raw, size);
    return sig.encode(size);
  }

  static toDER(raw, size) {
    const sig = Signature.decode(raw, size);
    return sig.toDER(size);
  }
}

/*
 * Helpers
 */

function encodeInt(buf) {
  const val = trimLeft(buf);

  if (val[0] & 0x80) {
    const out = Buffer.allocUnsafe(1 + val.length);
    out[0] = 0x00;
    val.copy(out, 1);
    return out;
  }

  return val;
}

/*
 * Expose
 */

module.exports = Signature;

}).call(this,req("buffer").Buffer)
},{"../encoding/util":63,"bsert":190,"buffer":303}],82:[function(req,module,exports){
(function (Buffer){
/*!
 * aead.js - aead for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7539#section-2.8
 *   https://github.com/openssh/openssh-portable
 */

'use strict';

const assert = req('bsert');
const ChaCha20 = req('./chacha20');
const Poly1305 = req('./poly1305');

/**
 * AEAD
 */

class AEAD {
  /**
   * Create an AEAD context.
   * @constructor
   */

  constructor() {
    this.chacha20 = new ChaCha20();
    this.poly1305 = new Poly1305();
    this.aadLen = 0;
    this.cipherLen = 0;
    this.hasCipher = false;
    this.polyKey = null;
  }

  /**
   * Initialize the AEAD with a key and iv.
   * @param {Buffer} key
   * @param {Buffer} iv - IV / packet sequence number.
   */

  init(key, iv) {
    assert(Buffer.isBuffer(key));
    assert(Buffer.isBuffer(iv));

    const polyKey = Buffer.alloc(32, 0x00);

    this.chacha20.init(key, iv, 0);
    this.chacha20.encrypt(polyKey);
    this.poly1305.init(polyKey);

    // We need to encrypt a full block
    // to get the cipher in the correct state.
    this.chacha20.encrypt(Buffer.alloc(32, 0x00));

    // Expose for debugging.
    this.polyKey = polyKey;

    this.aadLen = 0;
    this.cipherLen = 0;
    this.hasCipher = false;

    return this;
  }

  /**
   * Update the aad (will be finalized
   * on an encrypt/decrypt call).
   * @param {Buffer} aad
   */

  aad(data) {
    assert(!this.hasCipher, 'Cannot update aad.');
    this.poly1305.update(data);
    this.aadLen += data.length;
    return this;
  }

  /**
   * Encrypt a piece of data.
   * @param {Buffer} data
   */

  encrypt(data) {
    if (!this.hasCipher)
      this._pad16(this.aadLen);

    this.chacha20.encrypt(data);
    this.poly1305.update(data);

    this.cipherLen += data.length;
    this.hasCipher = true;

    return data;
  }

  /**
   * Decrypt a piece of data.
   * @param {Buffer} data
   */

  decrypt(data) {
    assert(Buffer.isBuffer(data));

    if (!this.hasCipher)
      this._pad16(this.aadLen);

    this.cipherLen += data.length;
    this.hasCipher = true;

    this.poly1305.update(data);
    this.chacha20.encrypt(data);

    return data;
  }

  /**
   * Authenticate data without decrypting.
   * @param {Buffer} data
   */

  auth(data) {
    assert(Buffer.isBuffer(data));

    if (!this.hasCipher)
      this._pad16(this.aadLen);

    this.cipherLen += data.length;
    this.hasCipher = true;

    this.poly1305.update(data);

    return data;
  }

  /**
   * Finalize the aead and generate a MAC.
   * @returns {Buffer} MAC
   */

  final() {
    const len = Buffer.allocUnsafe(16);

    let lo, hi;

    // The RFC says these are supposed to be
    // uint32le, but their own fucking test
    // cases fail unless they are uint64le's.
    lo = this.aadLen % 0x100000000;
    hi = (this.aadLen - lo) / 0x100000000;
    writeU32(len, lo, 0);
    writeU32(len, hi, 4);

    lo = this.cipherLen % 0x100000000;
    hi = (this.cipherLen - lo) / 0x100000000;
    writeU32(len, lo, 8);
    writeU32(len, hi, 12);

    if (!this.hasCipher)
      this._pad16(this.aadLen);

    this._pad16(this.cipherLen);
    this.poly1305.update(len);

    return this.poly1305.final();
  }

  /**
   * Pad a chunk before updating mac.
   * @private
   * @param {Number} size
   */

  _pad16(size) {
    size %= 16;

    if (size === 0)
      return;

    const pad = Buffer.allocUnsafe(16 - size);
    pad.fill(0);

    this.poly1305.update(pad);
  }

  /**
   * Encrypt a piece of data.
   * @param {Buffer} key
   * @param {Buffer} iv
   * @param {Buffer} msg
   * @param {Buffer?} aad
   * @returns {Buffer} tag
   */

  static encrypt(key, iv, msg, aad) {
    const aead = new AEAD();

    aead.init(key, iv);

    if (aad)
      aead.aad(aad);

    aead.encrypt(msg);

    return aead.final();
  }

  /**
   * Decrypt a piece of data.
   * @param {Buffer} key
   * @param {Buffer} iv
   * @param {Buffer} msg
   * @param {Buffer} tag
   * @param {Buffer?} aad
   * @returns {Boolean}
   */

  static decrypt(key, iv, msg, tag, aad) {
    const aead = new AEAD();

    aead.init(key, iv);

    if (aad)
      aead.aad(aad);

    aead.decrypt(msg);

    return AEAD.verify(aead.final(), tag);
  }

  /**
   * Authenticate data without decrypting.
   * @param {Buffer} key
   * @param {Buffer} iv
   * @param {Buffer} msg
   * @param {Buffer} tag
   * @param {Buffer?} aad
   * @returns {Boolean}
   */

  static auth(key, iv, msg, tag, aad) {
    const aead = new AEAD();

    aead.init(key, iv);

    if (aad)
      aead.aad(aad);

    aead.auth(msg);

    return AEAD.verify(aead.final(), tag);
  }

  /**
   * Compare two MACs in constant time.
   * @param {Buffer} mac1
   * @param {Buffer} mac2
   * @returns {Boolean}
   */

  static verify(mac1, mac2) {
    return Poly1305.verify(mac1, mac2);
  }
}

/*
 * Static
 */

AEAD.native = ChaCha20.native;

/*
 * Helpers
 */

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = AEAD;

}).call(this,req("buffer").Buffer)
},{"./chacha20":90,"./poly1305":121,"bsert":190,"buffer":303}],83:[function(req,module,exports){
(function (Buffer){
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const AES = req('./ciphers/aes');
const {CBCCipher, CBCDecipher} = req('./ciphers/modes');

/**
 * Encrypt data with aes 256 cbc.
 * @param {Buffer} data
 * @param {Buffer} key
 * @param {Buffer} iv
 * @returns {Buffer}
 */

function encipher(data, key, iv) {
  const ctx = new CBCCipher(new AES(256));
  ctx.init(key, iv);
  return concat(ctx.update(data), ctx.final());
}

/**
 * Decrypt data with aes 256 cbc.
 * @param {Buffer} data
 * @param {Buffer} key
 * @param {Buffer} iv
 * @returns {Buffer}
 */

function decipher(data, key, iv) {
  const ctx = new CBCDecipher(new AES(256));
  ctx.init(key, iv);
  return concat(ctx.update(data), ctx.final());
}

/*
 * Helpers
 */

function concat(a, b) {
  const data = Buffer.allocUnsafe(a.length + b.length);
  a.copy(data, 0);
  b.copy(data, a.length);
  return data;
}

/*
 * Expose
 */

exports.native = 0;
exports.encipher = encipher;
exports.decipher = decipher;

}).call(this,req("buffer").Buffer)
},{"./ciphers/aes":92,"./ciphers/modes":99,"buffer":303}],84:[function(req,module,exports){
(function (Buffer){
/*!
 * base58.js - base58 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const CHARSET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8, -1, -1, -1, -1, -1, -1,
  -1,  9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1,
  22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1,
  -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46,
  47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1
];

/**
 * Encode a base58 string.
 * @param {Buffer} data
 * @returns {String}
 */

function encode(data) {
  assert(Buffer.isBuffer(data));

  let zeroes = 0;
  let i = 0;

  for (; i < data.length; i++) {
    if (data[i] !== 0)
      break;

    zeroes += 1;
  }

  const b58 = Buffer.allocUnsafe(((data.length * 138 / 100) | 0) + 1);

  b58.fill(0);

  let length = 0;

  for (; i < data.length; i++) {
    let carry = data[i];
    let j = 0;

    for (let k = b58.length - 1; k >= 0; k--, j++) {
      if (carry === 0 && j >= length)
        break;

      carry += 256 * b58[k];
      b58[k] = carry % 58;
      carry = (carry / 58) | 0;
    }

    assert(carry === 0);

    length = j;
  }

  i = b58.length - length;

  while (i < b58.length && b58[i] === 0)
    i += 1;

  let str = '';

  for (let j = 0; j < zeroes; j++)
    str += '1';

  for (; i < b58.length; i++)
    str += CHARSET[b58[i]];

  return str;
}

/**
 * Decode a base58 string.
 * @param {String} str
 * @returns {Buffer}
 * @throws on non-base58 character.
 */

function decode(str) {
  assert(typeof str === 'string');

  let zeroes = 0;
  let i = 0;

  for (; i < str.length; i++) {
    if (str[i] !== '1')
      break;

    zeroes += 1;
  }

  const b256 = Buffer.allocUnsafe(((str.length * 733) / 1000 | 0) + 1);

  b256.fill(0);

  let length = 0;

  for (; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    const v = (ch & 0xff80) ? -1 : TABLE[ch];

    if (v === -1)
      throw new Error('Non-base58 character.');

    let carry = v;
    let j = 0;

    for (let k = b256.length - 1; k >= 0; k--, j++) {
      if (carry === 0 && j >= length)
        break;

      carry += 58 * b256[k];
      b256[k] = carry & 0xff;
      carry >>>= 8;
    }

    assert(carry === 0);

    length = j;
  }

  i = 0;

  while (i < b256.length && b256[i] === 0)
    i += 1;

  const out = Buffer.allocUnsafe(zeroes + (b256.length - i));

  let j;

  for (j = 0; j < zeroes; j++)
    out[j] = 0;

  while (i < b256.length)
    out[j++] = b256[i++];

  return out;
}

/**
 * Test whether the string is a base58 string.
 * @param {String} str
 * @returns {Buffer}
 */

function test(str) {
  assert(typeof str === 'string');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch & 0xff80)
      return false;

    if (TABLE[ch] === -1)
      return false;
  }

  return true;
}

/*
 * Expose
 */

exports.native = 0;
exports.encode = encode;
exports.decode = decode;
exports.test = test;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],85:[function(req,module,exports){
(function (Buffer){
/*!
 * bech32.js - bech32 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bech32:
 *   Copyright (c) 2017, Pieter Wuille (MIT License).
 *   https://github.com/sipa/bech32
 *
 * Resources:
 *   https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 *   https://github.com/sipa/bech32/blob/master/ref/c/segwit_addr.c
 *   https://github.com/bitcoin/bitcoin/blob/master/src/bech32.cpp
 */

'use strict';

const assert = req('bsert');

/**
 * Constants
 */

const POOL66 = Buffer.allocUnsafe(66);
const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
];

/**
 * Update checksum.
 * @ignore
 * @param {Number} chk
 * @returns {Number}
 */

function polymod(pre) {
  const b = pre >>> 25;
  return ((pre & 0x1ffffff) << 5)
    ^ (-((b >>> 0) & 1) & 0x3b6a57b2)
    ^ (-((b >>> 1) & 1) & 0x26508e6d)
    ^ (-((b >>> 2) & 1) & 0x1ea119fa)
    ^ (-((b >>> 3) & 1) & 0x3d4233dd)
    ^ (-((b >>> 4) & 1) & 0x2a1462b3);
}

/**
 * Encode hrp and data as a bech32 string.
 * @param {String} hrp
 * @param {Buffer} data
 * @returns {String}
 */

function serialize(hrp, data) {
  assert(typeof hrp === 'string');
  assert(Buffer.isBuffer(data));

  let chk = 1;
  let i;

  for (i = 0; i < hrp.length; i++) {
    const ch = hrp.charCodeAt(i);

    if ((ch & 0xff00) || (ch >>> 5) === 0)
      throw new Error('Invalid bech32 character.');

    chk = polymod(chk) ^ (ch >>> 5);
  }

  if (i + 7 + data.length > 90)
    throw new Error('Invalid bech32 data length.');

  chk = polymod(chk);

  let str = '';

  for (let i = 0; i < hrp.length; i++) {
    const ch = hrp.charCodeAt(i);
    chk = polymod(chk) ^ (ch & 0x1f);
    str += hrp[i];
  }

  str += '1';

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];

    if ((ch >>> 5) !== 0)
      throw new Error('Invalid bech32 value.');

    chk = polymod(chk) ^ ch;
    str += CHARSET[ch];
  }

  for (let i = 0; i < 6; i++)
    chk = polymod(chk);

  chk ^= 1;

  for (let i = 0; i < 6; i++)
    str += CHARSET[(chk >>> ((5 - i) * 5)) & 0x1f];

  return str;
}

/**
 * Decode a bech32 string.
 * @param {String} str
 * @returns {Array} [hrp, data]
 */

function deserialize(str) {
  assert(typeof str === 'string');

  if (str.length < 8 || str.length > 90)
    throw new Error('Invalid bech32 string length.');

  let dlen = 0;

  while (dlen < str.length && str[(str.length - 1) - dlen] !== '1')
    dlen += 1;

  const hlen = str.length - (1 + dlen);

  if (1 + dlen >= str.length || dlen < 6)
    throw new Error('Invalid bech32 data length.');

  dlen -= 6;

  const data = Buffer.allocUnsafe(dlen);

  let chk = 1;
  let lower = false;
  let upper = false;
  let hrp = '';

  for (let i = 0; i < hlen; i++) {
    let ch = str.charCodeAt(i);

    if (ch < 0x21 || ch > 0x7e)
      throw new Error('Invalid bech32 character.');

    if (ch >= 0x61 && ch <= 0x7a) {
      lower = true;
    } else if (ch >= 0x41 && ch <= 0x5a) {
      upper = true;
      ch = (ch - 0x41) + 0x61;
    }

    hrp += String.fromCharCode(ch);
    chk = polymod(chk) ^ (ch >>> 5);
  }

  chk = polymod(chk);

  let i;
  for (i = 0; i < hlen; i++)
    chk = polymod(chk) ^ (str.charCodeAt(i) & 0x1f);

  i += 1;

  while (i < str.length) {
    const ch = str.charCodeAt(i);
    const v = (ch & 0xff80) ? -1 : TABLE[ch];

    if (v === -1)
      throw new Error('Invalid bech32 character.');

    if (ch >= 0x61 && ch <= 0x7a)
      lower = true;
    else if (ch >= 0x41 && ch <= 0x5a)
      upper = true;

    chk = polymod(chk) ^ v;

    if (i + 6 < str.length)
      data[i - (1 + hlen)] = v;

    i += 1;
  }

  if (lower && upper)
    throw new Error('Invalid bech32 casing.');

  if (chk !== 1)
    throw new Error('Invalid bech32 checksum.');

  return [hrp, data.slice(0, dlen)];
}

/**
 * Test whether a string is a bech32 string.
 * @param {String} str
 * @returns {Boolean}
 */

function is(str) {
  assert(typeof str === 'string');

  try {
    deserialize(str);
  } catch (e) {
    return false;
  }

  return true;
}

/**
 * Convert serialized data to another base.
 * @param {Buffer} input
 * @param {Number} i
 * @param {Buffer} output
 * @param {Number} j
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Boolean} pad
 * @returns {Buffer}
 */

function convert(input, i, output, j, frombits, tobits, pad) {
  assert(Buffer.isBuffer(input));
  assert((i >>> 0) === i);
  assert(Buffer.isBuffer(output));
  assert((j >>> 0) === j);
  assert((frombits & 0xff) === frombits);
  assert((tobits & 0xff) === tobits);
  assert(typeof pad === 'boolean');
  assert(frombits !== 0);
  assert(tobits !== 0);

  const maxv = (1 << tobits) - 1;

  let acc = 0;
  let bits = 0;

  for (; i < input.length; i++) {
    const value = input[i];

    if ((value >>> frombits) !== 0)
      throw new Error('Invalid bits.');

    acc = (acc << frombits) | value;
    bits += frombits;

    while (bits >= tobits) {
      bits -= tobits;
      output[j++] = (acc >>> bits) & maxv;
    }
  }

  if (pad) {
    if (bits)
      output[j++] = (acc << (tobits - bits)) & maxv;
  } else {
    if (bits >= frombits || ((acc << (tobits - bits)) & maxv))
      throw new Error('Invalid bits.');
  }

  assert(j <= output.length);

  return output.slice(0, j);
}

/**
 * Calculate size reqd for bit conversion.
 * @param {Number} len
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Boolean} pad
 * @returns {Number}
 */

function convertSize(len, frombits, tobits, pad) {
  assert((len >>> 0) === len);
  assert((frombits & 0xff) === frombits);
  assert((tobits & 0xff) === tobits);
  assert(typeof pad === 'boolean');
  assert(frombits !== 0);
  assert(tobits !== 0);

  let size = (len * frombits + (tobits - 1)) / tobits;

  size >>>= 0;

  if (pad)
    size += 1;

  return size;
}

/**
 * Convert serialized data to another base.
 * @param {Buffer} data
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Boolean} pad
 * @returns {Buffer}
 */

function convertBits(data, frombits, tobits, pad) {
  assert(Buffer.isBuffer(data));

  const size = convertSize(data.length, frombits, tobits, pad);
  const out = Buffer.allocUnsafe(size);

  return convert(data, 0, out, 0, frombits, tobits, pad);
}

/**
 * Serialize data to bech32 address.
 * @param {String} hrp
 * @param {Number} version
 * @param {Buffer} hash
 * @returns {String}
 */

function encode(hrp, version, hash) {
  assert(typeof hrp === 'string');
  assert((version & 0xff) === version);
  assert(Buffer.isBuffer(hash));

  if (version < 0 || version > 31)
    throw new Error('Invalid bech32 version.');

  if (hash.length < 2 || hash.length > 40)
    throw new Error('Invalid bech32 data length.');

  const out = POOL66;
  out[0] = version;

  const data = convert(hash, 0, out, 1, 8, 5, true);

  return serialize(hrp, data);
}

/**
 * Deserialize data from bech32 address.
 * @param {String} str
 * @returns {Array}
 */

function decode(str) {
  const [hrp, data] = deserialize(str);

  if (data.length === 0 || data.length > 65)
    throw new Error('Invalid bech32 data length.');

  const version = data[0];

  if (version > 31)
    throw new Error('Invalid bech32 version.');

  const hash = convert(data, 1, data, 0, 5, 8, false);

  if (hash.length < 2 || hash.length > 40)
    throw new Error('Invalid bech32 data length.');

  return [hrp, version, hash];
}

/**
 * Test whether a string is a bech32 string.
 * @param {String} str
 * @returns {Boolean}
 */

function test(str) {
  assert(typeof str === 'string');

  let data;

  try {
    [, data] = deserialize(str);
  } catch (e) {
    return false;
  }

  if (data.length === 0 || data.length > 65)
    return false;

  const version = data[0];

  if (version > 31)
    return false;

  return true;
}

/*
 * Expose
 */

exports.native = 0;
exports.serialize = serialize;
exports.deserialize = deserialize;
exports.is = is;
exports.convertBits = convertBits;
exports.encode = encode;
exports.decode = decode;
exports.test = test;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],86:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2b.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dcposch/blakejs:
 *   Daniel Clemens Posch (CC0)
 *   https://github.com/dcposch/blakejs/blob/master/blake2b.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)
 *   https://tools.ietf.org/html/rfc7693
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = 0x80000000;

const IV = new Uint32Array([
  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85,
  0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,
  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
]);

const SIGMA = new Uint8Array([
  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,
  0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
  0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c,
  0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06,
  0x16, 0x10, 0x18, 0x00, 0x0a, 0x04, 0x1e, 0x1a,
  0x14, 0x1c, 0x06, 0x0c, 0x0e, 0x02, 0x12, 0x08,
  0x0e, 0x12, 0x06, 0x02, 0x1a, 0x18, 0x16, 0x1c,
  0x04, 0x0c, 0x0a, 0x14, 0x08, 0x00, 0x1e, 0x10,
  0x12, 0x00, 0x0a, 0x0e, 0x04, 0x08, 0x14, 0x1e,
  0x1c, 0x02, 0x16, 0x18, 0x0c, 0x10, 0x06, 0x1a,
  0x04, 0x18, 0x0c, 0x14, 0x00, 0x16, 0x10, 0x06,
  0x08, 0x1a, 0x0e, 0x0a, 0x1e, 0x1c, 0x02, 0x12,
  0x18, 0x0a, 0x02, 0x1e, 0x1c, 0x1a, 0x08, 0x14,
  0x00, 0x0e, 0x0c, 0x06, 0x12, 0x04, 0x10, 0x16,
  0x1a, 0x16, 0x0e, 0x1c, 0x18, 0x02, 0x06, 0x12,
  0x0a, 0x00, 0x1e, 0x08, 0x10, 0x0c, 0x04, 0x14,
  0x0c, 0x1e, 0x1c, 0x12, 0x16, 0x06, 0x00, 0x10,
  0x18, 0x04, 0x1a, 0x0e, 0x02, 0x08, 0x14, 0x0a,
  0x14, 0x04, 0x10, 0x08, 0x0e, 0x0c, 0x02, 0x0a,
  0x1e, 0x16, 0x12, 0x1c, 0x06, 0x18, 0x1a, 0x00,
  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,
  0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
  0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c,
  0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06
]);

const V = new Uint32Array(32);
const M = new Uint32Array(32);
const BLOCK = Buffer.alloc(128, 0x00);

/**
 * BLAKE2b
 */

class BLAKE2b {
  /**
   * Create a BLAKE2b context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(16);
    this.block = Buffer.allocUnsafe(128);
    this.size = 32;
    this.count = 0;
    this.pos = FINALIZED;
  }

  init(size = 32, key = null) {
    assert((size >>> 0) === size);
    assert(!key || Buffer.isBuffer(key));

    if (size === 0 || size > 64)
      throw new Error('Bad output length.');

    if (key && key.length > 64)
      throw new Error('Bad key length.');

    const klen = key ? key.length : 0;

    for (let i = 0; i < 16; i++)
      this.state[i] = IV[i];

    this.size = size;
    this.count = 0;
    this.pos = 0;

    this.state[0] ^= 0x01010000 ^ (klen << 8) ^ this.size;

    if (klen > 0) {
      const block = BLOCK;

      key.copy(block, 0);

      this.update(block);

      block.fill(0x00, 0, key.length);
    }

    return this;
  }

  update(data) {
    assert(Buffer.isBuffer(data));
    assert(!(this.pos & FINALIZED), 'Context already finalized.');

    let off = 0;
    let len = data.length;

    if (len > 0) {
      const left = this.pos;
      const fill = 128 - left;

      if (len > fill) {
        this.pos = 0;

        data.copy(this.block, left, off, off + fill);

        this.count += 128;
        this.compress(this.block, 0, false);

        off += fill;
        len -= fill;

        while (len > 128) {
          this.count += 128;
          this.compress(data, off, false);
          off += 128;
          len -= 128;
        }
      }

      data.copy(this.block, this.pos, off, off + len);

      this.pos += len;
    }

    return this;
  }

  final() {
    assert(!(this.pos & FINALIZED), 'Context already finalized.');

    this.count += this.pos;
    this.block.fill(0, this.pos, 128);
    this.compress(this.block, 0, true);
    this.pos = FINALIZED;

    const out = Buffer.allocUnsafe(this.size);

    for (let i = 0; i < this.size; i++)
      out[i] = this.state[i >>> 2] >>> (8 * (i & 3));

    for (let i = 0; i < 16; i++)
      this.state[i] = 0;

    for (let i = 0; i < 128; i++)
      this.block[i] = 0;

    return out;
  }

  compress(block, off, last) {
    for (let i = 0; i < 16; i++) {
      V[i] = this.state[i];
      V[i + 16] = IV[i];
    }

    // uint128
    V[24] ^= this.count;
    V[25] ^= this.count * (1 / 0x100000000);
    V[26] ^= 0;
    V[27] ^= 0;

    if (last) {
      // last block
      V[28] ^= -1;
      V[29] ^= -1;

      // last node
      V[29] ^= 0;
      V[30] ^= 0;
    }

    for (let i = 0; i < 32; i++) {
      M[i] = readU32(block, off);
      off += 4;
    }

    for (let i = 0; i < 12; i++) {
      G(V, M, 0, 8, 16, 24, SIGMA[i * 16 + 0], SIGMA[i * 16 + 1]);
      G(V, M, 2, 10, 18, 26, SIGMA[i * 16 + 2], SIGMA[i * 16 + 3]);
      G(V, M, 4, 12, 20, 28, SIGMA[i * 16 + 4], SIGMA[i * 16 + 5]);
      G(V, M, 6, 14, 22, 30, SIGMA[i * 16 + 6], SIGMA[i * 16 + 7]);
      G(V, M, 0, 10, 20, 30, SIGMA[i * 16 + 8], SIGMA[i * 16 + 9]);
      G(V, M, 2, 12, 22, 24, SIGMA[i * 16 + 10], SIGMA[i * 16 + 11]);
      G(V, M, 4, 14, 16, 26, SIGMA[i * 16 + 12], SIGMA[i * 16 + 13]);
      G(V, M, 6, 8, 18, 28, SIGMA[i * 16 + 14], SIGMA[i * 16 + 15]);
    }

    for (let i = 0; i < 16; i++)
      this.state[i] ^= V[i] ^ V[i + 16];
  }

  static hash() {
    return new BLAKE2b();
  }

  static hmac(size = 32) {
    return new HMAC(BLAKE2b, 128, [size]);
  }

  static digest(data, size = 32, key = null) {
    const ctx = BLAKE2b.ctx;
    ctx.init(size, key);
    ctx.update(data);
    return ctx.final();
  }

  static root(left, right, size = 32) {
    assert(Buffer.isBuffer(left) && left.length === size);
    assert(Buffer.isBuffer(right) && right.length === size);
    const ctx = BLAKE2b.ctx;
    ctx.init(size);
    ctx.update(left);
    ctx.update(right);
    return ctx.final();
  }

  static multi(x, y, z, size = 32) {
    const ctx = BLAKE2b.ctx;
    ctx.init(size);
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key, size = 32) {
    return BLAKE2b.hmac(size).init(key).update(data).final();
  }
}

/*
 * Static
 */

BLAKE2b.native = 0;
BLAKE2b.id = 'BLAKE2B256';
BLAKE2b.size = 32;
BLAKE2b.bits = 256;
BLAKE2b.blockSize = 128;
BLAKE2b.zero = Buffer.alloc(32, 0x00);
BLAKE2b.ctx = new BLAKE2b();

/*
 * Helpers
 */

function sum64(v, a, b) {
  const o0 = v[a] + v[b];

  let o1 = v[a + 1] + v[b + 1];

  if (o0 >= 0x100000000)
    o1 += 1;

  v[a] = o0;
  v[a + 1] = o1;
}

function sum64c(v, a, b0, b1) {
  const o0 = v[a] + b0;

  let o1 = v[a + 1] + b1;

  if (o0 >= 0x100000000)
    o1 += 1;

  v[a] = o0;
  v[a + 1] = o1;
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function G(v, m, a, b, c, d, ix, iy) {
  const x0 = m[ix];
  const x1 = m[ix + 1];
  const y0 = m[iy];
  const y1 = m[iy + 1];

  let xor0, xor1;

  // v[a,a+1] += v[b,b+1]
  sum64(v, a, b);
  // v[a, a+1] += x
  sum64c(v, a, x0, x1);

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotr 32
  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor1;
  v[d + 1] = xor0;

  sum64(v, c, d);

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotr 24
  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = (xor0 >>> 24) ^ (xor1 << 8);
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);

  sum64(v, a, b);
  sum64c(v, a, y0, y1);

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotr 16
  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = (xor0 >>> 16) ^ (xor1 << 16);
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);

  sum64(v, c, d);

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotr 63
  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = (xor1 >>> 31) ^ (xor0 << 1);
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
}

/*
 * Expose
 */

module.exports = BLAKE2b;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],87:[function(req,module,exports){
(function (Buffer){
/*!
 * blake2s.js - BLAKE2s implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dcposch/blakejs:
 *   Daniel Clemens Posch (CC0)
 *   https://github.com/dcposch/blakejs/blob/master/blake2s.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)
 *   https://tools.ietf.org/html/rfc7693
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = 0x80000000;

const IV = new Uint32Array([
  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);

const SIGMA = new Uint8Array([
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x0e, 0x0a, 0x04, 0x08, 0x09, 0x0f, 0x0d, 0x06,
  0x01, 0x0c, 0x00, 0x02, 0x0b, 0x07, 0x05, 0x03,
  0x0b, 0x08, 0x0c, 0x00, 0x05, 0x02, 0x0f, 0x0d,
  0x0a, 0x0e, 0x03, 0x06, 0x07, 0x01, 0x09, 0x04,
  0x07, 0x09, 0x03, 0x01, 0x0d, 0x0c, 0x0b, 0x0e,
  0x02, 0x06, 0x05, 0x0a, 0x04, 0x00, 0x0f, 0x08,
  0x09, 0x00, 0x05, 0x07, 0x02, 0x04, 0x0a, 0x0f,
  0x0e, 0x01, 0x0b, 0x0c, 0x06, 0x08, 0x03, 0x0d,
  0x02, 0x0c, 0x06, 0x0a, 0x00, 0x0b, 0x08, 0x03,
  0x04, 0x0d, 0x07, 0x05, 0x0f, 0x0e, 0x01, 0x09,
  0x0c, 0x05, 0x01, 0x0f, 0x0e, 0x0d, 0x04, 0x0a,
  0x00, 0x07, 0x06, 0x03, 0x09, 0x02, 0x08, 0x0b,
  0x0d, 0x0b, 0x07, 0x0e, 0x0c, 0x01, 0x03, 0x09,
  0x05, 0x00, 0x0f, 0x04, 0x08, 0x06, 0x02, 0x0a,
  0x06, 0x0f, 0x0e, 0x09, 0x0b, 0x03, 0x00, 0x08,
  0x0c, 0x02, 0x0d, 0x07, 0x01, 0x04, 0x0a, 0x05,
  0x0a, 0x02, 0x08, 0x04, 0x07, 0x06, 0x01, 0x05,
  0x0f, 0x0b, 0x09, 0x0e, 0x03, 0x0c, 0x0d, 0x00
]);

const V = new Uint32Array(16);
const M = new Uint32Array(16);
const BLOCK = Buffer.alloc(64, 0x00);

/**
 * BLAKE2s
 */

class BLAKE2s {
  /**
   * Create a BLAKE2s context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(8);
    this.block = Buffer.allocUnsafe(64);
    this.size = 32;
    this.count = 0;
    this.pos = FINALIZED;
  }

  init(size = 32, key = null) {
    assert((size >>> 0) === size);
    assert(!key || Buffer.isBuffer(key));

    if (size === 0 || size > 32)
      throw new Error('Bad output length.');

    if (key && key.length > 32)
      throw new Error('Bad key length.');

    const klen = key ? key.length : 0;

    for (let i = 0; i < 8; i++)
      this.state[i] = IV[i];

    this.size = size;
    this.count = 0;
    this.pos = 0;

    this.state[0] ^= 0x01010000 ^ (klen << 8) ^ this.size;

    if (klen > 0) {
      const block = BLOCK;

      key.copy(block, 0);

      this.update(block);

      block.fill(0x00, 0, key.length);
    }

    return this;
  }

  update(data) {
    assert(Buffer.isBuffer(data));
    assert(!(this.pos & FINALIZED), 'Context already finalized.');

    let off = 0;
    let len = data.length;

    if (len > 0) {
      const left = this.pos;
      const fill = 64 - left;

      if (len > fill) {
        this.pos = 0;

        data.copy(this.block, left, off, off + fill);

        this.count += 64;
        this.compress(this.block, 0, false);

        off += fill;
        len -= fill;

        while (len > 64) {
          this.count += 64;
          this.compress(data, off, false);
          off += 64;
          len -= 64;
        }
      }

      data.copy(this.block, this.pos, off, off + len);

      this.pos += len;
    }

    return this;
  }

  final() {
    assert(!(this.pos & FINALIZED), 'Context already finalized.');

    this.count += this.pos;
    this.block.fill(0, this.pos, 64);
    this.compress(this.block, 0, true);
    this.pos = FINALIZED;

    const out = Buffer.allocUnsafe(this.size);

    for (let i = 0; i < this.size; i++)
      out[i] = this.state[i >>> 2] >>> (8 * (i & 3));

    for (let i = 0; i < 8; i++)
      this.state[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    return out;
  }

  compress(block, off, last) {
    for (let i = 0; i < 8; i++) {
      V[i] = this.state[i];
      V[i + 8] = IV[i];
    }

    // uint64
    V[12] ^= this.count;
    V[13] ^= this.count * (1 / 0x100000000);

    if (last) {
      // last block
      V[14] ^= -1;

      // last node
      V[15] ^= 0;
    }

    for (let i = 0; i < 16; i++) {
      M[i] = readU32(block, off);
      off += 4;
    }

    for (let i = 0; i < 10; i++) {
      G(V, M, 0, 4, 8, 12, SIGMA[i * 16 + 0], SIGMA[i * 16 + 1]);
      G(V, M, 1, 5, 9, 13, SIGMA[i * 16 + 2], SIGMA[i * 16 + 3]);
      G(V, M, 2, 6, 10, 14, SIGMA[i * 16 + 4], SIGMA[i * 16 + 5]);
      G(V, M, 3, 7, 11, 15, SIGMA[i * 16 + 6], SIGMA[i * 16 + 7]);
      G(V, M, 0, 5, 10, 15, SIGMA[i * 16 + 8], SIGMA[i * 16 + 9]);
      G(V, M, 1, 6, 11, 12, SIGMA[i * 16 + 10], SIGMA[i * 16 + 11]);
      G(V, M, 2, 7, 8, 13, SIGMA[i * 16 + 12], SIGMA[i * 16 + 13]);
      G(V, M, 3, 4, 9, 14, SIGMA[i * 16 + 14], SIGMA[i * 16 + 15]);
    }

    for (let i = 0; i < 8; i++)
      this.state[i] ^= V[i] ^ V[i + 8];
  }

  static hash() {
    return new BLAKE2s();
  }

  static hmac(size = 32) {
    return new HMAC(BLAKE2s, 64, [size]);
  }

  static digest(data, size = 32, key = null) {
    const ctx = BLAKE2s.ctx;
    ctx.init(size, key);
    ctx.update(data);
    return ctx.final();
  }

  static root(left, right, size = 32) {
    assert(Buffer.isBuffer(left) && left.length === size);
    assert(Buffer.isBuffer(right) && right.length === size);
    const ctx = BLAKE2s.ctx;
    ctx.init(size);
    ctx.update(left);
    ctx.update(right);
    return ctx.final();
  }

  static multi(x, y, z, size = 32) {
    const ctx = BLAKE2s.ctx;
    ctx.init(size);
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key, size = 32) {
    return BLAKE2s.hmac(size).init(key).update(data).final();
  }
}

/*
 * Static
 */

BLAKE2s.native = 0;
BLAKE2s.id = 'BLAKE2S256';
BLAKE2s.size = 32;
BLAKE2s.bits = 256;
BLAKE2s.blockSize = 64;
BLAKE2s.zero = Buffer.alloc(32, 0x00);
BLAKE2s.ctx = new BLAKE2s();

/*
 * Helpers
 */

function rotr32(x, y) {
  return (x >>> y) ^ (x << (32 - y));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function G(v, m, a, b, c, d, ix, iy) {
  const x = m[ix];
  const y = m[iy];

  v[a] = v[a] + v[b] + x;
  v[d] = rotr32(v[d] ^ v[a], 16);
  v[c] = v[c] + v[d];
  v[b] = rotr32(v[b] ^ v[c], 12);
  v[a] = v[a] + v[b] + y;
  v[d] = rotr32(v[d] ^ v[a], 8);
  v[c] = v[c] + v[d];
  v[b] = rotr32(v[b] ^ v[c], 7);
}

/*
 * Expose
 */

module.exports = BLAKE2s;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],88:[function(req,module,exports){
(function (Buffer){
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */

/* eslint valid-typeof: "off" */

'use strict';

const {custom} = req('../internal/custom');

/*
 * Constants
 */

const zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

const groupSizes = [
  0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a,
  0x09, 0x08, 0x08, 0x07, 0x07, 0x07,
  0x07, 0x06, 0x06, 0x06, 0x06, 0x06,
  0x06, 0x06, 0x05, 0x05, 0x05, 0x05,
  0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
  0x05, 0x05, 0x05, 0x05, 0x05, 0x05
];

const groupBases = [
  0x00000000, 0x02000000, 0x0290d741, 0x01000000,
  0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000,
  0x0290d741, 0x00989680, 0x012959c3, 0x0222c000,
  0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000,
  0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000,
  0x003e5185, 0x004ea360, 0x006235f7, 0x00798000,
  0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00,
  0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000,
  0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400
];

const primes = {
  p192: null,
  p224: null,
  p521: null,
  k256: null,
  p25519: null,
  p448: null
};

const modes = {
  NONE: 0,
  QUO: 1,
  REM: 2,
  BOTH: 3,
  EUCLID: 4,
  ALL: 7
};

/**
 * BN
 */

class BN {
  constructor(num, base, endian) {
    this.words = [0];
    this.length = 1;
    this.negative = 0;
    this.red = null;
    this.from(num, base, endian);
  }

  /*
   * Addition
   */

  iadd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      this.isub(num);
      this.negative ^= 1;
      return this._normalize();
    }

    // positive + negative
    if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      const r = this.isub(num);
      num.negative = 1;
      return r._normalize();
    }

    // a.length > b.length
    let a = this;
    let b = num;

    if (a.length < b.length)
      [a, b] = [b, a];

    let carry = 0;
    let i = 0;

    if (a !== this)
      this._alloc(a.length);

    for (; i < b.length; i++) {
      const r = (a.words[i] | 0) + (b.words[i] | 0) + carry;

      this.words[i] = r & 0x3ffffff;

      carry = r >>> 26;
    }

    for (; carry !== 0 && i < a.length; i++) {
      const r = (a.words[i] | 0) + carry;

      this.words[i] = r & 0x3ffffff;

      carry = r >>> 26;
    }

    this.length = a.length;

    if (carry !== 0) {
      this._alloc(this.length + 1);
      this.words[this.length++] = carry;
    } else if (a !== this) {
      // Copy the rest of the words.
      for (; i < a.length; i++)
        this.words[i] = a.words[i];
    }

    // Note: we shouldn't need to strip here.
    return this;
  }

  iaddn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if (num < 0)
      return this.isubn(-num);

    // Possible sign change.
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;

      return this;
    }

    // Add without checks.
    return this._iaddn(num);
  }

  _iaddn(num) {
    this.words[0] += num;

    if (this.words[0] < 0x4000000)
      return this;

    // Carry.
    let i = 0;

    this._alloc(this.length + 1);

    this.words[this.length] = 0;

    for (; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      this.words[i + 1] += 1;
    }

    this.length = Math.max(this.length, i + 1);

    // Note: we shouldn't need to strip here.
    return this;
  }

  add(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      const res = this.sub(num);
      num.negative ^= 1;
      return res;
    }

    if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      const res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length)
      return this.clone().iadd(num);

    return num.clone().iadd(this);
  }

  addn(num) {
    return this.clone().iaddn(num);
  }

  /*
   * Subtraction
   */

  isub(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      const r = this.iadd(num);
      num.negative = 1;
      return r._normalize();
    }

    // -this - num = -(this + num)
    if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normalize();
    }

    // At this point both numbers are positive.
    const cmp = this.ucmp(num);

    // Optimization - zeroify.
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    let a = this;
    let b = num;

    if (cmp < 0)
      [a, b] = [b, a];

    let carry = 0;
    let i = 0;

    if (a !== this)
      this._alloc(a.length);

    for (; i < b.length; i++) {
      const r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    for (; carry !== 0 && i < a.length; i++) {
      const r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words.
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++)
        this.words[i] = a.words[i];
    }

    this.length = Math.max(this.length, i);

    if (a !== this)
      this.negative = 1;

    return this._strip();
  }

  isubn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if (num < 0)
      return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.words[0] >= 0)
      return this;

    if (this.length === 1) {
      this.words[0] = -this.words[0];
      this.negative = 1;
      return this;
    }

    // Carry.
    this._alloc(this.length + 1);

    for (let i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 0x4000000;
      this.words[i + 1] -= 1;
    }

    this.words[this.length] = 0;

    return this._strip();
  }

  sub(num) {
    return this.clone().isub(num);
  }

  subn(num) {
    return this.clone().isubn(num);
  }

  /*
   * Multiplication Engine
   */

  _mul(num, out) {
    enforce(BN.isBN(num), 'num', 'bignum');
    enforce(BN.isBN(out), 'out', 'bignum');

    if (this.length === 10 && num.length === 10)
      return comb10MulTo(this, num, out);

    const len = this.length + num.length;

    if (len < 63)
      return smallMulTo(this, num, out);

    return bigMulTo(this, num, out);
  }

  /*
   * Multiplication
   */

  imul(num) {
    return this.mul(num)._move(this);
  }

  imuln(num) {
    enforce(isSMI(num), 'num', 'smi');

    const neg = (num < 0) | 0;

    if (neg)
      num = -num;

    // Carry.
    let carry = 0;

    for (let i = 0; i < this.length; i++) {
      const w = this.words[i] * num;
      const lo = (w & 0x3ffffff) + (carry & 0x3ffffff);

      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      carry += lo >>> 26;

      this.words[i] = lo & 0x3ffffff;
    }

    this.negative ^= neg;

    if (carry !== 0) {
      this._alloc(this.length + 1);
      this.words[this.length++] = carry;
    } else {
      this._strip();
    }

    return this;
  }

  mul(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const len = this.length + num.length;
    const out = new BN();

    out.words = new Array(len);

    for (let i = 0; i < len; i ++)
      out.words[i] = 0;

    return this._mul(num, out);
  }

  muln(num) {
    return this.clone().imuln(num);
  }

  /*
   * Division Engine
   */

  _div(num, flags) {
    enforce(BN.isBN(num), 'num', 'bignum');
    assert((flags & modes.ALL) === flags);
    assert(flags !== modes.NONE);

    const a = this;
    const b = num;

    nonzero(!b.isZero());

    if (a.isZero())
      return [new BN(0), new BN(0)];

    const as = a.negative;
    const bs = b.negative;

    a.negative = 0;
    b.negative = 0;

    let q = null;
    let r = null;

    if (a.length < b.length || a.cmp(b) < 0) {
      q = new BN(0);
      r = a.clone();
    } else if (b.length === 1) {
      if (flags & modes.QUO)
        q = a.quon(b.words[0]);

      if (flags & modes.REM)
        r = a.remn(b.words[0]);
    } else {
      [q, r] = a._wordDiv(b, flags);
    }

    a.negative = as;
    b.negative = bs;

    if (flags & modes.QUO) {
      q.negative = a.negative ^ b.negative;
      q._normalize();
    }

    if (flags & modes.REM) {
      r.negative = a.negative;
      r._normalize();
    }

    if (flags & modes.EUCLID) {
      if (flags & modes.QUO) {
        assert((flags & modes.REM) !== 0);

        if (r.negative !== 0) {
          if (b.negative !== 0)
            q.iaddn(1);
          else
            q.isubn(1);
        }
      }

      if (flags & modes.REM) {
        if (r.negative !== 0) {
          if (b.negative !== 0)
            r.isub(b);
          else
            r.iadd(b);
        }
      }
    }

    return [q, r];
  }

  _wordDiv(num, flags) {
    let shift = this.length - num.length;
    let a = this.clone();
    let b = num;

    // Normalize.
    let bhi = b.words[b.length - 1] | 0;

    const bhiBits = countBits(bhi);

    shift = 26 - bhiBits;

    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient.
    const m = a.length - b.length;
    assert(m >= 0);

    let q = null;

    if (flags & modes.QUO) {
      q = new BN(0);
      q.length = m + 1;
      q.words = new Array(q.length);

      for (let i = 0; i < q.length; i++)
        q.words[i] = 0;
    }

    const diff = a.clone()._ishlnsubmul(b, 1, m);

    if (diff.negative === 0) {
      a = diff;
      if (q)
        q.words[m] = 1;
    }

    for (let j = m - 1; j >= 0; j--) {
      const ahi = a.words[b.length + j];
      const alo = a.words[b.length + j - 1];

      let qj = Math.min(((ahi * 0x4000000 + alo) / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);

      while (a.negative !== 0) {
        qj -= 1;

        a.negative = 0;
        a._ishlnsubmul(b, 1, j);

        if (!a.isZero())
          a.negative ^= 1;
      }

      if (q)
        q.words[j] = qj;
    }

    if (q)
      q._strip();

    a._strip();

    // Denormalize.
    if ((flags & modes.REM) && shift !== 0)
      a.iushrn(shift);

    return [q, a];
  }

  _ishlnsubmul(num, mul, shift) {
    const len = num.length + shift;

    this._expand(len);

    let carry = 0;
    let i = 0;
    let w;

    for (; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      const right = num.words[i] * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }

    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0)
      return this._strip();

    // Subtraction overflow.
    assert(carry === -1);
    carry = 0;

    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }

    this.negative = 1;

    return this._strip();
  }

  /*
   * Truncation Division + Modulo
   */

  quorem(num) {
    return this._div(num, modes.BOTH);
  }

  /*
   * Truncation Division
   */

  iquo(num) {
    return this.quo(num)._move(this);
  }

  iquon(num) {
    enforce(isSMI(num), 'num', 'smi');
    nonzero(num !== 0);

    const neg = (num < 0) | 0;

    if (neg)
      num = -num;

    let carry = 0;

    for (let i = this.length - 1; i >= 0; i--) {
      const w = (this.words[i] | 0) + carry * 0x4000000;

      this.words[i] = (w / num) | 0;

      carry = w % num;
    }

    this.negative ^= neg;

    return this._strip();
  }

  quo(num) {
    return this._div(num, modes.QUO)[0];
  }

  quon(num) {
    return this.clone().iquon(num);
  }

  /*
   * Truncation Modulo
   */

  irem(num) {
    return this.rem(num)._move(this);
  }

  iremn(num) {
    let m = this.remrn(num);

    if (m < 0)
      m = -m;

    this.words[0] = m;
    this.length = 1;

    return this._normalize();
  }

  rem(num) {
    return this._div(num, modes.REM)[1];
  }

  remn(num) {
    return this.clone().iremn(num);
  }

  remrn(num) {
    enforce(isSMI(num), 'num', 'smi');
    nonzero(num !== 0);

    if (num < 0)
      num = -num;

    const p = (1 << 26) % num;

    let acc = 0;

    for (let i = this.length - 1; i >= 0; i--)
      acc = (p * acc + (this.words[i] | 0)) % num;

    return this.negative ? (-acc | 0) : acc;
  }

  /*
   * Euclidean Division + Modulo
   */

  divmod(num) {
    return this._div(num, modes.BOTH | modes.EUCLID);
  }

  /*
   * Euclidean Division
   */

  idiv(num) {
    return this.div(num)._move(this);
  }

  idivn(num) {
    if (this.negative === 0)
      return this.iquon(num);

    const r = this.remrn(num);

    this.iquon(num);

    if (r < 0) {
      if (num < 0)
        this.iaddn(1);
      else
        this.isubn(1);
    }

    return this;
  }

  div(num) {
    return this._div(num, modes.BOTH | modes.EUCLID)[0];
  }

  divn(num) {
    return this.clone().idivn(num);
  }

  /*
   * Euclidean Modulo
   */

  imod(num) {
    if (this.ucmp(num) < 0) {
      if (this.negative !== 0) {
        if (num.negative !== 0)
          this.isub(num);
        else
          this.iadd(num);
      }
      return this;
    }

    return this.mod(num)._move(this);
  }

  imodn(num) {
    this.words[0] = this.modrn(num);
    this.length = 1;
    this.negative = 0;
    return this;
  }

  mod(num) {
    return this._div(num, modes.REM | modes.EUCLID)[1];
  }

  modn(num) {
    return this.clone().imodn(num);
  }

  modrn(num) {
    enforce(isSMI(num), 'num', 'smi');

    let r = this.remrn(num);

    if (r < 0) {
      if (num < 0)
        r -= num;
      else
        r += num;
    }

    return r;
  }

  /*
   * Round Division
   */

  divRound(num) {
    const [q, r] = this.quorem(num);

    // Fast case - exact division.
    if (r.isZero())
      return q;

    const bit = num.words[0] & 1;

    num.iushrn(1);

    const cmp = r.ucmp(num);

    num.iushln(1);

    num.words[0] |= bit;

    // Round down.
    if (cmp < 0 || (num.isOdd() && cmp === 0))
      return q;

    // Round up.
    if (this.negative ^ num.negative)
      return q.isubn(1);

    return q.iaddn(1);
  }

  /*
   * Exponentiation
   */

  ipow(num) {
    return this.pow(num)._move(this);
  }

  ipown(num) {
    enforce(isSMI(num), 'num', 'smi');

    let x = this;
    let y = Math.abs(num);
    let r = new BN(1);

    while (y > 0) {
      if (y & 1)
        r = r.imul(x);

      y >>>= 1;
      x = x.isqr();
    }

    return r._move(this);
  }

  pow(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const w = toBitArray(num);

    if (w.length === 0)
      return new BN(1);

    // Skip leading zeroes.
    let res = this;
    let i = 0;

    for (; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0)
        break;
    }

    if (++i < w.length) {
      for (let q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0)
          continue;

        res = res.mul(q);
      }
    }

    return res;
  }

  pown(num) {
    return this.clone().ipown(num);
  }

  isqr() {
    return this.imul(this);
  }

  sqr() {
    return this.mul(this);
  }

  isqrt() {
    return this.sqrt()._move(this);
  }

  sqrt() {
    range(this.negative === 0, 'sqrt');

    if (this.cmpn(1) <= 0)
      return this.clone();

    let r = new BN(1);

    r.iushln((this.bitLength() >>> 1) + 1);

    for (;;) {
      const z = this.quo(r);

      z.iadd(r);
      z.iushrn(1);

      if (z.cmp(r) >= 0)
        break;

      r = z;
    }

    return r;
  }

  isSquare() {
    if (this.negative !== 0)
      return false;

    return this.sqrt().isqr().eq(this);
  }

  /*
   * AND
   */

  iand(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let x = this;
    let y = num;

    if (x === y)
      return x;

    if ((x.negative | y.negative) === 0)
      return x.iuand(y);

    if ((x.negative & y.negative) === 1) {
      // (-x) & (-y) == ~(x-1) & ~(y-1)
      //             == ~((x-1) | (y-1))
      //             == -(((x-1) | (y-1)) + 1)
      //             == (-x+1) || (-y+1) - 1
      y.iaddn(1);
      x.iaddn(1).iuor(y).isubn(1);
      y.isubn(1);
      return x;
    }

    // Assume x is the positive number.
    if (x.negative !== 0)
      [x, y] = [y.clone(), x];

    // x & (-y) == x & ~(y-1)
    //          == x & ~(y-1)
    //          == x && ~(-y+1)
    const width = x.bitLength();

    y.iaddn(1).inotn(width);
    x.iuand(y);
    y.inotn(width).isubn(1);

    return x._move(this);
  }

  iandn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0)
      return this.iand(new BN(num));

    this.words[0] &= num;
    this.length = 1;

    return this;
  }

  and(num) {
    return this.clone().iand(num);
  }

  andn(num) {
    return this.clone().iandn(num);
  }

  andrn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0) {
      const n = this.iand(new BN(num));

      if (n.length > 1)
        throw new RangeError('Number exceeds 26 bits.');

      return n.negative !== 0 ? -n.words[0] : n.words[0];
    }

    return this.words[0] & num;
  }

  /*
   * Unsigned AND
   */

  iuand(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    this.length = Math.min(this.length, num.length);

    for (let i = 0; i < this.length; i++)
      this.words[i] &= num.words[i];

    return this._strip();
  }

  iuandn(num) {
    enforce(isSMI(num), 'num', 'smi');

    this.words[0] &= Math.abs(num);
    this.length = 1;

    return this._normalize();
  }

  uand(num) {
    return this.clone().iuand(num);
  }

  uandn(num) {
    return this.clone().iuandn(num);
  }

  uandrn(num) {
    enforce(isSMI(num), 'num', 'smi');

    const n = this.words[0] & Math.abs(num);

    return this.negative !== 0 ? (-n | 0) : n;
  }

  /*
   * OR
   */

  ior(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let x = this;
    let y = num;

    if (x === y)
      return x;

    if ((x.negative | y.negative) === 0)
      return x.iuor(y);

    if ((x.negative & y.negative) === 1) {
      // (-x) | (-y) == ~(x-1) | ~(y-1)
      //             == ~((x-1) & (y-1))
      //             == -(((x-1) & (y-1)) + 1)
      //             == ((-x+1) && (-y+1)) - 1
      y.iaddn(1);
      x.iaddn(1);
      x.iuand(y).isubn(1);
      y.isubn(1);
      return x;
    }

    // Assume x is the positive number.
    y = y.clone();

    if (x.negative !== 0)
      [x, y] = [y, x];

    // x | (-y) == x | ~(y-1)
    //          == ~((y-1) & ~x)
    //          == -(((y-1) & ~x) + 1)
    //          == ((-y+1) && ~x) - 1
    y.iaddn(1);
    x.inotn(y.bitLength());
    y.iuand(x);
    y.isubn(1);

    return y._move(this);
  }

  iorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0)
      return this.ior(new BN(num));

    this.words[0] |= num;

    return this;
  }

  or(num) {
    return this.clone().ior(num);
  }

  orn(num) {
    return this.clone().iorn(num);
  }

  /*
   * Unsigned OR
   */

  iuor(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    this._expand(num.length);

    for (let i = 0; i < num.length; i++)
      this.words[i] |= num.words[i];

    return this._strip();
  }

  iuorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    this.words[0] |= Math.abs(num);

    return this;
  }

  uor(num) {
    return this.clone().iuor(num);
  }

  uorn(num) {
    return this.clone().iuorn(num);
  }

  /*
   * XOR
   */

  ixor(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let x = this;
    let y = num;

    if (x === y) {
      x.words[0] = 0;
      x.length = 1;
      x.negative = 0;
      return x;
    }

    if ((x.negative | y.negative) === 0)
      return x.iuxor(y);

    if ((x.negative & y.negative) === 1) {
      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)
      //             == (x-1) ^ (y-1)
      //             == -((-x+1) ^^ (-y+1))
      x.iaddn(1);
      y.iaddn(1);
      x.iuxor(y);
      x.ineg();
      y.isubn(1);
      return x;
    }

    // Assume x is the positive number.
    if (x.negative !== 0)
      [x, y] = [y.clone(), x];

    // x ^ (-y) == x ^ ~(y-1)
    //          == ~(x ^ (y-1))
    //          == -((x ^ (y-1)) + 1)
    //          == -((x ^^ (-y+1)) + 1)
    y.iaddn(1);
    x.iuxor(y);
    x.iaddn(1);
    x.ineg();
    y.isubn(1);

    return x._move(this);
  }

  ixorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0)
      return this.ixor(new BN(num));

    this.words[0] ^= num;

    return this;
  }

  xor(num) {
    return this.clone().ixor(num);
  }

  xorn(num) {
    return this.clone().ixorn(num);
  }

  /*
   * Unsigned XOR
   */

  iuxor(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let a = this;
    let b = num;

    if (a.length < b.length)
      [a, b] = [b, a];

    let i = 0;

    for (; i < b.length; i++)
      this.words[i] = a.words[i] ^ b.words[i];

    if (a !== this) {
      this._alloc(a.length);

      for (; i < a.length; i++)
        this.words[i] = a.words[i];
    }

    this.length = a.length;

    return this._strip();
  }

  iuxorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    this.words[0] ^= Math.abs(num);

    return this._normalize();
  }

  uxor(num) {
    return this.clone().iuxor(num);
  }

  uxorn(num) {
    return this.clone().iuxorn(num);
  }

  /*
   * NOT
   */

  inot() {
    if (this.negative !== 0) {
      // ~(-x) == ~(~(x-1)) == x-1
      this.ineg().isubn(1);
    } else {
      // ~x == -x-1 == -(x+1)
      this.iaddn(1).ineg();
    }
    return this;
  }

  not() {
    return this.clone().inot();
  }

  inotn(width) {
    enforce(isInteger(width), 'width', 'integer');
    range(width >= 0, 'inotn');

    const bitsLeft = width % 26;

    let bytesNeeded = Math.ceil(width / 26) | 0;
    let i = 0;

    // Extend the buffer with leading zeroes.
    this._expand(bytesNeeded);

    if (bitsLeft > 0)
      bytesNeeded -= 1;

    // Handle complete words.
    for (; i < bytesNeeded; i++)
      this.words[i] = ~this.words[i] & 0x3ffffff;

    // Handle the residue.
    if (bitsLeft > 0)
      this.words[i] = ~this.words[i] & ((1 << bitsLeft) - 1);

    // And remove leading zeroes.
    return this._strip();
  }

  notn(width) {
    return this.clone().inotn(width);
  }

  /*
   * Left Shift
   */

  ishl(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    return this.ishln(num.toNumber());
  }

  ishln(bits) {
    return this.iushln(bits);
  }

  shl(num) {
    return this.clone().ishl(num);
  }

  shln(bits) {
    return this.clone().ishln(bits);
  }

  /*
   * Unsigned Left Shift
   */

  iushl(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    return this.iushln(num.toNumber());
  }

  iushln(bits) {
    enforce(isInteger(bits), 'bits', 'integer');
    range(bits >= 0, 'iushln');

    const r = bits % 26;
    const s = (bits - r) / 26;
    const mask = ((1 << r) - 1) << (26 - r);

    if (r !== 0) {
      let carry = 0;

      for (let i = 0; i < this.length; i++) {
        const ncarry = this.words[i] & mask;
        const c = ((this.words[i] | 0) - ncarry) << r;

        this.words[i] = c | carry;

        carry = ncarry >>> (26 - r);
      }

      if (carry !== 0) {
        this._alloc(this.length + 1);
        this.words[this.length++] = carry;
      }
    }

    if (s !== 0) {
      this._alloc(this.length + s);

      for (let i = this.length - 1; i >= 0; i--)
        this.words[i + s] = this.words[i];

      for (let i = 0; i < s; i++)
        this.words[i] = 0;

      this.length += s;
    }

    return this._strip();
  }

  ushl(num) {
    return this.clone().iushl(num);
  }

  ushln(bits) {
    return this.clone().iushln(bits);
  }

  /*
   * Right Shift
   */

  ishr(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    return this.ishrn(num.toNumber());
  }

  ishrn(bits) {
    enforce(isInteger(bits), 'bits', 'integer');
    range(bits >= 0, 'ishrn');

    if (this.negative !== 0) {
      // (-x) >> y == ~(x-1) >> y
      //           == ~((x-1) >> y)
      //           == -(((x-1) >> y) + 1)
      this.negative = 0;
      this.isubn(1);
      this.iushrn(bits);
      this.iaddn(1);
      this.negative = 1;
      return this;
    }

    return this.iushrn(bits);
  }

  shr(num) {
    return this.clone().ishr(num);
  }

  shrn(bits) {
    return this.clone().ishrn(bits);
  }

  /*
   * Unsigned Right Shift
   */

  iushr(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    return this.iushrn(num.toNumber());
  }

  iushrn(bits) {
    enforce(isInteger(bits), 'bits', 'integer');
    range(bits >= 0, 'iushrn');
    return this._split(bits, null);
  }

  _split(bits, output) {
    const r = bits % 26;
    const s = Math.min((bits - r) / 26, this.length);
    const mask = (1 << r) - 1;

    // Extended mode, copy masked part.
    if (output) {
      output._alloc(s);

      for (let i = 0; i < s; i++)
        output.words[i] = this.words[i];

      output.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all.
    } else if (this.length > s) {
      this.length -= s;
      for (let i = 0; i < this.length; i++)
        this.words[i] = this.words[i + s];
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    let carry = 0;

    for (let i = this.length - 1; i >= 0; i--) {
      const word = this.words[i] | 0;

      this.words[i] = (carry << (26 - r)) | (word >>> r);

      carry = word & mask;
    }

    // Push carried bits as a mask.
    if (output) {
      if (carry !== 0) {
        output._alloc(output.length + 1);
        output.words[output.length++] = carry;
      } else {
        if (output.length === 0)
          output.words[output.length++] = 0;

        output._strip();
      }
    }

    return this._strip();
  }

  ushr(num) {
    return this.clone().iushr(num);
  }

  ushrn(bits) {
    return this.clone().iushrn(bits);
  }

  /*
   * Bit Manipulation
   */

  setn(bit, val) {
    const negative = this.negative;

    if (negative !== 0) {
      this.iaddn(1);
      val = !val;
    }

    this.usetn(bit, val);

    if (negative !== 0)
      this.isubn(1);

    return this;
  }

  usetn(bit, val) {
    enforce(isInteger(bit), 'bit', 'integer');
    range(bit >= 0, 'setn');

    const r = bit % 26;
    const s = (bit - r) / 26;

    this._expand(s + 1);

    if (val)
      this.words[s] |= (1 << r);
    else
      this.words[s] &= ~(1 << r);

    return this._strip();
  }

  testn(bit) {
    enforce(isInteger(bit), 'bit', 'integer');
    range(bit >= 0, 'bit');

    const r = bit % 26;
    const s = (bit - r) / 26;
    const q = 1 << r;

    // Fast case: bit is much higher than all existing words.
    if (this.length <= s)
      return this.negative !== 0;

    // Check bit and return.
    const w = this.words[s];
    const val = (w & q) !== 0;

    if (this.negative !== 0) {
      if (r > 0 && (w & (q - 1)))
        return !val;

      let j = s;

      while (j--) {
        if (this.words[j] > 0)
          return !val;
      }
    }

    return val;
  }

  utestn(bit) {
    enforce(isInteger(bit), 'bit', 'integer');
    range(bit >= 0, 'bit');

    const r = bit % 26;
    const s = (bit - r) / 26;
    const q = 1 << r;

    // Fast case: bit is much higher than all existing words.
    if (this.length <= s)
      return false;

    // Check bit and return.
    const w = this.words[s];

    return (w & q) !== 0;
  }

  imaskn(bits) {
    enforce(isInteger(bits), 'bits', 'integer');
    range(bits >= 0, 'imaskn');

    if (this.negative !== 0) {
      this.iaddn(1).inotn(bits + 1);
      this.negative = 0;
    }

    return this.iumaskn(bits);
  }

  maskn(bits) {
    return this.clone().imaskn(bits);
  }

  iumaskn(bits) {
    enforce(isInteger(bits), 'bits', 'integer');
    range(bits >= 0, 'iumaskn');

    const r = bits % 26;

    let s = (bits - r) / 26;

    if (this.length <= s)
      return this;

    if (r !== 0)
      s += 1;

    this.length = Math.min(s, this.length);

    if (r !== 0)
      this.words[this.length - 1] &= (1 << r) - 1;

    if (this.length === 0)
      this.words[this.length++] = 0;

    return this._strip();
  }

  umaskn(bits) {
    return this.clone().iumaskn(bits);
  }

  andln(num) {
    return this.words[0] & num;
  }

  /*
   * Negation
   */

  ineg() {
    if (!this.isZero())
      this.negative ^= 1;

    return this;
  }

  neg() {
    return this.clone().ineg();
  }

  iabs() {
    this.negative = 0;
    return this;
  }

  abs() {
    return this.clone().iabs();
  }

  /*
   * Comparison
   */

  cmp(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.negative !== num.negative)
      return num.negative - this.negative;

    const res = this.ucmp(num);

    if (this.negative !== 0)
      return -res | 0;

    return res;
  }

  cmpn(num) {
    enforce(isSMI(num), 'num', 'smi');

    const negative = (num < 0) | 0;

    if (this.negative !== negative)
      return negative - this.negative;

    const res = this.ucmpn(num);

    if (this.negative !== 0)
      return -res | 0;

    return res;
  }

  eq(num) {
    return this.cmp(num) === 0;
  }

  eqn(num) {
    return this.cmpn(num) === 0;
  }

  gt(num) {
    return this.cmp(num) > 0;
  }

  gtn(num) {
    return this.cmpn(num) > 0;
  }

  gte(num) {
    return this.cmp(num) >= 0;
  }

  gten(num) {
    return this.cmpn(num) >= 0;
  }

  lt(num) {
    return this.cmp(num) < 0;
  }

  ltn(num) {
    return this.cmpn(num) < 0;
  }

  lte(num) {
    return this.cmp(num) <= 0;
  }

  lten(num) {
    return this.cmpn(num) <= 0;
  }

  sign() {
    if (this.negative !== 0)
      return -1;

    if (this.length === 1 && this.words[0] === 0)
      return 0;

    return 1;
  }

  isZero() {
    return this.length === 1 && this.words[0] === 0;
  }

  isNeg() {
    return this.negative !== 0;
  }

  isOdd() {
    return (this.words[0] & 1) === 1;
  }

  isEven() {
    return (this.words[0] & 1) === 0;
  }

  /*
   * Unsigned Comparison
   */

  ucmp(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.length < num.length)
      return -1;

    if (this.length > num.length)
      return 1;

    for (let i = this.length - 1; i >= 0; i--) {
      const a = this.words[i] | 0;
      const b = num.words[i] | 0;

      if (a === b)
        continue;

      return (a > b) - (a < b);
    }

    return 0;
  }

  ucmpn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if (this.length > 1)
      return 1;

    const w = this.words[0];

    if (num < 0)
      num = -num;

    return (w > num) - (w < num);
  }

  /*
   * Number Theoretic Functions
   */

  legendre(num) {
    return this.toRed(BN.mont(num)).redLegendre();
  }

  jacobi(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (num.isZero() || num.isEven())
      throw new Error('jacobi: `num` must be odd.');

    // See chapter 2, section 2.4:
    // http://yacas.sourceforge.net/Algo.book.pdf
    let a = this._cloneNormal();
    let b = num._cloneNormal();
    let j = 1;

    if (b.isNeg()) {
      if (a.isNeg())
        j = -1;
      b.ineg();
    }

    for (;;) {
      if (b.cmpn(1) === 0)
        return j;

      if (a.isZero())
        return 0;

      a = a.imod(b);

      if (a.isZero())
        return 0;

      const s = a.zeroBits();

      if (s & 1) {
        const bmod8 = b.andln(7);

        if (bmod8 === 3 || bmod8 === 5)
          j = -j;
      }

      const c = a.iushrn(s);

      if (b.andln(3) === 3 && c.andln(3) === 3)
        j = -j;

      a = b;
      b = c;
    }
  }

  kronecker(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const table = [
      0,  1, 0, -1,
      0, -1, 0,  1
    ];

    let a = this._cloneNormal();
    let b = num._cloneNormal();
    let s = 1;

    if (b.isZero())
      return a.ucmpn(1) === 0 ? s : 0;

    if (!a.isOdd() && !b.isOdd())
      return 0;

    const z = b.zeroBits();

    b.iushrn(z);

    if (z & 1)
      s = table[a.andln(7)];

    if (b.isNeg()) {
      if (a.isNeg())
        s = -s;
      b.ineg();
    }

    for (;;) {
      if (a.isZero())
        return b.cmpn(1) === 0 ? s : 0;

      const z = a.zeroBits();

      a.iushrn(z);

      if (z & 1)
        s *= table[b.andln(7)];

      const w = a.words[0] ^ (a.negative * 0x3ffffff);

      if (w & b.words[0] & 2)
        s = -s;

      b.imod(a);

      [a, b] = [b, a];

      b.negative = 0;
    }
  }

  igcd(num) {
    return this.gcd(num)._move(this);
  }

  gcd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.isZero())
      return num.abs();

    if (num.isZero())
      return this.abs();

    let a = this.clone();
    let b = num.clone();
    let shift = 0;

    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two.
    for (; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    for (;;) {
      while (a.isEven())
        a.iushrn(1);

      while (b.isEven())
        b.iushrn(1);

      const r = a.cmp(b);

      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`.
        [a, b] = [b, a];
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    }

    return b.iushln(shift);
  }

  ilcm(num) {
    return this.lcm(num)._move(this);
  }

  lcm(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.isZero() || num.isZero())
      return new BN(0);

    return this.quo(this.gcd(num)).mul(num).iabs();
  }

  egcd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.isZero()) {
      return [
        new BN(0),
        new BN(num.sign()),
        num.abs()
      ];
    }

    if (num.isZero()) {
      return [
        new BN(this.sign()),
        new BN(0),
        this.abs()
      ];
    }

    const x = this.clone();
    const y = num.clone();

    x.negative = 0;
    y.negative = 0;

    // A * x + B * y = x
    const A = new BN(1);
    const B = new BN(0);

    // C * x + D * y = y
    const C = new BN(0);
    const D = new BN(1);

    let g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      g += 1;
    }

    const yp = y.clone();
    const xp = x.clone();

    while (!x.isZero()) {
      let i = 0;

      for (let im = 1; (x.words[0] & im) === 0 && i < 26; im <<= 1)
        i += 1;

      if (i > 0) {
        x.iushrn(i);

        while (i > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);

          i -= 1;
        }
      }

      let j = 0;

      for (let jm = 1; (y.words[0] & jm) === 0 && j < 26; jm <<= 1)
        j += 1;

      if (j > 0) {
        y.iushrn(j);

        while (j > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);

          j -= 1;
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    if (this.negative !== 0)
      C.ineg();

    if (num.negative !== 0)
      D.ineg();

    return [C, D, y.iushln(g)];
  }

  iinvert(num) {
    return this.invert(num)._move(this);
  }

  invert(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    range(num.sign() > 0, 'invert');

    if (num.cmpn(1) === 0)
      throw new RangeError('Not invertible.');

    const [s,, g] = this.egcd(num);

    if (g.cmpn(1) !== 0)
      throw new RangeError('Not invertible.');

    return s.imod(num);
  }

  ifermat(num) {
    return this.fermat(num)._move(this);
  }

  fermat(num) {
    return this.toRed(BN.mont(num)).redFermat().fromRed();
  }

  ipowm(y, m, mont) {
    return this.powm(y, m, mont)._move(this);
  }

  powm(y, m, mont) {
    const p = mont ? BN.mont(m) : BN.red(m);
    const n = this.toRed(p);
    return n.redPow(y).fromRed();
  }

  ipowmn(y, m, mont) {
    return this.powmn(y, m, mont)._move(this);
  }

  powmn(y, m, mont) {
    const p = mont ? BN.mont(m) : BN.red(m);
    const n = this.toRed(p);
    return n.redPown(y).fromRed();
  }

  isqrtm(p) {
    return this.sqrtm(p)._move(this);
  }

  sqrtm(p) {
    const n = this.toRed(BN.mont(p));
    return n.redSqrt().fromRed();
  }

  isqrtpq(p, q) {
    return this.sqrtpq(p, q)._move(this);
  }

  sqrtpq(p, q) {
    const sp = this.sqrtm(p);
    const sq = this.sqrtm(q);
    const [mp, mq] = p.egcd(q);
    const lhs = sq.imul(mp).imul(p);
    const rhs = sp.imul(mq).imul(q);
    const n = p.mul(q);

    return lhs.iadd(rhs).imod(n);
  }

  /*
   * Primality Testing
   */

  isPrime(rng, reps, limit) {
    enforce((reps >>> 0) === reps, 'reps', 'integer');

    if (!this.isPrimeMR(rng, reps + 1, true))
      return false;

    if (!this.isPrimeLucas(limit))
      return false;

    return true;
  }

  isPrimeMR(rng, reps, force2 = false) {
    enforce((reps >>> 0) === reps, 'reps', 'integer');
    enforce(reps > 0, 'reps', 'integer');
    enforce(typeof force2 === 'boolean', 'force2', 'boolean');

    const n = this;

    if (n.cmpn(7) < 0) {
      if (n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0)
        return true;
      return false;
    }

    if (n.isEven())
      return false;

    const nm1 = n.subn(1);
    const nm3 = nm1.subn(2);
    const k = nm1.zeroBits();
    const q = nm1.ushrn(k);

    const red = BN.red(n);
    const rnm1 = nm1.toRed(red);
    const rone = new BN(1).toRed(red);

    // Miller-Rabin primality test.
next:
    for (let i = 0; i < reps; i++) {
      let x;

      if (i === reps - 1 && force2) {
        x = new BN(2);
      } else {
        x = BN.random(rng, 0, nm3);
        x.iaddn(2);
      }

      const y = x.toRed(red).redPow(q);

      if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0)
        continue;

      for (let j = 1; j < k; j++) {
        y.redISqr();

        if (y.cmp(rnm1) === 0)
          continue next;

        if (y.cmp(rone) === 0)
          return false;
      }

      return false;
    }

    return true;
  }

  isPrimeLucas(limit = 0) {
    enforce((limit >>> 0) === limit, 'limit', 'integer');

    const n = this;

    // Ignore 0 and 1.
    if (n.cmpn(1) <= 0)
      return false;

    // Two is the only even prime.
    if (n.isEven())
      return n.cmpn(2) === 0;

    // Baillie-OEIS "method C" for choosing D, P, Q.
    // See: https://oeis.org/A217719/a217719.txt.
    let p = 3;

    for (;;) {
      if (p > 10000) {
        // Thought to be impossible.
        throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);
      }

      if (limit > 0 && p > limit) {
        // It's thought to be impossible for `p`
        // to be larger than 10,000, but fail
        // on anything higher than a limit to
        // prevent DoS attacks. `p` never seems
        // to be higher than 30 in practice.
        return false;
      }

      const d = new BN(p * p - 4);
      const j = d.jacobi(n);

      if (j === -1)
        break;

      if (j === 0)
        return n.cmpn(p + 2) === 0;

      if (p === 40) {
        if (n.isSquare())
          return false;
      }

      p += 1;
    }

    // Check for Grantham definition of
    // "extra strong Lucas pseudoprime".
    const s = n.addn(1);
    const r = s.zeroBits();
    const nm2 = n.subn(2);

    let x = new BN(2);
    let y = new BN(p);

    s.iushrn(r);

    for (let i = s.bitLength(); i >= 0; i--) {
      if (s.testn(i)) {
        x = x.imul(y).iadd(n).isubn(p).imod(n);
        y = y.isqr().iadd(nm2).imod(n);
      } else {
        y = y.imul(x).iadd(n).isubn(p).imod(n);
        x = x.isqr().iadd(nm2).imod(n);
      }
    }

    if (x.cmpn(2) === 0 || x.cmp(nm2) === 0) {
      let a = x.muln(p);
      let b = y.ushln(1);

      if (a.cmp(b) < 0)
        [a, b] = [b, a];

      if (a.isub(b).imod(n).isZero())
        return true;
    }

    for (let t = 0; t < r - 1; t++) {
      if (x.isZero())
        return true;

      if (x.cmpn(2) === 0)
        return false;

      x = x.isqr().isubn(2).imod(n);
    }

    return false;
  }

  /*
   * Twos Complement
   */

  toTwos(width) {
    if (this.negative !== 0)
      return this.abs().inotn(width).iaddn(1);

    return this.clone();
  }

  fromTwos(width) {
    enforce(isInteger(width), 'width', 'integer');
    range(width > 0, 'width');

    if (this.testn(width - 1))
      return this.notn(width).iaddn(1).ineg();

    return this.clone();
  }

  /*
   * Reduction Context
   */

  toRed(ctx) {
    enforce(ctx instanceof Red, 'ctx', 'reduction context');

    if (this.red)
      throw new Error('Already in reduction context.');

    return ctx.convertTo(this)._forceRed(ctx);
  }

  fromRed() {
    red(this.red, 'fromRed');
    return this.red.convertFrom(this);
  }

  forceRed(ctx) {
    if (this.red)
      throw new Error('Already in reduction context.');

    return this._forceRed(ctx);
  }

  redIAdd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIAdd');
    return this.red.iadd(this, num);
  }

  redAdd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redAdd');
    return this.red.add(this, num);
  }

  redISub(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redISub');
    return this.red.isub(this, num);
  }

  redSub(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redSub');
    return this.red.sub(this, num);
  }

  redIShln(num) {
    enforce(isInteger(num), 'num', 'integer');
    red(this.red, 'redIShln');
    return this.red.ishln(this, num);
  }

  redShln(num) {
    enforce(isInteger(num), 'num', 'integer');
    red(this.red, 'redShln');
    return this.red.shln(this, num);
  }

  redIMul(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIMul');
    return this.red.imul(this, num);
  }

  redMul(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redMul');
    return this.red.mul(this, num);
  }

  redISqr() {
    red(this.red, 'redISqr');
    return this.red.isqr(this);
  }

  redSqr() {
    red(this.red, 'redISqr');
    return this.red.sqr(this);
  }

  redISqrt() {
    red(this.red, 'redISqrt');
    return this.red.isqrt(this);
  }

  redSqrt() {
    red(this.red, 'redSqrt');
    return this.red.sqrt(this);
  }

  redIInvert() {
    red(this.red, 'redIInvert');
    return this.red.iinvert(this);
  }

  redInvert() {
    red(this.red, 'redInvert');
    return this.red.invert(this);
  }

  redIFermat() {
    red(this.red, 'redIFermat');
    return this.red.ifermat(this);
  }

  redFermat() {
    red(this.red, 'redFermat');
    return this.red.fermat(this);
  }

  redINeg() {
    red(this.red, 'redINeg');
    return this.red.ineg(this);
  }

  redNeg() {
    red(this.red, 'redNeg');
    return this.red.neg(this);
  }

  redLegendre() {
    red(this.red, 'redLegendre');
    return this.red.legendre(this);
  }

  redJacobi() {
    red(this.red, 'redJacobi');
    return this.red.jacobi(this);
  }

  redKronecker() {
    red(this.red, 'redKronecker');
    return this.red.kronecker(this);
  }

  redIPow(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIPow');
    nonred(!num.red, 'redIPow');
    return this.red.ipow(this, num);
  }

  redPow(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redPow');
    nonred(!num.red, 'redPow');
    return this.red.pow(this, num);
  }

  redIPown(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redIPown');
    return this.red.ipown(this, num);
  }

  redPown(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redPown');
    return this.red.pown(this, num);
  }

  /*
   * Internal
   */

  _move(dest) {
    dest.words = this.words;
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
    return dest;
  }

  _alloc(size) {
    while (this.words.length < size)
      this.words.push(0);

    return this;
  }

  _expand(size) {
    this._alloc(size);

    while (this.length < size)
      this.words[this.length++] = 0;

    return this;
  }

  _strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0)
      this.length -= 1;

    return this._normalize();
  }

  _normalize() {
    assert(this.length > 0);

    // -0 = 0
    if (this.length === 1 && this.words[0] === 0)
      this.negative = 0;

    return this;
  }

  _check() {
    // We never have a zero length number.
    assert(this.length > 0);

    if (this.length === 1) {
      // Must be normalized.
      if (this.words[0] === 0)
        assert(this.negative === 0);
      return this;
    }

    // Must be stripped.
    assert(this.words[this.length - 1] !== 0);

    return this;
  }

  _invertp(p) {
    enforce(BN.isBN(p), 'p', 'bignum');
    assert(this.negative === 0);
    assert(p.sign() > 0);

    if (this.isZero() || p.cmpn(1) === 0)
      throw new RangeError('Not invertible.');

    const a = this.clone();
    const b = p.clone();
    const x1 = new BN(1);
    const x2 = new BN(0);
    const delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      let i = 0;

      for (let im = 1; (a.words[0] & im) === 0 && i < 26; im <<= 1)
        i += 1;

      if (i > 0) {
        a.iushrn(i);

        while (i > 0) {
          if (x1.isOdd())
            x1.iadd(delta);

          x1.iushrn(1);

          i -= 1;
        }
      }

      let j = 0;

      for (let jm = 1; (b.words[0] & jm) === 0 && j < 26; jm <<= 1)
        j += 1;

      if (j > 0) {
        b.iushrn(j);

        while (j > 0) {
          if (x2.isOdd())
            x2.iadd(delta);

          x2.iushrn(1);

          j -= 1;
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    let res;

    if (a.cmpn(1) === 0)
      res = x1;
    else
      res = x2;

    if (res.sign() < 0)
      res.iadd(p);

    return res;
  }

  _cloneNormal() {
    return this.red ? this.fromRed() : this.clone();
  }

  _forceRed(ctx) {
    this.red = ctx;
    return this;
  }

  /*
   * Helpers
   */

  clone() {
    return new BN().inject(this);
  }

  inject(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    this.words = new Array(num.length);

    for (let i = 0; i < num.length; i++)
      this.words[i] = num.words[i];

    this.length = num.length;
    this.negative = num.negative;
    this.red = num.red;

    return this;
  }

  set(num, endian) {
    return this.fromNumber(num, endian);
  }

  swap(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const x = this;
    const y = num;

    [x.words, y.words] = [y.words, x.words];
    [x.length, y.length] = [y.length, x.length];
    [x.negative, y.negative] = [y.negative, x.negative];
    [x.red, y.red] = [y.red, x.red];

    return x;
  }

  reverse() {
    const neg = this.negative;

    this.fromBuffer(this.toBuffer('be'), 'le');
    this.negative = neg;

    return this;
  }

  byteLength() {
    return Math.ceil(this.bitLength() / 8);
  }

  bitLength() {
    const w = this.words[this.length - 1];
    const hi = countBits(w);
    return (this.length - 1) * 26 + hi;
  }

  zeroBits() {
    if (this.isZero())
      return 0;

    let r = 0;

    for (let i = 0; i < this.length; i++) {
      const b = zeroBits(this.words[i]);

      r += b;

      if (b !== 26)
        break;
    }

    return r;
  }

  isSafe() {
    if (this.length <= 2)
      return true;

    if (this.length === 3 && this.words[2] === 0x01)
      return true;

    return false;
  }

  [custom]() {
    let prefix = 'BN';

    if (this.red)
      prefix = 'BN-R';

    return `<${prefix}: ${this.toString(10)}>`;
  }

  /*
   * Conversion
   */

  toNumber() {
    let num = this.words[0];

    if (this.length === 2) {
      num += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // Note: at this stage it is known that the top bit is set.
      num += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      throw new RangeError('Number can only safely store up to 53 bits.');
    }

    return this.negative !== 0 ? -num : num;
  }

  toDouble() {
    let num = 0;

    for (let i = this.length - 1; i >= 0; i--)
      num = (num * 0x4000000) + this.words[i];

    return this.negative !== 0 ? -num : num;
  }

  valueOf() {
    return this.toDouble();
  }

  toBigInt() {
    if (typeof BigInt !== 'function')
      throw new Error('BigInt is not supported!');

    const shift = BigInt(26);

    let num = BigInt(0);

    for (let i = this.length - 1; i >= 0; i--)
      num = (num << shift) | BigInt(this.words[i]);

    return this.negative !== 0 ? -num : num;
  }

  toBool() {
    return !this.isZero();
  }

  toString(base, padding) {
    base = getBase(base);

    if (padding == null)
      padding = 0;

    if (padding === 0)
      padding = 1;

    enforce((base >>> 0) === base, 'base', 'integer');
    enforce((padding >>> 0) === padding, 'padding', 'integer');

    if (base < 2 || base > 36)
      throw new RangeError('Base ranges between 2 and 36.');

    this._check();

    if (base === 16) {
      let out = '';
      let off = 0;
      let carry = 0;

      for (let i = 0; i < this.length; i++) {
        const w = this.words[i];
        const word = (((w << off) | carry) & 0xffffff).toString(16);

        carry = (w >>> (24 - off)) & 0xffffff;

        if (carry !== 0 || i !== this.length - 1)
          out = zeros[6 - word.length] + word + out;
        else
          out = word + out;

        off += 2;

        if (off >= 26) {
          off -= 26;
          i -= 1;
        }
      }

      if (carry !== 0)
        out = carry.toString(16) + out;

      while (out.length % padding !== 0)
        out = '0' + out;

      if (this.negative !== 0)
        out = '-' + out;

      return out;
    }

    const groupSize = groupSizes[base - 1];
    const groupBase = groupBases[base - 1];

    let c = this.clone();
    let out = '';

    c.negative = 0;

    while (!c.isZero()) {
      const r = c.remrn(groupBase).toString(base);

      c = c.iquon(groupBase);

      if (!c.isZero())
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }

    if (this.isZero())
      out = '0' + out;

    while (out.length % padding !== 0)
      out = '0' + out;

    if (this.negative !== 0)
      out = '-' + out;

    return out;
  }

  toJSON() {
    return this.toString(16, 2);
  }

  toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  }

  toBuffer(endian, length) {
    return this.toArrayLike(Buffer, endian, length);
  }

  toArrayLike(ArrayType, endian, length) {
    if (endian == null)
      endian = 'be';

    if (length == null)
      length = 0;

    enforce(typeof ArrayType === 'function', 'ArrayType', 'function');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
    enforce((length >>> 0) === length, 'length', 'integer');

    this._check();

    const bytes = this.byteLength();
    const size = length || Math.max(1, bytes);

    if (bytes > size)
      throw new RangeError('Byte array longer than desired length.');

    const res = allocate(ArrayType, size);
    const q = this.clone();

    if (endian === 'be') {
      let i = size - 1;

      while (!q.isZero()) {
        res[i--] = q.words[0] & 0xff;
        q.iushrn(8);
      }

      for (; i >= 0; i--)
        res[i] = 0x00;
    } else {
      let i = 0;

      while (!q.isZero()) {
        res[i++] = q.words[0] & 0xff;
        q.iushrn(8);
      }

      for (; i < size; i++)
        res[i] = 0x00;
    }

    return res;
  }

  encode(endian, length) {
    return this.toBuffer(endian, length);
  }

  /*
   * Instantiation
   */

  of(num, endian) {
    return this.fromNumber(num, endian);
  }

  fromNumber(num, endian) {
    if (endian == null)
      endian = 'be';

    enforce(isInteger(num), 'num', 'integer');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    const neg = (num < 0) | 0;

    if (neg)
      num = -num;

    if (num < 0x4000000) {
      this.words = [num & 0x3ffffff];
      this.length = 1;
    } else if (num < 0x10000000000000) {
      this.words = [
        num & 0x3ffffff,
        (num / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      this.words = [
        num & 0x3ffffff,
        (num / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    this.negative = neg;

    if (endian === 'le')
      this.reverse();

    return this;
  }

  fromDouble(num, endian) {
    if (endian == null)
      endian = 'be';

    enforce(typeof num === 'number', 'num', 'double');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (!isFinite(num))
      num = 0;

    const neg = (num <= -1) | 0;

    if (num < 0)
      num = -num;

    num = Math.floor(num);

    this.words = [];

    while (num > 0) {
      const lo = num % 0x4000000;
      const hi = (num - lo) / 0x4000000;

      this.words.push(lo);

      num = hi;
    }

    if (this.words.length === 0)
      this.words.push(0);

    this.length = this.words.length;
    this.negative = neg;

    if (endian === 'le')
      this.reverse();

    return this;
  }

  fromBigInt(num, endian) {
    if (endian == null)
      endian = 'be';

    enforce(typeof num === 'bigint', 'num', 'bigint');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (typeof BigInt !== 'function')
      throw new Error('BigInt is not supported!');

    const zero = BigInt(0);
    const mask = BigInt(0x3ffffff);
    const shift = BigInt(26);

    const neg = (num < zero) | 0;

    if (neg)
      num = -num;

    this.words = [];

    while (num > zero) {
      this.words.push(Number(num & mask));
      num >>= shift;
    }

    if (this.words.length === 0)
      this.words.push(0);

    this.length = this.words.length;
    this.negative = neg;

    if (endian === 'le')
      this.reverse();

    return this;
  }

  fromBool(value) {
    enforce(typeof value === 'boolean', 'value', 'boolean');
    return this.set(value ? 1 : 0);
  }

  fromString(str, base, endian) {
    if (base === 'le' || base === 'be')
      [base, endian] = [endian, base];

    base = getBase(base);

    if (endian == null)
      endian = 'be';

    enforce(typeof str === 'string', 'string', 'string');
    enforce((base >>> 0) === base, 'base', 'integer');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (base < 2 || base > 36)
      throw new Error('Base ranges between 2 and 36.');

    str = str.replace(/[\t\n\r ]/g, '');

    let start = 0;

    if (str.length > 0 && str.charCodeAt(0) === 0x2d)
      start = 1;

    if (base === 16)
      this._fromHex(str, start);
    else
      this._fromBase(str, base, start);

    this.negative = start;

    this._strip();

    if (endian === 'le')
      this.reverse();

    return this;
  }

  _fromHex(str, start) {
    // Create possibly bigger array to ensure that it fits the number.
    this.length = Math.max(2, Math.ceil((str.length - start) / 6));
    this.words = new Array(this.length);

    for (let i = 0; i < this.length; i++)
      this.words[i] = 0;

    // Scan 24-bit chunks and add them to the number.
    let off = 0;
    let i = str.length - 6;
    let j = 0;

    for (; i >= start; i -= 6) {
      const w = parseHex(str, i, i + 6);

      this.words[j] |= (w << off) & 0x3ffffff;

      // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.
      this.words[j + 1] |= (w >>> (26 - off)) & 0x3fffff;

      off += 24;

      if (off >= 26) {
        off -= 26;
        j += 1;
      }
    }

    if (i + 6 !== start) {
      const w = parseHex(str, start, i + 6);

      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= (w >>> (26 - off)) & 0x3fffff;
    }

    return this._strip();
  }

  _fromBase(str, base, start) {
    // Initialize as zero.
    this.words = [0];
    this.length = 1;
    this.negative = 0;

    // Find length of limb in base.
    let limbLen = 0;
    let limbPow = 1;

    for (; limbPow <= 0x3ffffff; limbPow *= base)
      limbLen += 1;

    limbLen -= 1;
    limbPow = (limbPow / base) | 0;

    const total = str.length - start;
    const mod = total % limbLen;
    const end = Math.min(total, total - mod) + start;

    let word = 0;
    let i = start;

    for (; i < end; i += limbLen) {
      word = parseBase(str, i, i + limbLen, base);

      this.imuln(limbPow);

      if (this.words[0] + word < 0x4000000)
        this.words[0] += word;
      else
        this._iaddn(word);
    }

    if (mod !== 0) {
      let pow = 1;

      word = parseBase(str, i, str.length, base);

      for (i = 0; i < mod; i++)
        pow *= base;

      this.imuln(pow);

      if (this.words[0] + word < 0x4000000)
        this.words[0] += word;
      else
        this._iaddn(word);
    }

    return this;
  }

  fromJSON(json) {
    return this.fromString(json, 16);
  }

  fromBN(num) {
    return this.inject(num);
  }

  fromArray(data, endian) {
    enforce(Array.isArray(data), 'data', 'array');
    return this.fromArrayLike(data, endian);
  }

  fromBuffer(data, endian) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    return this.fromArrayLike(data, endian);
  }

  fromArrayLike(data, endian) {
    if (endian == null)
      endian = 'be';

    enforce(data && typeof data.length === 'number', 'data', 'array-like');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (data.length <= 0) {
      this.words = [0];
      this.length = 1;
      this.negative = 0;
      return this;
    }

    this.length = Math.max(2, Math.ceil(data.length / 3));
    this.words = new Array(this.length);
    this.negative = 0;

    for (let i = 0; i < this.length; i++)
      this.words[i] = 0;

    const left = data.length % 3;

    let off = 0;
    let j = 0;
    let w = 0;

    if (endian === 'be') {
      for (let i = data.length - 1; i >= 2; i -= 3) {
        const w = data[i] | (data[i - 1] << 8) | (data[i - 2] << 16);

        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;

        off += 24;

        if (off >= 26) {
          off -= 26;
          j += 1;
        }
      }

      switch (left) {
        case 2:
          w = data[1] | (data[0] << 8);
          break;
        case 1:
          w = data[0];
          break;
      }
    } else {
      const len = data.length - left;

      for (let i = 0; i < len; i += 3) {
        const w = data[i] | (data[i + 1] << 8) | (data[i + 2] << 16);

        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;

        off += 24;

        if (off >= 26) {
          off -= 26;
          j += 1;
        }
      }

      switch (left) {
        case 2:
          w = data[len] | (data[len + 1] << 8);
          break;
        case 1:
          w = data[len];
          break;
      }
    }

    if (left > 0) {
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
    }

    return this._strip();
  }

  decode(data, endian) {
    return this.fromBuffer(data, endian);
  }

  from(num, base, endian) {
    if (num == null)
      return this;

    if (base === 'le' || base === 'be')
      [base, endian] = [endian, base];

    if (typeof num === 'number')
      return this.fromNumber(num, endian);

    if (typeof num === 'bigint')
      return this.fromBigInt(num, endian);

    if (typeof num === 'string')
      return this.fromString(num, base, endian);

    if (typeof num === 'object') {
      if (BN.isBN(num))
        return this.fromBN(num, endian);

      if (typeof num.length === 'number')
        return this.fromArrayLike(num, endian);
    }

    if (typeof num === 'boolean')
      return this.fromBool(num);

    throw new TypeError('Non-numeric object passed to BN.');
  }

  /*
   * Static Methods
   */

  static min(a, b) {
    enforce(BN.isBN(a), 'a', 'bignum');
    return a.cmp(b) < 0 ? a : b;
  }

  static max(a, b) {
    enforce(BN.isBN(a), 'a', 'bignum');
    return a.cmp(b) > 0 ? a : b;
  }

  static cmp(a, b) {
    enforce(BN.isBN(a), 'a', 'bignum');
    return a.cmp(b);
  }

  static ucmp(a, b) {
    enforce(BN.isBN(a), 'a', 'bignum');
    return a.ucmp(b);
  }

  static red(num) {
    return new Red(num);
  }

  static mont(num) {
    return new Mont(num);
  }

  static _prime(name) {
    if (primes[name])
      return primes[name];

    let prime;

    if (name === 'p192')
      prime = new P192();
    else if (name === 'p224')
      prime = new P224();
    else if (name === 'p521')
      prime = new P521();
    else if (name === 'k256')
      prime = new K256();
    else if (name === 'p25519')
      prime = new P25519();
    else if (name === 'p448')
      prime = new P448();
    else
      throw new Error('Unknown prime ' + name);

    primes[name] = prime;

    return prime;
  }

  static pow(num, exp) {
    return new BN().fromNumber(num).ipown(exp);
  }

  static shift(num, bits) {
    return new BN().fromNumber(num).ishln(bits);
  }

  static randomBits(rng, bits) {
    enforce(rng != null, 'rng', 'rng');
    enforce(isInteger(bits), 'bits', 'integer');
    range(bits >= 0, 'randomBits');

    if (typeof rng === 'object') {
      enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');

      const size = (bits + 7) >>> 3;
      const total = size * 8;
      const bytes = rng.randomBytes(size);

      enforce(Buffer.isBuffer(bytes), 'bytes', 'buffer');

      if (bytes.length !== size)
        throw new RangeError('Invalid number of bytes returned from RNG.');

      const num = BN.fromBuffer(bytes);

      if (total > bits)
        num.iushrn(total - bits);

      return num;
    }

    enforce(typeof rng === 'function', 'rng', 'rng');

    const num = rng(bits);

    enforce(BN.isBN(num), 'num', 'bignum');
    range(num.negative === 0, 'RNG');
    nonred(!num.red, 'RNG');

    if (num.bitLength() > bits)
      throw new RangeError('Invalid number of bits returned from RNG.');

    return num;
  }

  static random(rng, min, max) {
    min = BN.cast(min, 16);
    max = BN.cast(max, 16);

    if (min.cmp(max) > 0)
      throw new RangeError('Minimum cannot be greater than maximum.');

    const space = max.sub(min).iabs();
    const bits = space.bitLength();

    if (bits === 0)
      return min.clone();

    for (;;) {
      const num = BN.randomBits(rng, bits);

      // Maximum is _exclusive_!
      if (num.cmp(space) >= 0)
        continue;

      // Minimum is _inclusive_!
      num.iadd(min);

      return num;
    }
  }

  static of(num, endian) {
    return new BN().of(num, endian);
  }

  static fromNumber(num, endian) {
    return new BN().fromNumber(num, endian);
  }

  static fromDouble(num, endian) {
    return new BN().fromDouble(num, endian);
  }

  static fromBigInt(num, endian) {
    return new BN().fromBigInt(num, endian);
  }

  static fromBool(value) {
    return new BN().fromBool(value);
  }

  static fromString(str, base, endian) {
    return new BN().fromString(str, base, endian);
  }

  static fromJSON(json) {
    return new BN().fromJSON(json);
  }

  static fromBN(num) {
    return new BN().fromBN(num);
  }

  static fromArray(data, endian) {
    return new BN().fromArray(data, endian);
  }

  static fromBuffer(data, endian) {
    return new BN().fromBuffer(data, endian);
  }

  static fromArrayLike(data, endian) {
    return new BN().fromArrayLike(data, endian);
  }

  static decode(data, endian) {
    return new BN().decode(data, endian);
  }

  static from(num, base, endian) {
    return new BN().from(num, base, endian);
  }

  static cast(num, base, endian) {
    if (BN.isBN(num))
      return num;

    return new BN(num, base, endian);
  }

  static isBN(obj) {
    return obj instanceof BN;
  }
}

/*
 * Static
 */

BN.BN = BN;
BN.wordSize = 26;
BN.native = 0;

/**
 * Prime
 */

class Prime {
  constructor(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = BN.shift(1, this.n).isub(this.p);
    this.tmp = this._tmp();
  }

  _tmp() {
    const tmp = new BN();

    tmp.words = new Array(Math.ceil(this.n / 13));

    for (let i = 0; i < tmp.words.length; i++)
      tmp.words[i] = 0;

    return tmp;
  }

  ireduce(num) {
    // Assumes that `num` is less than `P^2`:
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    let r = num;
    let rlen;

    assert(r.negative === 0);
    assert(r.length <= this.p.length * 2);

    if (r.length < this.p.length)
      return r;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    const cmp = rlen < this.n ? -1 : r.ucmp(this.p);

    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      // Note: we shouldn't need to strip here.
    }

    return r;
  }

  split(input, out) {
    input._split(this.n, out);
  }

  imulK(num) {
    return num.imul(this.k);
  }
}

/**
 * P192
 */

class P192 extends Prime {
  constructor() {
    super('p192', 'ffffffff ffffffff ffffffff fffffffe'
                + 'ffffffff ffffffff');
  }

  imulK(num) {
    // K = 0x10000000000000001
    const n = num.clone();
    return num.iushln(64).iadd(n);
  }
}

/**
 * P224
 */

class P224 extends Prime {
  constructor() {
    super('p224', 'ffffffff ffffffff ffffffff ffffffff'
                + '00000000 00000000 00000001');
  }

  imulK(num) {
    // K = 0xffffffffffffffffffffffff
    const n = num.clone();
    return num.iushln(96).isub(n);
  }
}

/**
 * P521
 */

class P521 extends Prime {
  constructor() {
    super('p521', '000001ff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff');
  }

  imulK(num) {
    // K = 0x01
    return num;
  }
}

/**
 * K256
 */

class K256 extends Prime {
  constructor() {
    super('k256', 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff fffffffe fffffc2f');
  }

  split(input, output) {
    // 256 = 9 * 26 + 22
    const mask = 0x3fffff;
    const outLen = Math.min(input.length, 9);

    output._alloc(outLen + 1);

    for (let i = 0; i < outLen; i++)
      output.words[i] = input.words[i];

    output.length = outLen;

    if (input.length <= 9) {
      output._strip();
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs.
    let prev = input.words[9];
    let i = 10;

    output.words[output.length++] = prev & mask;
    output._strip();

    for (; i < input.length; i++) {
      const next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }

    prev >>>= 22;
    input.words[i - 10] = prev;

    if (prev === 0 && input.length > 10)
      input.length -= 10;
    else
      input.length -= 9;

    input._strip(); // Unsure if we need this.
  }

  imulK(num) {
    // K = 0x1000003d1 = [0x40, 0x3d1]
    num._expand(num.length + 2);

    // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    let lo = 0;

    for (let i = 0; i < num.length; i++) {
      const w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction.
    if (num.words[num.length - 1] === 0) {
      num.length -= 1;
      if (num.words[num.length - 1] === 0)
        num.length -= 1;
    }

    // Note: we shouldn't need to strip here.
    return num;
  }
}

/**
 * P25519
 */

class P25519 extends Prime {
  constructor() {
    // 2^255 - 19
    super('p25519', '7fffffff ffffffff ffffffff ffffffff'
                  + 'ffffffff ffffffff ffffffff ffffffed');
  }

  imulK(num) {
    // K = 0x13
    let carry = 0;

    for (let i = 0; i < num.length; i++) {
      let hi = (num.words[i] | 0) * 0x13 + carry;

      const lo = hi & 0x3ffffff;

      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }

    if (carry !== 0) {
      num._alloc(num.length + 1);
      num.words[num.length++] = carry;
    }

    // Note: we shouldn't need to strip here.
    return num;
  }
}

/**
 * P448
 */

class P448 extends Prime {
  constructor() {
    // 2^448 - 2^224 - 1
    super('p448', 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff fffffffe ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff');
  }

  imulK(num) {
    // K = 0x100000000000000000000000000000000000000000000000000000001
    const n = num.clone();
    return num.iushln(224).iadd(n);
  }
}

/**
 * Reduction Engine
 */

class Red {
  constructor(m) {
    let prime = null;

    if (typeof m === 'string') {
      prime = BN._prime(m);
      m = prime.p;
    }

    enforce(BN.isBN(m), 'm', 'bignum');
    range(m.cmpn(1) >= 0, 'reduction');

    this.m = m;
    this.prime = prime;
  }

  _verify1(a) {
    range(a.negative === 0, 'red');
    red(a.red, 'red');
  }

  _verify2(a, b) {
    range((a.negative | b.negative) === 0, 'red');
    red(a.red && a.red === b.red, 'red');
  }

  imod(a) {
    if (this.prime)
      return this.prime.ireduce(a)._forceRed(this);

    return a.imod(this.m)._forceRed(this);
  }

  ineg(a) {
    this._verify1(a);

    if (!a.isZero()) {
      a.isub(this.m);
      a.ineg();
    }

    return a;
  }

  neg(a) {
    this._verify1(a);

    if (a.isZero())
      return a.clone();

    return this.m.sub(a)._forceRed(this);
  }

  iadd(a, b) {
    this._verify2(a, b);

    const res = a.iadd(b);

    if (res.cmp(this.m) >= 0)
      res.isub(this.m);

    return res;
  }

  add(a, b) {
    this._verify2(a, b);

    const res = a.add(b);

    if (res.cmp(this.m) >= 0)
      res.isub(this.m);

    return res._forceRed(this);
  }

  isub(a, b) {
    this._verify2(a, b);

    const res = a.isub(b);

    if (res.sign() < 0)
      res.iadd(this.m);

    return res;
  }

  sub(a, b) {
    this._verify2(a, b);

    const res = a.sub(b);

    if (res.sign() < 0)
      res.iadd(this.m);

    return res._forceRed(this);
  }

  ishln(a, num) {
    this._verify1(a);
    return this.imod(a.iushln(num));
  }

  shln(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  }

  imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  }

  mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  }

  isqr(a) {
    return this.imul(a, a);
  }

  sqr(a) {
    return this.mul(a, a);
  }

  isqrt(x) {
    return this.sqrt(x)._move(x);
  }

  sqrt(x) {
    this._verify1(x);

    switch (this.jacobi(x)) {
      case -1:
        throw new Error('X is not a square mod P.');
      case 0:
        return new BN(0)._forceRed(this);
      case 1:
        break;
    }

    // Fast case (mod 4 == 3).
    if (this.m.andln(3) === 3) {
      const e = this.m.addn(1).iushrn(2);
      return this.pow(x, e);
    }

    const one = new BN(1).toRed(this);

    // Fast case (mod 8 == 5).
    if (this.m.andln(7) === 5) {
      const e = this.m.ushrn(3);
      const t = this.shln(x, 1);
      const a = this.pow(t, e);
      const b = this.sqr(a);

      this.imul(b, t);
      this.isub(b, one);
      this.imul(b, x);
      this.imul(b, a);

      return b;
    }

    const s = this.m.subn(1);
    const e = s.zeroBits();

    s.iushrn(e);

    const n = new BN(2).toRed(this);

    while (this.jacobi(n) !== -1)
      this.iadd(n, one);

    let b = this.pow(x, s);
    let g = this.pow(n, s);
    let y = this.pow(x, s.iaddn(1).iushrn(1));
    let k = e;

    for (;;) {
      let t = b;
      let m = 0;

      while (t.cmp(one) !== 0) {
        t = this.sqr(t);
        m += 1;
      }

      if (m === 0)
        break;

      assert(m !== k);

      t = BN.shift(1, k - m - 1);
      t = this.pow(g, t);
      g = this.sqr(t);
      y = this.mul(y, t);
      b = this.mul(b, g);
      k = m;
    }

    return y;
  }

  iinvert(a) {
    return this.invert(a)._move(a);
  }

  invert(a) {
    this._verify1(a);

    if (this.prime) {
      const inv = a._invertp(this.m);

      if (inv.negative !== 0) {
        inv.negative = 0;
        this.imod(inv);
        this.ineg(inv);
      } else {
        this.imod(inv);
      }

      return inv;
    }

    return a.invert(this.m)._forceRed(this);
  }

  ifermat(a) {
    return this.fermat(a)._move(a);
  }

  fermat(a) {
    this._verify1(a);

    if (a.isZero() || this.m.cmpn(1) === 0)
      throw new RangeError('Not invertible.');

    // Invert using fermat's little theorem.
    return this.pow(a, this.m.subn(2));
  }

  legendre(a) {
    this._verify1(a);

    if (this.m.isEven())
      throw new Error('legendre: `num` must be odd.');

    // Euler's criterion.
    const s = this.pow(a, this.m.subn(1).iushrn(1));

    if (s.isZero())
      return 0;

    const one = new BN(1).toRed(this);

    if (s.cmp(one) === 0)
      return 1;

    if (this.iadd(s, one).isZero())
      return -1;

    throw new Error('Invalid prime.');
  }

  jacobi(a) {
    this._verify1(a);
    return a.jacobi(this.m);
  }

  kronecker(a) {
    this._verify1(a);
    return a.kronecker(this.m);
  }

  ipow(a, num) {
    return this.pow(a, num)._move(a);
  }

  pow(a, num) {
    this._verify1(a);

    if (num.isZero())
      return new BN(1).toRed(this);

    // GMP behavior.
    if (num.isNeg())
      a = this.invert(a);

    if (num.ucmpn(1) === 0)
      return a.clone();

    if (num.length === 1)
      return this.pown(a, num.words[0]);

    const windowSize = 4;
    const wnd = new Array(1 << windowSize);

    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;

    for (let i = 2; i < wnd.length; i++)
      wnd[i] = this.mul(wnd[i - 1], a);

    let res = wnd[0];
    let current = 0;
    let currentLen = 0;
    let start = num.bitLength() % 26;

    if (start === 0)
      start = 26;

    for (let i = num.length - 1; i >= 0; i--) {
      const word = num.words[i];

      for (let j = start - 1; j >= 0; j--) {
        const bit = (word >> j) & 1;

        if (res !== wnd[0])
          res = this.sqr(res);

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen += 1;

        if (currentLen !== windowSize && (i !== 0 || j !== 0))
          continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }

      start = 26;
    }

    return res;
  }

  ipown(a, num) {
    return this.pown(a, num)._move(a);
  }

  pown(a, num) {
    this._verify1(a);

    let x = a;
    let y = num;
    let r = new BN(1).toRed(this);

    if (y < 0) {
      x = this.invert(x);
      y = -y;
    }

    while (y > 0) {
      if (y & 1)
        r = this.mul(r, x);

      y >>>= 1;
      x = this.sqr(x);
    }

    return r;
  }

  convertTo(num) {
    return num.mod(this.m);
  }

  convertFrom(num) {
    const res = num.clone();
    res.red = null;
    return res;
  }

  [custom]() {
    return `<Red: ${this.m.toString(10)}>`;
  }
}

/**
 * Montgomery Method Engine
 */

class Mont extends Red {
  constructor(m) {
    super(m);

    this.n = this.m.bitLength();

    if (this.n % 26 !== 0)
      this.n += 26 - (this.n % 26);

    this.r = BN.shift(1, this.n);
    this.r2 = this.imod(this.r.sqr());
    this.ri = this.r._invertp(this.m).imod(this.m);
    this.mi = this.r.sub(this.ri.mul(this.r).isubn(1).div(this.m).imod(this.r));
  }

  convertTo(num) {
    return this.imod(num.ushln(this.n));
  }

  convertFrom(num) {
    const r = this.imod(num.mul(this.ri));
    r.red = null;
    return r;
  }

  imul(a, b) {
    this._verify2(a, b);

    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    const t = a.imul(b);
    const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n).mul(this.m);
    const u = t.isub(c).iushrn(this.n);

    let res = u;

    if (u.cmp(this.m) >= 0)
      res = u.isub(this.m);
    else if (u.sign() < 0)
      res = u.iadd(this.m);

    return res._forceRed(this);
  }

  mul(a, b) {
    this._verify2(a, b);

    if (a.isZero() || b.isZero())
      return new BN(0)._forceRed(this);

    const t = a.mul(b);
    const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n).mul(this.m);
    const u = t.isub(c).iushrn(this.n);

    let res = u;

    if (u.cmp(this.m) >= 0)
      res = u.isub(this.m);
    else if (u.sign() < 0)
      res = u.iadd(this.m);

    return res._forceRed(this);
  }

  invert(a) {
    this._verify1(a);

    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    const res = this.imod(a._invertp(this.m).mul(this.r2));

    return res._forceRed(this);
  }
}

/*
 * Helpers
 */

function makeError(Error, msg, start) {
  const err = new Error(msg);

  if (Error.captureStackTrace)
    Error.captureStackTrace(err, start);

  return err;
}

function assert(value, message) {
  if (!value) {
    const msg = message || 'Assertion failed.';
    throw makeError(Error, msg, assert);
  }
}

function enforce(value, name, type) {
  if (!value) {
    const msg = `"${name}" must be a(n) ${type}.`;
    throw makeError(TypeError, msg, enforce);
  }
}

function range(value, name) {
  if (!value) {
    const msg = `"${name}" only works with positive numbers.`;
    throw makeError(RangeError, msg, range);
  }
}

function red(value, name) {
  if (!value) {
    const msg = `"${name}" only works with red numbers.`;
    throw makeError(TypeError, msg, red);
  }
}

function nonred(value, name) {
  if (!value) {
    const msg = `"${name}" only works with normal numbers.`;
    throw makeError(TypeError, msg, nonred);
  }
}

function nonzero(value) {
  if (!value) {
    const msg = 'Cannot divide by zero.';
    throw makeError(RangeError, msg, nonzero);
  }
}

function isInteger(num) {
  return Number.isSafeInteger(num);
}

function isSMI(num) {
  return isInteger(num)
      && num >= -0x3ffffff
      && num <= 0x3ffffff;
}

function allocate(ArrayType, size) {
  if (ArrayType.allocUnsafe)
    return ArrayType.allocUnsafe(size);

  return new ArrayType(size);
}

function getBase(base) {
  if (base == null)
    return 10;

  if (typeof base === 'number')
    return base;

  switch (base) {
    case 'bin':
      return 2;
    case 'oct':
      return 8;
    case 'dec':
      return 10;
    case 'hex':
      return 16;
  }

  return 0;
}

/*
 * Internal
 */

function toBitArray(num) {
  const w = new Array(num.bitLength());

  for (let bit = 0; bit < w.length; bit++) {
    const wbit = bit % 26;
    const off = (bit - wbit) / 26;

    w[bit] = (num.words[off] >>> wbit) & 1;
  }

  return w;
}

function countBits(w) {
  if (Math.clz32)
    return 32 - Math.clz32(w);

  let t = w;
  let r = 0;

  if (t >= 0x1000) {
    r += 13;
    t >>>= 13;
  }

  if (t >= 0x40) {
    r += 7;
    t >>>= 7;
  }

  if (t >= 0x8) {
    r += 4;
    t >>>= 4;
  }

  if (t >= 0x02) {
    r += 2;
    t >>>= 2;
  }

  return r + t;
}

function zeroBits(w) {
  // Shortcut.
  if (w === 0)
    return 26;

  let t = w;
  let r = 0;

  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }

  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }

  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }

  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }

  if ((t & 0x1) === 0)
    r += 1;

  return r;
}

function parseHex(str, start, end) {
  const len = Math.min(str.length, end);

  let r = 0;
  let z = 0;

  for (let i = start; i < len; i++) {
    const c = str.charCodeAt(i) - 48;

    r <<= 4;

    let b;

    if (c >= 49 && c <= 54) {
      // 'a' - 'f'
      b = c - 49 + 0xa;
    } else if (c >= 17 && c <= 22) {
      // 'A' - 'F'
      b = c - 17 + 0xa;
    } else {
      // '0' - '9'
      b = c;
    }

    r |= b;
    z |= b;
  }

  if (z & 0xfff0)
    throw new Error('Invalid string.');

  return r;
}

function parseBase(str, start, end, mul) {
  const len = Math.min(str.length, end);

  let r = 0;
  let b = 0;

  for (let i = start; i < len; i++) {
    const c = str.charCodeAt(i) - 48;

    r *= mul;

    if (c >= 49) {
      // 'a'
      b = c - 49 + 0xa;
    } else if (c >= 17) {
      // 'A'
      b = c - 17 + 0xa;
    } else {
      // '0' - '9'
      b = c;
    }

    if (c < 0 || c > 207 || b >= mul)
      throw new Error('Invalid string.');

    r += b;
  }

  return r;
}

/*
 * Multiplication
 */

function smallMulTo(self, num, out) {
  const len = self.length + num.length;

  out.negative = self.negative ^ num.negative;
  out._alloc(len);
  out.length = len;

  // Peel one iteration (compiler can't
  // do it, because of code complexity).
  const a = self.words[0];
  const b = num.words[0];
  const r = a * b;
  const lo = r & 0x3ffffff;

  let carry = (r / 0x4000000) | 0;
  let k = 1;

  out.words[0] = lo;

  for (; k < out.length - 1; k++) {
    // Sum all words with the same
    // `i + j = k` and accumulate
    // `ncarry`, note that ncarry
    // could be >= 0x3ffffff.
    let ncarry = carry >>> 26;
    let rword = carry & 0x3ffffff;

    const min = Math.max(0, k - self.length + 1);
    const max = Math.min(k, num.length - 1);

    for (let j = min; j <= max; j++) {
      const i = k - j;
      const a = self.words[i];
      const b = num.words[j];
      const r = a * b + rword;

      ncarry += (r / 0x4000000) | 0;
      rword = r & 0x3ffffff;
    }

    out.words[k] = rword | 0;
    carry = ncarry | 0;
  }

  if (carry !== 0)
    out.words[k] = carry | 0;
  else
    out.length -= 1;

  return out._strip();
}

function bigMulTo(self, num, out) {
  const len = self.length + num.length;

  out.negative = self.negative ^ num.negative;
  out._alloc(len);
  out.length = len;

  let carry = 0;
  let hncarry = 0;
  let k = 0;

  for (; k < out.length - 1; k++) {
    // Sum all words with the same
    // `i + j = k` and accumulate
    // `ncarry`, note that ncarry
    // could be >= 0x3ffffff.
    let ncarry = hncarry;

    hncarry = 0;

    let rword = carry & 0x3ffffff;

    const min = Math.max(0, k - self.length + 1);
    const max = Math.min(k, num.length - 1);

    for (let j = min; j <= max; j++) {
      const i = k - j;
      const a = self.words[i];
      const b = num.words[j];
      const r = a * b;

      let lo = r & 0x3ffffff;

      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }

    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }

  if (carry !== 0)
    out.words[k] = carry;
  else
    out.length -= 1;

  return out._strip();
}

function comb10MulTo(self, num, out) {
  const a = self.words;
  const b = num.words;
  const o = out.words;
  const a0 = a[0] | 0;
  const al0 = a0 & 0x1fff;
  const ah0 = a0 >>> 13;
  const a1 = a[1] | 0;
  const al1 = a1 & 0x1fff;
  const ah1 = a1 >>> 13;
  const a2 = a[2] | 0;
  const al2 = a2 & 0x1fff;
  const ah2 = a2 >>> 13;
  const a3 = a[3] | 0;
  const al3 = a3 & 0x1fff;
  const ah3 = a3 >>> 13;
  const a4 = a[4] | 0;
  const al4 = a4 & 0x1fff;
  const ah4 = a4 >>> 13;
  const a5 = a[5] | 0;
  const al5 = a5 & 0x1fff;
  const ah5 = a5 >>> 13;
  const a6 = a[6] | 0;
  const al6 = a6 & 0x1fff;
  const ah6 = a6 >>> 13;
  const a7 = a[7] | 0;
  const al7 = a7 & 0x1fff;
  const ah7 = a7 >>> 13;
  const a8 = a[8] | 0;
  const al8 = a8 & 0x1fff;
  const ah8 = a8 >>> 13;
  const a9 = a[9] | 0;
  const al9 = a9 & 0x1fff;
  const ah9 = a9 >>> 13;
  const b0 = b[0] | 0;
  const bl0 = b0 & 0x1fff;
  const bh0 = b0 >>> 13;
  const b1 = b[1] | 0;
  const bl1 = b1 & 0x1fff;
  const bh1 = b1 >>> 13;
  const b2 = b[2] | 0;
  const bl2 = b2 & 0x1fff;
  const bh2 = b2 >>> 13;
  const b3 = b[3] | 0;
  const bl3 = b3 & 0x1fff;
  const bh3 = b3 >>> 13;
  const b4 = b[4] | 0;
  const bl4 = b4 & 0x1fff;
  const bh4 = b4 >>> 13;
  const b5 = b[5] | 0;
  const bl5 = b5 & 0x1fff;
  const bh5 = b5 >>> 13;
  const b6 = b[6] | 0;
  const bl6 = b6 & 0x1fff;
  const bh6 = b6 >>> 13;
  const b7 = b[7] | 0;
  const bl7 = b7 & 0x1fff;
  const bh7 = b7 >>> 13;
  const b8 = b[8] | 0;
  const bl8 = b8 & 0x1fff;
  const bh8 = b8 >>> 13;
  const b9 = b[9] | 0;
  const bl9 = b9 & 0x1fff;
  const bh9 = b9 >>> 13;

  let c = 0;
  let lo;
  let mid;
  let hi;

  out.negative = self.negative ^ num.negative;
  out._alloc(20);
  out.length = 19;

  /* k = 0 */
  lo = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = (mid + Math.imul(ah0, bl0)) | 0;
  hi = Math.imul(ah0, bh0);
  let w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
  w0 &= 0x3ffffff;

  /* k = 1 */
  lo = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = (mid + Math.imul(ah1, bl0)) | 0;
  hi = Math.imul(ah1, bh0);
  lo = (lo + Math.imul(al0, bl1)) | 0;
  mid = (mid + Math.imul(al0, bh1)) | 0;
  mid = (mid + Math.imul(ah0, bl1)) | 0;
  hi = (hi + Math.imul(ah0, bh1)) | 0;
  let w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
  w1 &= 0x3ffffff;

  /* k = 2 */
  lo = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = (mid + Math.imul(ah2, bl0)) | 0;
  hi = Math.imul(ah2, bh0);
  lo = (lo + Math.imul(al1, bl1)) | 0;
  mid = (mid + Math.imul(al1, bh1)) | 0;
  mid = (mid + Math.imul(ah1, bl1)) | 0;
  hi = (hi + Math.imul(ah1, bh1)) | 0;
  lo = (lo + Math.imul(al0, bl2)) | 0;
  mid = (mid + Math.imul(al0, bh2)) | 0;
  mid = (mid + Math.imul(ah0, bl2)) | 0;
  hi = (hi + Math.imul(ah0, bh2)) | 0;
  let w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;

  /* k = 3 */
  lo = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = (mid + Math.imul(ah3, bl0)) | 0;
  hi = Math.imul(ah3, bh0);
  lo = (lo + Math.imul(al2, bl1)) | 0;
  mid = (mid + Math.imul(al2, bh1)) | 0;
  mid = (mid + Math.imul(ah2, bl1)) | 0;
  hi = (hi + Math.imul(ah2, bh1)) | 0;
  lo = (lo + Math.imul(al1, bl2)) | 0;
  mid = (mid + Math.imul(al1, bh2)) | 0;
  mid = (mid + Math.imul(ah1, bl2)) | 0;
  hi = (hi + Math.imul(ah1, bh2)) | 0;
  lo = (lo + Math.imul(al0, bl3)) | 0;
  mid = (mid + Math.imul(al0, bh3)) | 0;
  mid = (mid + Math.imul(ah0, bl3)) | 0;
  hi = (hi + Math.imul(ah0, bh3)) | 0;
  let w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;

  /* k = 4 */
  lo = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = (mid + Math.imul(ah4, bl0)) | 0;
  hi = Math.imul(ah4, bh0);
  lo = (lo + Math.imul(al3, bl1)) | 0;
  mid = (mid + Math.imul(al3, bh1)) | 0;
  mid = (mid + Math.imul(ah3, bl1)) | 0;
  hi = (hi + Math.imul(ah3, bh1)) | 0;
  lo = (lo + Math.imul(al2, bl2)) | 0;
  mid = (mid + Math.imul(al2, bh2)) | 0;
  mid = (mid + Math.imul(ah2, bl2)) | 0;
  hi = (hi + Math.imul(ah2, bh2)) | 0;
  lo = (lo + Math.imul(al1, bl3)) | 0;
  mid = (mid + Math.imul(al1, bh3)) | 0;
  mid = (mid + Math.imul(ah1, bl3)) | 0;
  hi = (hi + Math.imul(ah1, bh3)) | 0;
  lo = (lo + Math.imul(al0, bl4)) | 0;
  mid = (mid + Math.imul(al0, bh4)) | 0;
  mid = (mid + Math.imul(ah0, bl4)) | 0;
  hi = (hi + Math.imul(ah0, bh4)) | 0;
  let w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;

  /* k = 5 */
  lo = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = (mid + Math.imul(ah5, bl0)) | 0;
  hi = Math.imul(ah5, bh0);
  lo = (lo + Math.imul(al4, bl1)) | 0;
  mid = (mid + Math.imul(al4, bh1)) | 0;
  mid = (mid + Math.imul(ah4, bl1)) | 0;
  hi = (hi + Math.imul(ah4, bh1)) | 0;
  lo = (lo + Math.imul(al3, bl2)) | 0;
  mid = (mid + Math.imul(al3, bh2)) | 0;
  mid = (mid + Math.imul(ah3, bl2)) | 0;
  hi = (hi + Math.imul(ah3, bh2)) | 0;
  lo = (lo + Math.imul(al2, bl3)) | 0;
  mid = (mid + Math.imul(al2, bh3)) | 0;
  mid = (mid + Math.imul(ah2, bl3)) | 0;
  hi = (hi + Math.imul(ah2, bh3)) | 0;
  lo = (lo + Math.imul(al1, bl4)) | 0;
  mid = (mid + Math.imul(al1, bh4)) | 0;
  mid = (mid + Math.imul(ah1, bl4)) | 0;
  hi = (hi + Math.imul(ah1, bh4)) | 0;
  lo = (lo + Math.imul(al0, bl5)) | 0;
  mid = (mid + Math.imul(al0, bh5)) | 0;
  mid = (mid + Math.imul(ah0, bl5)) | 0;
  hi = (hi + Math.imul(ah0, bh5)) | 0;
  let w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;

  /* k = 6 */
  lo = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = (mid + Math.imul(ah6, bl0)) | 0;
  hi = Math.imul(ah6, bh0);
  lo = (lo + Math.imul(al5, bl1)) | 0;
  mid = (mid + Math.imul(al5, bh1)) | 0;
  mid = (mid + Math.imul(ah5, bl1)) | 0;
  hi = (hi + Math.imul(ah5, bh1)) | 0;
  lo = (lo + Math.imul(al4, bl2)) | 0;
  mid = (mid + Math.imul(al4, bh2)) | 0;
  mid = (mid + Math.imul(ah4, bl2)) | 0;
  hi = (hi + Math.imul(ah4, bh2)) | 0;
  lo = (lo + Math.imul(al3, bl3)) | 0;
  mid = (mid + Math.imul(al3, bh3)) | 0;
  mid = (mid + Math.imul(ah3, bl3)) | 0;
  hi = (hi + Math.imul(ah3, bh3)) | 0;
  lo = (lo + Math.imul(al2, bl4)) | 0;
  mid = (mid + Math.imul(al2, bh4)) | 0;
  mid = (mid + Math.imul(ah2, bl4)) | 0;
  hi = (hi + Math.imul(ah2, bh4)) | 0;
  lo = (lo + Math.imul(al1, bl5)) | 0;
  mid = (mid + Math.imul(al1, bh5)) | 0;
  mid = (mid + Math.imul(ah1, bl5)) | 0;
  hi = (hi + Math.imul(ah1, bh5)) | 0;
  lo = (lo + Math.imul(al0, bl6)) | 0;
  mid = (mid + Math.imul(al0, bh6)) | 0;
  mid = (mid + Math.imul(ah0, bl6)) | 0;
  hi = (hi + Math.imul(ah0, bh6)) | 0;
  let w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;

  /* k = 7 */
  lo = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = (mid + Math.imul(ah7, bl0)) | 0;
  hi = Math.imul(ah7, bh0);
  lo = (lo + Math.imul(al6, bl1)) | 0;
  mid = (mid + Math.imul(al6, bh1)) | 0;
  mid = (mid + Math.imul(ah6, bl1)) | 0;
  hi = (hi + Math.imul(ah6, bh1)) | 0;
  lo = (lo + Math.imul(al5, bl2)) | 0;
  mid = (mid + Math.imul(al5, bh2)) | 0;
  mid = (mid + Math.imul(ah5, bl2)) | 0;
  hi = (hi + Math.imul(ah5, bh2)) | 0;
  lo = (lo + Math.imul(al4, bl3)) | 0;
  mid = (mid + Math.imul(al4, bh3)) | 0;
  mid = (mid + Math.imul(ah4, bl3)) | 0;
  hi = (hi + Math.imul(ah4, bh3)) | 0;
  lo = (lo + Math.imul(al3, bl4)) | 0;
  mid = (mid + Math.imul(al3, bh4)) | 0;
  mid = (mid + Math.imul(ah3, bl4)) | 0;
  hi = (hi + Math.imul(ah3, bh4)) | 0;
  lo = (lo + Math.imul(al2, bl5)) | 0;
  mid = (mid + Math.imul(al2, bh5)) | 0;
  mid = (mid + Math.imul(ah2, bl5)) | 0;
  hi = (hi + Math.imul(ah2, bh5)) | 0;
  lo = (lo + Math.imul(al1, bl6)) | 0;
  mid = (mid + Math.imul(al1, bh6)) | 0;
  mid = (mid + Math.imul(ah1, bl6)) | 0;
  hi = (hi + Math.imul(ah1, bh6)) | 0;
  lo = (lo + Math.imul(al0, bl7)) | 0;
  mid = (mid + Math.imul(al0, bh7)) | 0;
  mid = (mid + Math.imul(ah0, bl7)) | 0;
  hi = (hi + Math.imul(ah0, bh7)) | 0;
  let w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;

  /* k = 8 */
  lo = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = (mid + Math.imul(ah8, bl0)) | 0;
  hi = Math.imul(ah8, bh0);
  lo = (lo + Math.imul(al7, bl1)) | 0;
  mid = (mid + Math.imul(al7, bh1)) | 0;
  mid = (mid + Math.imul(ah7, bl1)) | 0;
  hi = (hi + Math.imul(ah7, bh1)) | 0;
  lo = (lo + Math.imul(al6, bl2)) | 0;
  mid = (mid + Math.imul(al6, bh2)) | 0;
  mid = (mid + Math.imul(ah6, bl2)) | 0;
  hi = (hi + Math.imul(ah6, bh2)) | 0;
  lo = (lo + Math.imul(al5, bl3)) | 0;
  mid = (mid + Math.imul(al5, bh3)) | 0;
  mid = (mid + Math.imul(ah5, bl3)) | 0;
  hi = (hi + Math.imul(ah5, bh3)) | 0;
  lo = (lo + Math.imul(al4, bl4)) | 0;
  mid = (mid + Math.imul(al4, bh4)) | 0;
  mid = (mid + Math.imul(ah4, bl4)) | 0;
  hi = (hi + Math.imul(ah4, bh4)) | 0;
  lo = (lo + Math.imul(al3, bl5)) | 0;
  mid = (mid + Math.imul(al3, bh5)) | 0;
  mid = (mid + Math.imul(ah3, bl5)) | 0;
  hi = (hi + Math.imul(ah3, bh5)) | 0;
  lo = (lo + Math.imul(al2, bl6)) | 0;
  mid = (mid + Math.imul(al2, bh6)) | 0;
  mid = (mid + Math.imul(ah2, bl6)) | 0;
  hi = (hi + Math.imul(ah2, bh6)) | 0;
  lo = (lo + Math.imul(al1, bl7)) | 0;
  mid = (mid + Math.imul(al1, bh7)) | 0;
  mid = (mid + Math.imul(ah1, bl7)) | 0;
  hi = (hi + Math.imul(ah1, bh7)) | 0;
  lo = (lo + Math.imul(al0, bl8)) | 0;
  mid = (mid + Math.imul(al0, bh8)) | 0;
  mid = (mid + Math.imul(ah0, bl8)) | 0;
  hi = (hi + Math.imul(ah0, bh8)) | 0;
  let w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;

  /* k = 9 */
  lo = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = (mid + Math.imul(ah9, bl0)) | 0;
  hi = Math.imul(ah9, bh0);
  lo = (lo + Math.imul(al8, bl1)) | 0;
  mid = (mid + Math.imul(al8, bh1)) | 0;
  mid = (mid + Math.imul(ah8, bl1)) | 0;
  hi = (hi + Math.imul(ah8, bh1)) | 0;
  lo = (lo + Math.imul(al7, bl2)) | 0;
  mid = (mid + Math.imul(al7, bh2)) | 0;
  mid = (mid + Math.imul(ah7, bl2)) | 0;
  hi = (hi + Math.imul(ah7, bh2)) | 0;
  lo = (lo + Math.imul(al6, bl3)) | 0;
  mid = (mid + Math.imul(al6, bh3)) | 0;
  mid = (mid + Math.imul(ah6, bl3)) | 0;
  hi = (hi + Math.imul(ah6, bh3)) | 0;
  lo = (lo + Math.imul(al5, bl4)) | 0;
  mid = (mid + Math.imul(al5, bh4)) | 0;
  mid = (mid + Math.imul(ah5, bl4)) | 0;
  hi = (hi + Math.imul(ah5, bh4)) | 0;
  lo = (lo + Math.imul(al4, bl5)) | 0;
  mid = (mid + Math.imul(al4, bh5)) | 0;
  mid = (mid + Math.imul(ah4, bl5)) | 0;
  hi = (hi + Math.imul(ah4, bh5)) | 0;
  lo = (lo + Math.imul(al3, bl6)) | 0;
  mid = (mid + Math.imul(al3, bh6)) | 0;
  mid = (mid + Math.imul(ah3, bl6)) | 0;
  hi = (hi + Math.imul(ah3, bh6)) | 0;
  lo = (lo + Math.imul(al2, bl7)) | 0;
  mid = (mid + Math.imul(al2, bh7)) | 0;
  mid = (mid + Math.imul(ah2, bl7)) | 0;
  hi = (hi + Math.imul(ah2, bh7)) | 0;
  lo = (lo + Math.imul(al1, bl8)) | 0;
  mid = (mid + Math.imul(al1, bh8)) | 0;
  mid = (mid + Math.imul(ah1, bl8)) | 0;
  hi = (hi + Math.imul(ah1, bh8)) | 0;
  lo = (lo + Math.imul(al0, bl9)) | 0;
  mid = (mid + Math.imul(al0, bh9)) | 0;
  mid = (mid + Math.imul(ah0, bl9)) | 0;
  hi = (hi + Math.imul(ah0, bh9)) | 0;
  let w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;

  /* k = 10 */
  lo = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = (mid + Math.imul(ah9, bl1)) | 0;
  hi = Math.imul(ah9, bh1);
  lo = (lo + Math.imul(al8, bl2)) | 0;
  mid = (mid + Math.imul(al8, bh2)) | 0;
  mid = (mid + Math.imul(ah8, bl2)) | 0;
  hi = (hi + Math.imul(ah8, bh2)) | 0;
  lo = (lo + Math.imul(al7, bl3)) | 0;
  mid = (mid + Math.imul(al7, bh3)) | 0;
  mid = (mid + Math.imul(ah7, bl3)) | 0;
  hi = (hi + Math.imul(ah7, bh3)) | 0;
  lo = (lo + Math.imul(al6, bl4)) | 0;
  mid = (mid + Math.imul(al6, bh4)) | 0;
  mid = (mid + Math.imul(ah6, bl4)) | 0;
  hi = (hi + Math.imul(ah6, bh4)) | 0;
  lo = (lo + Math.imul(al5, bl5)) | 0;
  mid = (mid + Math.imul(al5, bh5)) | 0;
  mid = (mid + Math.imul(ah5, bl5)) | 0;
  hi = (hi + Math.imul(ah5, bh5)) | 0;
  lo = (lo + Math.imul(al4, bl6)) | 0;
  mid = (mid + Math.imul(al4, bh6)) | 0;
  mid = (mid + Math.imul(ah4, bl6)) | 0;
  hi = (hi + Math.imul(ah4, bh6)) | 0;
  lo = (lo + Math.imul(al3, bl7)) | 0;
  mid = (mid + Math.imul(al3, bh7)) | 0;
  mid = (mid + Math.imul(ah3, bl7)) | 0;
  hi = (hi + Math.imul(ah3, bh7)) | 0;
  lo = (lo + Math.imul(al2, bl8)) | 0;
  mid = (mid + Math.imul(al2, bh8)) | 0;
  mid = (mid + Math.imul(ah2, bl8)) | 0;
  hi = (hi + Math.imul(ah2, bh8)) | 0;
  lo = (lo + Math.imul(al1, bl9)) | 0;
  mid = (mid + Math.imul(al1, bh9)) | 0;
  mid = (mid + Math.imul(ah1, bl9)) | 0;
  hi = (hi + Math.imul(ah1, bh9)) | 0;
  let w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;

  /* k = 11 */
  lo = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = (mid + Math.imul(ah9, bl2)) | 0;
  hi = Math.imul(ah9, bh2);
  lo = (lo + Math.imul(al8, bl3)) | 0;
  mid = (mid + Math.imul(al8, bh3)) | 0;
  mid = (mid + Math.imul(ah8, bl3)) | 0;
  hi = (hi + Math.imul(ah8, bh3)) | 0;
  lo = (lo + Math.imul(al7, bl4)) | 0;
  mid = (mid + Math.imul(al7, bh4)) | 0;
  mid = (mid + Math.imul(ah7, bl4)) | 0;
  hi = (hi + Math.imul(ah7, bh4)) | 0;
  lo = (lo + Math.imul(al6, bl5)) | 0;
  mid = (mid + Math.imul(al6, bh5)) | 0;
  mid = (mid + Math.imul(ah6, bl5)) | 0;
  hi = (hi + Math.imul(ah6, bh5)) | 0;
  lo = (lo + Math.imul(al5, bl6)) | 0;
  mid = (mid + Math.imul(al5, bh6)) | 0;
  mid = (mid + Math.imul(ah5, bl6)) | 0;
  hi = (hi + Math.imul(ah5, bh6)) | 0;
  lo = (lo + Math.imul(al4, bl7)) | 0;
  mid = (mid + Math.imul(al4, bh7)) | 0;
  mid = (mid + Math.imul(ah4, bl7)) | 0;
  hi = (hi + Math.imul(ah4, bh7)) | 0;
  lo = (lo + Math.imul(al3, bl8)) | 0;
  mid = (mid + Math.imul(al3, bh8)) | 0;
  mid = (mid + Math.imul(ah3, bl8)) | 0;
  hi = (hi + Math.imul(ah3, bh8)) | 0;
  lo = (lo + Math.imul(al2, bl9)) | 0;
  mid = (mid + Math.imul(al2, bh9)) | 0;
  mid = (mid + Math.imul(ah2, bl9)) | 0;
  hi = (hi + Math.imul(ah2, bh9)) | 0;
  let w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;

  /* k = 12 */
  lo = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = (mid + Math.imul(ah9, bl3)) | 0;
  hi = Math.imul(ah9, bh3);
  lo = (lo + Math.imul(al8, bl4)) | 0;
  mid = (mid + Math.imul(al8, bh4)) | 0;
  mid = (mid + Math.imul(ah8, bl4)) | 0;
  hi = (hi + Math.imul(ah8, bh4)) | 0;
  lo = (lo + Math.imul(al7, bl5)) | 0;
  mid = (mid + Math.imul(al7, bh5)) | 0;
  mid = (mid + Math.imul(ah7, bl5)) | 0;
  hi = (hi + Math.imul(ah7, bh5)) | 0;
  lo = (lo + Math.imul(al6, bl6)) | 0;
  mid = (mid + Math.imul(al6, bh6)) | 0;
  mid = (mid + Math.imul(ah6, bl6)) | 0;
  hi = (hi + Math.imul(ah6, bh6)) | 0;
  lo = (lo + Math.imul(al5, bl7)) | 0;
  mid = (mid + Math.imul(al5, bh7)) | 0;
  mid = (mid + Math.imul(ah5, bl7)) | 0;
  hi = (hi + Math.imul(ah5, bh7)) | 0;
  lo = (lo + Math.imul(al4, bl8)) | 0;
  mid = (mid + Math.imul(al4, bh8)) | 0;
  mid = (mid + Math.imul(ah4, bl8)) | 0;
  hi = (hi + Math.imul(ah4, bh8)) | 0;
  lo = (lo + Math.imul(al3, bl9)) | 0;
  mid = (mid + Math.imul(al3, bh9)) | 0;
  mid = (mid + Math.imul(ah3, bl9)) | 0;
  hi = (hi + Math.imul(ah3, bh9)) | 0;
  let w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;

  /* k = 13 */
  lo = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = (mid + Math.imul(ah9, bl4)) | 0;
  hi = Math.imul(ah9, bh4);
  lo = (lo + Math.imul(al8, bl5)) | 0;
  mid = (mid + Math.imul(al8, bh5)) | 0;
  mid = (mid + Math.imul(ah8, bl5)) | 0;
  hi = (hi + Math.imul(ah8, bh5)) | 0;
  lo = (lo + Math.imul(al7, bl6)) | 0;
  mid = (mid + Math.imul(al7, bh6)) | 0;
  mid = (mid + Math.imul(ah7, bl6)) | 0;
  hi = (hi + Math.imul(ah7, bh6)) | 0;
  lo = (lo + Math.imul(al6, bl7)) | 0;
  mid = (mid + Math.imul(al6, bh7)) | 0;
  mid = (mid + Math.imul(ah6, bl7)) | 0;
  hi = (hi + Math.imul(ah6, bh7)) | 0;
  lo = (lo + Math.imul(al5, bl8)) | 0;
  mid = (mid + Math.imul(al5, bh8)) | 0;
  mid = (mid + Math.imul(ah5, bl8)) | 0;
  hi = (hi + Math.imul(ah5, bh8)) | 0;
  lo = (lo + Math.imul(al4, bl9)) | 0;
  mid = (mid + Math.imul(al4, bh9)) | 0;
  mid = (mid + Math.imul(ah4, bl9)) | 0;
  hi = (hi + Math.imul(ah4, bh9)) | 0;
  let w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;

  /* k = 14 */
  lo = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = (mid + Math.imul(ah9, bl5)) | 0;
  hi = Math.imul(ah9, bh5);
  lo = (lo + Math.imul(al8, bl6)) | 0;
  mid = (mid + Math.imul(al8, bh6)) | 0;
  mid = (mid + Math.imul(ah8, bl6)) | 0;
  hi = (hi + Math.imul(ah8, bh6)) | 0;
  lo = (lo + Math.imul(al7, bl7)) | 0;
  mid = (mid + Math.imul(al7, bh7)) | 0;
  mid = (mid + Math.imul(ah7, bl7)) | 0;
  hi = (hi + Math.imul(ah7, bh7)) | 0;
  lo = (lo + Math.imul(al6, bl8)) | 0;
  mid = (mid + Math.imul(al6, bh8)) | 0;
  mid = (mid + Math.imul(ah6, bl8)) | 0;
  hi = (hi + Math.imul(ah6, bh8)) | 0;
  lo = (lo + Math.imul(al5, bl9)) | 0;
  mid = (mid + Math.imul(al5, bh9)) | 0;
  mid = (mid + Math.imul(ah5, bl9)) | 0;
  hi = (hi + Math.imul(ah5, bh9)) | 0;
  let w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;

  /* k = 15 */
  lo = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = (mid + Math.imul(ah9, bl6)) | 0;
  hi = Math.imul(ah9, bh6);
  lo = (lo + Math.imul(al8, bl7)) | 0;
  mid = (mid + Math.imul(al8, bh7)) | 0;
  mid = (mid + Math.imul(ah8, bl7)) | 0;
  hi = (hi + Math.imul(ah8, bh7)) | 0;
  lo = (lo + Math.imul(al7, bl8)) | 0;
  mid = (mid + Math.imul(al7, bh8)) | 0;
  mid = (mid + Math.imul(ah7, bl8)) | 0;
  hi = (hi + Math.imul(ah7, bh8)) | 0;
  lo = (lo + Math.imul(al6, bl9)) | 0;
  mid = (mid + Math.imul(al6, bh9)) | 0;
  mid = (mid + Math.imul(ah6, bl9)) | 0;
  hi = (hi + Math.imul(ah6, bh9)) | 0;
  let w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;

  /* k = 16 */
  lo = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = (mid + Math.imul(ah9, bl7)) | 0;
  hi = Math.imul(ah9, bh7);
  lo = (lo + Math.imul(al8, bl8)) | 0;
  mid = (mid + Math.imul(al8, bh8)) | 0;
  mid = (mid + Math.imul(ah8, bl8)) | 0;
  hi = (hi + Math.imul(ah8, bh8)) | 0;
  lo = (lo + Math.imul(al7, bl9)) | 0;
  mid = (mid + Math.imul(al7, bh9)) | 0;
  mid = (mid + Math.imul(ah7, bl9)) | 0;
  hi = (hi + Math.imul(ah7, bh9)) | 0;
  let w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;

  /* k = 17 */
  lo = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = (mid + Math.imul(ah9, bl8)) | 0;
  hi = Math.imul(ah9, bh8);
  lo = (lo + Math.imul(al8, bl9)) | 0;
  mid = (mid + Math.imul(al8, bh9)) | 0;
  mid = (mid + Math.imul(ah8, bl9)) | 0;
  hi = (hi + Math.imul(ah8, bh9)) | 0;
  let w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
  w17 &= 0x3ffffff;

  /* k = 18 */
  lo = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = (mid + Math.imul(ah9, bl9)) | 0;
  hi = Math.imul(ah9, bh9);
  let w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
  w18 &= 0x3ffffff;

  o[0] = w0;
  o[1] = w1;
  o[2] = w2;
  o[3] = w3;
  o[4] = w4;
  o[5] = w5;
  o[6] = w6;
  o[7] = w7;
  o[8] = w8;
  o[9] = w9;
  o[10] = w10;
  o[11] = w11;
  o[12] = w12;
  o[13] = w13;
  o[14] = w14;
  o[15] = w15;
  o[16] = w16;
  o[17] = w17;
  o[18] = w18;

  if (c !== 0) {
    o[19] = c;
    out.length += 1;
  }

  // Note: we shouldn't need to strip here.
  return out;
}

// Polyfill comb.
if (!Math.imul)
  comb10MulTo = smallMulTo;

/*
 * Expose
 */

module.exports = BN;

}).call(this,req("buffer").Buffer)
},{"../internal/custom":73,"buffer":303}],89:[function(req,module,exports){
(function (Buffer){
/*!
 * cash32.js - cashaddr for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Bitcoin-ABC/bitcoin-abc:
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   Copyright (c) 2009-2017, The Bitcoin Core Developers (MIT License).
 *   https://github.com/Bitcoin-ABC/bitcoin-abc
 *
 * Parts of this software are based on sipa/bech32:
 *   Copyright (c) 2017, Pieter Wuille (MIT License).
 *   https://github.com/sipa/bech32
 *
 * Resources:
 *   https://github.com/bitcoincashorg/spec/blob/master/cashaddr.md
 *   https://github.com/Bitcoin-ABC/bitcoin-abc/blob/master/src/cashaddr.cpp
 */

'use strict';

const assert = req('bsert');

/**
 * Constants
 */

const POOL105 = Buffer.allocUnsafe(105);
const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
];

const CHECKSUM_MASK = [0x00000007, 0xffffffff];

const GENERATOR = [
  0x00000098, 0xf2bc8e61,
  0x00000079, 0xb76d99e2,
  0x000000f3, 0x3e5fb3c4,
  0x000000ae, 0x2eabe2a8,
  0x0000001e, 0x4f43e470
];

/**
 * Update checksum
 * @ignore
 * @param {Number[]} chk
 * @param {Number} x
 * @returns {Number[]} -- new checksum
 */

function polymod(pre, x) {
  const c = pre;

  // b = c >> 35
  const b = c[0] >>> 3;

  // c = (c & CHECKSUM_MASK) << 5
  c[0] &= CHECKSUM_MASK[0];
  c[1] &= CHECKSUM_MASK[1];
  c[0] <<= 5;
  c[0] |= c[1] >>> 27;
  c[1] <<= 5;

  for (let i = 0; i < 5; i++) {
    if ((b >>> i) & 1) {
      // c ^= GENERATOR[i]
      c[0] ^= GENERATOR[i * 2 + 0];
      c[1] ^= GENERATOR[i * 2 + 1];
    }
  }

  // c ^= x
  c[1] ^= x;

  return c;
}

/**
 * Serialize data to cash32.
 * @param {String} prefix
 * @param {Buffer} data - 5bit serialized
 * @returns {String}
 */

function serialize(prefix, data) {
  assert(typeof prefix === 'string');
  assert(Buffer.isBuffer(data));

  const chk = [0, 1];

  let upper = false;
  let lower = false;
  let str = '';

  for (let i = 0; i < prefix.length; i++) {
    let ch = prefix.charCodeAt(i);

    if ((ch & 0xff00) || (ch >>> 5) === 0)
      throw new Error('Invalid cash32 character.');

    if (ch >= 0x61 && ch <= 0x7a) {
      lower = true;
    } else if (ch >= 0x41 && ch <= 0x5a) {
      upper = true;
      ch = (ch - 0x41) + 0x61;
    } else if (ch >= 0x30 && ch <= 0x39) {
      throw new Error('Invalid cash32 prefix.');
    }

    polymod(chk, ch & 0x1f);

    str += String.fromCharCode(ch);
  }

  if (lower && upper)
    throw new Error('Invalid cash32 prefix.');

  polymod(chk, 0);
  str += ':';

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];

    if ((ch >>> 5) !== 0)
      throw new Error('Invalid cash32 value.');

    polymod(chk, ch);

    str += CHARSET[ch];
  }

  for (let i = 0; i < 8; i++)
    polymod(chk, 0);

  chk[1] ^= 1;

  // i = 0, shift = 35
  str += CHARSET[(chk[0] >>> 3) & 0x1f];

  for (let i = 1; i < 7; i++) {
    const shift = (7 - i) * 5;
    const v = (chk[1] >>> shift) | (chk[0] << (32 - shift));

    str += CHARSET[v & 0x1f];
  }

  // i = 7, shift = 0
  str += CHARSET[chk[1] & 0x1f];

  return str;
}

/**
 * Decode cash32 string.
 * @param {String} str
 * @param {String} defaultPrefix (lowercase and w/o numbers)
 * @returns {Array} [prefix, data]
 */

function deserialize(str, defaultPrefix) {
  assert(typeof str === 'string');
  assert(typeof defaultPrefix === 'string');

  if (str.length < 8 || str.length > 196) // 83 + 1 + 112
    throw new Error('Invalid cash32 data length.');

  let lower = false;
  let upper = false;
  let number = false;
  let plen = 0;

  // Process lower/upper, make sure we have prefix.
  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch >= 0x61 && ch <= 0x7a) {
      lower = true;
      continue;
    }

    if (ch >= 0x41 && ch <= 0x5a) {
      upper = true;
      continue;
    }

    if (ch >= 0x30 && ch <= 0x39) {
      number = true;
      continue;
    }

    if (ch === 0x3a) { // :
      if (number || i === 0 || i > 83)
        throw new Error('Invalid cash32 prefix.');

      if (plen !== 0)
        throw new Error('Invalid cash32 separators.');

      plen = i;

      continue;
    }

    throw new Error('Invalid cash32 character.');
  }

  if (upper && lower)
    throw new Error('Invalid cash32 casing.');

  // Process checksum.
  const chk = [0, 1];

  let prefix;

  if (plen === 0) {
    prefix = defaultPrefix.toLowerCase();
  } else {
    prefix = str.substring(0, plen).toLowerCase();
    plen += 1;
  }

  // Process prefix.
  for (let i = 0; i < prefix.length; i++) {
    const ch = prefix.charCodeAt(i);

    polymod(chk, (ch | 0x20) & 0x1f);
  }

  polymod(chk, 0);

  const dlen = str.length - plen;

  if (dlen <= 8 || dlen > 112)
    throw new Error('Invalid cash32 data length.');

  const data = Buffer.allocUnsafe(dlen);

  for (let i = plen; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    const v = (ch & 0xff80) ? -1 : TABLE[ch];

    if (v === -1)
      throw new Error('Invalid cash32 character.');

    polymod(chk, v);

    if (i + 8 < str.length)
      data[i - plen] = v;
  }

  const valid = chk[0] === 0 && chk[1] === 1 && prefix === defaultPrefix;

  if (!valid)
    throw new Error('Invalid cash32 checksum.');

  return [prefix, data.slice(0, -8)];
}

/**
 * Test whether a string is a cash32 string.
 * @param {String} str
 * @returns {Boolean}
 */

function is(str, defaultPrefix) {
  assert(typeof str === 'string');
  assert(typeof defaultPrefix === 'string');

  try {
    deserialize(str, defaultPrefix);
  } catch (e) {
    return false;
  }

  return true;
}

/**
 * Convert serialized data to another base.
 * @param {Buffer} input
 * @param {Number} i
 * @param {Buffer} output
 * @param {Number} j
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Boolean} pad
 * @returns {Buffer}
 */

function convert(input, i, output, j, frombits, tobits, pad) {
  assert(Buffer.isBuffer(input));
  assert((i >>> 0) === i);
  assert(Buffer.isBuffer(output));
  assert((j >>> 0) === j);
  assert((frombits & 0xff) === frombits);
  assert((tobits & 0xff) === tobits);
  assert(typeof pad === 'boolean');
  assert(frombits !== 0);
  assert(tobits !== 0);

  const maxv = (1 << tobits) - 1;

  let acc = 0;
  let bits = 0;

  for (; i < input.length; i++) {
    const value = input[i];

    if ((value >>> frombits) !== 0)
      throw new Error('Invalid bits.');

    acc = (acc << frombits) | value;
    bits += frombits;

    while (bits >= tobits) {
      bits -= tobits;
      output[j++] = (acc >>> bits) & maxv;
    }
  }

  if (pad) {
    if (bits)
      output[j++] = (acc << (tobits - bits)) & maxv;
  } else {
    if (bits >= frombits || ((acc << (tobits - bits)) & maxv))
      throw new Error('Invalid bits.');
  }

  assert(j <= output.length);

  return output.slice(0, j);
}

/**
 * Calculate size reqd for bit conversion.
 * @param {Number} len
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Boolean} pad
 * @returns {Number}
 */

function convertSize(len, frombits, tobits, pad) {
  assert((len >>> 0) === len);
  assert((frombits & 0xff) === frombits);
  assert((tobits & 0xff) === tobits);
  assert(typeof pad === 'boolean');
  assert(frombits !== 0);
  assert(tobits !== 0);

  let size = (len * frombits + (tobits - 1)) / tobits;

  size >>>= 0;

  if (pad)
    size += 1;

  return size;
}

/**
 * Convert serialized data to another base.
 * @param {Buffer} data
 * @param {Number} frombits
 * @param {Number} tobits
 * @param {Boolean} pad
 * @returns {Buffer}
 */

function convertBits(data, frombits, tobits, pad) {
  assert(Buffer.isBuffer(data));

  const size = convertSize(data.length, frombits, tobits, pad);
  const out = Buffer.allocUnsafe(size);

  return convert(data, 0, out, 0, frombits, tobits, pad);
}

/**
 * Get cash32 encoded size.
 * @param {Number} size
 * @returns {Number}
 */

function encodedSize(size) {
  assert((size >>> 0) === size);

  switch (size) {
    case 20:
      return 0;
    case 24:
      return 1;
    case 28:
      return 2;
    case 32:
      return 3;
    case 40:
      return 4;
    case 48:
      return 5;
    case 56:
      return 6;
    case 64:
      return 7;
    default:
      throw new Error('Non standard length.');
  }
}

/**
 * Serialize data to cash32
 * @param {String} prefix
 * @param {Number} type - (0 = P2PKH, 1 = P2SH)
 * @param {Buffer} hash
 * @returns {String}
 */

function encode(prefix, type, hash) {
  assert(typeof prefix === 'string');
  // There are 4 bits available for the version (2 ^ 4 = 16)
  assert((type & 0x0f) === type, 'Invalid cash32 type.');
  assert(Buffer.isBuffer(hash));

  if (prefix.length === 0 || prefix.length > 83)
    throw new Error('Invalid cash32 prefix.');

  const size = encodedSize(hash.length);
  const data = Buffer.allocUnsafe(hash.length + 1);
  data[0] = (type << 3) | size;
  hash.copy(data, 1);

  const output = POOL105;
  const converted = convert(data, 0, output, 0, 8, 5, true);

  return serialize(prefix, converted);
}

/**
 * Deserialize data from cash32 address.
 * @param {String} str
 * @param {String} defaultPrefix (lowercase and w/o numbers)
 * @returns {Array}
 */

function decode(str, defaultPrefix = 'bitcoincash') {
  const [prefix, data] = deserialize(str, defaultPrefix);
  const extrabits = (data.length * 5) & 7;

  if (extrabits >= 5)
    throw new Error('Invalid padding in data.');

  const last = data[data.length - 1];
  const mask = (1 << extrabits) - 1;

  if (last & mask)
    throw new Error('Non zero padding.');

  const output = data;
  const converted = convert(data, 0, output, 0, 5, 8, false);

  const type = (converted[0] >>> 3) & 0x1f;
  const hash = converted.slice(1);

  let size = 20 + 4 * (converted[0] & 0x03);

  if (converted[0] & 0x04)
    size *= 2;

  if (size !== hash.length)
    throw new Error('Invalid cash32 data length.');

  return [prefix, type, hash];
}

/**
 * Test whether a string is a cash32 string.
 * @param {String} str
 * @param {String} defaultPrefix (lowercase and w/o numbers)
 * @returns {Boolean}
 */

function test(str, defaultPrefix = 'bitcoincash') {
  assert(typeof str === 'string');
  assert(typeof defaultPrefix === 'string');

  try {
    decode(str, defaultPrefix);
  } catch (e) {
    return false;
  }

  return true;
}

/*
 * Expose
 */

exports.native = 0;
exports.serialize = serialize;
exports.deserialize = deserialize;
exports.is = is;
exports.convertBits = convertBits;
exports.encode = encode;
exports.decode = decode;
exports.test = test;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],90:[function(req,module,exports){
(function (Buffer){
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;

/**
 * ChaCha20
 */

class ChaCha20 {
  /**
   * Create a ChaCha20 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(16);
    this.stream = new Uint32Array(16);
    this.bytes = new Uint8Array(this.stream.buffer);
    this.pos = 0;

    if (BIG_ENDIAN)
      this.bytes = Buffer.allocUnsafe(64);
  }

  /**
   * Initialize chacha20 with a key, nonce, and counter.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @param {Number} counter
   */

  init(key, nonce, counter) {
    if (counter == null)
      counter = 0;

    assert(Buffer.isBuffer(key));
    assert(Buffer.isBuffer(nonce));
    assert(Number.isSafeInteger(counter));

    if (key.length !== 16 && key.length !== 32)
      throw new RangeError('Invalid key size.');

    if (nonce.length >= 24) {
      key = ChaCha20.derive(key, nonce.slice(0, 16));
      nonce = nonce.slice(16);
    }

    this.state[0] = 0x61707865;
    this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
    this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
    this.state[3] = 0x6b206574;
    this.state[4] = readU32(key, 0);
    this.state[5] = readU32(key, 4);
    this.state[6] = readU32(key, 8);
    this.state[7] = readU32(key, 12);
    this.state[8] = readU32(key, 16 % key.length);
    this.state[9] = readU32(key, 20 % key.length);
    this.state[10] = readU32(key, 24 % key.length);
    this.state[11] = readU32(key, 28 % key.length);
    this.state[12] = counter >>> 0;

    if (nonce.length === 8) {
      this.state[13] = (counter / 0x100000000) >>> 0;
      this.state[14] = readU32(nonce, 0);
      this.state[15] = readU32(nonce, 4);
    } else if (nonce.length === 12) {
      this.state[13] = readU32(nonce, 0);
      this.state[14] = readU32(nonce, 4);
      this.state[15] = readU32(nonce, 8);
    } else if (nonce.length === 16) {
      this.state[12] = readU32(nonce, 0);
      this.state[13] = readU32(nonce, 4);
      this.state[14] = readU32(nonce, 8);
      this.state[15] = readU32(nonce, 12);
    } else {
      throw new RangeError('Invalid nonce size.');
    }

    this.pos = 0;

    return this;
  }

  /**
   * Encrypt/decrypt data.
   * @param {Buffer} data - Will be mutated.
   * @returns {Buffer}
   */

  encrypt(data) {
    return this.crypt(data, data);
  }

  /**
   * Encrypt/decrypt data.
   * @param {Buffer} input
   * @param {Buffer} output
   * @returns {Buffer} output
   */

  crypt(input, output) {
    assert(Buffer.isBuffer(input));
    assert(Buffer.isBuffer(output));

    if (output.length < input.length)
      throw new Error('Invalid output size.');

    for (let i = 0; i < input.length; i++) {
      if ((this.pos & 63) === 0) {
        this._block();
        this.pos = 0;
      }

      output[i] = input[i] ^ this.bytes[this.pos++];
    }

    return output;
  }

  /**
   * Stir the stream.
   */

  _block() {
    for (let i = 0; i < 16; i++)
      this.stream[i] = this.state[i];

    for (let i = 0; i < 10; i++) {
      qround(this.stream, 0, 4, 8, 12);
      qround(this.stream, 1, 5, 9, 13);
      qround(this.stream, 2, 6, 10, 14);
      qround(this.stream, 3, 7, 11, 15);
      qround(this.stream, 0, 5, 10, 15);
      qround(this.stream, 1, 6, 11, 12);
      qround(this.stream, 2, 7, 8, 13);
      qround(this.stream, 3, 4, 9, 14);
    }

    for (let i = 0; i < 16; i++)
      this.stream[i] += this.state[i];

    if (BIG_ENDIAN) {
      for (let i = 0; i < 16; i++)
        writeU32(this.bytes, this.stream[i], i * 4);
    }

    this.state[12] += 1;

    if (this.state[12] === 0)
      this.state[13] += 1;
  }

  /**
   * Destroy context.
   */

  destroy() {
    for (let i = 0; i < 16; i++) {
      this.state[i] = 0;
      this.stream[i] = 0;
    }

    if (BIG_ENDIAN) {
      for (let i = 0; i < 64; i++)
        this.bytes[i] = 0;
    }

    this.pos = 0;

    return this;
  }

  /**
   * Derive key with XChaCha20.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @returns {Buffer}
   */

  static derive(key, nonce) {
    assert(Buffer.isBuffer(key));
    assert(Buffer.isBuffer(nonce));

    if (key.length !== 16 && key.length !== 32)
      throw new RangeError('Invalid key size.');

    if (nonce.length !== 16)
      throw new RangeError('Invalid nonce size.');

    const state = new Uint32Array(16);

    state[0] = 0x61707865;
    state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
    state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
    state[3] = 0x6b206574;
    state[4] = readU32(key, 0);
    state[5] = readU32(key, 4);
    state[6] = readU32(key, 8);
    state[7] = readU32(key, 12);
    state[8] = readU32(key, 16 % key.length);
    state[9] = readU32(key, 20 % key.length);
    state[10] = readU32(key, 24 % key.length);
    state[11] = readU32(key, 28 % key.length);
    state[12] = readU32(nonce, 0);
    state[13] = readU32(nonce, 4);
    state[14] = readU32(nonce, 8);
    state[15] = readU32(nonce, 12);

    for (let i = 0; i < 10; i++) {
      qround(state, 0, 4, 8, 12);
      qround(state, 1, 5, 9, 13);
      qround(state, 2, 6, 10, 14);
      qround(state, 3, 7, 11, 15);
      qround(state, 0, 5, 10, 15);
      qround(state, 1, 6, 11, 12);
      qround(state, 2, 7, 8, 13);
      qround(state, 3, 4, 9, 14);
    }

    const out = Buffer.alloc(32);

    writeU32(out, state[0], 0);
    writeU32(out, state[1], 4);
    writeU32(out, state[2], 8);
    writeU32(out, state[3], 12);
    writeU32(out, state[12], 16);
    writeU32(out, state[13], 20);
    writeU32(out, state[14], 24);
    writeU32(out, state[15], 28);

    return out;
  }
}

/*
 * Static
 */

ChaCha20.native = 0;

/*
 * Helpers
 */

function qround(x, a, b, c, d) {
  x[a] += x[b];
  x[d] = rotl32(x[d] ^ x[a], 16);

  x[c] += x[d];
  x[b] = rotl32(x[b] ^ x[c], 12);

  x[a] += x[b];
  x[d] = rotl32(x[d] ^ x[a], 8);

  x[c] += x[d];
  x[b] = rotl32(x[b] ^ x[c], 7);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = ChaCha20;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],91:[function(req,module,exports){
(function (Buffer){
/*!
 * cipher.js - ciphers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');
const ciphers = req('../internal/ciphers');
const modes = req('./ciphers/modes');
const AES = req('./ciphers/aes');
const Blowfish = req('./ciphers/blowfish');
const Camellia = req('./ciphers/camellia');
const CAST5 = req('./ciphers/cast5');
const {DES, EDE, EDE3} = req('./ciphers/des');
const IDEA = req('./ciphers/idea');
const RC2 = req('./ciphers/rc2');
const Twofish = req('./ciphers/twofish');

/**
 * CipherBase
 */

class CipherBase {
  constructor(name, encrypt) {
    assert(typeof name === 'string');
    assert(typeof encrypt === 'boolean');

    this.encrypt = encrypt;
    this.ctx = null;
    this._init(name);
  }

  _init(name) {
    assert(typeof name === 'string');

    const info = ciphers.get(name);
    const Mode = modes.get(info.mode, this.encrypt);

    switch (info.algorithm) {
      case 'AES-128':
      case 'AES-192':
      case 'AES-256': {
        const bits = info.keySize * 8;
        this.ctx = new Mode(new AES(bits));
        break;
      }

      case 'BF': {
        this.ctx = new Mode(new Blowfish());
        break;
      }

      case 'CAMELLIA-128':
      case 'CAMELLIA-192':
      case 'CAMELLIA-256': {
        const bits = info.keySize * 8;
        this.ctx = new Mode(new Camellia(bits));
        break;
      }

      case 'CAST5': {
        this.ctx = new Mode(new CAST5());
        break;
      }

      case 'DES': {
        this.ctx = new Mode(new DES());
        break;
      }

      case 'DES-EDE': {
        this.ctx = new Mode(new EDE());
        break;
      }

      case 'DES-EDE3': {
        this.ctx = new Mode(new EDE3());
        break;
      }

      case 'IDEA': {
        this.ctx = new Mode(new IDEA());
        break;
      }

      case 'RC2-64': {
        this.ctx = new Mode(new RC2());
        break;
      }

      case 'TWOFISH-128':
      case 'TWOFISH-192':
      case 'TWOFISH-256': {
        const bits = info.keySize * 8;
        this.ctx = new Mode(new Twofish(bits));
        break;
      }

      default: {
        throw new Error(`Unsupported cipher: ${info.name}.`);
      }
    }

    return this;
  }

  init(key, iv) {
    this.ctx.init(key, iv);
    return this;
  }

  update(data) {
    return this.ctx.update(data);
  }

  final() {
    return this.ctx.final();
  }

  setAAD(data) {
    assert(this.ctx);
    this.ctx.setAAD(data);
    return this;
  }

  getAuthTag() {
    assert(this.ctx);
    assert(this.encrypt);
    return this.ctx.getAuthTag();
  }

  setAuthTag(tag) {
    assert(this.ctx);
    assert(!this.encrypt);
    this.ctx.setAuthTag(tag);
    return this;
  }
}

/**
 * Cipher
 * @extends CipherBase
 */

class Cipher extends CipherBase {
  constructor(name) {
    super(name, true);
  }
}

/**
 * Decipher
 * @extends CipherBase
 */

class Decipher extends CipherBase {
  constructor(name) {
    super(name, false);
  }
}

/*
 * API
 */

function encrypt(name, key, iv, data) {
  const ctx = new Cipher(name);
  ctx.init(key, iv);
  return Buffer.concat([
    ctx.update(data),
    ctx.final()
  ]);
}

function decrypt(name, key, iv, data) {
  const ctx = new Decipher(name);
  ctx.init(key, iv);
  return Buffer.concat([
    ctx.update(data),
    ctx.final()
  ]);
}

/*
 * Expose
 */

exports.native = 0;
exports._CipherBase = CipherBase;
exports.Cipher = Cipher;
exports.Decipher = Decipher;
exports.info = ciphers.info;
exports.get = ciphers.get;
exports.has = ciphers.has;
exports.encrypt = encrypt;
exports.decrypt = decrypt;

}).call(this,req("buffer").Buffer)
},{"../internal/ciphers":72,"./ciphers/aes":92,"./ciphers/blowfish":93,"./ciphers/camellia":94,"./ciphers/cast5":95,"./ciphers/des":96,"./ciphers/idea":98,"./ciphers/modes":99,"./ciphers/rc2":100,"./ciphers/twofish":101,"bsert":190,"buffer":303}],92:[function(req,module,exports){
(function (Buffer){
/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on openssl/openssl:
 *   Based on code entered into the public domain by Vincent Rijmen.
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const TE0 = new Uint32Array([
  0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d,
  0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
  0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d,
  0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
  0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87,
  0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
  0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea,
  0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
  0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,
  0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
  0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108,
  0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
  0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e,
  0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
  0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,
  0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
  0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e,
  0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
  0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce,
  0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
  0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c,
  0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
  0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b,
  0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
  0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16,
  0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
  0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81,
  0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
  0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a,
  0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
  0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163,
  0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
  0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,
  0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
  0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47,
  0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
  0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f,
  0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
  0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,
  0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
  0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e,
  0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
  0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6,
  0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
  0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,
  0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
  0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25,
  0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
  0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72,
  0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
  0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,
  0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
  0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa,
  0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
  0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0,
  0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
  0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,
  0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
  0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920,
  0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
  0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17,
  0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
  0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,
  0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a
]);

const TE1 = new Uint32Array([
  0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b,
  0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5,
  0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b,
  0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676,
  0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d,
  0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0,
  0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf,
  0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0,
  0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626,
  0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc,
  0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1,
  0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515,
  0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3,
  0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a,
  0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2,
  0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575,
  0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a,
  0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0,
  0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3,
  0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484,
  0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded,
  0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b,
  0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939,
  0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf,
  0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb,
  0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585,
  0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f,
  0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8,
  0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f,
  0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5,
  0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121,
  0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2,
  0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec,
  0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717,
  0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d,
  0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373,
  0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc,
  0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888,
  0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414,
  0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb,
  0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a,
  0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c,
  0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262,
  0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979,
  0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d,
  0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9,
  0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea,
  0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808,
  0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e,
  0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6,
  0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f,
  0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a,
  0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666,
  0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e,
  0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9,
  0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e,
  0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111,
  0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494,
  0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9,
  0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf,
  0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d,
  0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868,
  0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f,
  0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616
]);

const TE2 = new Uint32Array([
  0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b,
  0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5,
  0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b,
  0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76,
  0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d,
  0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0,
  0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af,
  0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0,
  0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26,
  0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc,
  0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1,
  0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15,
  0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3,
  0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a,
  0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2,
  0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75,
  0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a,
  0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0,
  0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3,
  0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384,
  0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed,
  0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b,
  0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239,
  0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf,
  0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb,
  0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185,
  0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f,
  0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8,
  0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f,
  0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5,
  0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221,
  0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2,
  0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec,
  0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17,
  0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d,
  0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673,
  0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc,
  0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88,
  0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814,
  0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb,
  0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a,
  0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c,
  0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462,
  0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279,
  0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d,
  0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9,
  0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea,
  0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008,
  0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e,
  0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6,
  0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f,
  0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a,
  0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66,
  0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e,
  0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9,
  0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e,
  0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211,
  0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394,
  0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9,
  0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df,
  0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d,
  0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068,
  0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f,
  0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16
]);

const TE3 = new Uint32Array([
  0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6,
  0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491,
  0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56,
  0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec,
  0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa,
  0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb,
  0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45,
  0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b,
  0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c,
  0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83,
  0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9,
  0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a,
  0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d,
  0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f,
  0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf,
  0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea,
  0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34,
  0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b,
  0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d,
  0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713,
  0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1,
  0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6,
  0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72,
  0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85,
  0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed,
  0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411,
  0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe,
  0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b,
  0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05,
  0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1,
  0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342,
  0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf,
  0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3,
  0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e,
  0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a,
  0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6,
  0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3,
  0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b,
  0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28,
  0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad,
  0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14,
  0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8,
  0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4,
  0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2,
  0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da,
  0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049,
  0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf,
  0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810,
  0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c,
  0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197,
  0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e,
  0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f,
  0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc,
  0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c,
  0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069,
  0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927,
  0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322,
  0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733,
  0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9,
  0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5,
  0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a,
  0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0,
  0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e,
  0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c
]);

const TD0 = new Uint32Array([
  0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96,
  0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393,
  0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25,
  0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f,
  0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1,
  0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,
  0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da,
  0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844,
  0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd,
  0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4,
  0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45,
  0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,
  0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7,
  0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a,
  0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5,
  0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c,
  0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1,
  0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a,
  0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75,
  0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051,
  0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46,
  0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff,
  0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77,
  0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb,
  0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000,
  0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e,
  0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927,
  0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a,
  0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e,
  0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,
  0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d,
  0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8,
  0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd,
  0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34,
  0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163,
  0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,
  0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d,
  0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0,
  0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422,
  0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef,
  0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36,
  0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,
  0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662,
  0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5,
  0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3,
  0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b,
  0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8,
  0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,
  0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6,
  0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0,
  0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815,
  0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f,
  0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df,
  0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,
  0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e,
  0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713,
  0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89,
  0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c,
  0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf,
  0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,
  0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f,
  0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541,
  0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190,
  0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742
]);

const TD1 = new Uint32Array([
  0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e,
  0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303,
  0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c,
  0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3,
  0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0,
  0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9,
  0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259,
  0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8,
  0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971,
  0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a,
  0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f,
  0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b,
  0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8,
  0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab,
  0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708,
  0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682,
  0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2,
  0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe,
  0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb,
  0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10,
  0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd,
  0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015,
  0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e,
  0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee,
  0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000,
  0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72,
  0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39,
  0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e,
  0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91,
  0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a,
  0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17,
  0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9,
  0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60,
  0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e,
  0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1,
  0xcad731dc, 0x10426385, 0x40139722, 0x2084c611,
  0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1,
  0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3,
  0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964,
  0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390,
  0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b,
  0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf,
  0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46,
  0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af,
  0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512,
  0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb,
  0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a,
  0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8,
  0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c,
  0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266,
  0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8,
  0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6,
  0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604,
  0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551,
  0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41,
  0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647,
  0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c,
  0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1,
  0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737,
  0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db,
  0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340,
  0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95,
  0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1,
  0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857
]);

const TD2 = new Uint32Array([
  0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27,
  0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3,
  0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502,
  0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562,
  0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe,
  0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3,
  0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552,
  0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9,
  0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9,
  0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce,
  0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253,
  0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908,
  0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b,
  0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655,
  0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337,
  0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16,
  0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69,
  0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6,
  0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6,
  0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e,
  0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6,
  0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050,
  0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9,
  0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8,
  0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000,
  0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a,
  0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d,
  0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436,
  0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b,
  0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12,
  0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b,
  0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e,
  0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f,
  0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb,
  0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4,
  0xdccad731, 0x85104263, 0x22401397, 0x112084c6,
  0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729,
  0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1,
  0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9,
  0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233,
  0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4,
  0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad,
  0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e,
  0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3,
  0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25,
  0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b,
  0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f,
  0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15,
  0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0,
  0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2,
  0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7,
  0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791,
  0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496,
  0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665,
  0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b,
  0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6,
  0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13,
  0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47,
  0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7,
  0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844,
  0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3,
  0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d,
  0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456,
  0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8
]);

const TD3 = new Uint32Array([
  0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a,
  0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b,
  0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5,
  0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5,
  0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d,
  0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b,
  0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95,
  0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e,
  0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27,
  0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d,
  0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562,
  0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9,
  0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752,
  0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66,
  0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3,
  0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced,
  0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e,
  0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4,
  0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4,
  0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd,
  0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d,
  0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60,
  0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767,
  0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79,
  0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000,
  0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c,
  0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736,
  0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24,
  0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b,
  0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c,
  0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12,
  0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814,
  0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3,
  0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b,
  0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8,
  0x31dccad7, 0x63851042, 0x97224013, 0xc6112084,
  0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7,
  0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077,
  0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247,
  0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22,
  0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698,
  0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f,
  0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254,
  0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582,
  0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf,
  0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb,
  0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883,
  0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef,
  0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629,
  0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035,
  0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533,
  0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17,
  0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4,
  0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46,
  0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb,
  0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d,
  0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb,
  0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a,
  0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73,
  0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678,
  0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2,
  0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff,
  0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064,
  0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0
]);

const TD4 = new Uint8Array([
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
  0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
  0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
  0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
  0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
  0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
  0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
  0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
  0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
  0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
  0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
  0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
  0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
  0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
  0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
  0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
  0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
]);

const RCON = new Uint32Array([
  0x01000000, 0x02000000, 0x04000000, 0x08000000,
  0x10000000, 0x20000000, 0x40000000, 0x80000000,
  0x1b000000, 0x36000000
]);

/**
 * AES
 */

class AES {
  constructor(bits = 256) {
    assert((bits >>> 0) === bits);

    this.bits = bits;
    this.rounds = getRounds(bits);
    this.key = null;
    this.encKey = null;
    this.decKey = null;
  }

  get blockSize() {
    return 16;
  }

  init(key) {
    assert(Buffer.isBuffer(key));

    if (key.length !== (this.bits >>> 3))
      throw new Error('Invalid key size.');

    this.destroy();
    this.key = Buffer.from(key);
    this.encKey = null;
    this.decKey = null;

    return this;
  }

  createEncryptKey() {
    if (!this.key)
      throw new Error('Cipher is not initialized.');

    const ukey = this.key;

    if (ukey.length !== (this.bits >>> 3))
      throw new Error('Invalid key size.');

    const key = new Uint32Array(60);

    key[0] = readU32(ukey, 0);
    key[1] = readU32(ukey, 4);
    key[2] = readU32(ukey, 8);
    key[3] = readU32(ukey, 12);

    let p = 0;
    let i = 0;
    let t;

    if (this.bits === 128) {
      for (;;) {
        const tmp = key[p + 3];

        t = key[p];
        t ^= TE2[(tmp >>> 16) & 0xff] & 0xff000000;
        t ^= TE3[(tmp >>> 8) & 0xff] & 0x00ff0000;
        t ^= TE0[(tmp >>> 0) & 0xff] & 0x0000ff00;
        t ^= TE1[(tmp >>> 24) & 0xff] & 0x000000ff;
        t ^= RCON[i];

        key[p + 4] = t;
        key[p + 5] = key[p + 1] ^ key[p + 4];
        key[p + 6] = key[p + 2] ^ key[p + 5];
        key[p + 7] = key[p + 3] ^ key[p + 6];

        i += 1;

        if (i === 10)
          break;

        p += 4;
      }

      return key;
    }

    key[p + 4] = readU32(ukey, 16);
    key[p + 5] = readU32(ukey, 20);

    if (this.bits === 192) {
      for (;;) {
        const tmp = key[p + 5];

        t = key[p];
        t ^= TE2[(tmp >>> 16) & 0xff] & 0xff000000;
        t ^= TE3[(tmp >>> 8) & 0xff] & 0x00ff0000;
        t ^= TE0[(tmp >>> 0) & 0xff] & 0x0000ff00;
        t ^= TE1[(tmp >>> 24) & 0xff] & 0x000000ff;
        t ^= RCON[i];

        key[p + 6] = t;
        key[p + 7] = key[p + 1] ^ key[p + 6];
        key[p + 8] = key[p + 2] ^ key[p + 7];
        key[p + 9] = key[p + 3] ^ key[p + 8];

        i += 1;

        if (i === 8)
          break;

        key[p + 10] = key[p + 4] ^ key[p + 9];
        key[p + 11] = key[p + 5] ^ key[p + 10];
        p += 6;
      }

      return key;
    }

    key[p + 6] = readU32(ukey, 24);
    key[p + 7] = readU32(ukey, 28);

    if (this.bits === 256) {
      for (;;) {
        let tmp = key[p + 7];

        t = key[p];
        t ^= TE2[(tmp >>> 16) & 0xff] & 0xff000000;
        t ^= TE3[(tmp >>> 8) & 0xff] & 0x00ff0000;
        t ^= TE0[(tmp >>> 0) & 0xff] & 0x0000ff00;
        t ^= TE1[(tmp >>> 24) & 0xff] & 0x000000ff;
        t ^= RCON[i];

        key[p + 8] = t;
        key[p + 9] = key[p + 1] ^ key[p + 8];
        key[p + 10] = key[p + 2] ^ key[p + 9];
        key[p + 11] = key[p + 3] ^ key[p + 10];

        i += 1;

        if (i === 7)
          break;

        tmp = key[p + 11];

        t = key[p + 4];
        t ^= TE2[(tmp >>> 24) & 0xff] & 0xff000000;
        t ^= TE3[(tmp >>> 16) & 0xff] & 0x00ff0000;
        t ^= TE0[(tmp >>> 8) & 0xff] & 0x0000ff00;
        t ^= TE1[(tmp >>> 0) & 0xff] & 0x000000ff;

        key[p + 12] = t;
        key[p + 13] = key[p +  5] ^ key[p + 12];
        key[p + 14] = key[p +  6] ^ key[p + 13];
        key[p + 15] = key[p +  7] ^ key[p + 14];

        p += 8;
      }

      return key;
    }

    throw new Error('Bad key size.');
  }

  createDecryptKey() {
    // First, start with an encryption schedule.
    const key = this.createEncryptKey();

    let p = 0;

    // Invert the order of the round keys.
    for (let i = 0, j = 4 * this.rounds; i < j; i += 4, j -= 4) {
      let tmp = key[p + i + 0];

      key[p + i + 0] = key[p + j + 0];
      key[p + j + 0] = tmp;

      tmp = key[p + i + 1];
      key[p + i + 1] = key[p + j + 1];
      key[p + j + 1] = tmp;

      tmp = key[p + i + 2];
      key[p + i + 2] = key[p + j + 2];
      key[p + j + 2] = tmp;

      tmp = key[p + i + 3];
      key[p + i + 3] = key[p + j + 3];
      key[p + j + 3] = tmp;
    }

    // Apply the inverse MixColumn transform to
    // all round keys but the first and the last.
    for (let i = 1; i < this.rounds; i++) {
      let t0, t1, t2, t3;

      p += 4;

      t0 = TD0[TE1[(key[p + 0] >>> 24) & 0xff] & 0xff];
      t0 ^= TD1[TE1[(key[p + 0] >>> 16) & 0xff] & 0xff];
      t0 ^= TD2[TE1[(key[p + 0] >>> 8) & 0xff] & 0xff];
      t0 ^= TD3[TE1[(key[p + 0] >>> 0) & 0xff] & 0xff];

      t1 = TD0[TE1[(key[p + 1] >>> 24) & 0xff] & 0xff];
      t1 ^= TD1[TE1[(key[p + 1] >>> 16) & 0xff] & 0xff];
      t1 ^= TD2[TE1[(key[p + 1] >>> 8) & 0xff] & 0xff];
      t1 ^= TD3[TE1[(key[p + 1] >>> 0) & 0xff] & 0xff];

      t2 = TD0[TE1[(key[p + 2] >>> 24) & 0xff] & 0xff];
      t2 ^= TD1[TE1[(key[p + 2] >>> 16) & 0xff] & 0xff];
      t2 ^= TD2[TE1[(key[p + 2] >>> 8) & 0xff] & 0xff];
      t2 ^= TD3[TE1[(key[p + 2] >>> 0) & 0xff] & 0xff];

      t3 = TD0[TE1[(key[p + 3] >>> 24) & 0xff] & 0xff];
      t3 ^= TD1[TE1[(key[p + 3] >>> 16) & 0xff] & 0xff];
      t3 ^= TD2[TE1[(key[p + 3] >>> 8) & 0xff] & 0xff];
      t3 ^= TD3[TE1[(key[p + 3] >>> 0) & 0xff] & 0xff];

      key[p + 0] = t0;
      key[p + 1] = t1;
      key[p + 2] = t2;
      key[p + 3] = t3;
    }

    return key;
  }

  getEncryptKey() {
    if (!this.encKey)
      this.encKey = this.createEncryptKey();
    return this.encKey;
  }

  getDecryptKey() {
    if (!this.decKey)
      this.decKey = this.createDecryptKey();
    return this.decKey;
  }

  encrypt(input, ipos, output, opos) {
    const key = this.getEncryptKey();

    // Map byte array block to cipher
    // state and add initial round key.
    let s0 = readU32(input, ipos + 0) ^ key[0];
    let s1 = readU32(input, ipos + 4) ^ key[1];
    let s2 = readU32(input, ipos + 8) ^ key[2];
    let s3 = readU32(input, ipos + 12) ^ key[3];

    // Nr - 1 full rounds
    let r = this.rounds >>> 1;
    let p = 0;
    let t0, t1, t2, t3;

    for (;;) {
      t0 = TE0[(s0 >>> 24) & 0xff];
      t0 ^= TE1[(s1 >>> 16) & 0xff];
      t0 ^= TE2[(s2 >>> 8) & 0xff];
      t0 ^= TE3[(s3 >>> 0) & 0xff];
      t0 ^= key[p + 4];

      t1 = TE0[(s1 >>> 24) & 0xff];
      t1 ^= TE1[(s2 >>> 16) & 0xff];
      t1 ^= TE2[(s3 >>> 8) & 0xff];
      t1 ^= TE3[(s0 >>> 0) & 0xff];
      t1 ^= key[p + 5];

      t2 = TE0[(s2 >>> 24) & 0xff];
      t2 ^= TE1[(s3 >>> 16) & 0xff];
      t2 ^= TE2[(s0 >>> 8) & 0xff];
      t2 ^= TE3[(s1 >>> 0) & 0xff];
      t2 ^= key[p + 6];

      t3 = TE0[(s3 >>> 24) & 0xff];
      t3 ^= TE1[(s0 >>> 16) & 0xff];
      t3 ^= TE2[(s1 >>> 8) & 0xff];
      t3 ^= TE3[(s2 >>> 0) & 0xff];
      t3 ^= key[p + 7];

      p += 8;
      r -= 1;

      if (r === 0)
        break;

      s0 = TE0[(t0 >>> 24) & 0xff];
      s0 ^= TE1[(t1 >>> 16) & 0xff];
      s0 ^= TE2[(t2 >>> 8) & 0xff];
      s0 ^= TE3[(t3 >>> 0) & 0xff];
      s0 ^= key[p + 0];

      s1 = TE0[(t1 >>> 24) & 0xff];
      s1 ^= TE1[(t2 >>> 16) & 0xff];
      s1 ^= TE2[(t3 >>> 8) & 0xff];
      s1 ^= TE3[(t0 >>> 0) & 0xff];
      s1 ^= key[p + 1];

      s2 = TE0[(t2 >>> 24) & 0xff];
      s2 ^= TE1[(t3 >>> 16) & 0xff];
      s2 ^= TE2[(t0 >>> 8) & 0xff];
      s2 ^= TE3[(t1 >>> 0) & 0xff];
      s2 ^= key[p + 2];

      s3 = TE0[(t3 >>> 24) & 0xff];
      s3 ^= TE1[(t0 >>> 16) & 0xff];
      s3 ^= TE2[(t1 >>> 8) & 0xff];
      s3 ^= TE3[(t2 >>> 0) & 0xff];
      s3 ^= key[p + 3];
    }

    // Apply last round and map cipher
    // state to byte array block.
    s0 = TE2[(t0 >>> 24) & 0xff] & 0xff000000;
    s0 ^= TE3[(t1 >>> 16) & 0xff] & 0x00ff0000;
    s0 ^= TE0[(t2 >>> 8) & 0xff] & 0x0000ff00;
    s0 ^= TE1[(t3 >>> 0) & 0xff] & 0x000000ff;
    s0 ^= key[p + 0];

    s1 = TE2[(t1 >>> 24) & 0xff] & 0xff000000;
    s1 ^= TE3[(t2 >>> 16) & 0xff] & 0x00ff0000;
    s1 ^= TE0[(t3 >>> 8) & 0xff] & 0x0000ff00;
    s1 ^= TE1[(t0 >>> 0) & 0xff] & 0x000000ff;
    s1 ^= key[p + 1];

    s2 = TE2[(t2 >>> 24) & 0xff] & 0xff000000;
    s2 ^= TE3[(t3 >>> 16) & 0xff] & 0x00ff0000;
    s2 ^= TE0[(t0 >>> 8) & 0xff] & 0x0000ff00;
    s2 ^= TE1[(t1 >>> 0) & 0xff] & 0x000000ff;
    s2 ^= key[p + 2];

    s3 = TE2[(t3 >>> 24) & 0xff] & 0xff000000;
    s3 ^= TE3[(t0 >>> 16) & 0xff] & 0x00ff0000;
    s3 ^= TE0[(t1 >>> 8) & 0xff] & 0x0000ff00;
    s3 ^= TE1[(t2 >>> 0) & 0xff] & 0x000000ff;
    s3 ^= key[p + 3];

    writeU32(output, s0, opos + 0);
    writeU32(output, s1, opos + 4);
    writeU32(output, s2, opos + 8);
    writeU32(output, s3, opos + 12);

    return this;
  }

  decrypt(input, ipos, output, opos) {
    const key = this.getDecryptKey();

    // Map byte array block to cipher
    // state and add initial round key.
    let s0 = readU32(input, ipos + 0) ^ key[0];
    let s1 = readU32(input, ipos + 4) ^ key[1];
    let s2 = readU32(input, ipos + 8) ^ key[2];
    let s3 = readU32(input, ipos + 12) ^ key[3];

    // Nr - 1 full rounds
    let r = this.rounds >>> 1;
    let p = 0;
    let t0, t1, t2, t3;

    for (;;) {
      t0 = TD0[(s0 >>> 24) & 0xff];
      t0 ^= TD1[(s3 >>> 16) & 0xff];
      t0 ^= TD2[(s2 >>> 8) & 0xff];
      t0 ^= TD3[(s1 >>> 0) & 0xff];
      t0 ^= key[p + 4];

      t1 = TD0[(s1 >>> 24) & 0xff];
      t1 ^= TD1[(s0 >>> 16) & 0xff];
      t1 ^= TD2[(s3 >>> 8) & 0xff];
      t1 ^= TD3[(s2 >>> 0) & 0xff];
      t1 ^= key[p + 5];

      t2 = TD0[(s2 >>> 24) & 0xff];
      t2 ^= TD1[(s1 >>> 16) & 0xff];
      t2 ^= TD2[(s0 >>> 8) & 0xff];
      t2 ^= TD3[(s3 >>> 0) & 0xff];
      t2 ^= key[p + 6];

      t3 = TD0[(s3 >>> 24) & 0xff];
      t3 ^= TD1[(s2 >>> 16) & 0xff];
      t3 ^= TD2[(s1 >>> 8) & 0xff];
      t3 ^= TD3[(s0 >>> 0) & 0xff];
      t3 ^= key[p + 7];

      p += 8;
      r -= 1;

      if (r === 0)
        break;

      s0 = TD0[(t0 >>> 24) & 0xff];
      s0 ^= TD1[(t3 >>> 16) & 0xff];
      s0 ^= TD2[(t2 >>> 8) & 0xff];
      s0 ^= TD3[(t1 >>> 0) & 0xff];
      s0 ^= key[p + 0];

      s1 = TD0[(t1 >>> 24) & 0xff];
      s1 ^= TD1[(t0 >>> 16) & 0xff];
      s1 ^= TD2[(t3 >>> 8) & 0xff];
      s1 ^= TD3[(t2 >>> 0) & 0xff];
      s1 ^= key[p + 1];

      s2 = TD0[(t2 >>> 24) & 0xff];
      s2 ^= TD1[(t1 >>> 16) & 0xff];
      s2 ^= TD2[(t0 >>> 8) & 0xff];
      s2 ^= TD3[(t3 >>> 0) & 0xff];
      s2 ^= key[p + 2];

      s3 = TD0[(t3 >>> 24) & 0xff];
      s3 ^= TD1[(t2 >>> 16) & 0xff];
      s3 ^= TD2[(t1 >>> 8) & 0xff];
      s3 ^= TD3[(t0 >>> 0) & 0xff];
      s3 ^= key[p + 3];
    }

    // Apply last round and map cipher
    // state to byte array block.
    s0 = TD4[(t0 >>> 24) & 0xff] << 24;
    s0 ^= TD4[(t3 >>> 16) & 0xff] << 16;
    s0 ^= TD4[(t2 >>> 8) & 0xff] << 8;
    s0 ^= TD4[(t1 >>> 0) & 0xff] << 0;
    s0 ^= key[p + 0];

    s1 = TD4[(t1 >>> 24) & 0xff] << 24;
    s1 ^= TD4[(t0 >>> 16) & 0xff] << 16;
    s1 ^= TD4[(t3 >>> 8) & 0xff] << 8;
    s1 ^= TD4[(t2 >>> 0) & 0xff] << 0;
    s1 ^= key[p + 1];

    s2 = TD4[(t2 >>> 24) & 0xff] << 24;
    s2 ^= TD4[(t1 >>> 16) & 0xff] << 16;
    s2 ^= TD4[(t0 >>> 8) & 0xff] << 8;
    s2 ^= TD4[(t3 >>> 0) & 0xff] << 0;
    s2 ^= key[p + 2];

    s3 = TD4[(t3 >>> 24) & 0xff] << 24;
    s3 ^= TD4[(t2 >>> 16) & 0xff] << 16;
    s3 ^= TD4[(t1 >>> 8) & 0xff] << 8;
    s3 ^= TD4[(t0 >>> 0) & 0xff] << 0;
    s3 ^= key[p + 3];

    writeU32(output, s0, opos + 0);
    writeU32(output, s1, opos + 4);
    writeU32(output, s2, opos + 8);
    writeU32(output, s3, opos + 12);

    return this;
  }

  destroy() {
    if (this.key) {
      for (let i = 0; i < this.key.length; i++)
        this.key[i] = 0;
    }

    if (this.encKey) {
      for (let i = 0; i < 60; i++)
        this.encKey[i] = 0;
    }

    if (this.decKey) {
      for (let i = 0; i < 60; i++)
        this.decKey[i] = 0;
    }

    this.key = null;
    this.encKey = null;
    this.decKey = null;

    return this;
  }
}

/*
 * Helpers
 */

function getRounds(bits) {
  switch (bits) {
    case 128:
      return 10;
    case 192:
      return 12;
    case 256:
      return 14;
    default:
      throw new Error('Bad key size.');
  }
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(dst, num, off) {
  dst[off++] = num >>> 24;
  dst[off++] = num >>> 16;
  dst[off++] = num >>> 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = AES;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],93:[function(req,module,exports){
(function (Buffer){
/*!
 * blowfish.js - blowfish for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on joyent/node-bcrypt-pbkdf:
 *   Copyright (c) 2016, Joyent Inc
 *   https://github.com/joyent/node-bcrypt-pbkdf
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Blowfish_(cipher)
 *   https://www.schneier.com/blowfish.html
 *   https://github.com/joyent/node-bcrypt-pbkdf/blob/master/index.js
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const S0 = new Uint32Array([
  0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
  0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
  0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
  0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
  0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
  0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
  0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
  0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
  0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
  0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
  0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
  0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
  0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
  0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
  0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
  0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
  0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
  0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
  0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
  0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
  0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
  0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
  0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
  0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
  0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
  0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
  0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
  0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
  0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
  0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
  0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
  0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
  0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
  0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
  0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
  0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
  0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
  0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
  0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
  0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
  0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
  0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
  0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
  0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
  0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
  0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
  0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
  0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
  0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
  0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
  0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
  0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
  0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
  0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
  0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
  0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
  0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
  0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
  0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
  0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
  0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
  0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
  0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
  0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
]);

const S1 = new Uint32Array([
  0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
  0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
  0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
  0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
  0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
  0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
  0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
  0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
  0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
  0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
  0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
  0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
  0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
  0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
  0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
  0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
  0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
  0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
  0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
  0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
  0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
  0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
  0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
  0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
  0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
  0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
  0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
  0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
  0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
  0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
  0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
  0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
  0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
  0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
  0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
  0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
  0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
  0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
  0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
  0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
  0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
  0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
  0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
  0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
  0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
  0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
  0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
  0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
  0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
  0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
  0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
  0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
  0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
  0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
  0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
  0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
  0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
  0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
  0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
  0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
  0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
  0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
  0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
  0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
]);

const S2 = new Uint32Array([
  0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
  0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
  0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
  0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
  0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
  0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
  0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
  0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
  0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
  0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
  0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
  0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
  0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
  0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
  0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
  0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
  0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
  0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
  0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
  0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
  0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
  0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
  0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
  0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
  0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
  0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
  0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
  0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
  0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
  0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
  0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
  0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
  0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
  0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
  0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
  0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
  0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
  0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
  0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
  0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
  0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
  0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
  0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
  0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
  0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
  0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
  0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
  0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
  0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
  0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
  0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
  0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
  0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
  0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
  0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
  0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
  0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
  0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
  0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
  0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
  0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
  0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
  0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
  0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
]);

const S3 = new Uint32Array([
  0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
  0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
  0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
  0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
  0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
  0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
  0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
  0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
  0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
  0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
  0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
  0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
  0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
  0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
  0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
  0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
  0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
  0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
  0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
  0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
  0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
  0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
  0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
  0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
  0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
  0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
  0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
  0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
  0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
  0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
  0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
  0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
  0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
  0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
  0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
  0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
  0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
  0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
  0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
  0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
  0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
  0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
  0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
  0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
  0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
  0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
  0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
  0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
  0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
  0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
  0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
  0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
  0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
  0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
  0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
  0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
  0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
  0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
  0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
  0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
  0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
  0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
  0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
  0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
]);

const P = new Uint32Array([
  0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
  0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
  0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
  0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
  0x9216d5d9, 0x8979fb1b
]);

/**
 * Blowfish
 */

class Blowfish {
  constructor() {
    this.S = [
      new Uint32Array(S0.length),
      new Uint32Array(S1.length),
      new Uint32Array(S2.length),
      new Uint32Array(S3.length)
    ];
    this.P = new Uint32Array(P.length);
    this.block = new Uint32Array(2);
    this.off = 0;
  }

  get blockSize() {
    return 8;
  }

  init(key, salt) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 1 && key.length <= 72);

    if (salt != null) {
      assert(Buffer.isBuffer(salt));
      assert(salt.length >= 0 && salt.length <= 1096);
    }

    copy(this.S[0], S0);
    copy(this.S[1], S1);
    copy(this.S[2], S2);
    copy(this.S[3], S3);
    copy(this.P, P);
    this.off = 0;

    if (salt && salt.length > 0)
      this.expandstate(key, salt);
    else
      this.expand0state(key);

    return this;
  }

  encrypt(input, ipos, output, opos) {
    const d = this.block;

    d[0] = readU32(input, ipos);
    d[1] = readU32(input, ipos + 4);

    this.encipher(d, 0);

    writeU32(output, d[0], opos);
    writeU32(output, d[1], opos + 4);

    return this;
  }

  decrypt(input, ipos, output, opos) {
    const d = this.block;

    d[0] = readU32(input, ipos);
    d[1] = readU32(input, ipos + 4);

    this.decipher(d, 0);

    writeU32(output, d[0], opos);
    writeU32(output, d[1], opos + 4);

    return this;
  }

  destroy() {
    cleanse(this.S[0]);
    cleanse(this.S[1]);
    cleanse(this.S[2]);
    cleanse(this.S[3]);
    cleanse(this.P);
    cleanse(this.block);
    this.off = 0;
    return this;
  }

  encipher(x, off) {
    const P = this.P;
    const S = this.S;

    let l = x[off] ^ P[0];
    let r = x[off + 1];
    let j = 0;

    while (j <= 14) {
      r ^= ((S[0][(l >>> 24) & 0xff]
        + S[1][(l >>> 16) & 0xff]
        ^ S[2][(l >>> 8) & 0xff])
        + S[3][l & 0xff])
        ^ P[++j];

      l ^= ((S[0][(r >>> 24) & 0xff]
        + S[1][(r >>> 16) & 0xff]
        ^ S[2][(r >>> 8) & 0xff])
        + S[3][r & 0xff])
        ^ P[++j];
    }

    x[off] = r ^ P[17];
    x[off + 1] = l;
  }

  decipher(x, off) {
    const P = this.P;
    const S = this.S;

    let l = x[off] ^ P[17];
    let r = x[off + 1];
    let j = 17;

    while (j >= 3) {
      r ^= ((S[0][(l >>> 24) & 0xff]
        + S[1][(l >>> 16) & 0xff]
        ^ S[2][(l >>> 8) & 0xff])
        + S[3][l & 0xff])
        ^ P[--j];

      l ^= ((S[0][(r >>> 24) & 0xff]
        + S[1][(r >>> 16) & 0xff]
        ^ S[2][(r >>> 8) & 0xff])
        + S[3][r & 0xff])
        ^ P[--j];
    }

    x[off] = r ^ P[0];
    x[off + 1] = l;
  }

  stream2word(data) {
    let word = 0;

    if (data.length === 0)
      return word;

    for (let i = 0; i < 4; i++) {
      if (this.off >= data.length)
        this.off = 0;

      word *= 0x100;
      word += data[this.off];

      this.off += 1;
    }

    return word;
  }

  expand0state(key) {
    const d = new Uint32Array(2);

    this.off = 0;

    for (let i = 0; i < 18; i++)
      this.P[i] ^= this.stream2word(key);

    this.off = 0;

    for (let i = 0; i < 18; i += 2) {
      this.encipher(d, 0);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }

    for (let i = 0; i < 4; i++) {
      for (let k = 0; k < 256; k += 2) {
        this.encipher(d, 0);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
  }

  expandstate(key, data) {
    const d = new Uint32Array(2);

    this.off = 0;

    for (let i = 0; i < 18; i++)
      this.P[i] ^= this.stream2word(key);

    this.off = 0;

    for (let i = 0; i < 18; i += 2) {
      d[0] ^= this.stream2word(data);
      d[1] ^= this.stream2word(data);
      this.encipher(d, 0);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }

    for (let i = 0; i < 4; i++) {
      for (let k = 0; k < 256; k += 2) {
        d[0] ^= this.stream2word(data);
        d[1] ^= this.stream2word(data);
        this.encipher(d, 0);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }

    this.off = 0;
  }

  enc(data) {
    const blocks = data.byteLength >>> 3;

    for (let i = 0; i < blocks; i++)
      this.encipher(data, i * 2);
  }

  dec(data) {
    const blocks = data.byteLength >>> 3;

    for (let i = 0; i < blocks; i++)
      this.decipher(data, i * 2);
  }
}

/*
 * Helpers
 */

function copy(dst, src) {
  for (let i = 0; i < src.length; i++)
    dst[i] = src[i];
}

function cleanse(arr) {
  for (let i = 0; i < arr.length; i++)
    arr[i] = 0;
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(dst, num, off) {
  dst[off++] = num >>> 24;
  dst[off++] = num >>> 16;
  dst[off++] = num >>> 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = Blowfish;

}).call(this,{"isBuffer":req("../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],94:[function(req,module,exports){
(function (Buffer){
/*!
 * camellia.js - camellia128/192/256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on aead/camellia:
 *   Copyright (c) 2016, Andreas Auernhammer (MIT License).
 *   https://github.com/aead/camellia
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Camellia_(cipher)
 *   https://tools.ietf.org/html/rfc3713
 *   https://github.com/aead/camellia/blob/master/camellia.go
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const SIGMA = new Uint32Array([
  0xa09e667f, 0x3bcc908b, 0xb67ae858, 0x4caa73b2,
  0xc6ef372f, 0xe94f82be, 0x54ff53a5, 0xf1d36f1c,
  0x10e527fa, 0xde682d1d, 0xb05688c2, 0xb3e6c1fd
]);

const S1 = new Uint32Array([
  0x70707000, 0x82828200, 0x2c2c2c00, 0xececec00,
  0xb3b3b300, 0x27272700, 0xc0c0c000, 0xe5e5e500,
  0xe4e4e400, 0x85858500, 0x57575700, 0x35353500,
  0xeaeaea00, 0x0c0c0c00, 0xaeaeae00, 0x41414100,
  0x23232300, 0xefefef00, 0x6b6b6b00, 0x93939300,
  0x45454500, 0x19191900, 0xa5a5a500, 0x21212100,
  0xededed00, 0x0e0e0e00, 0x4f4f4f00, 0x4e4e4e00,
  0x1d1d1d00, 0x65656500, 0x92929200, 0xbdbdbd00,
  0x86868600, 0xb8b8b800, 0xafafaf00, 0x8f8f8f00,
  0x7c7c7c00, 0xebebeb00, 0x1f1f1f00, 0xcecece00,
  0x3e3e3e00, 0x30303000, 0xdcdcdc00, 0x5f5f5f00,
  0x5e5e5e00, 0xc5c5c500, 0x0b0b0b00, 0x1a1a1a00,
  0xa6a6a600, 0xe1e1e100, 0x39393900, 0xcacaca00,
  0xd5d5d500, 0x47474700, 0x5d5d5d00, 0x3d3d3d00,
  0xd9d9d900, 0x01010100, 0x5a5a5a00, 0xd6d6d600,
  0x51515100, 0x56565600, 0x6c6c6c00, 0x4d4d4d00,
  0x8b8b8b00, 0x0d0d0d00, 0x9a9a9a00, 0x66666600,
  0xfbfbfb00, 0xcccccc00, 0xb0b0b000, 0x2d2d2d00,
  0x74747400, 0x12121200, 0x2b2b2b00, 0x20202000,
  0xf0f0f000, 0xb1b1b100, 0x84848400, 0x99999900,
  0xdfdfdf00, 0x4c4c4c00, 0xcbcbcb00, 0xc2c2c200,
  0x34343400, 0x7e7e7e00, 0x76767600, 0x05050500,
  0x6d6d6d00, 0xb7b7b700, 0xa9a9a900, 0x31313100,
  0xd1d1d100, 0x17171700, 0x04040400, 0xd7d7d700,
  0x14141400, 0x58585800, 0x3a3a3a00, 0x61616100,
  0xdedede00, 0x1b1b1b00, 0x11111100, 0x1c1c1c00,
  0x32323200, 0x0f0f0f00, 0x9c9c9c00, 0x16161600,
  0x53535300, 0x18181800, 0xf2f2f200, 0x22222200,
  0xfefefe00, 0x44444400, 0xcfcfcf00, 0xb2b2b200,
  0xc3c3c300, 0xb5b5b500, 0x7a7a7a00, 0x91919100,
  0x24242400, 0x08080800, 0xe8e8e800, 0xa8a8a800,
  0x60606000, 0xfcfcfc00, 0x69696900, 0x50505000,
  0xaaaaaa00, 0xd0d0d000, 0xa0a0a000, 0x7d7d7d00,
  0xa1a1a100, 0x89898900, 0x62626200, 0x97979700,
  0x54545400, 0x5b5b5b00, 0x1e1e1e00, 0x95959500,
  0xe0e0e000, 0xffffff00, 0x64646400, 0xd2d2d200,
  0x10101000, 0xc4c4c400, 0x00000000, 0x48484800,
  0xa3a3a300, 0xf7f7f700, 0x75757500, 0xdbdbdb00,
  0x8a8a8a00, 0x03030300, 0xe6e6e600, 0xdadada00,
  0x09090900, 0x3f3f3f00, 0xdddddd00, 0x94949400,
  0x87878700, 0x5c5c5c00, 0x83838300, 0x02020200,
  0xcdcdcd00, 0x4a4a4a00, 0x90909000, 0x33333300,
  0x73737300, 0x67676700, 0xf6f6f600, 0xf3f3f300,
  0x9d9d9d00, 0x7f7f7f00, 0xbfbfbf00, 0xe2e2e200,
  0x52525200, 0x9b9b9b00, 0xd8d8d800, 0x26262600,
  0xc8c8c800, 0x37373700, 0xc6c6c600, 0x3b3b3b00,
  0x81818100, 0x96969600, 0x6f6f6f00, 0x4b4b4b00,
  0x13131300, 0xbebebe00, 0x63636300, 0x2e2e2e00,
  0xe9e9e900, 0x79797900, 0xa7a7a700, 0x8c8c8c00,
  0x9f9f9f00, 0x6e6e6e00, 0xbcbcbc00, 0x8e8e8e00,
  0x29292900, 0xf5f5f500, 0xf9f9f900, 0xb6b6b600,
  0x2f2f2f00, 0xfdfdfd00, 0xb4b4b400, 0x59595900,
  0x78787800, 0x98989800, 0x06060600, 0x6a6a6a00,
  0xe7e7e700, 0x46464600, 0x71717100, 0xbababa00,
  0xd4d4d400, 0x25252500, 0xababab00, 0x42424200,
  0x88888800, 0xa2a2a200, 0x8d8d8d00, 0xfafafa00,
  0x72727200, 0x07070700, 0xb9b9b900, 0x55555500,
  0xf8f8f800, 0xeeeeee00, 0xacacac00, 0x0a0a0a00,
  0x36363600, 0x49494900, 0x2a2a2a00, 0x68686800,
  0x3c3c3c00, 0x38383800, 0xf1f1f100, 0xa4a4a400,
  0x40404000, 0x28282800, 0xd3d3d300, 0x7b7b7b00,
  0xbbbbbb00, 0xc9c9c900, 0x43434300, 0xc1c1c100,
  0x15151500, 0xe3e3e300, 0xadadad00, 0xf4f4f400,
  0x77777700, 0xc7c7c700, 0x80808000, 0x9e9e9e00
]);

const S2 = new Uint32Array([
  0x00e0e0e0, 0x00050505, 0x00585858, 0x00d9d9d9,
  0x00676767, 0x004e4e4e, 0x00818181, 0x00cbcbcb,
  0x00c9c9c9, 0x000b0b0b, 0x00aeaeae, 0x006a6a6a,
  0x00d5d5d5, 0x00181818, 0x005d5d5d, 0x00828282,
  0x00464646, 0x00dfdfdf, 0x00d6d6d6, 0x00272727,
  0x008a8a8a, 0x00323232, 0x004b4b4b, 0x00424242,
  0x00dbdbdb, 0x001c1c1c, 0x009e9e9e, 0x009c9c9c,
  0x003a3a3a, 0x00cacaca, 0x00252525, 0x007b7b7b,
  0x000d0d0d, 0x00717171, 0x005f5f5f, 0x001f1f1f,
  0x00f8f8f8, 0x00d7d7d7, 0x003e3e3e, 0x009d9d9d,
  0x007c7c7c, 0x00606060, 0x00b9b9b9, 0x00bebebe,
  0x00bcbcbc, 0x008b8b8b, 0x00161616, 0x00343434,
  0x004d4d4d, 0x00c3c3c3, 0x00727272, 0x00959595,
  0x00ababab, 0x008e8e8e, 0x00bababa, 0x007a7a7a,
  0x00b3b3b3, 0x00020202, 0x00b4b4b4, 0x00adadad,
  0x00a2a2a2, 0x00acacac, 0x00d8d8d8, 0x009a9a9a,
  0x00171717, 0x001a1a1a, 0x00353535, 0x00cccccc,
  0x00f7f7f7, 0x00999999, 0x00616161, 0x005a5a5a,
  0x00e8e8e8, 0x00242424, 0x00565656, 0x00404040,
  0x00e1e1e1, 0x00636363, 0x00090909, 0x00333333,
  0x00bfbfbf, 0x00989898, 0x00979797, 0x00858585,
  0x00686868, 0x00fcfcfc, 0x00ececec, 0x000a0a0a,
  0x00dadada, 0x006f6f6f, 0x00535353, 0x00626262,
  0x00a3a3a3, 0x002e2e2e, 0x00080808, 0x00afafaf,
  0x00282828, 0x00b0b0b0, 0x00747474, 0x00c2c2c2,
  0x00bdbdbd, 0x00363636, 0x00222222, 0x00383838,
  0x00646464, 0x001e1e1e, 0x00393939, 0x002c2c2c,
  0x00a6a6a6, 0x00303030, 0x00e5e5e5, 0x00444444,
  0x00fdfdfd, 0x00888888, 0x009f9f9f, 0x00656565,
  0x00878787, 0x006b6b6b, 0x00f4f4f4, 0x00232323,
  0x00484848, 0x00101010, 0x00d1d1d1, 0x00515151,
  0x00c0c0c0, 0x00f9f9f9, 0x00d2d2d2, 0x00a0a0a0,
  0x00555555, 0x00a1a1a1, 0x00414141, 0x00fafafa,
  0x00434343, 0x00131313, 0x00c4c4c4, 0x002f2f2f,
  0x00a8a8a8, 0x00b6b6b6, 0x003c3c3c, 0x002b2b2b,
  0x00c1c1c1, 0x00ffffff, 0x00c8c8c8, 0x00a5a5a5,
  0x00202020, 0x00898989, 0x00000000, 0x00909090,
  0x00474747, 0x00efefef, 0x00eaeaea, 0x00b7b7b7,
  0x00151515, 0x00060606, 0x00cdcdcd, 0x00b5b5b5,
  0x00121212, 0x007e7e7e, 0x00bbbbbb, 0x00292929,
  0x000f0f0f, 0x00b8b8b8, 0x00070707, 0x00040404,
  0x009b9b9b, 0x00949494, 0x00212121, 0x00666666,
  0x00e6e6e6, 0x00cecece, 0x00ededed, 0x00e7e7e7,
  0x003b3b3b, 0x00fefefe, 0x007f7f7f, 0x00c5c5c5,
  0x00a4a4a4, 0x00373737, 0x00b1b1b1, 0x004c4c4c,
  0x00919191, 0x006e6e6e, 0x008d8d8d, 0x00767676,
  0x00030303, 0x002d2d2d, 0x00dedede, 0x00969696,
  0x00262626, 0x007d7d7d, 0x00c6c6c6, 0x005c5c5c,
  0x00d3d3d3, 0x00f2f2f2, 0x004f4f4f, 0x00191919,
  0x003f3f3f, 0x00dcdcdc, 0x00797979, 0x001d1d1d,
  0x00525252, 0x00ebebeb, 0x00f3f3f3, 0x006d6d6d,
  0x005e5e5e, 0x00fbfbfb, 0x00696969, 0x00b2b2b2,
  0x00f0f0f0, 0x00313131, 0x000c0c0c, 0x00d4d4d4,
  0x00cfcfcf, 0x008c8c8c, 0x00e2e2e2, 0x00757575,
  0x00a9a9a9, 0x004a4a4a, 0x00575757, 0x00848484,
  0x00111111, 0x00454545, 0x001b1b1b, 0x00f5f5f5,
  0x00e4e4e4, 0x000e0e0e, 0x00737373, 0x00aaaaaa,
  0x00f1f1f1, 0x00dddddd, 0x00595959, 0x00141414,
  0x006c6c6c, 0x00929292, 0x00545454, 0x00d0d0d0,
  0x00787878, 0x00707070, 0x00e3e3e3, 0x00494949,
  0x00808080, 0x00505050, 0x00a7a7a7, 0x00f6f6f6,
  0x00777777, 0x00939393, 0x00868686, 0x00838383,
  0x002a2a2a, 0x00c7c7c7, 0x005b5b5b, 0x00e9e9e9,
  0x00eeeeee, 0x008f8f8f, 0x00010101, 0x003d3d3d
]);

const S3 = new Uint32Array([
  0x38003838, 0x41004141, 0x16001616, 0x76007676,
  0xd900d9d9, 0x93009393, 0x60006060, 0xf200f2f2,
  0x72007272, 0xc200c2c2, 0xab00abab, 0x9a009a9a,
  0x75007575, 0x06000606, 0x57005757, 0xa000a0a0,
  0x91009191, 0xf700f7f7, 0xb500b5b5, 0xc900c9c9,
  0xa200a2a2, 0x8c008c8c, 0xd200d2d2, 0x90009090,
  0xf600f6f6, 0x07000707, 0xa700a7a7, 0x27002727,
  0x8e008e8e, 0xb200b2b2, 0x49004949, 0xde00dede,
  0x43004343, 0x5c005c5c, 0xd700d7d7, 0xc700c7c7,
  0x3e003e3e, 0xf500f5f5, 0x8f008f8f, 0x67006767,
  0x1f001f1f, 0x18001818, 0x6e006e6e, 0xaf00afaf,
  0x2f002f2f, 0xe200e2e2, 0x85008585, 0x0d000d0d,
  0x53005353, 0xf000f0f0, 0x9c009c9c, 0x65006565,
  0xea00eaea, 0xa300a3a3, 0xae00aeae, 0x9e009e9e,
  0xec00ecec, 0x80008080, 0x2d002d2d, 0x6b006b6b,
  0xa800a8a8, 0x2b002b2b, 0x36003636, 0xa600a6a6,
  0xc500c5c5, 0x86008686, 0x4d004d4d, 0x33003333,
  0xfd00fdfd, 0x66006666, 0x58005858, 0x96009696,
  0x3a003a3a, 0x09000909, 0x95009595, 0x10001010,
  0x78007878, 0xd800d8d8, 0x42004242, 0xcc00cccc,
  0xef00efef, 0x26002626, 0xe500e5e5, 0x61006161,
  0x1a001a1a, 0x3f003f3f, 0x3b003b3b, 0x82008282,
  0xb600b6b6, 0xdb00dbdb, 0xd400d4d4, 0x98009898,
  0xe800e8e8, 0x8b008b8b, 0x02000202, 0xeb00ebeb,
  0x0a000a0a, 0x2c002c2c, 0x1d001d1d, 0xb000b0b0,
  0x6f006f6f, 0x8d008d8d, 0x88008888, 0x0e000e0e,
  0x19001919, 0x87008787, 0x4e004e4e, 0x0b000b0b,
  0xa900a9a9, 0x0c000c0c, 0x79007979, 0x11001111,
  0x7f007f7f, 0x22002222, 0xe700e7e7, 0x59005959,
  0xe100e1e1, 0xda00dada, 0x3d003d3d, 0xc800c8c8,
  0x12001212, 0x04000404, 0x74007474, 0x54005454,
  0x30003030, 0x7e007e7e, 0xb400b4b4, 0x28002828,
  0x55005555, 0x68006868, 0x50005050, 0xbe00bebe,
  0xd000d0d0, 0xc400c4c4, 0x31003131, 0xcb00cbcb,
  0x2a002a2a, 0xad00adad, 0x0f000f0f, 0xca00caca,
  0x70007070, 0xff00ffff, 0x32003232, 0x69006969,
  0x08000808, 0x62006262, 0x00000000, 0x24002424,
  0xd100d1d1, 0xfb00fbfb, 0xba00baba, 0xed00eded,
  0x45004545, 0x81008181, 0x73007373, 0x6d006d6d,
  0x84008484, 0x9f009f9f, 0xee00eeee, 0x4a004a4a,
  0xc300c3c3, 0x2e002e2e, 0xc100c1c1, 0x01000101,
  0xe600e6e6, 0x25002525, 0x48004848, 0x99009999,
  0xb900b9b9, 0xb300b3b3, 0x7b007b7b, 0xf900f9f9,
  0xce00cece, 0xbf00bfbf, 0xdf00dfdf, 0x71007171,
  0x29002929, 0xcd00cdcd, 0x6c006c6c, 0x13001313,
  0x64006464, 0x9b009b9b, 0x63006363, 0x9d009d9d,
  0xc000c0c0, 0x4b004b4b, 0xb700b7b7, 0xa500a5a5,
  0x89008989, 0x5f005f5f, 0xb100b1b1, 0x17001717,
  0xf400f4f4, 0xbc00bcbc, 0xd300d3d3, 0x46004646,
  0xcf00cfcf, 0x37003737, 0x5e005e5e, 0x47004747,
  0x94009494, 0xfa00fafa, 0xfc00fcfc, 0x5b005b5b,
  0x97009797, 0xfe00fefe, 0x5a005a5a, 0xac00acac,
  0x3c003c3c, 0x4c004c4c, 0x03000303, 0x35003535,
  0xf300f3f3, 0x23002323, 0xb800b8b8, 0x5d005d5d,
  0x6a006a6a, 0x92009292, 0xd500d5d5, 0x21002121,
  0x44004444, 0x51005151, 0xc600c6c6, 0x7d007d7d,
  0x39003939, 0x83008383, 0xdc00dcdc, 0xaa00aaaa,
  0x7c007c7c, 0x77007777, 0x56005656, 0x05000505,
  0x1b001b1b, 0xa400a4a4, 0x15001515, 0x34003434,
  0x1e001e1e, 0x1c001c1c, 0xf800f8f8, 0x52005252,
  0x20002020, 0x14001414, 0xe900e9e9, 0xbd00bdbd,
  0xdd00dddd, 0xe400e4e4, 0xa100a1a1, 0xe000e0e0,
  0x8a008a8a, 0xf100f1f1, 0xd600d6d6, 0x7a007a7a,
  0xbb00bbbb, 0xe300e3e3, 0x40004040, 0x4f004f4f
]);

const S4 = new Uint32Array([
  0x70700070, 0x2c2c002c, 0xb3b300b3, 0xc0c000c0,
  0xe4e400e4, 0x57570057, 0xeaea00ea, 0xaeae00ae,
  0x23230023, 0x6b6b006b, 0x45450045, 0xa5a500a5,
  0xeded00ed, 0x4f4f004f, 0x1d1d001d, 0x92920092,
  0x86860086, 0xafaf00af, 0x7c7c007c, 0x1f1f001f,
  0x3e3e003e, 0xdcdc00dc, 0x5e5e005e, 0x0b0b000b,
  0xa6a600a6, 0x39390039, 0xd5d500d5, 0x5d5d005d,
  0xd9d900d9, 0x5a5a005a, 0x51510051, 0x6c6c006c,
  0x8b8b008b, 0x9a9a009a, 0xfbfb00fb, 0xb0b000b0,
  0x74740074, 0x2b2b002b, 0xf0f000f0, 0x84840084,
  0xdfdf00df, 0xcbcb00cb, 0x34340034, 0x76760076,
  0x6d6d006d, 0xa9a900a9, 0xd1d100d1, 0x04040004,
  0x14140014, 0x3a3a003a, 0xdede00de, 0x11110011,
  0x32320032, 0x9c9c009c, 0x53530053, 0xf2f200f2,
  0xfefe00fe, 0xcfcf00cf, 0xc3c300c3, 0x7a7a007a,
  0x24240024, 0xe8e800e8, 0x60600060, 0x69690069,
  0xaaaa00aa, 0xa0a000a0, 0xa1a100a1, 0x62620062,
  0x54540054, 0x1e1e001e, 0xe0e000e0, 0x64640064,
  0x10100010, 0x00000000, 0xa3a300a3, 0x75750075,
  0x8a8a008a, 0xe6e600e6, 0x09090009, 0xdddd00dd,
  0x87870087, 0x83830083, 0xcdcd00cd, 0x90900090,
  0x73730073, 0xf6f600f6, 0x9d9d009d, 0xbfbf00bf,
  0x52520052, 0xd8d800d8, 0xc8c800c8, 0xc6c600c6,
  0x81810081, 0x6f6f006f, 0x13130013, 0x63630063,
  0xe9e900e9, 0xa7a700a7, 0x9f9f009f, 0xbcbc00bc,
  0x29290029, 0xf9f900f9, 0x2f2f002f, 0xb4b400b4,
  0x78780078, 0x06060006, 0xe7e700e7, 0x71710071,
  0xd4d400d4, 0xabab00ab, 0x88880088, 0x8d8d008d,
  0x72720072, 0xb9b900b9, 0xf8f800f8, 0xacac00ac,
  0x36360036, 0x2a2a002a, 0x3c3c003c, 0xf1f100f1,
  0x40400040, 0xd3d300d3, 0xbbbb00bb, 0x43430043,
  0x15150015, 0xadad00ad, 0x77770077, 0x80800080,
  0x82820082, 0xecec00ec, 0x27270027, 0xe5e500e5,
  0x85850085, 0x35350035, 0x0c0c000c, 0x41410041,
  0xefef00ef, 0x93930093, 0x19190019, 0x21210021,
  0x0e0e000e, 0x4e4e004e, 0x65650065, 0xbdbd00bd,
  0xb8b800b8, 0x8f8f008f, 0xebeb00eb, 0xcece00ce,
  0x30300030, 0x5f5f005f, 0xc5c500c5, 0x1a1a001a,
  0xe1e100e1, 0xcaca00ca, 0x47470047, 0x3d3d003d,
  0x01010001, 0xd6d600d6, 0x56560056, 0x4d4d004d,
  0x0d0d000d, 0x66660066, 0xcccc00cc, 0x2d2d002d,
  0x12120012, 0x20200020, 0xb1b100b1, 0x99990099,
  0x4c4c004c, 0xc2c200c2, 0x7e7e007e, 0x05050005,
  0xb7b700b7, 0x31310031, 0x17170017, 0xd7d700d7,
  0x58580058, 0x61610061, 0x1b1b001b, 0x1c1c001c,
  0x0f0f000f, 0x16160016, 0x18180018, 0x22220022,
  0x44440044, 0xb2b200b2, 0xb5b500b5, 0x91910091,
  0x08080008, 0xa8a800a8, 0xfcfc00fc, 0x50500050,
  0xd0d000d0, 0x7d7d007d, 0x89890089, 0x97970097,
  0x5b5b005b, 0x95950095, 0xffff00ff, 0xd2d200d2,
  0xc4c400c4, 0x48480048, 0xf7f700f7, 0xdbdb00db,
  0x03030003, 0xdada00da, 0x3f3f003f, 0x94940094,
  0x5c5c005c, 0x02020002, 0x4a4a004a, 0x33330033,
  0x67670067, 0xf3f300f3, 0x7f7f007f, 0xe2e200e2,
  0x9b9b009b, 0x26260026, 0x37370037, 0x3b3b003b,
  0x96960096, 0x4b4b004b, 0xbebe00be, 0x2e2e002e,
  0x79790079, 0x8c8c008c, 0x6e6e006e, 0x8e8e008e,
  0xf5f500f5, 0xb6b600b6, 0xfdfd00fd, 0x59590059,
  0x98980098, 0x6a6a006a, 0x46460046, 0xbaba00ba,
  0x25250025, 0x42420042, 0xa2a200a2, 0xfafa00fa,
  0x07070007, 0x55550055, 0xeeee00ee, 0x0a0a000a,
  0x49490049, 0x68680068, 0x38380038, 0xa4a400a4,
  0x28280028, 0x7b7b007b, 0xc9c900c9, 0xc1c100c1,
  0xe3e300e3, 0xf4f400f4, 0xc7c700c7, 0x9e9e009e
]);

/**
 * Camellia128
 */

class Camellia128 {
  constructor() {
    this.key = new Uint32Array(52);
    this.block = new Uint32Array(4);
  }

  get blockSize() {
    return 16;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 16);
    this.keySchedule(key);
    return this;
  }

  keySchedule(key) {
    const s = this.block;
    const k = this.key;

    s[0] = readU32(key, 0);
    s[1] = readU32(key, 4);
    s[2] = readU32(key, 8);
    s[3] = readU32(key, 12);

    set4(k, 0, 1, 2, 3, s, 0, 1, 2, 3);

    feis(s, 0, 1, 2, 3, SIGMA[0], SIGMA[1]);
    feis(s, 2, 3, 0, 1, SIGMA[2], SIGMA[3]);

    xor4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);

    feis(s, 0, 1, 2, 3, SIGMA[4], SIGMA[5]);
    feis(s, 2, 3, 0, 1, SIGMA[6], SIGMA[7]);
    set4(k, 4, 5, 6, 7, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 15); // KA << 15
    set4(k, 12, 13, 14, 15, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 15); // KA << 30
    set4(k, 16, 17, 18, 19, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 15); // KA << 45
    set2(k, 24, 25, s, 0, 1);

    rotl(s, 0, 1, 2, 3, 15); // KA << 60
    set4(k, 28, 29, 30, 31, s, 0, 1, 2, 3);

    rotl(s, 1, 2, 3, 0, 2); // KA << 94
    set4(k, 40, 41, 42, 43, s, 1, 2, 3, 0);

    rotl(s, 1, 2, 3, 0, 17); // KA << 111
    set4(k, 48, 49, 50, 51, s, 1, 2, 3, 0);
    set4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 15); // KL << 15
    set4(k, 8, 9, 10, 11, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 30); // KL << 45
    set4(k, 20, 21, 22, 23, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 15); // KL << 60
    set2(k, 26, 27, s, 2, 3);

    rotl(s, 0, 1, 2, 3, 17); // KL << 77
    set4(k, 32, 33, 34, 35, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 17); // KL << 94
    set4(k, 36, 37, 38, 39, s, 0, 1, 2, 3);

    rotl(s, 0, 1, 2, 3, 17); // KL << 111
    set4(k, 44, 45, 46, 47, s, 0, 1, 2, 3);

    return this;
  }

  encrypt(input, ipos, output, opos) {
    const r = this.block;
    const k = this.key;

    r[0] = readU32(input, ipos + 0);
    r[1] = readU32(input, ipos + 4);
    r[2] = readU32(input, ipos + 8);
    r[3] = readU32(input, ipos + 12);

    xor4(r, 0, 1, 2, 3, k, 0, 1, 2, 3);

    feis(r, 0, 1, 2, 3, k[4], k[5]);
    feis(r, 2, 3, 0, 1, k[6], k[7]);
    feis(r, 0, 1, 2, 3, k[8], k[9]);
    feis(r, 2, 3, 0, 1, k[10], k[11]);
    feis(r, 0, 1, 2, 3, k[12], k[13]);
    feis(r, 2, 3, 0, 1, k[14], k[15]);

    let t = r[0] & k[16];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[19];
    r[0] ^= r[1] | k[17];
    t = r[2] & k[18];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[20], k[21]);
    feis(r, 2, 3, 0, 1, k[22], k[23]);
    feis(r, 0, 1, 2, 3, k[24], k[25]);
    feis(r, 2, 3, 0, 1, k[26], k[27]);
    feis(r, 0, 1, 2, 3, k[28], k[29]);
    feis(r, 2, 3, 0, 1, k[30], k[31]);

    t = r[0] & k[32];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[35];
    r[0] ^= r[1] | k[33];
    t = r[2] & k[34];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[36], k[37]);
    feis(r, 2, 3, 0, 1, k[38], k[39]);
    feis(r, 0, 1, 2, 3, k[40], k[41]);
    feis(r, 2, 3, 0, 1, k[42], k[43]);
    feis(r, 0, 1, 2, 3, k[44], k[45]);
    feis(r, 2, 3, 0, 1, k[46], k[47]);

    xor4(r, 2, 3, 0, 1, k, 48, 49, 50, 51);

    writeU32(output, r[2], opos + 0);
    writeU32(output, r[3], opos + 4);
    writeU32(output, r[0], opos + 8);
    writeU32(output, r[1], opos + 12);
  }

  decrypt(input, ipos, output, opos) {
    const r = this.block;
    const k = this.key;

    r[0] = readU32(input, ipos + 0);
    r[1] = readU32(input, ipos + 4);
    r[2] = readU32(input, ipos + 8);
    r[3] = readU32(input, ipos + 12);

    xor4(r, 3, 2, 1, 0, k, 51, 50, 49, 48);

    feis(r, 0, 1, 2, 3, k[46], k[47]);
    feis(r, 2, 3, 0, 1, k[44], k[45]);
    feis(r, 0, 1, 2, 3, k[42], k[43]);
    feis(r, 2, 3, 0, 1, k[40], k[41]);
    feis(r, 0, 1, 2, 3, k[38], k[39]);
    feis(r, 2, 3, 0, 1, k[36], k[37]);

    let t = r[0] & k[34];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[33];
    r[0] ^= r[1] | k[35];
    t = r[2] & k[32];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[30], k[31]);
    feis(r, 2, 3, 0, 1, k[28], k[29]);
    feis(r, 0, 1, 2, 3, k[26], k[27]);
    feis(r, 2, 3, 0, 1, k[24], k[25]);
    feis(r, 0, 1, 2, 3, k[22], k[23]);
    feis(r, 2, 3, 0, 1, k[20], k[21]);

    t = r[0] & k[18];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[17];
    r[0] ^= r[1] | k[19];
    t = r[2] & k[16];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[14], k[15]);
    feis(r, 2, 3, 0, 1, k[12], k[13]);
    feis(r, 0, 1, 2, 3, k[10], k[11]);
    feis(r, 2, 3, 0, 1, k[8], k[9]);
    feis(r, 0, 1, 2, 3, k[6], k[7]);
    feis(r, 2, 3, 0, 1, k[4], k[5]);

    xor4(r, 1, 0, 3, 2, k, 3, 2, 1, 0);

    writeU32(output, r[2], opos + 0);
    writeU32(output, r[3], opos + 4);
    writeU32(output, r[0], opos + 8);
    writeU32(output, r[1], opos + 12);

    return this;
  }

  destroy() {
    for (let i = 0; i < 52; i++)
      this.key[i] = 0;

    for (let i = 0; i < 4; i++)
      this.block[i] = 0;

    return this;
  }
}

/**
 * Camellia256
 */

class Camellia256 {
  constructor() {
    this.key = new Uint32Array(68);
    this.block = new Uint32Array(4);
  }

  get blockSize() {
    return 16;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 24 || key.length === 32);
    this.keySchedule(key);
    return this;
  }

  keySchedule(key) {
    const s = this.block;
    const k = this.key;

    k[0] = readU32(key, 0);
    k[1] = readU32(key, 4);
    k[2] = readU32(key, 8);
    k[3] = readU32(key, 12);

    k[8] = readU32(key, 16);
    k[9] = readU32(key, 20);

    if (key.length === 24) {
      k[10] = ~k[8];
      k[11] = ~k[9];
    } else {
      k[10] = readU32(key, 24);
      k[11] = readU32(key, 28);
    }

    s[0] = k[8] ^ k[0];
    s[1] = k[9] ^ k[1];
    s[2] = k[10] ^ k[2];
    s[3] = k[11] ^ k[3];

    feis(s, 0, 1, 2, 3, SIGMA[0], SIGMA[1]);
    feis(s, 2, 3, 0, 1, SIGMA[2], SIGMA[3]);

    xor4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);
    feis(s, 0, 1, 2, 3, SIGMA[4], SIGMA[5]);
    feis(s, 2, 3, 0, 1, SIGMA[6], SIGMA[7]);

    set4(k, 12, 13, 14, 15, s, 0, 1, 2, 3);

    xor4(s, 0, 1, 2, 3, k, 8, 9, 10, 11);
    feis(s, 0, 1, 2, 3, SIGMA[8], SIGMA[9]);
    feis(s, 2, 3, 0, 1, SIGMA[10], SIGMA[11]);

    set4(k, 4, 5, 6, 7, s, 0, 1, 2, 3);
    rotl(s, 0, 1, 2, 3, 30); // KB << 30
    set4(k, 20, 21, 22, 23, s, 0, 1, 2, 3);
    rotl(s, 0, 1, 2, 3, 30); // KB << 60
    set4(k, 40, 41, 42, 43, s, 0, 1, 2, 3);
    rotl(s, 1, 2, 3, 0, 19); // KB << 111
    set4(k, 64, 65, 66, 67, s, 1, 2, 3, 0);

    set4(s, 0, 1, 2, 3, k, 8, 9, 10, 11);
    rotl(s, 0, 1, 2, 3, 15); // KR << 15
    set4(k, 8, 9, 10, 11, s, 0, 1, 2, 3);
    rotl(s, 0, 1, 2, 3, 15); // KR << 30
    set4(k, 16, 17, 18, 19, s, 0, 1, 2, 3);
    rotl(s, 0, 1, 2, 3, 30); // KR << 60
    set4(k, 36, 37, 38, 39, s, 0, 1, 2, 3);
    rotl(s, 1, 2, 3, 0, 2); // KR << 94
    set4(k, 52, 53, 54, 55, s, 1, 2, 3, 0);

    set4(s, 0, 1, 2, 3, k, 12, 13, 14, 15);
    rotl(s, 0, 1, 2, 3, 15); // KA << 15
    set4(k, 12, 13, 14, 15, s, 0, 1, 2, 3);
    rotl(s, 0, 1, 2, 3, 30); // KA << 45
    set4(k, 28, 29, 30, 31, s, 0, 1, 2, 3);
    // KA << 77
    set4(k, 48, 49, 50, 51, s, 1, 2, 3, 0);
    rotl(s, 1, 2, 3, 0, 17); // KA << 94
    set4(k, 56, 57, 58, 59, s, 1, 2, 3, 0);

    set4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);
    rotl(s, 1, 2, 3, 0, 13); // KL << 45
    set4(k, 24, 25, 26, 27, s, 1, 2, 3, 0);
    rotl(s, 1, 2, 3, 0, 15); // KL << 60
    set4(k, 32, 33, 34, 35, s, 1, 2, 3, 0);
    rotl(s, 1, 2, 3, 0, 17); // KL << 77
    set4(k, 44, 45, 46, 47, s, 1, 2, 3, 0);
    rotl(s, 2, 3, 0, 1, 2); // KL << 111
    set4(k, 60, 61, 62, 63, s, 2, 3, 0, 1);

    return this;
  }

  encrypt(input, ipos, output, opos) {
    const r = this.block;
    const k = this.key;

    r[0] = readU32(input, ipos + 0);
    r[1] = readU32(input, ipos + 4);
    r[2] = readU32(input, ipos + 8);
    r[3] = readU32(input, ipos + 12);

    xor4(r, 0, 1, 2, 3, k, 0, 1, 2, 3);

    feis(r, 0, 1, 2, 3, k[4], k[5]);
    feis(r, 2, 3, 0, 1, k[6], k[7]);
    feis(r, 0, 1, 2, 3, k[8], k[9]);
    feis(r, 2, 3, 0, 1, k[10], k[11]);
    feis(r, 0, 1, 2, 3, k[12], k[13]);
    feis(r, 2, 3, 0, 1, k[14], k[15]);

    let t = r[0] & k[16];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[19];
    r[0] ^= r[1] | k[17];
    t = r[2] & k[18];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[20], k[21]);
    feis(r, 2, 3, 0, 1, k[22], k[23]);
    feis(r, 0, 1, 2, 3, k[24], k[25]);
    feis(r, 2, 3, 0, 1, k[26], k[27]);
    feis(r, 0, 1, 2, 3, k[28], k[29]);
    feis(r, 2, 3, 0, 1, k[30], k[31]);

    t = r[0] & k[32];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[35];
    r[0] ^= r[1] | k[33];
    t = r[2] & k[34];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[36], k[37]);
    feis(r, 2, 3, 0, 1, k[38], k[39]);
    feis(r, 0, 1, 2, 3, k[40], k[41]);
    feis(r, 2, 3, 0, 1, k[42], k[43]);
    feis(r, 0, 1, 2, 3, k[44], k[45]);
    feis(r, 2, 3, 0, 1, k[46], k[47]);

    t = r[0] & k[48];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[51];
    r[0] ^= r[1] | k[49];
    t = r[2] & k[50];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[52], k[53]);
    feis(r, 2, 3, 0, 1, k[54], k[55]);
    feis(r, 0, 1, 2, 3, k[56], k[57]);
    feis(r, 2, 3, 0, 1, k[58], k[59]);
    feis(r, 0, 1, 2, 3, k[60], k[61]);
    feis(r, 2, 3, 0, 1, k[62], k[63]);

    xor4(r, 2, 3, 0, 1, k, 64, 65, 66, 67);

    writeU32(output, r[2], opos + 0);
    writeU32(output, r[3], opos + 4);
    writeU32(output, r[0], opos + 8);
    writeU32(output, r[1], opos + 12);

    return this;
  }

  decrypt(input, ipos, output, opos) {
    const r = this.block;
    const k = this.key;

    r[0] = readU32(input, ipos + 0);
    r[1] = readU32(input, ipos + 4);
    r[2] = readU32(input, ipos + 8);
    r[3] = readU32(input, ipos + 12);

    xor4(r, 3, 2, 1, 0, k, 67, 66, 65, 64);

    feis(r, 0, 1, 2, 3, k[62], k[63]);
    feis(r, 2, 3, 0, 1, k[60], k[61]);
    feis(r, 0, 1, 2, 3, k[58], k[59]);
    feis(r, 2, 3, 0, 1, k[56], k[57]);
    feis(r, 0, 1, 2, 3, k[54], k[55]);
    feis(r, 2, 3, 0, 1, k[52], k[53]);

    let t = r[0] & k[50];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[49];
    r[0] ^= r[1] | k[51];
    t = r[2] & k[48];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[46], k[47]);
    feis(r, 2, 3, 0, 1, k[44], k[45]);
    feis(r, 0, 1, 2, 3, k[42], k[43]);
    feis(r, 2, 3, 0, 1, k[40], k[41]);
    feis(r, 0, 1, 2, 3, k[38], k[39]);
    feis(r, 2, 3, 0, 1, k[36], k[37]);

    t = r[0] & k[34];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[33];
    r[0] ^= r[1] | k[35];
    t = r[2] & k[32];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[30], k[31]);
    feis(r, 2, 3, 0, 1, k[28], k[29]);
    feis(r, 0, 1, 2, 3, k[26], k[27]);
    feis(r, 2, 3, 0, 1, k[24], k[25]);
    feis(r, 0, 1, 2, 3, k[22], k[23]);
    feis(r, 2, 3, 0, 1, k[20], k[21]);

    t = r[0] & k[18];
    r[1] ^= (t << 1) | (t >>> (32 - 1));
    r[2] ^= r[3] | k[17];
    r[0] ^= r[1] | k[19];
    t = r[2] & k[16];
    r[3] ^= (t << 1) | (t >>> (32 - 1));

    feis(r, 0, 1, 2, 3, k[14], k[15]);
    feis(r, 2, 3, 0, 1, k[12], k[13]);
    feis(r, 0, 1, 2, 3, k[10], k[11]);
    feis(r, 2, 3, 0, 1, k[8], k[9]);
    feis(r, 0, 1, 2, 3, k[6], k[7]);
    feis(r, 2, 3, 0, 1, k[4], k[5]);

    xor4(r, 1, 0, 3, 2, k, 3, 2, 1, 0);

    writeU32(output, r[2], opos + 0);
    writeU32(output, r[3], opos + 4);
    writeU32(output, r[0], opos + 8);
    writeU32(output, r[1], opos + 12);

    return this;
  }

  destroy() {
    for (let i = 0; i < 68; i++)
      this.key[i] = 0;

    for (let i = 0; i < 4; i++)
      this.block[i] = 0;

    return this;
  }
}

/**
 * Camellia
 */

class Camellia {
  constructor(bits) {
    assert((bits >>> 0) === bits);

    this.bits = bits;
    this.ctx = null;

    switch (bits) {
      case 128:
        this.ctx = new Camellia128();
        break;
      case 192:
      case 256:
        this.ctx = new Camellia256();
        break;
      default:
        throw new Error('Invalid key size.');
    }
  }

  get blockSize() {
    return this.ctx.blockSize;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === (this.bits >>> 3));
    this.ctx.init(key);
    return this;
  }

  encrypt(input, ipos, output, opos) {
    this.ctx.encrypt(input, ipos, output, opos);
    return this;
  }

  decrypt(input, ipos, output, opos) {
    this.ctx.decrypt(input, ipos, output, opos);
    return this;
  }

  destroy() {
    this.ctx.destroy();
    return this;
  }
}

/*
 * Helpers
 */

function feis(r, i0, i1, i2, i3, k0, k1) {
  k0 ^= r[i0];
  k1 ^= r[i1];

  let t = 0;

  t = S4[k0 & 0xff];
  t ^= S3[(k0 >>> 8) & 0xff];
  t ^= S2[(k0 >>> 16) & 0xff];
  t ^= S1[(k0 >>> 24) & 0xff];

  r[i3] ^= (t >>> 8) | (t << (32 - 8));

  k0 = t;
  k0 ^= S1[k1 & 0xff];
  k0 ^= S4[(k1 >>> 8) & 0xff];
  k0 ^= S3[(k1 >>> 16) & 0xff];
  k0 ^= S2[(k1 >>> 24) & 0xff];

  r[i2] ^= k0;
  r[i3] ^= k0;
}

function rotl(r, i0, i1, i2, i3, n) {
  const t = r[i0] >>> (32 - n);

  r[i0] = (r[i0] << n) | (r[i1] >>> (32 - n));
  r[i1] = (r[i1] << n) | (r[i2] >>> (32 - n));
  r[i2] = (r[i2] << n) | (r[i3] >>> (32 - n));
  r[i3] = (r[i3] << n) | t;
}

function set2(x, x0, x1, y, y0, y1) {
  x[x0] = y[y0];
  x[x1] = y[y1];
}

function set4(x, x0, x1, x2, x3, y, y0, y1, y2, y3) {
  x[x0] = y[y0];
  x[x1] = y[y1];
  x[x2] = y[y2];
  x[x3] = y[y3];
}

function xor4(x, x0, x1, x2, x3, y, y0, y1, y2, y3) {
  x[x0] ^= y[y0];
  x[x1] ^= y[y1];
  x[x2] ^= y[y2];
  x[x3] ^= y[y3];
}

function readU32(data, pos) {
  return (data[pos++] * 0x1000000
        + data[pos++] * 0x10000
        + data[pos++] * 0x100
        + data[pos]);
}

function writeU32(data, value, pos) {
  data[pos++] = value >>> 24;
  data[pos++] = value >>> 16;
  data[pos++] = value >>> 8;
  data[pos++] = value >>> 0;
  return pos;
}

/*
 * Expose
 */

module.exports = Camellia;

}).call(this,{"isBuffer":req("../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],95:[function(req,module,exports){
(function (Buffer){
/*!
 * cast5.js - CAST5 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/CAST-128
 *   https://tools.ietf.org/html/rfc2144
 *   https://github.com/golang/crypto/blob/master/cast5/cast5.go
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const S = [
  new Uint32Array([
    0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a,
    0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949,
    0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675,
    0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e,
    0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2,
    0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d,
    0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f,
    0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0,
    0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de,
    0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7,
    0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f,
    0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935,
    0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d,
    0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d,
    0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165,
    0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50,
    0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272,
    0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe,
    0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d,
    0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3,
    0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a,
    0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167,
    0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f,
    0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291,
    0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9,
    0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779,
    0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6,
    0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2,
    0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9,
    0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511,
    0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e,
    0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d,
    0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e,
    0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5,
    0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82,
    0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324,
    0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac,
    0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c,
    0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f,
    0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc,
    0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491,
    0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d,
    0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de,
    0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96,
    0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a,
    0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a,
    0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79,
    0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d,
    0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779,
    0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd,
    0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755,
    0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6,
    0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb,
    0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9,
    0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0,
    0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872,
    0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79,
    0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c,
    0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298,
    0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e,
    0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571,
    0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9,
    0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d,
    0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf
  ]),
  new Uint32Array([
    0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380,
    0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651,
    0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba,
    0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3,
    0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909,
    0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb,
    0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b,
    0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806,
    0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4,
    0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b,
    0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f,
    0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359,
    0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21,
    0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b,
    0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d,
    0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c,
    0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f,
    0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34,
    0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d,
    0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb,
    0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4,
    0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd,
    0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801,
    0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860,
    0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755,
    0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b,
    0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709,
    0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304,
    0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b,
    0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b,
    0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c,
    0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf,
    0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9,
    0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c,
    0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3,
    0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13,
    0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9,
    0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f,
    0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab,
    0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6,
    0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4,
    0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6,
    0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43,
    0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58,
    0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8,
    0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906,
    0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171,
    0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d,
    0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89,
    0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6,
    0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b,
    0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4,
    0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb,
    0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6,
    0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e,
    0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f,
    0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea,
    0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249,
    0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea,
    0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa,
    0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd,
    0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9,
    0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef,
    0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1
  ]),
  new Uint32Array([
    0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907,
    0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90,
    0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae,
    0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5,
    0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e,
    0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e,
    0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc,
    0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240,
    0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e,
    0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5,
    0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f,
    0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b,
    0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99,
    0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71,
    0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f,
    0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04,
    0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380,
    0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82,
    0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8,
    0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15,
    0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504,
    0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2,
    0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6,
    0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176,
    0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e,
    0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148,
    0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d,
    0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc,
    0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1,
    0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341,
    0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c,
    0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e,
    0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15,
    0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51,
    0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4,
    0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f,
    0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b,
    0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a,
    0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392,
    0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b,
    0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231,
    0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b,
    0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889,
    0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5,
    0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67,
    0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45,
    0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49,
    0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536,
    0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d,
    0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc,
    0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d,
    0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0,
    0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e,
    0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69,
    0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767,
    0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2,
    0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce,
    0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49,
    0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24,
    0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d,
    0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0,
    0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a,
    0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5,
    0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783
  ]),
  new Uint32Array([
    0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298,
    0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1,
    0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120,
    0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf,
    0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220,
    0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15,
    0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe,
    0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121,
    0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701,
    0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25,
    0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b,
    0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5,
    0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93,
    0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb,
    0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746,
    0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5,
    0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9,
    0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d,
    0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb,
    0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6,
    0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c,
    0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23,
    0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7,
    0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003,
    0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340,
    0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6,
    0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327,
    0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119,
    0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec,
    0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24,
    0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205,
    0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a,
    0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031,
    0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79,
    0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5,
    0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df,
    0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c,
    0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26,
    0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69,
    0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab,
    0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9,
    0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7,
    0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff,
    0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417,
    0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3,
    0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2,
    0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2,
    0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2,
    0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff,
    0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a,
    0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091,
    0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919,
    0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df,
    0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef,
    0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf,
    0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876,
    0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367,
    0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab,
    0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c,
    0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04,
    0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43,
    0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282,
    0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e,
    0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2
  ]),
  new Uint32Array([
    0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911,
    0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f,
    0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00,
    0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a,
    0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180,
    0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff,
    0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2,
    0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02,
    0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725,
    0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a,
    0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b,
    0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7,
    0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571,
    0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9,
    0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec,
    0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981,
    0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea,
    0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774,
    0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263,
    0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655,
    0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468,
    0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2,
    0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b,
    0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910,
    0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284,
    0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1,
    0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4,
    0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da,
    0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7,
    0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049,
    0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce,
    0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f,
    0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6,
    0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba,
    0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4,
    0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be,
    0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561,
    0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3,
    0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6,
    0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840,
    0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406,
    0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4,
    0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472,
    0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2,
    0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487,
    0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7,
    0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288,
    0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5,
    0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2,
    0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e,
    0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78,
    0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e,
    0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76,
    0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801,
    0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0,
    0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad,
    0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58,
    0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0,
    0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2,
    0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20,
    0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be,
    0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8,
    0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55,
    0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4
  ]),
  new Uint32Array([
    0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c,
    0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac,
    0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9,
    0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138,
    0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e,
    0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367,
    0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866,
    0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98,
    0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c,
    0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072,
    0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd,
    0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3,
    0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53,
    0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd,
    0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d,
    0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8,
    0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf,
    0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9,
    0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807,
    0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54,
    0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a,
    0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387,
    0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563,
    0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc,
    0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0,
    0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf,
    0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be,
    0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf,
    0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0,
    0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f,
    0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2,
    0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289,
    0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853,
    0x20951063, 0x4576698d, 0xb6fad407, 0x592af950,
    0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa,
    0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f,
    0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9,
    0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b,
    0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751,
    0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be,
    0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358,
    0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13,
    0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397,
    0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976,
    0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459,
    0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0,
    0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4,
    0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891,
    0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f,
    0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da,
    0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb,
    0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc,
    0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2,
    0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084,
    0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab,
    0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25,
    0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b,
    0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121,
    0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b,
    0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5,
    0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855,
    0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd,
    0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454,
    0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f
  ]),
  new Uint32Array([
    0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693,
    0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f,
    0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82,
    0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de,
    0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd,
    0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43,
    0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f,
    0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19,
    0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9,
    0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2,
    0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e,
    0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516,
    0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83,
    0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88,
    0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e,
    0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816,
    0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a,
    0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756,
    0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f,
    0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a,
    0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b,
    0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264,
    0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78,
    0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688,
    0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d,
    0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28,
    0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802,
    0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3,
    0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9,
    0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7,
    0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302,
    0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06,
    0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858,
    0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033,
    0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a,
    0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a,
    0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4,
    0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566,
    0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df,
    0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509,
    0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9,
    0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962,
    0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c,
    0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e,
    0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07,
    0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c,
    0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939,
    0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c,
    0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e,
    0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285,
    0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378,
    0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301,
    0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd,
    0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be,
    0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567,
    0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767,
    0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2,
    0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647,
    0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf,
    0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914,
    0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2,
    0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c,
    0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada,
    0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3
  ]),
  new Uint32Array([
    0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095,
    0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5,
    0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174,
    0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc,
    0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940,
    0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd,
    0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42,
    0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d,
    0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164,
    0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2,
    0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4,
    0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862,
    0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0,
    0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc,
    0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6,
    0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c,
    0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491,
    0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e,
    0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b,
    0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039,
    0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8,
    0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8,
    0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006,
    0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42,
    0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564,
    0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5,
    0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab,
    0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472,
    0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc,
    0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225,
    0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8,
    0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c,
    0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441,
    0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb,
    0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f,
    0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054,
    0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504,
    0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70,
    0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c,
    0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc,
    0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6,
    0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c,
    0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd,
    0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3,
    0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4,
    0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4,
    0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc,
    0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101,
    0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba,
    0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f,
    0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf,
    0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e,
    0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603,
    0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a,
    0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37,
    0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c,
    0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819,
    0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384,
    0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d,
    0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c,
    0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347,
    0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82,
    0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d,
    0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e
  ])
];

const schedule = [
  {
    a: [
      new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 0x8]),
      new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]),
      new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]),
      new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb])
    ],
    b: [
      new Uint8Array([16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2]),
      new Uint8Array([16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6]),
      new Uint8Array([16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9]),
      new Uint8Array([16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc])
    ]
  },
  {
    a: [
      new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]),
      new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]),
      new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]),
      new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3])
    ],
    b: [
      new Uint8Array([3, 2, 0xc, 0xd, 8]),
      new Uint8Array([1, 0, 0xe, 0xf, 0xd]),
      new Uint8Array([7, 6, 8, 9, 3]),
      new Uint8Array([5, 4, 0xa, 0xb, 7])
    ]
  },
  {
    a: [
      new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 8]),
      new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]),
      new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]),
      new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb])
    ],
    b: [
      new Uint8Array([16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9]),
      new Uint8Array([16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc]),
      new Uint8Array([16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2]),
      new Uint8Array([16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6])
    ]
  },
  {
    a: [
      new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]),
      new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]),
      new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]),
      new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3])
    ],
    b: [
      new Uint8Array([8, 9, 7, 6, 3]),
      new Uint8Array([0xa, 0xb, 5, 4, 7]),
      new Uint8Array([0xc, 0xd, 3, 2, 8]),
      new Uint8Array([0xe, 0xf, 1, 0, 0xd])
    ]
  }
];

const X = new Uint8Array([6, 7, 4, 5]);

/**
 * CAST5
 */

class CAST5 {
  constructor() {
    this.masking = new Uint32Array(16);
    this.rotate = new Uint8Array(16);
  }

  get blockSize() {
    return 8;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 16);
    this.keySchedule(key);
    return this;
  }

  destroy() {
    for (let i = 0; i < 16; i++)
      this.masking[i] = 0;

    for (let i = 0; i < 16; i++)
      this.rotate[i] = 0;

    return this;
  }

  keySchedule(input) {
    const t = new Uint32Array(8);
    const k = new Uint32Array(32);

    for (let i = 0; i < 4; i++)
      t[i] = readU32(input, i * 4);

    let ki = 0;
    let w;

    for (let half = 0; half < 2; half++) {
      for (const round of schedule) {
        for (let j = 0; j < 4; j++) {
          const a = round.a[j];

          w = t[a[1]];
          w ^= S[4][(t[a[2] >>> 2] >>> (24 - 8 * (a[2] & 3))) & 0xff];
          w ^= S[5][(t[a[3] >>> 2] >>> (24 - 8 * (a[3] & 3))) & 0xff];
          w ^= S[6][(t[a[4] >>> 2] >>> (24 - 8 * (a[4] & 3))) & 0xff];
          w ^= S[7][(t[a[5] >>> 2] >>> (24 - 8 * (a[5] & 3))) & 0xff];
          w ^= S[X[j]][(t[a[6] >>> 2] >>> (24 - 8 * (a[6] & 3))) & 0xff];

          t[a[0]] = w;
        }

        for (let j = 0; j < 4; j++) {
          const b = round.b[j];

          w = S[4][(t[b[0] >>> 2] >>> (24 - 8 * (b[0] & 3))) & 0xff];
          w ^= S[5][(t[b[1] >>> 2] >>> (24 - 8 * (b[1] & 3))) & 0xff];
          w ^= S[6][(t[b[2] >>> 2] >>> (24 - 8 * (b[2] & 3))) & 0xff];
          w ^= S[7][(t[b[3] >>> 2] >>> (24 - 8 * (b[3] & 3))) & 0xff];
          w ^= S[4 + j][(t[b[4] >>> 2] >>> (24 - 8 * (b[4] & 3))) & 0xff];

          k[ki] = w;
          ki += 1;
        }
      }
    }

    for (let i = 0; i < 16; i++) {
      this.masking[i] = k[i];
      this.rotate[i] = k[16 + i] & 0x1f;
    }

    return this;
  }

  encrypt(input, ipos, output, opos) {
    let l = readU32(input, ipos);
    let r = readU32(input, ipos + 4);

    [l, r] = [r, l ^ f1(r, this.masking[0], this.rotate[0])];
    [l, r] = [r, l ^ f2(r, this.masking[1], this.rotate[1])];
    [l, r] = [r, l ^ f3(r, this.masking[2], this.rotate[2])];
    [l, r] = [r, l ^ f1(r, this.masking[3], this.rotate[3])];

    [l, r] = [r, l ^ f2(r, this.masking[4], this.rotate[4])];
    [l, r] = [r, l ^ f3(r, this.masking[5], this.rotate[5])];
    [l, r] = [r, l ^ f1(r, this.masking[6], this.rotate[6])];
    [l, r] = [r, l ^ f2(r, this.masking[7], this.rotate[7])];

    [l, r] = [r, l ^ f3(r, this.masking[8], this.rotate[8])];
    [l, r] = [r, l ^ f1(r, this.masking[9], this.rotate[9])];
    [l, r] = [r, l ^ f2(r, this.masking[10], this.rotate[10])];
    [l, r] = [r, l ^ f3(r, this.masking[11], this.rotate[11])];

    [l, r] = [r, l ^ f1(r, this.masking[12], this.rotate[12])];
    [l, r] = [r, l ^ f2(r, this.masking[13], this.rotate[13])];
    [l, r] = [r, l ^ f3(r, this.masking[14], this.rotate[14])];
    [l, r] = [r, l ^ f1(r, this.masking[15], this.rotate[15])];

    writeU32(output, r, opos);
    writeU32(output, l, opos + 4);

    return this;
  }

  decrypt(input, ipos, output, opos) {
    let l = readU32(input, ipos);
    let r = readU32(input, ipos + 4);

    [l, r] = [r, l ^ f1(r, this.masking[15], this.rotate[15])];
    [l, r] = [r, l ^ f3(r, this.masking[14], this.rotate[14])];
    [l, r] = [r, l ^ f2(r, this.masking[13], this.rotate[13])];
    [l, r] = [r, l ^ f1(r, this.masking[12], this.rotate[12])];

    [l, r] = [r, l ^ f3(r, this.masking[11], this.rotate[11])];
    [l, r] = [r, l ^ f2(r, this.masking[10], this.rotate[10])];
    [l, r] = [r, l ^ f1(r, this.masking[9], this.rotate[9])];
    [l, r] = [r, l ^ f3(r, this.masking[8], this.rotate[8])];

    [l, r] = [r, l ^ f2(r, this.masking[7], this.rotate[7])];
    [l, r] = [r, l ^ f1(r, this.masking[6], this.rotate[6])];
    [l, r] = [r, l ^ f3(r, this.masking[5], this.rotate[5])];
    [l, r] = [r, l ^ f2(r, this.masking[4], this.rotate[4])];

    [l, r] = [r, l ^ f1(r, this.masking[3], this.rotate[3])];
    [l, r] = [r, l ^ f3(r, this.masking[2], this.rotate[2])];
    [l, r] = [r, l ^ f2(r, this.masking[1], this.rotate[1])];
    [l, r] = [r, l ^ f1(r, this.masking[0], this.rotate[0])];

    writeU32(output, r, opos);
    writeU32(output, l, opos + 4);

    return this;
  }
}

/*
 * Helpers
 */

function f1(d, m, r) {
  const t = m + d;
  const I = (t << r) | (t >>> (32 - r));;
  return (((S[0][I >>> 24]
    ^ S[1][(I >>> 16) & 0xff])
    - S[2][(I >>> 8) & 0xff])
    + S[3][I & 0xff]);
}

function f2(d, m, r) {
  const t = m ^ d;
  const I = (t << r) | (t >>> (32 - r));
  return (((S[0][I >>> 24]
    - S[1][(I >>> 16) & 0xff])
    + S[2][(I >>> 8) & 0xff])
    ^ S[3][I & 0xff]);
}

function f3(d, m, r) {
  const t = m - d;
  const I = (t << r) | (t >>> (32 - r));
  return (((S[0][I >>> 24]
    + S[1][(I >>> 16) & 0xff])
    ^ S[2][(I >>> 8) & 0xff])
    - S[3][I & 0xff]);
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(dst, num, off) {
  dst[off++] = num >>> 24;
  dst[off++] = num >>> 16;
  dst[off++] = num >>> 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = CAST5;

}).call(this,{"isBuffer":req("../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],96:[function(req,module,exports){
(function (Buffer){
/*!
 * des.js - DES for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/des.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/des.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Data_Encryption_Standard
 *   https://github.com/indutny/des.js/tree/master/lib/des
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const PC2 = new Uint8Array([
  // inL => outL
  0x0e, 0x0b, 0x11, 0x04, 0x1b, 0x17, 0x19, 0x00,
  0x0d, 0x16, 0x07, 0x12, 0x05, 0x09, 0x10, 0x18,
  0x02, 0x14, 0x0c, 0x15, 0x01, 0x08, 0x0f, 0x1a,

  // inR => outR
  0x0f, 0x04, 0x19, 0x13, 0x09, 0x01, 0x1a, 0x10,
  0x05, 0x0b, 0x17, 0x08, 0x0c, 0x07, 0x11, 0x00,
  0x16, 0x03, 0x0a, 0x0e, 0x06, 0x14, 0x1b, 0x18
]);

const S = new Uint8Array([
  0x0e, 0x00, 0x04, 0x0f, 0x0d, 0x07, 0x01, 0x04,
  0x02, 0x0e, 0x0f, 0x02, 0x0b, 0x0d, 0x08, 0x01,
  0x03, 0x0a, 0x0a, 0x06, 0x06, 0x0c, 0x0c, 0x0b,
  0x05, 0x09, 0x09, 0x05, 0x00, 0x03, 0x07, 0x08,
  0x04, 0x0f, 0x01, 0x0c, 0x0e, 0x08, 0x08, 0x02,
  0x0d, 0x04, 0x06, 0x09, 0x02, 0x01, 0x0b, 0x07,
  0x0f, 0x05, 0x0c, 0x0b, 0x09, 0x03, 0x07, 0x0e,
  0x03, 0x0a, 0x0a, 0x00, 0x05, 0x06, 0x00, 0x0d,

  0x0f, 0x03, 0x01, 0x0d, 0x08, 0x04, 0x0e, 0x07,
  0x06, 0x0f, 0x0b, 0x02, 0x03, 0x08, 0x04, 0x0e,
  0x09, 0x0c, 0x07, 0x00, 0x02, 0x01, 0x0d, 0x0a,
  0x0c, 0x06, 0x00, 0x09, 0x05, 0x0b, 0x0a, 0x05,
  0x00, 0x0d, 0x0e, 0x08, 0x07, 0x0a, 0x0b, 0x01,
  0x0a, 0x03, 0x04, 0x0f, 0x0d, 0x04, 0x01, 0x02,
  0x05, 0x0b, 0x08, 0x06, 0x0c, 0x07, 0x06, 0x0c,
  0x09, 0x00, 0x03, 0x05, 0x02, 0x0e, 0x0f, 0x09,

  0x0a, 0x0d, 0x00, 0x07, 0x09, 0x00, 0x0e, 0x09,
  0x06, 0x03, 0x03, 0x04, 0x0f, 0x06, 0x05, 0x0a,
  0x01, 0x02, 0x0d, 0x08, 0x0c, 0x05, 0x07, 0x0e,
  0x0b, 0x0c, 0x04, 0x0b, 0x02, 0x0f, 0x08, 0x01,
  0x0d, 0x01, 0x06, 0x0a, 0x04, 0x0d, 0x09, 0x00,
  0x08, 0x06, 0x0f, 0x09, 0x03, 0x08, 0x00, 0x07,
  0x0b, 0x04, 0x01, 0x0f, 0x02, 0x0e, 0x0c, 0x03,
  0x05, 0x0b, 0x0a, 0x05, 0x0e, 0x02, 0x07, 0x0c,

  0x07, 0x0d, 0x0d, 0x08, 0x0e, 0x0b, 0x03, 0x05,
  0x00, 0x06, 0x06, 0x0f, 0x09, 0x00, 0x0a, 0x03,
  0x01, 0x04, 0x02, 0x07, 0x08, 0x02, 0x05, 0x0c,
  0x0b, 0x01, 0x0c, 0x0a, 0x04, 0x0e, 0x0f, 0x09,
  0x0a, 0x03, 0x06, 0x0f, 0x09, 0x00, 0x00, 0x06,
  0x0c, 0x0a, 0x0b, 0x01, 0x07, 0x0d, 0x0d, 0x08,
  0x0f, 0x09, 0x01, 0x04, 0x03, 0x05, 0x0e, 0x0b,
  0x05, 0x0c, 0x02, 0x07, 0x08, 0x02, 0x04, 0x0e,

  0x02, 0x0e, 0x0c, 0x0b, 0x04, 0x02, 0x01, 0x0c,
  0x07, 0x04, 0x0a, 0x07, 0x0b, 0x0d, 0x06, 0x01,
  0x08, 0x05, 0x05, 0x00, 0x03, 0x0f, 0x0f, 0x0a,
  0x0d, 0x03, 0x00, 0x09, 0x0e, 0x08, 0x09, 0x06,
  0x04, 0x0b, 0x02, 0x08, 0x01, 0x0c, 0x0b, 0x07,
  0x0a, 0x01, 0x0d, 0x0e, 0x07, 0x02, 0x08, 0x0d,
  0x0f, 0x06, 0x09, 0x0f, 0x0c, 0x00, 0x05, 0x09,
  0x06, 0x0a, 0x03, 0x04, 0x00, 0x05, 0x0e, 0x03,

  0x0c, 0x0a, 0x01, 0x0f, 0x0a, 0x04, 0x0f, 0x02,
  0x09, 0x07, 0x02, 0x0c, 0x06, 0x09, 0x08, 0x05,
  0x00, 0x06, 0x0d, 0x01, 0x03, 0x0d, 0x04, 0x0e,
  0x0e, 0x00, 0x07, 0x0b, 0x05, 0x03, 0x0b, 0x08,
  0x09, 0x04, 0x0e, 0x03, 0x0f, 0x02, 0x05, 0x0c,
  0x02, 0x09, 0x08, 0x05, 0x0c, 0x0f, 0x03, 0x0a,
  0x07, 0x0b, 0x00, 0x0e, 0x04, 0x01, 0x0a, 0x07,
  0x01, 0x06, 0x0d, 0x00, 0x0b, 0x08, 0x06, 0x0d,

  0x04, 0x0d, 0x0b, 0x00, 0x02, 0x0b, 0x0e, 0x07,
  0x0f, 0x04, 0x00, 0x09, 0x08, 0x01, 0x0d, 0x0a,
  0x03, 0x0e, 0x0c, 0x03, 0x09, 0x05, 0x07, 0x0c,
  0x05, 0x02, 0x0a, 0x0f, 0x06, 0x08, 0x01, 0x06,
  0x01, 0x06, 0x04, 0x0b, 0x0b, 0x0d, 0x0d, 0x08,
  0x0c, 0x01, 0x03, 0x04, 0x07, 0x0a, 0x0e, 0x07,
  0x0a, 0x09, 0x0f, 0x05, 0x06, 0x00, 0x08, 0x0f,
  0x00, 0x0e, 0x05, 0x02, 0x09, 0x03, 0x02, 0x0c,

  0x0d, 0x01, 0x02, 0x0f, 0x08, 0x0d, 0x04, 0x08,
  0x06, 0x0a, 0x0f, 0x03, 0x0b, 0x07, 0x01, 0x04,
  0x0a, 0x0c, 0x09, 0x05, 0x03, 0x06, 0x0e, 0x0b,
  0x05, 0x00, 0x00, 0x0e, 0x0c, 0x09, 0x07, 0x02,
  0x07, 0x02, 0x0b, 0x01, 0x04, 0x0e, 0x01, 0x07,
  0x09, 0x04, 0x0c, 0x0a, 0x0e, 0x08, 0x02, 0x0d,
  0x00, 0x0f, 0x06, 0x0c, 0x0a, 0x09, 0x0d, 0x00,
  0x0f, 0x03, 0x03, 0x05, 0x05, 0x06, 0x08, 0x0b
]);

const PERMUTE = new Uint8Array([
  0x10, 0x19, 0x0c, 0x0b, 0x03, 0x14, 0x04, 0x0f,
  0x1f, 0x11, 0x09, 0x06, 0x1b, 0x0e, 0x01, 0x16,
  0x1e, 0x18, 0x08, 0x12, 0x00, 0x05, 0x1d, 0x17,
  0x0d, 0x13, 0x02, 0x1a, 0x0a, 0x15, 0x1c, 0x07
]);

const SHIFT = new Uint8Array([
  0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01
]);

/**
 * DES
 */

class DES {
  constructor() {
    this.block = new Uint32Array(2);
    this.keys = new Uint32Array(16 * 2);
  }

  get blockSize() {
    return 8;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 8);
    return this.derive(key);
  }

  encrypt(input, ipos, output, opos) {
    return this.crypt(input, ipos, output, opos, true);
  }

  decrypt(input, ipos, output, opos) {
    return this.crypt(input, ipos, output, opos, false);
  }

  destroy() {
    for (let i = 0; i < 2; i++)
      this.block[i] = 0;

    for (let i = 0; i < 32; i++)
      this.keys[i] = 0;

    return this;
  }

  derive(key) {
    let kL = readU32(key, 0);
    let kR = readU32(key, 4);

    pc1(kL, kR, this.block, 0);
    kL = this.block[0];
    kR = this.block[1];

    for (let i = 0; i < this.keys.length; i += 2) {
      const shift = SHIFT[i >>> 1];
      kL = r28shl(kL, shift);
      kR = r28shl(kR, shift);
      pc2(kL, kR, this.keys, i);
    }

    return this;
  }

  crypt(input, ipos, output, opos, encrypt) {
    let l = readU32(input, ipos);
    let r = readU32(input, ipos + 4);

    // Initial Permutation
    ip(l, r, this.block, 0);

    l = this.block[0];
    r = this.block[1];

    if (encrypt)
      this.encipher(l, r, this.block, 0);
    else
      this.decipher(l, r, this.block, 0);

    l = this.block[0];
    r = this.block[1];

    writeU32(output, l, opos);
    writeU32(output, r, opos + 4);

    return this;
  }

  encipher(lStart, rStart, out, off) {
    let l = lStart;
    let r = rStart;

    // Apply f() x16 times
    for (let i = 0; i < this.keys.length; i += 2) {
      let keyL = this.keys[i];
      let keyR = this.keys[i + 1];

      // f(r, k)
      expand(r, this.block, 0);

      keyL ^= this.block[0];
      keyR ^= this.block[1];

      const s = substitute(keyL, keyR);
      const f = permute(s);
      const t = r;

      r = (l ^ f) >>> 0;
      l = t;
    }

    // Reverse Initial Permutation
    rip(r, l, out, off);

    return this;
  }

  decipher(lStart, rStart, out, off) {
    let l = rStart;
    let r = lStart;

    // Apply f() x16 times
    for (let i = this.keys.length - 2; i >= 0; i -= 2) {
      let keyL = this.keys[i];
      let keyR = this.keys[i + 1];

      // f(r, k)
      expand(l, this.block, 0);

      keyL ^= this.block[0];
      keyR ^= this.block[1];

      const s = substitute(keyL, keyR);
      const f = permute(s);
      const t = l;

      l = (r ^ f) >>> 0;
      r = t;
    }

    // Reverse Initial Permutation
    rip(l, r, out, off);

    return this;
  }
}

/**
 * EDE
 */

class EDE {
  constructor() {
    this.x = new DES();
    this.y = new DES();
  }

  get blockSize() {
    return 8;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 16);

    const k1 = key.slice(0, 8);
    const k2 = key.slice(8, 16);

    this.x.init(k1);
    this.y.init(k2);

    return this;
  }

  encrypt(input, ipos, output, opos) {
    this.x.encrypt(input, ipos, output, opos);
    this.y.decrypt(output, opos, output, opos);
    this.x.encrypt(output, opos, output, opos);
    return this;
  }

  decrypt(input, ipos, output, opos) {
    this.x.decrypt(input, ipos, output, opos);
    this.y.encrypt(output, opos, output, opos);
    this.x.decrypt(output, opos, output, opos);
    return this;
  }

  destroy() {
    this.x.destroy();
    this.y.destroy();
    return this;
  }
}

/**
 * EDE3
 */

class EDE3 {
  constructor() {
    this.x = new DES();
    this.y = new DES();
    this.z = new DES();
  }

  get blockSize() {
    return 8;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 24);

    const k1 = key.slice(0, 8);
    const k2 = key.slice(8, 16);
    const k3 = key.slice(16, 24);

    this.x.init(k1);
    this.y.init(k2);
    this.z.init(k3);

    return this;
  }

  encrypt(input, ipos, output, opos) {
    this.x.encrypt(input, ipos, output, opos);
    this.y.decrypt(output, opos, output, opos);
    this.z.encrypt(output, opos, output, opos);
    return this;
  }

  decrypt(input, ipos, output, opos) {
    this.z.decrypt(input, ipos, output, opos);
    this.y.encrypt(output, opos, output, opos);
    this.x.decrypt(output, opos, output, opos);
    return this;
  }

  destroy() {
    this.x.destroy();
    this.y.destroy();
    this.z.destroy();
    return this;
  }
}

/*
 * Helpers
 */

function ip(inL, inR, out, off) {
  let outL = 0;
  let outR = 0;

  for (let i = 6; i >= 0; i -= 2) {
    for (let j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }

    for (let j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (let i = 6; i >= 0; i -= 2) {
    for (let j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }

    for (let j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
}

function rip(inL, inR, out, off) {
  let outL = 0;
  let outR = 0;

  for (let i = 0; i < 4; i++) {
    for (let j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (let i = 4; i < 8; i++) {
    for (let j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
}

function pc1(inL, inR, out, off) {
  let outL = 0;
  let outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (let i = 7; i >= 5; i--) {
    for (let j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }

    for (let j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }

  for (let j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + 4)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (let i = 1; i <= 3; i++) {
    for (let j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }

    for (let j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }

  for (let j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + 4)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
}

function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
}

function pc2(inL, inR, out, off) {
  let outL = 0;
  let outR = 0;

  const len = PC2.length >>> 1;

  for (let i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> PC2[i]) & 1;
  }

  for (let i = len; i < PC2.length; i++) {
    outR <<= 1;
    outR |= (inR >>> PC2[i]) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
}

function expand(r, out, off) {
  let outL = 0;
  let outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);

  for (let i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }

  for (let i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }

  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
}

function substitute(inL, inR) {
  let out = 0;

  for (let i = 0; i < 4; i++) {
    const b = (inL >>> (18 - i * 6)) & 0x3f;
    const sb = S[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }

  for (let i = 0; i < 4; i++) {
    const b = (inR >>> (18 - i * 6)) & 0x3f;
    const sb = S[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }

  return out >>> 0;
}

function permute(num) {
  let out = 0;

  for (let i = 0; i < PERMUTE.length; i++) {
    out <<= 1;
    out |= (num >>> PERMUTE[i]) & 1;
  }

  return out >>> 0;
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(dst, num, off) {
  dst[off++] = num >>> 24;
  dst[off++] = num >>> 16;
  dst[off++] = num >>> 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

exports.DES = DES;
exports.EDE = EDE;
exports.EDE3 = EDE3;

}).call(this,{"isBuffer":req("../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],97:[function(req,module,exports){
(function (Buffer){
/*!
 * gcm.js - gcm for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Galois/Counter_Mode
 *   https://dx.doi.org/10.6028/NIST.SP.800-38D
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go
 *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const PADDING = Buffer.alloc(16, 0x00);
const FINALIZED = -1;

const REDUCTION = new Uint16Array([
  0x0000, 0x1c20, 0x3840, 0x2460,
  0x7080, 0x6ca0, 0x48c0, 0x54e0,
  0xe100, 0xfd20, 0xd940, 0xc560,
  0x9180, 0x8da0, 0xa9c0, 0xb5e0
]);

/**
 * GHASH
 */

class GHASH {
  constructor() {
    this.state = new Uint32Array(4);
    this.block = Buffer.allocUnsafe(16);
    this.size = FINALIZED;
    this.adLen = 0;
    this.ctLen = 0;
    this.table = [];

    for (let i = 0; i < 16; i++)
      this.table.push(new Uint32Array(4));
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 16);

    for (let i = 0; i < 4; i++)
      this.state[i] = 0;

    this.block.fill(0x00);
    this.size = 0;
    this.adLen = 0;
    this.ctLen = 0;

    for (let i = 0; i < 16; i++) {
      for (let j = 0; j < 4; j++)
        this.table[i][j] = 0;
    }

    const x = new Uint32Array(4);

    // Note: We store elements in
    // ascending significance (i.e.
    // 0 is the LSW, 3 is the MSW).
    // x1, x0 = lo
    // x3, x2 = hi
    x[1] = readU32BE(key, 0);
    x[0] = readU32BE(key, 4);
    x[3] = readU32BE(key, 8);
    x[2] = readU32BE(key, 12);

    this.table[reverse(1)] = x;

    for (let i = 2; i < 16; i += 2) {
      this.table[reverse(i)] = this.double(this.table[reverse(i >>> 1)]);
      this.table[reverse(i + 1)] = this.add(this.table[reverse(i)], x);
    }

    return this;
  }

  absorb(data) {
    this._absorb(data, data.length);
    return this;
  }

  _absorb(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 15;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 16 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 16)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 16) {
      this.transform(data, off);
      off += 16;
      len -= 16;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  transform(block, off) {
    this.state[1] ^= readU32BE(block, off + 0);
    this.state[0] ^= readU32BE(block, off + 4);
    this.state[3] ^= readU32BE(block, off + 8);
    this.state[2] ^= readU32BE(block, off + 12);
    this.mul(this.state);
  }

  pad() {
    const pos = this.size & 15;

    if (pos !== 0)
      this._absorb(PADDING, 16 - pos);
  }

  aad(data) {
    assert(Buffer.isBuffer(data));
    assert(this.ctLen === 0);
    this.adLen += data.length;
    return this.absorb(data);
  }

  update(data) {
    assert(Buffer.isBuffer(data));

    if (data.length === 0)
      return this;

    if (this.ctLen === 0)
      this.pad();

    this.ctLen += data.length;

    return this.absorb(data);
  }

  final() {
    const out = Buffer.allocUnsafe(16);

    this.pad();

    const adLen = this.adLen * 8;
    const ctLen = this.ctLen * 8;

    this.state[1] ^= hi32(adLen);
    this.state[0] ^= lo32(adLen);
    this.state[3] ^= hi32(ctLen);
    this.state[2] ^= lo32(ctLen);

    this.mul(this.state);

    writeU32BE(out, this.state[1], 0);
    writeU32BE(out, this.state[0], 4);
    writeU32BE(out, this.state[3], 8);
    writeU32BE(out, this.state[2], 12);

    for (let i = 0; i < 4; i++)
      this.state[i] = 0;

    this.block.fill(0x00);
    this.size = FINALIZED;
    this.adLen = 0;
    this.ctLen = 0;

    for (let i = 0; i < 16; i++) {
      for (let j = 0; j < 4; j++)
        this.table[i][j] = 0;
    }

    return out;
  }

  add(x, y) {
    assert(x instanceof Uint32Array);
    assert(x.length === 4);
    assert(y instanceof Uint32Array);
    assert(y.length === 4);

    const z = new Uint32Array(4);

    z[0] = x[0] ^ y[0];
    z[1] = x[1] ^ y[1];
    z[2] = x[2] ^ y[2];
    z[3] = x[3] ^ y[3];

    return z;
  }

  double(x) {
    assert(x instanceof Uint32Array);
    assert(x.length === 4);

    const d = new Uint32Array(4);

    const msb = (x[2] & 1) === 1;

    let v;

    d[3] = x[3];
    d[2] = x[2];
    v = d[3] & 1;
    d[3] >>>= 1;
    d[2] >>>= 1;
    d[2] |= v << 31;

    d[3] |= (x[0] & 1) << 31;

    d[1] = x[1];
    d[0] = x[0];
    v = d[1] & 1;
    d[1] >>>= 1;
    d[0] >>>= 1;
    d[0] |= v << 31;

    if (msb) {
      d[1] ^= 0xe1000000;
      d[0] ^= 0x00000000;
    }

    return d;
  }

  mul(y) {
    assert(y instanceof Uint32Array);
    assert(y.length === 4);

    const z = new Uint32Array(4);
    const w = new Uint32Array(2);

    let v, t;

    for (let i = 0; i < 2; i++) {
      w[0] = y[2];
      w[1] = y[3];

      if (i === 1) {
        w[0] = y[0];
        w[1] = y[1];
      }

      for (let j = 0; j < 64; j += 4) {
        const msw = z[2] & 0x0f;

        v = z[3] & 0x0f;
        z[3] >>>= 4;
        z[2] >>>= 4;
        z[2] |= v << 28;

        z[3] |= z[0] << 28;

        v = z[1] & 0x0f;
        z[1] >>>= 4;
        z[0] >>>= 4;
        z[0] |= v << 28;

        z[1] ^= REDUCTION[msw] << 16;

        t = this.table[w[0] & 0x0f];

        z[0] ^= t[0];
        z[1] ^= t[1];

        z[2] ^= t[2];
        z[3] ^= t[3];

        v = w[1] & 0x0f;
        w[1] >>>= 4;
        w[0] >>>= 4;
        w[0] |= v << 28;
      }
    }

    y[0] = z[0];
    y[1] = z[1];
    y[2] = z[2];
    y[3] = z[3];
  }
}

/**
 * CTR
 */

class CTR {
  constructor(ctx) {
    assert(ctx && typeof ctx === 'object');
    assert(typeof ctx.blockSize === 'number');

    if (ctx.blockSize !== 16)
      throw new Error('GCM only available with a 128 bit block size.');

    this.ctx = ctx;
    this.state = Buffer.alloc(16, 0x00);
    this.block = Buffer.alloc(16, 0x00);
    this.pos = 0;
  }

  get blockSize() {
    return 16;
  }

  init(key, iv, counter) {
    this.initKey(key);
    this.initIV(iv, counter);
    return this;
  }

  initKey(key) {
    this.ctx.init(key);
    this.state.fill(0x00);
    this.pos = 0;
    return this;
  }

  initIV(iv, counter) {
    assert(Buffer.isBuffer(iv));
    assert(iv.length === 12 || iv.length === 16);

    iv.copy(this.state, 0);

    if (iv.length !== 16)
      this.setCounter(counter);

    return this;
  }

  encrypt(data) {
    return this.crypt(data, data);
  }

  crypt(input, output) {
    assert(Buffer.isBuffer(input));
    assert(Buffer.isBuffer(output));

    if (output.length < input.length)
      throw new Error('Invalid output size.');

    for (let i = 0; i < input.length; i++) {
      if ((this.pos & 15) === 0) {
        this._block();
        this.pos = 0;
      }

      output[i] = input[i] ^ this.block[this.pos++];
    }

    return output;
  }

  _block() {
    this.ctx.encrypt(this.state, 0, this.block, 0);

    for (let j = 15; j >= 12; j--) {
      this.state[j] += 1;
      if (this.state[j] !== 0)
        break;
    }
  }

  setCounter(counter) {
    if (counter == null)
      counter = 0;

    assert((counter >>> 0) === counter);
    writeU32BE(this.state, counter, 12);

    return this;
  }

  getCounter() {
    return readU32BE(this.state, 12);
  }

  destroy() {
    this.ctx.destroy();
    this.state.fill(0x00);
    this.block.fill(0x00);
    this.pos = 0;
    return this;
  }
}

/**
 * GCM
 */

class GCM {
  constructor(ctx) {
    this.cipher = new CTR(ctx);
    this.mac = new GHASH();
    this.mask = Buffer.alloc(16, 0x00);
  }

  init(key, iv) {
    const macKey = Buffer.alloc(16, 0x00);

    this.cipher.initKey(key);
    this.cipher.encrypt(macKey);
    this.mac.init(macKey);

    // Full round of ghash with same key.
    if (iv.length !== 12) {
      this.mac.update(iv);
      iv = this.mac.final();
      this.mac.init(macKey);
    }

    this.cipher.initIV(iv, 1);

    // Counter should be one.
    if (iv.length !== 16)
      assert(this.cipher.getCounter() === 1);

    this.cipher.encrypt(this.mask);

    return this;
  }

  aad(data) {
    this.mac.aad(data);
    return this;
  }

  encrypt(data) {
    this.cipher.encrypt(data);
    this.mac.update(data);
    return data;
  }

  decrypt(data) {
    this.mac.update(data);
    this.cipher.encrypt(data);
    return data;
  }

  auth(data) {
    this.mac.update(data);
    return data;
  }

  final(size = 16) {
    assert((size >>> 0) === size);
    assert(size === 4 || size === 8
       || (size >= 12 && size <= 16));

    const mac = this.mac.final();

    for (let i = 0; i < 16; i++)
      mac[i] ^= this.mask[i];

    return mac.slice(0, size);
  }

  static encrypt(key, iv, msg, aad) {
    const aead = new GCM();

    aead.init(key, iv);

    if (aad)
      aead.aad(aad);

    aead.encrypt(msg);

    return aead.final();
  }

  static decrypt(key, iv, msg, tag, aad) {
    const aead = new GCM();

    aead.init(key, iv);

    if (aad)
      aead.aad(aad);

    aead.decrypt(msg);

    return GCM.verify(aead.final(), tag);
  }

  static auth(key, iv, msg, tag, aad) {
    const aead = new GCM();

    aead.init(key, iv);

    if (aad)
      aead.aad(aad);

    aead.auth(msg);

    return GCM.verify(aead.final(), tag);
  }

  static verify(mac1, mac2) {
    assert(Buffer.isBuffer(mac1));
    assert(Buffer.isBuffer(mac2));
    assert(mac1.length === mac2.length);

    let dif = 0;

    // Compare in constant time.
    for (let i = 0; i < mac1.length; i++)
      dif |= mac1[i] ^ mac2[i];

    dif = (dif - 1) >>> 31;

    return (dif & 1) !== 0;
  }
}

/*
 * Helpers
 */

function hi32(num) {
  return (num * (1 / 0x100000000)) >>> 0;
}

function lo32(num) {
  return num >>> 0;
}

function reverse(i) {
  i &= 0x0f;
  i = ((i << 2) & 0x0c) | ((i >>> 2) & 0x03);
  i &= 0x0f;
  i = ((i << 1) & 0x0a) | ((i >>> 1) & 0x05);
  i &= 0x0f;
  return i;
}

function readU32BE(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off++]);
}

function writeU32BE(dst, num, off) {
  dst[off++] = num >>> 24;
  dst[off++] = num >>> 16;
  dst[off++] = num >>> 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

exports.GHASH = GHASH;
exports.CTR = CTR;
exports.GCM = GCM;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],98:[function(req,module,exports){
(function (Buffer){
/*!
 * idea.js - IDEA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dgryski/go-idea:
 *   Copyright (c) 2013-2017, Damian Gryski. All rights reserved.
 *   https://github.com/dgryski/go-idea
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm
 *   https://github.com/dgryski/go-idea/blob/master/idea.go
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const ROUNDS = 8;
const KEYLEN = 6 * ROUNDS + 4;
const ZERO16 = Buffer.alloc(16, 0x00);

/**
 * IDEA
 */

class IDEA {
  constructor() {
    this.key = ZERO16;
    this.encryptKey = null;
    this.decryptKey = null;
  }

  get blockSize() {
    return 8;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length === 16);

    this.destroy();
    this.key = Buffer.from(key);

    return this;
  }

  getEncryptKey() {
    if (!this.encryptKey)
      this.encryptKey = this.expandKey(this.key);

    return this.encryptKey;
  }

  getDecryptKey() {
    if (!this.decryptKey)
      this.decryptKey = this.invertKey(this.getEncryptKey());

    return this.decryptKey;
  }

  encrypt(input, ipos, output, opos) {
    const key = this.getEncryptKey();
    return this.crypt(input, ipos, output, opos, key);
  }

  decrypt(input, ipos, output, opos) {
    const key = this.getDecryptKey();
    return this.crypt(input, ipos, output, opos, key);
  }

  destroy() {
    for (let i = 0; i < 16; i++)
      this.key[i] = 0;

    if (this.encryptKey) {
      for (let i = 0; i < KEYLEN; i++)
        this.encryptKey[i] = 0;
    }

    if (this.decryptKey) {
      for (let i = 0; i < KEYLEN; i++)
        this.decryptKey[i] = 0;
    }

    this.key = ZERO16;
    this.encryptKey = null;
    this.decryptKey = null;

    return this;
  }

  expandKey(key) {
    const ek = new Uint16Array(KEYLEN);

    let p = 0;
    let j = 0;
    let i = 0;

    for (; j < 8; j++) {
      ek[j] = readU16(key, p);
      p += 2;
    }

    p = 0;

    for (; j < KEYLEN; j++) {
      i += 1;
      ek[p + (i + 7)] = (ek[p + (i & 7)] << 9) | (ek[p + ((i + 1) & 7)] >>> 7);
      p += i & 8;
      i &= 7;
    }

    return ek;
  }

  invertKey(ek) {
    const dk = new Uint16Array(KEYLEN);

    let t1, t2, t3;
    let dki = KEYLEN;
    let eki = 0;

    t1 = invm(ek[eki]);
    eki += 1;
    t2 = -ek[eki];
    eki += 1;
    t3 = -ek[eki];
    eki += 1;
    dki -= 1;
    dk[dki] = invm(ek[eki]);
    eki += 1;
    dki -= 1;
    dk[dki] = t3;
    dki -= 1;
    dk[dki] = t2;
    dki -= 1;
    dk[dki] = t1;

    for (let i = 0; i < ROUNDS - 1; i++) {
      t1 = ek[eki];
      eki += 1;
      dki -= 1;
      dk[dki] = ek[eki];
      eki += 1;
      dki -= 1;
      dk[dki] = t1;

      t1 = invm(ek[eki]);
      eki += 1;
      t2 = -ek[eki];
      eki += 1;
      t3 = -ek[eki];
      eki += 1;
      dki -= 1;
      dk[dki] = invm(ek[eki]);
      eki += 1;
      dki -= 1;
      dk[dki] = t2;
      dki -= 1;
      dk[dki] = t3;
      dki -= 1;
      dk[dki] = t1;
    }

    t1 = ek[eki];
    eki += 1;
    dki -= 1;
    dk[dki] = ek[eki];
    eki += 1;
    dki -= 1;
    dk[dki] = t1;

    t1 = invm(ek[eki]);
    eki += 1;
    t2 = -ek[eki];
    eki += 1;
    t3 = -ek[eki];
    eki += 1;
    dki -= 1;
    dk[dki] = invm(ek[eki]);
    dki -= 1;
    dk[dki] = t3;
    dki -= 1;
    dk[dki] = t2;
    dki -= 1;
    dk[dki] = t1;

    return dk;
  }

  crypt(input, ipos, output, opos, key) {
    let x1 = readU16(input, ipos + 0);
    let x2 = readU16(input, ipos + 2);
    let x3 = readU16(input, ipos + 4);
    let x4 = readU16(input, ipos + 6);
    let s2 = 0;
    let s3 = 0;
    let p = 0;

    for (let r = ROUNDS; r > 0; r--) {
      x1 = mul(x1, key[p]);
      p += 1;
      x2 += key[p];
      p += 1;
      x3 += key[p];
      p += 1;

      x4 = mul(x4, key[p]);
      p += 1;

      s3 = x3;
      x3 ^= x1;
      x3 = mul(x3, key[p]);
      p += 1;
      s2 = x2;

      x2 ^= x4;
      x2 += x3;
      x2 = mul(x2, key[p]);
      p += 1;
      x3 += x2;

      x1 ^= x2;
      x4 ^= x3;

      x2 ^= s3;
      x3 ^= s2;
    }

    x1 = mul(x1, key[p]);
    p += 1;

    x3 += key[p];
    p += 1;
    x2 += key[p];
    p += 1;
    x4 = mul(x4, key[p]);

    writeU16(output, x1, opos + 0);
    writeU16(output, x3, opos + 2);
    writeU16(output, x2, opos + 4);
    writeU16(output, x4, opos + 6);
  }
}

/*
 * Helpers
 */

function invm(x) {
  x &= 0xffff;

  if (x <= 1)
    return x;

  let t1 = (0x10001 / x) & 0xffff;
  let y = 0x10001 % x;

  if (y === 1)
    return (1 - t1) & 0xffff;

  let t0 = 1;
  let q = 0;

  while (y !== 1) {
    q = (x / y) & 0xffff;
    x %= y;

    t0 += q * t1;
    t0 &= 0xffff;

    if (x === 1)
      return t0;

    q = (y / x) & 0xffff;
    y %= x;
    t1 += q * t0;
    t1 &= 0xffff;
  }

  return (1 - t1) & 0xffff;
}

function mul(x, y) {
  x &= 0xffff;
  y &= 0xffff;

  if (y === 0)
    return (1 - x) & 0xffff;

  if (x === 0)
    return (1 - y) & 0xffff;

  const t32 = (x * y) >>> 0;

  x = t32 & 0xffff;
  y = t32 >>> 16;

  if (x < y)
    return (x - y + 1) & 0xffff;

  return (x - y) & 0xffff;
}

function readU16(data, pos) {
  return data[pos++] * 0x100 + data[pos];
}

function writeU16(data, value, pos) {
  data[pos++] = value >>> 8;
  data[pos++] = value;
  return pos;
}

/*
 * Expose
 */

module.exports = IDEA;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],99:[function(req,module,exports){
(function (Buffer){
/*!
 * modes.js - cipher modes for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
 */

'use strict';

const assert = req('bsert');
const gcm = req('./gcm');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const ZERO16 = Buffer.alloc(16, 0x00);

/**
 * Cipher
 */

class Cipher {
  constructor(ctx, padding = false) {
    assert(ctx && typeof ctx.encrypt === 'function');
    assert(typeof ctx.blockSize === 'number');
    assert(typeof padding === 'boolean');

    this.ctx = ctx;
    this.padding = padding;
    this.block = Buffer.allocUnsafe(ctx.blockSize);
    this.bpos = -1;
    this.lsize = 0;
    this.last = EMPTY;

    if (padding)
      this.last = Buffer.alloc(ctx.blockSize, 0x00);
  }

  get blockSize() {
    return this.block.length;
  }

  init(key, iv) {
    if (iv == null)
      iv = EMPTY;

    assert(Buffer.isBuffer(key));
    assert(Buffer.isBuffer(iv));

    this.ctx.init(key);
    this.bpos = 0;
    this.lsize = 0;
    this.last.fill(0x00);
    this._init(key, iv);

    return this;
  }

  update(input) {
    assert(Buffer.isBuffer(input));

    if (this.bpos === -1)
      throw new Error('Cipher not initialized.');

    const bs = this.block.length;

    let bpos = this.bpos;
    let ilen = input.length;
    let olen = ilen - (ilen % bs);
    let ipos = 0;
    let opos = 0;

    this.bpos = (this.bpos + ilen) % bs;

    if (bpos > 0) {
      let want = bs - bpos;

      if (want > ilen)
        want = ilen;

      input.copy(this.block, bpos, ipos, ipos + want);

      bpos += want;
      ilen -= want;
      ipos += want;

      if (bpos < bs)
        return EMPTY;

      olen += bs;
    }

    olen += this.lsize;

    const output = Buffer.allocUnsafe(olen);

    if (this.lsize > 0)
      opos += this.last.copy(output, opos, 0, this.lsize);

    if (ipos) {
      this._update(this.block, 0, output, opos);
      opos += bs;
    }

    while (ilen >= bs) {
      this._update(input, ipos, output, opos);
      opos += bs;
      ipos += bs;
      ilen -= bs;
    }

    if (ilen > 0)
      input.copy(this.block, 0, ipos, ipos + ilen);

    if (this.padding) {
      if (olen > 0) {
        this.lsize = output.copy(this.last, 0, olen - bs, olen);
        return output.slice(0, olen - bs);
      }

      this.lsize = 0;
      this.last.fill(0x00);
    }

    return output;
  }

  final() {
    if (this.bpos === -1)
      throw new Error('Cipher not initialized.');

    let ret;
    try {
      ret = this._final();
    } finally {
      this.ctx.destroy();
      this.block.fill(0x00);
      this.bpos = -1;
      this.lsize = 0;
      this.last.fill(0x00);
    }

    return ret;
  }

  setAAD(data) {
    throw new Error('Not authenticated.');
  }

  getAuthTag() {
    throw new Error('Not authenticated.');
  }

  setAuthTag(tag) {
    throw new Error('Not authenticated.');
  }

  _init() {
    return this;
  }

  _update() {
    throw new Error('Unimplemented.');
  }

  _final() {
    return EMPTY;
  }
}

/**
 * Block Cipher
 * @extends Cipher
 */

class BlockCipher extends Cipher {
  constructor(ctx, chain = false) {
    assert(typeof chain === 'boolean');

    super(ctx, false);

    this.chain = chain;
    this.prev = EMPTY;
  }

  _init(key, iv) {
    assert(Buffer.isBuffer(iv));

    if (this.chain)
      assert(iv.length === this.blockSize);
    else
      assert(iv.length === 0);

    this.prev = Buffer.from(iv);

    return this;
  }

  _update(input, ipos, output, opos) {
    if (this.chain) {
      const bs = this.blockSize;

      for (let i = 0; i < bs; i++)
        output[opos + i] = input[ipos + i] ^ this.prev[i];

      this.ctx.encrypt(output, opos, output, opos);

      output.copy(this.prev, 0, opos, opos + bs);
    } else {
      this.ctx.encrypt(input, ipos, output, opos);
    }

    return this;
  }

  _final() {
    const bs = this.blockSize;
    const left = bs - this.bpos;
    const block = Buffer.from(this.block);

    block.fill(left, this.bpos, bs);

    this._update(block, 0, block, 0);

    this.prev.fill(0x00);
    this.prev = EMPTY;

    return block;
  }
}

/**
 * Block Decipher
 * @extends Cipher
 */

class BlockDecipher extends Cipher {
  constructor(ctx, chain = false) {
    assert(typeof chain === 'boolean');

    super(ctx, true);

    this.chain = chain;
    this.prev = EMPTY;
  }

  _init(key, iv) {
    assert(Buffer.isBuffer(iv));

    if (this.chain)
      assert(iv.length === this.blockSize);
    else
      assert(iv.length === 0);

    this.prev = Buffer.from(iv);

    return this;
  }

  _update(input, ipos, output, opos) {
    if (this.chain) {
      const bs = this.blockSize;

      this.ctx.decrypt(input, ipos, output, opos);

      for (let i = 0; i < bs; i++)
        output[opos + i] = output[opos + i] ^ this.prev[i];

      input.copy(this.prev, 0, ipos, ipos + bs);
    } else {
      this.ctx.decrypt(input, ipos, output, opos);
    }

    return this;
  }

  _final() {
    const bs = this.blockSize;
    const block = Buffer.from(this.last);

    this.prev.fill(0x00);
    this.prev = EMPTY;

    if (this.bpos !== 0)
      throw new Error('Bad decrypt (trailing bytes).');

    const left = block[block.length - 1];

    if (left === 0 || left > bs)
      throw new Error('Bad decrypt (padding).');

    const end = bs - left;

    for (let i = end; i < block.length; i++) {
      if (block[i] !== left)
        throw new Error('Bad decrypt (padding).');
    }

    return block.slice(0, end);
  }
}

/**
 * ECB Cipher
 * @extends BlockCipher
 */

class ECBCipher extends BlockCipher {
  constructor(ctx) {
    super(ctx, false);
  }
}

/**
 * ECB Decipher
 * @extends BlockDecipher
 */

class ECBDecipher extends BlockDecipher {
  constructor(ctx) {
    super(ctx, false);
  }
}

/**
 * CBC Cipher
 * @extends BlockCipher
 */

class CBCCipher extends BlockCipher {
  constructor(ctx) {
    super(ctx, true);
  }
}

/**
 * CBC Decipher
 * @extends BlockDecipher
 */

class CBCDecipher extends BlockDecipher {
  constructor(ctx) {
    super(ctx, true);
  }
}

/**
 * CTR
 * @extends Cipher
 */

class CTR extends Cipher {
  constructor(ctx) {
    super(ctx, false);

    this.state = EMPTY;
    this.ctr = EMPTY;
  }

  _init(key, iv) {
    assert(Buffer.isBuffer(iv));
    assert(iv.length === this.blockSize);

    this.state = Buffer.allocUnsafe(this.blockSize);
    this.ctr = Buffer.from(iv);

    return this;
  }

  _increment() {
    for (let i = this.ctr.length - 1; i >= 0; i--) {
      this.ctr[i] += 1;
      if (this.ctr[i] !== 0x00)
        break;
    }
  }

  _update(input, ipos, output, opos) {
    const bs = this.blockSize;

    this.ctx.encrypt(this.ctr, 0, this.state, 0);
    this._increment();

    for (let i = 0; i < bs; i++)
      output[opos + i] = input[ipos + i] ^ this.state[i];

    return this;
  }

  _final() {
    this.ctx.encrypt(this.ctr, 0, this.state, 0);

    const out = Buffer.allocUnsafe(this.bpos);

    for (let i = 0; i < this.bpos; i++)
      out[i] = this.block[i] ^ this.state[i];

    this.state.fill(0x00);
    this.ctr.fill(0x00);
    this.state = EMPTY;
    this.ctr = EMPTY;

    return out;
  }
}

/**
 * CTR Cipher
 * @extends CTR
 */

class CTRCipher extends CTR {
  constructor(ctx) {
    super(ctx);
  }
}

/**
 * CTR Decipher
 * @extends CTR
 */

class CTRDecipher extends CTR {
  constructor(ctx) {
    super(ctx);
  }
}

/**
 * CFB
 * @extends Cipher
 */

class CFB extends Cipher {
  constructor(ctx, encrypt = true) {
    assert(typeof encrypt === 'boolean');

    super(ctx, false);

    this.encrypt = encrypt;
    this.state = EMPTY;
    this.prev = EMPTY;
  }

  _init(key, iv) {
    assert(Buffer.isBuffer(iv));
    assert(iv.length === this.blockSize);

    this.state = Buffer.allocUnsafe(this.blockSize);
    this.prev = Buffer.from(iv);

    return this;
  }

  _update(input, ipos, output, opos) {
    const bs = this.blockSize;

    this.ctx.encrypt(this.prev, 0, this.state, 0);

    for (let i = 0; i < bs; i++)
      output[opos + i] = input[ipos + i] ^ this.state[i];

    if (this.encrypt)
      output.copy(this.prev, 0, opos, opos + bs);
    else
      input.copy(this.prev, 0, ipos, ipos + bs);

    return this;
  }

  _final() {
    this.ctx.encrypt(this.prev, 0, this.state, 0);

    const out = Buffer.allocUnsafe(this.bpos);

    for (let i = 0; i < this.bpos; i++)
      out[i] = this.block[i] ^ this.state[i];

    this.state.fill(0x00);
    this.state = EMPTY;
    this.prev.fill(0x00);
    this.prev = EMPTY;

    return out;
  }
}

/**
 * CFB Cipher
 * @extends CFB
 */

class CFBCipher extends CFB {
  constructor(ctx) {
    super(ctx, true);
  }
}

/**
 * CFB Decipher
 * @extends CFB
 */

class CFBDecipher extends CFB {
  constructor(ctx) {
    super(ctx, false);
  }
}

/**
 * OFB
 * @extends Cipher
 */

class OFB extends Cipher {
  constructor(ctx) {
    super(ctx, false);

    this.state = EMPTY;
  }

  _init(key, iv) {
    assert(Buffer.isBuffer(iv));
    assert(iv.length === this.blockSize);

    this.state = Buffer.from(iv);

    return this;
  }

  _update(input, ipos, output, opos) {
    const bs = this.blockSize;

    this.ctx.encrypt(this.state, 0, this.state, 0);

    for (let i = 0; i < bs; i++)
      output[opos + i] = input[ipos + i] ^ this.state[i];

    return this;
  }

  _final() {
    this.ctx.encrypt(this.state, 0, this.state, 0);

    const out = Buffer.allocUnsafe(this.bpos);

    for (let i = 0; i < this.bpos; i++)
      out[i] = this.block[i] ^ this.state[i];

    this.state.fill(0x00);
    this.state = EMPTY;

    return out;
  }
}

/**
 * OFB Cipher
 * @extends OFB
 */

class OFBCipher extends OFB {
  constructor(ctx) {
    super(ctx);
  }
}

/**
 * OFB Decipher
 * @extends OFB
 */

class OFBDecipher extends OFB {
  constructor(ctx) {
    super(ctx);
  }
}

/**
 * GCM
 * @extends Cipher
 */

class GCM {
  constructor(ctx, encrypt) {
    this.aead = new gcm.GCM(ctx);
    this.encrypt = encrypt;
    this.tag = ZERO16;
    this.mac = ZERO16;
  }

  get blockSize() {
    return 16;
  }

  init(key, iv) {
    this.aead.init(key, iv);
    this.tag = ZERO16;
    this.mac = ZERO16;
    return this;
  }

  update(input) {
    assert(Buffer.isBuffer(input));

    const out = Buffer.allocUnsafe(input.length);
    input.copy(out, 0);

    if (this.encrypt)
      this.aead.encrypt(out);
    else
      this.aead.decrypt(out);

    return out;
  }

  final() {
    this.mac = this.aead.final(this.tag.length);

    if (!this.encrypt) {
      if (!gcm.GCM.verify(this.tag, this.mac))
        throw new Error('Invalid decryption tag.');
    }

    return EMPTY;
  }

  setAAD(data) {
    this.aead.aad(data);
    return this;
  }

  getAuthTag() {
    assert(this.encrypt);
    return this.mac;
  }

  setAuthTag(tag) {
    assert(!this.encrypt);
    assert(Buffer.isBuffer(tag));
    const t = tag.length;
    assert(t === 4 || t === 8 || (t >= 12 && t <= 16));
    this.tag = tag;
    return this;
  }
}

/**
 * GCM Cipher
 * @extends GCM
 */

class GCMCipher extends GCM {
  constructor(ctx) {
    super(ctx, true);
  }
}

/**
 * GCM Decipher
 * @extends GCM
 */

class GCMDecipher extends GCM {
  constructor(ctx) {
    super(ctx, false);
  }
}

/*
 * Helpers
 */

function get(name, encrypt = true) {
  assert(typeof name === 'string');
  assert(typeof encrypt === 'boolean');

  switch (name) {
    case 'ECB':
      return encrypt ? ECBCipher : ECBDecipher;
    case 'CBC':
      return encrypt ? CBCCipher : CBCDecipher;
    case 'CTR':
      return encrypt ? CTRCipher : CTRDecipher;
    case 'CFB':
      return encrypt ? CFBCipher : CFBDecipher;
    case 'OFB':
      return encrypt ? OFBCipher : OFBDecipher;
    case 'GCM':
      return encrypt ? GCMCipher : GCMDecipher;
    default:
      throw new Error(`Unknown mode: ${name}.`);
  }
}

/*
 * Expose
 */

exports.Cipher = Cipher;
exports.BlockCipher = BlockCipher;
exports.BlockDecipher = BlockDecipher;
exports.ECBCipher = ECBCipher;
exports.ECBDecipher = ECBDecipher;
exports.CBCCipher = CBCCipher;
exports.CBCDecipher = CBCDecipher;
exports.CTR = CTR;
exports.CTRCipher = CTRCipher;
exports.CTRDecipher = CTRDecipher;
exports.CFB = CFB;
exports.CFBCipher = CFBCipher;
exports.CFBDecipher = CFBDecipher;
exports.OFB = OFB;
exports.OFBCipher = OFBCipher;
exports.OFBDecipher = OFBDecipher;
exports.GCM = GCM;
exports.GCMCipher = GCMCipher;
exports.GCMDecipher = GCMDecipher;
exports.get = get;

}).call(this,req("buffer").Buffer)
},{"./gcm":97,"bsert":190,"buffer":303}],100:[function(req,module,exports){
(function (Buffer){
/*!
 * rc2.js - RC2 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RC2
 *   https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go
 *   https://en.wikipedia.org/wiki/RC2
 *   https://www.ietf.org/rfc/rfc2268.txt
 *   http://people.csail.mit.edu/rivest/pubs/KRRR98.pdf
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const PI = new Uint8Array([
  0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed,
  0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,
  0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e,
  0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,
  0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13,
  0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,
  0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b,
  0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,
  0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c,
  0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,
  0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1,
  0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,
  0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57,
  0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,
  0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7,
  0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,
  0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7,
  0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,
  0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74,
  0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,
  0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc,
  0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,
  0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a,
  0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,
  0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae,
  0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,
  0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c,
  0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,
  0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0,
  0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,
  0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77,
  0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad
]);

/**
 * RC2
 */

class RC2 {
  constructor() {
    this.k = new Uint16Array(64);
    this.r = new Uint16Array(4);
  }

  get blockSize() {
    return 8;
  }

  init(key) {
    assert(Buffer.isBuffer(key));
    assert(key.length >= 1 && key.length <= 128);
    this.expandKey(key, key.length * 8);
    return this;
  }

  expandKey(key, bits) {
    const L = Buffer.alloc(128, 0x00);

    key.copy(L, 0);

    const t = key.length;
    const t1 = bits;
    const t8 = (t1 + 7) >>> 3;
    const tm = 255 % (1 << (8 + t1 - 8 * t8));

    for (let i = key.length; i < 128; i++)
      L[i] = PI[(L[i - 1] + L[(i - t) & 0xff]) & 0xff];

    L[128 - t8] = PI[L[128 - t8] & tm];

    for (let i = 127 - t8; i >= 0; i--)
      L[i] = PI[L[i + 1] ^ L[i + t8]];

    for (let i = 0; i < 64; i++)
      this.k[i] = L[2 * i] + L[2 * i + 1] * 256;

    return this;
  }

  encrypt(input, ipos, output, opos) {
    const r = this.r;

    r[0] = readU16(input, ipos + 0);
    r[1] = readU16(input, ipos + 2);
    r[2] = readU16(input, ipos + 4);
    r[3] = readU16(input, ipos + 6);

    let j = 0;

    while (j <= 16) {
      // mix r[0]
      r[0] += this.k[j];
      r[0] += r[3] & r[2];
      r[0] += ~r[3] & r[1];
      r[0] = rotl16(r[0], 1);
      j += 1;

      // mix r[1]
      r[1] += this.k[j];
      r[1] += r[0] & r[3];
      r[1] += ~r[0] & r[2];
      r[1] = rotl16(r[1], 2);
      j += 1;

      // mix r[2]
      r[2] += this.k[j];
      r[2] += r[1] & r[0];
      r[2] += ~r[1] & r[3];
      r[2] = rotl16(r[2], 3);
      j += 1;

      // mix r[3]
      r[3] += this.k[j];
      r[3] += r[2] & r[1];
      r[3] += ~r[2] & r[0];
      r[3] = rotl16(r[3], 5);
      j += 1;
    };

    r[0] += this.k[r[3] & 63];
    r[1] += this.k[r[0] & 63];
    r[2] += this.k[r[1] & 63];
    r[3] += this.k[r[2] & 63];

    while (j <= 40) {
      // mix r[0]
      r[0] += this.k[j];
      r[0] += r[3] & r[2];
      r[0] += ~r[3] & r[1];
      r[0] = rotl16(r[0], 1);
      j += 1;

      // mix r[1]
      r[1] += this.k[j];
      r[1] += r[0] & r[3];
      r[1] += ~r[0] & r[2];
      r[1] = rotl16(r[1], 2);
      j += 1;

      // mix r[2]
      r[2] += this.k[j];
      r[2] += r[1] & r[0];
      r[2] += ~r[1] & r[3];
      r[2] = rotl16(r[2], 3);
      j += 1;

      // mix r[3]
      r[3] += this.k[j];
      r[3] += r[2] & r[1];
      r[3] += ~r[2] & r[0];
      r[3] = rotl16(r[3], 5);
      j += 1;
    }

    r[0] += this.k[r[3] & 63];
    r[1] += this.k[r[0] & 63];
    r[2] += this.k[r[1] & 63];
    r[3] += this.k[r[2] & 63];

    while (j <= 60) {
      // mix r[0]
      r[0] += this.k[j];
      r[0] += r[3] & r[2];
      r[0] += ~r[3] & r[1];
      r[0] = rotl16(r[0], 1);
      j += 1;

      // mix r[1]
      r[1] += this.k[j];
      r[1] += r[0] & r[3];
      r[1] += ~r[0] & r[2];
      r[1] = rotl16(r[1], 2);
      j += 1;

      // mix r[2]
      r[2] += this.k[j];
      r[2] += r[1] & r[0];
      r[2] += ~r[1] & r[3];
      r[2] = rotl16(r[2], 3);
      j += 1;

      // mix r[3]
      r[3] += this.k[j];
      r[3] += r[2] & r[1];
      r[3] += ~r[2] & r[0];
      r[3] = rotl16(r[3], 5);
      j += 1;
    }

    writeU16(output, r[0], opos + 0);
    writeU16(output, r[1], opos + 2);
    writeU16(output, r[2], opos + 4);
    writeU16(output, r[3], opos + 6);
  }

  decrypt(input, ipos, output, opos) {
    const r = this.r;

    r[0] = readU16(input, ipos + 0);
    r[1] = readU16(input, ipos + 2);
    r[2] = readU16(input, ipos + 4);
    r[3] = readU16(input, ipos + 6);

    let j = 63;

    while (j >= 44) {
      // unmix r[3]
      r[3] = rotl16(r[3], 16 - 5);
      r[3] -= this.k[j];
      r[3] -= r[2] & r[1];
      r[3] -= ~r[2] & r[0];
      j -= 1;

      // unmix r[2]
      r[2] = rotl16(r[2], 16 - 3);
      r[2] -= this.k[j];
      r[2] -= r[1] & r[0];
      r[2] -= ~r[1] & r[3];
      j -= 1;

      // unmix r[1]
      r[1] = rotl16(r[1], 16 - 2);
      r[1] -= this.k[j];
      r[1] -= r[0] & r[3];
      r[1] -= ~r[0] & r[2];
      j -= 1;

      // unmix r[0]
      r[0] = rotl16(r[0], 16 - 1);
      r[0] -= this.k[j];
      r[0] -= r[3] & r[2];
      r[0] -= ~r[3] & r[1];
      j -= 1;
    }

    r[3] -= this.k[r[2] & 63];
    r[2] -= this.k[r[1] & 63];
    r[1] -= this.k[r[0] & 63];
    r[0] -= this.k[r[3] & 63];

    while (j >= 20) {
      // unmix r[3]
      r[3] = rotl16(r[3], 16 - 5);
      r[3] -= this.k[j];
      r[3] -= r[2] & r[1];
      r[3] -= ~r[2] & r[0];
      j -= 1;

      // unmix r[2]
      r[2] = rotl16(r[2], 16 - 3);
      r[2] -= this.k[j];
      r[2] -= r[1] & r[0];
      r[2] -= ~r[1] & r[3];
      j -= 1;

      // unmix r[1]
      r[1] = rotl16(r[1], 16 - 2);
      r[1] -= this.k[j];
      r[1] -= r[0] & r[3];
      r[1] -= ~r[0] & r[2];
      j -= 1;

      // unmix r[0]
      r[0] = rotl16(r[0], 16 - 1);
      r[0] -= this.k[j];
      r[0] -= r[3] & r[2];
      r[0] -= ~r[3] & r[1];
      j -= 1;
    }

    r[3] -= this.k[r[2] & 63];
    r[2] -= this.k[r[1] & 63];
    r[1] -= this.k[r[0] & 63];
    r[0] -= this.k[r[3] & 63];

    while (j >= 0) {
      // unmix r[3]
      r[3] = rotl16(r[3], 16 - 5);
      r[3] -= this.k[j];
      r[3] -= r[2] & r[1];
      r[3] -= ~r[2] & r[0];
      j -= 1;

      // unmix r[2]
      r[2] = rotl16(r[2], 16 - 3);
      r[2] -= this.k[j];
      r[2] -= r[1] & r[0];
      r[2] -= ~r[1] & r[3];
      j -= 1;

      // unmix r[1]
      r[1] = rotl16(r[1], 16 - 2);
      r[1] -= this.k[j];
      r[1] -= r[0] & r[3];
      r[1] -= ~r[0] & r[2];
      j -= 1;

      // unmix r[0]
      r[0] = rotl16(r[0], 16 - 1);
      r[0] -= this.k[j];
      r[0] -= r[3] & r[2];
      r[0] -= ~r[3] & r[1];
      j -= 1;
    }

    writeU16(output, r[0], opos + 0);
    writeU16(output, r[1], opos + 2);
    writeU16(output, r[2], opos + 4);
    writeU16(output, r[3], opos + 6);
  }

  destroy() {
    for (let i = 0; i < 64; i++)
      this.k[i] = 0;

    for (let i = 0; i < 4; i++)
      this.r[i] = 0;

    return this;
  }
}

/*
 * Helpers
 */

function rotl16(x, b) {
  return (x >>> (16 - b)) | (x << b);
}

function readU16(data, pos) {
  return data[pos++] + data[pos] * 0x100;
}

function writeU16(data, value, pos) {
  data[pos++] = value;
  data[pos++] = value >>> 8;
  return pos;
}

/*
 * Expose
 */

module.exports = RC2;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],101:[function(req,module,exports){
(function (Buffer){
/*!
 * twofish.js - twofish for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Twofish
 *   https://www.schneier.com/academic/twofish/
 *   https://github.com/golang/crypto/blob/master/twofish/twofish.go
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const BLOCK_SIZE = 16;
const MDS_POLY = 0x169; // x^8 + x^6 + x^5 + x^3 + 1
const RS_POLY = 0x14d; // x^8 + x^6 + x^3 + x^2 + 1

const RS = [
  new Uint8Array([0x01, 0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e]),
  new Uint8Array([0xa4, 0x56, 0x82, 0xf3, 0x1e, 0xc6, 0x68, 0xe5]),
  new Uint8Array([0x02, 0xa1, 0xfc, 0xc1, 0x47, 0xae, 0x3d, 0x19]),
  new Uint8Array([0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e, 0x03])
];

const S0 = new Uint8Array([
  0xa9, 0x67, 0xb3, 0xe8, 0x04, 0xfd, 0xa3, 0x76,
  0x9a, 0x92, 0x80, 0x78, 0xe4, 0xdd, 0xd1, 0x38,
  0x0d, 0xc6, 0x35, 0x98, 0x18, 0xf7, 0xec, 0x6c,
  0x43, 0x75, 0x37, 0x26, 0xfa, 0x13, 0x94, 0x48,
  0xf2, 0xd0, 0x8b, 0x30, 0x84, 0x54, 0xdf, 0x23,
  0x19, 0x5b, 0x3d, 0x59, 0xf3, 0xae, 0xa2, 0x82,
  0x63, 0x01, 0x83, 0x2e, 0xd9, 0x51, 0x9b, 0x7c,
  0xa6, 0xeb, 0xa5, 0xbe, 0x16, 0x0c, 0xe3, 0x61,
  0xc0, 0x8c, 0x3a, 0xf5, 0x73, 0x2c, 0x25, 0x0b,
  0xbb, 0x4e, 0x89, 0x6b, 0x53, 0x6a, 0xb4, 0xf1,
  0xe1, 0xe6, 0xbd, 0x45, 0xe2, 0xf4, 0xb6, 0x66,
  0xcc, 0x95, 0x03, 0x56, 0xd4, 0x1c, 0x1e, 0xd7,
  0xfb, 0xc3, 0x8e, 0xb5, 0xe9, 0xcf, 0xbf, 0xba,
  0xea, 0x77, 0x39, 0xaf, 0x33, 0xc9, 0x62, 0x71,
  0x81, 0x79, 0x09, 0xad, 0x24, 0xcd, 0xf9, 0xd8,
  0xe5, 0xc5, 0xb9, 0x4d, 0x44, 0x08, 0x86, 0xe7,
  0xa1, 0x1d, 0xaa, 0xed, 0x06, 0x70, 0xb2, 0xd2,
  0x41, 0x7b, 0xa0, 0x11, 0x31, 0xc2, 0x27, 0x90,
  0x20, 0xf6, 0x60, 0xff, 0x96, 0x5c, 0xb1, 0xab,
  0x9e, 0x9c, 0x52, 0x1b, 0x5f, 0x93, 0x0a, 0xef,
  0x91, 0x85, 0x49, 0xee, 0x2d, 0x4f, 0x8f, 0x3b,
  0x47, 0x87, 0x6d, 0x46, 0xd6, 0x3e, 0x69, 0x64,
  0x2a, 0xce, 0xcb, 0x2f, 0xfc, 0x97, 0x05, 0x7a,
  0xac, 0x7f, 0xd5, 0x1a, 0x4b, 0x0e, 0xa7, 0x5a,
  0x28, 0x14, 0x3f, 0x29, 0x88, 0x3c, 0x4c, 0x02,
  0xb8, 0xda, 0xb0, 0x17, 0x55, 0x1f, 0x8a, 0x7d,
  0x57, 0xc7, 0x8d, 0x74, 0xb7, 0xc4, 0x9f, 0x72,
  0x7e, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34,
  0x6e, 0x50, 0xde, 0x68, 0x65, 0xbc, 0xdb, 0xf8,
  0xc8, 0xa8, 0x2b, 0x40, 0xdc, 0xfe, 0x32, 0xa4,
  0xca, 0x10, 0x21, 0xf0, 0xd3, 0x5d, 0x0f, 0x00,
  0x6f, 0x9d, 0x36, 0x42, 0x4a, 0x5e, 0xc1, 0xe0
]);

const S1 = new Uint8Array([
  0x75, 0xf3, 0xc6, 0xf4, 0xdb, 0x7b, 0xfb, 0xc8,
  0x4a, 0xd3, 0xe6, 0x6b, 0x45, 0x7d, 0xe8, 0x4b,
  0xd6, 0x32, 0xd8, 0xfd, 0x37, 0x71, 0xf1, 0xe1,
  0x30, 0x0f, 0xf8, 0x1b, 0x87, 0xfa, 0x06, 0x3f,
  0x5e, 0xba, 0xae, 0x5b, 0x8a, 0x00, 0xbc, 0x9d,
  0x6d, 0xc1, 0xb1, 0x0e, 0x80, 0x5d, 0xd2, 0xd5,
  0xa0, 0x84, 0x07, 0x14, 0xb5, 0x90, 0x2c, 0xa3,
  0xb2, 0x73, 0x4c, 0x54, 0x92, 0x74, 0x36, 0x51,
  0x38, 0xb0, 0xbd, 0x5a, 0xfc, 0x60, 0x62, 0x96,
  0x6c, 0x42, 0xf7, 0x10, 0x7c, 0x28, 0x27, 0x8c,
  0x13, 0x95, 0x9c, 0xc7, 0x24, 0x46, 0x3b, 0x70,
  0xca, 0xe3, 0x85, 0xcb, 0x11, 0xd0, 0x93, 0xb8,
  0xa6, 0x83, 0x20, 0xff, 0x9f, 0x77, 0xc3, 0xcc,
  0x03, 0x6f, 0x08, 0xbf, 0x40, 0xe7, 0x2b, 0xe2,
  0x79, 0x0c, 0xaa, 0x82, 0x41, 0x3a, 0xea, 0xb9,
  0xe4, 0x9a, 0xa4, 0x97, 0x7e, 0xda, 0x7a, 0x17,
  0x66, 0x94, 0xa1, 0x1d, 0x3d, 0xf0, 0xde, 0xb3,
  0x0b, 0x72, 0xa7, 0x1c, 0xef, 0xd1, 0x53, 0x3e,
  0x8f, 0x33, 0x26, 0x5f, 0xec, 0x76, 0x2a, 0x49,
  0x81, 0x88, 0xee, 0x21, 0xc4, 0x1a, 0xeb, 0xd9,
  0xc5, 0x39, 0x99, 0xcd, 0xad, 0x31, 0x8b, 0x01,
  0x18, 0x23, 0xdd, 0x1f, 0x4e, 0x2d, 0xf9, 0x48,
  0x4f, 0xf2, 0x65, 0x8e, 0x78, 0x5c, 0x58, 0x19,
  0x8d, 0xe5, 0x98, 0x57, 0x67, 0x7f, 0x05, 0x64,
  0xaf, 0x63, 0xb6, 0xfe, 0xf5, 0xb7, 0x3c, 0xa5,
  0xce, 0xe9, 0x68, 0x44, 0xe0, 0x4d, 0x43, 0x69,
  0x29, 0x2e, 0xac, 0x15, 0x59, 0xa8, 0x0a, 0x9e,
  0x6e, 0x47, 0xdf, 0x34, 0x35, 0x6a, 0xcf, 0xdc,
  0x22, 0xc9, 0xc0, 0x9b, 0x89, 0xd4, 0xed, 0xab,
  0x12, 0xa2, 0x0d, 0x52, 0xbb, 0x02, 0x2f, 0xa9,
  0xd7, 0x61, 0x1e, 0xb4, 0x50, 0x04, 0xf6, 0xc2,
  0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xbe, 0x91
]);

/**
 * Twofish
 */

class Twofish {
  constructor(bits = 256) {
    assert((bits >>> 0) === bits);
    assert(bits === 128 || bits === 192 || bits === 256);

    this.bits = bits;

    this.S = [
      new Uint32Array(256),
      new Uint32Array(256),
      new Uint32Array(256),
      new Uint32Array(256)
    ];

    this.k = new Uint32Array(40);
  }

  get blockSize() {
    return BLOCK_SIZE;
  }

  init(key) {
    assert(Buffer.isBuffer(key));

    const keylen = key.length;

    if (keylen !== 16 && keylen !== 24 && keylen !== 32)
      throw new Error('Invalid key size.');

    if (keylen !== (this.bits >>> 3))
      throw new Error('Invalid key size.');

    // k is the number of 64 bit words in key.
    const k = keylen >>> 3;

    // Create the S[..] words.
    const W = new Uint8Array(4 * 4);

    for (let i = 0; i < k; i++) {
      // Computes [y0 y1 y2 y3] = rs . [x0 x1 x2 x3 x4 x5 x6 x7].
      for (let j = 0; j < 4; j++) {
        const row = RS[j];
        for (let k = 0; k < 8; k++)
          W[4 * i + j] ^= gf(key[8 * i + k], row[k], RS_POLY);
      }
    }

    // Calculate subkeys.
    const tmp = new Uint8Array(4);

    for (let i = 0; i < 20; i++) {
      // A = h(p * 2x, Me)
      for (let j = 0; j < 4; j++)
        tmp[j] = 2 * i;

      const A = h(tmp, key, 0);

      // B = rolc(h(p * (2x + 1), Mo), 8)
      for (let j = 0; j < 4; j++)
        tmp[j] = 2 * i + 1;

      const B = rol32(h(tmp, key, 1), 8);

      this.k[2 * i] = A + B;

      // K[2i+1] = (A + 2B) <<< 9
      this.k[2 * i + 1] = rol32(2 * B + A, 9);
    }

    // Calculate sboxes.
    switch (k) {
      case 2:
        for (let i = 0; i < 256; i++) {
          this.S[0][i] = mds(S1[S0[S0[i] ^ W[0]] ^ W[4]], 0);
          this.S[1][i] = mds(S0[S0[S1[i] ^ W[1]] ^ W[5]], 1);
          this.S[2][i] = mds(S1[S1[S0[i] ^ W[2]] ^ W[6]], 2);
          this.S[3][i] = mds(S0[S1[S1[i] ^ W[3]] ^ W[7]], 3);
        }
        break;
      case 3:
        for (let i = 0; i < 256; i++) {
          this.S[0][i] = mds(S1[S0[S0[S1[i] ^ W[0]] ^ W[4]] ^ W[8]], 0);
          this.S[1][i] = mds(S0[S0[S1[S1[i] ^ W[1]] ^ W[5]] ^ W[9]], 1);
          this.S[2][i] = mds(S1[S1[S0[S0[i] ^ W[2]] ^ W[6]] ^ W[10]], 2);
          this.S[3][i] = mds(S0[S1[S1[S0[i] ^ W[3]] ^ W[7]] ^ W[11]], 3);
        }
        break;
      case 4:
        for (let i = 0; i < 256; i++) {
          this.S[0][i] =
            mds(S1[S0[S0[S1[S1[i] ^ W[0]] ^ W[4]] ^ W[8]] ^ W[12]], 0);
          this.S[1][i] =
            mds(S0[S0[S1[S1[S0[i] ^ W[1]] ^ W[5]] ^ W[9]] ^ W[13]], 1);
          this.S[2][i] =
            mds(S1[S1[S0[S0[S0[i] ^ W[2]] ^ W[6]] ^ W[10]] ^ W[14]], 2);
          this.S[3][i] =
            mds(S0[S1[S1[S0[S1[i] ^ W[3]] ^ W[7]] ^ W[11]] ^ W[15]], 3);
        }
        break;
      default:
        throw new Error('unreachable');
    }

    return this;
  }

  encrypt(input, ipos, output, opos) {
    const S0 = this.S[0];
    const S1 = this.S[1];
    const S2 = this.S[2];
    const S3 = this.S[3];

    // Load input.
    let ia = readU32(input, ipos + 0);
    let ib = readU32(input, ipos + 4);
    let ic = readU32(input, ipos + 8);
    let id = readU32(input, ipos + 12);
    let t1, t2;

    // Pre-whitening.
    ia ^= this.k[0];
    ib ^= this.k[1];
    ic ^= this.k[2];
    id ^= this.k[3];

    for (let i = 0; i < 8; i++) {
      const k = this.k.subarray(8 + i * 4, 12 + i * 4);

      t2 = S1[ib & 0xff]
         ^ S2[(ib >>> 8) & 0xff]
         ^ S3[(ib >>> 16) & 0xff]
         ^ S0[(ib >>> 24) & 0xff];

      t1 = ((S0[ia & 0xff]
         ^ S1[(ia >>> 8) & 0xff]
         ^ S2[(ia >>> 16) & 0xff]
         ^ S3[(ia >>> 24) & 0xff])
         + t2);

      ic = ror32(ic ^ (t1 + k[0]), 1);
      id = rol32(id, 1) ^ (t2 + t1 + k[1]);

      t2 = S1[id & 0xff]
         ^ S2[(id >>> 8) & 0xff]
         ^ S3[(id >>> 16) & 0xff]
         ^ S0[(id >>> 24) & 0xff];

      t1 = ((S0[ic & 0xff]
         ^ S1[(ic >>> 8) & 0xff]
         ^ S2[(ic >>> 16) & 0xff]
         ^ S3[(ic >>> 24) & 0xff])
         + t2);

      ia = ror32(ia ^ (t1 + k[2]), 1);
      ib = rol32(ib, 1) ^ (t2 + t1 + k[3]);
    }

    // Output with "undo last swap".
    const ta = ic ^ this.k[4];
    const tb = id ^ this.k[5];
    const tc = ia ^ this.k[6];
    const td = ib ^ this.k[7];

    writeU32(output, ta, opos + 0);
    writeU32(output, tb, opos + 4);
    writeU32(output, tc, opos + 8);
    writeU32(output, td, opos + 12);

    return this;
  }

  decrypt(input, ipos, output, opos) {
    const S0 = this.S[0];
    const S1 = this.S[1];
    const S2 = this.S[2];
    const S3 = this.S[3];

    // Load input.
    const ta = readU32(input, ipos + 0);
    const tb = readU32(input, ipos + 4);
    const tc = readU32(input, ipos + 8);
    const td = readU32(input, ipos + 12);

    // Undo undo final swap.
    let ia = tc ^ this.k[6];
    let ib = td ^ this.k[7];
    let ic = ta ^ this.k[4];
    let id = tb ^ this.k[5];
    let t1, t2;

    for (let i = 8; i > 0; i--) {
      const k = this.k.subarray(4 + i * 4, 8 + i * 4);

      t2 = S1[id & 0xff]
         ^ S2[(id >>> 8) & 0xff]
         ^ S3[(id >>> 16) & 0xff]
         ^ S0[(id >>> 24) & 0xff];

      t1 = ((S0[ic & 0xff]
         ^ S1[(ic >>> 8) & 0xff]
         ^ S2[(ic >>> 16) & 0xff]
         ^ S3[(ic >>> 24) & 0xff])
         + t2);

      ia = rol32(ia, 1) ^ (t1 + k[2]);
      ib = ror32(ib ^ (t2 + t1 + k[3]), 1);

      t2 = S1[ib & 0xff]
         ^ S2[(ib >>> 8) & 0xff]
         ^ S3[(ib >>> 16) & 0xff]
         ^ S0[(ib >>> 24) & 0xff];

      t1 = ((S0[ia & 0xff]
         ^ S1[(ia >>> 8) & 0xff]
         ^ S2[(ia >>> 16) & 0xff]
         ^ S3[(ia >>> 24) & 0xff])
         + t2);

      ic = rol32(ic, 1) ^ (t1 + k[0]);
      id = ror32(id ^ (t2 + t1 + k[1]), 1);
    }

    // Undo pre-whitening.
    ia ^= this.k[0];
    ib ^= this.k[1];
    ic ^= this.k[2];
    id ^= this.k[3];

    writeU32(output, ia, opos + 0);
    writeU32(output, ib, opos + 4);
    writeU32(output, ic, opos + 8);
    writeU32(output, id, opos + 12);

    return this;
  }

  destroy() {
    cleanse(this.S[0]);
    cleanse(this.S[1]);
    cleanse(this.S[2]);
    cleanse(this.S[3]);
    cleanse(this.k);
    return this;
  }
}

/*
 * Helpers
 */

function gf(a, b, p) {
  // gfMult = a*b in GF(2^8)/p
  const B = new Uint32Array([0, b & 0xff]);
  const P = new Uint32Array([0, p >>> 0]);

  let res = 0;

  // Branchless GF multiplier.
  for (let i = 0; i < 7; i++) {
    res ^= B[a & 1];
    a >>>= 1;
    B[1] = P[B[1] >>> 7] ^ (B[1] << 1);
  }

  res ^= B[a & 1];

  return res & 0xff;
}

function mds(v, col) {
  // mdsColumnMult = y{col} where [y0 y1 y2 y3] = MDS * [x0]
  const x = v & 0xff;
  const y = gf(v, 0x5b, MDS_POLY);
  const z = gf(v, 0xef, MDS_POLY);

  switch (col) {
    case 0:
      return x | (y << 8) | (z << 16) | (z << 24);
    case 1:
      return z | (z << 8) | (y << 16) | (x << 24);
    case 2:
      return y | (z << 8) | (x << 16) | (z << 24);
    case 3:
      return y | (x << 8) | (z << 16) | (y << 24);
  }

  throw new Error('unreachable');
}

function h(v, key, off) {
  const y = new Uint8Array(4);

  for (let i = 0; i < 4; i++)
    y[i] = v[i];

  const k = key.length >>> 3;

  switch (k) {
    case 4:
      y[0] = S1[y[0]] ^ key[4 * (6 + off) + 0];
      y[1] = S0[y[1]] ^ key[4 * (6 + off) + 1];
      y[2] = S0[y[2]] ^ key[4 * (6 + off) + 2];
      y[3] = S1[y[3]] ^ key[4 * (6 + off) + 3];
      // fallthrough
    case 3:
      y[0] = S1[y[0]] ^ key[4 * (4 + off) + 0];
      y[1] = S1[y[1]] ^ key[4 * (4 + off) + 1];
      y[2] = S0[y[2]] ^ key[4 * (4 + off) + 2];
      y[3] = S0[y[3]] ^ key[4 * (4 + off) + 3];
      // fallthrough
    case 2:
      y[0] = S1[S0[S0[y[0]]
           ^ key[4 * (2 + off) + 0]]
           ^ key[4 * (0 + off) + 0]];
      y[1] = S0[S0[S1[y[1]]
           ^ key[4 * (2 + off) + 1]]
           ^ key[4 * (0 + off) + 1]];
      y[2] = S1[S1[S0[y[2]]
           ^ key[4 * (2 + off) + 2]]
           ^ key[4 * (0 + off) + 2]];
      y[3] = S0[S1[S1[y[3]]
           ^ key[4 * (2 + off) + 3]]
           ^ key[4 * (0 + off) + 3]];
      break;
    default:
      throw new Error('Invalid key size.');
  }

  let mult = 0;

  // [y0 y1 y2 y3] = MDS . [x0 x1 x2 x3]
  for (let i = 0; i < 4; i++)
    mult ^= mds(y[i], i);

  return mult >>> 0;
}

function rol32(x, y) {
  return (x << (y & 31)) | (x >>> (32 - (y & 31)));
}

function ror32(x, y) {
  return (x >>> (y & 31)) | (x << (32 - (y & 31)));
}

function cleanse(arr) {
  for (let i = 0; i < arr.length; i++)
    arr[i] = 0;
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off++] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = Twofish;

}).call(this,{"isBuffer":req("../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],102:[function(req,module,exports){
(function (Buffer){
/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');

/*
 * State
 */

let counter = 0;

/**
 * A maybe-secure memzero.
 * @param {Buffer} data
 */

function cleanse(data) {
  assert(Buffer.isBuffer(data));

  let ctr = counter;

  for (let i = 0; i < data.length; i++) {
    data[i] = ctr & 0xff;
    ctr += i;
  }

  counter = ctr >>> 0;
}

/*
 * Static
 */

cleanse.native = 0;

/*
 * Expose
 */

module.exports = cleanse;

}).call(this,{"isBuffer":req("../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],103:[function(req,module,exports){
(function (Buffer){
/*!
 * curves.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Resources:
 *   https://safecurves.cr.yp.to/
 *   https://hyperelliptic.org/EFD/
 */

'use strict';

const {custom} = req('../internal/custom');
const BN = req('../bn.js');

/*
 * Constants
 */

const types = {
  AFFINE: 0,
  JACOBIAN: 1,
  PROJECTIVE: 2
};

const jsfIndex = [
  -3, // -1 -1
  -1, // -1 0
  -5, // -1 1
  -7, // 0 -1
  0, // 0 0
  7, // 0 1
  5, // 1 -1
  1, // 1 0
  3  // 1 1
];

/**
 * Curve
 */

class Curve {
  constructor(type, conf) {
    this.id = null;
    this.ossl = null;
    this.type = 'base';
    this.endian = 'be';
    this.hash = null;
    this.prefix = null;
    this.context = false;
    this.p = null;
    this.red = null;
    this.fieldSize = 0;
    this.fieldBits = 0;
    this.signBit = 0;
    this.zero = null;
    this.one = null;
    this.two = null;
    this.three = null;
    this.twisted = false;
    this.extended = false;
    this.n = null;
    this.h = null;
    this.g = null;
    this.nh = null;
    this.scalarSize = 0;
    this.scalarBits = 0;
    this.mask = null;
    this.maxwellTrick = false;
    this.redN = null;
    this.blinding = null;
    this.init(type, conf);
  }

  init(type, conf) {
    assert(typeof type === 'string');
    assert(conf && typeof conf === 'object');
    assert(conf.p != null, 'Must pass a prime.');

    // Meta.
    this.id = conf.id || null;
    this.ossl = conf.ossl || null;
    this.type = type;
    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');
    this.hash = conf.hash || null;
    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;
    this.context = conf.context || false;

    // Prime.
    this.p = new BN(conf.p, 16);

    // Use Montgomery, when there is no fast reduction for the prime.
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

    // Precalculate encoding length.
    this.fieldSize = this.p.byteLength();
    this.fieldBits = this.p.bitLength();
    this.signBit = this.fieldSize * 8 - 1;

    // Figure out where the sign bit goes on edwards/mont.
    if (this.p.testn(this.signBit)) {
      // If the hi bit is set on our prime, we need an
      // extra byte to encode the sign bit (a la Ed448).
      if (this.type === 'edwards')
        this.fieldSize += 1;

      // Move the sign bit over.
      if (this.type === 'mont' || this.type === 'edwards')
        this.signBit += 8;
    }

    // Useful for many curves.
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.three = new BN(3).toRed(this.red);

    // Necessary for edwards curves.
    if (this.type === 'edwards' && conf.a != null) {
      const a = new BN(conf.a, 16).toRed(this.red);

      this.twisted = a.cmp(this.one) !== 0;
      this.extended = a.cmp(this.one.redNeg()) === 0;
    }

    // Curve configuration, optional.
    this.n = conf.n ? new BN(conf.n, 16) : new BN(0);
    this.h = conf.h ? new BN(conf.h, 16) : new BN(0);
    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();
    this.nh = this.n.ushrn(1);
    this.scalarSize = this.n.byteLength();
    this.scalarBits = this.n.bitLength();
    this.mask = new Mask(this);

    // Generalized Greg Maxwell's trick.
    this.maxwellTrick = !this.n.isZero() && this.p.div(this.n).cmpn(100) <= 0;
    this.redN = this.n.toRed(this.red);

    // Scalar blinding.
    this.blinding = null;

    return this;
  }

  point() {
    throw new Error('Not implemented.');
  }

  validate() {
    throw new Error('Not implemented.');
  }

  precompute(rng) {
    assert(!this.g.isInfinity(), 'Must have base point.');
    assert(!this.n.isZero(), 'Must have order.');
    this.g.precompute(this.n.bitLength() + 1, rng);
    this.blinding = this._scalarBlinding(rng);
    return this;
  }

  encodeField(num) {
    assert(num instanceof BN);
    assert(!num.red);
    return num.encode(this.endian, this.fieldSize);
  }

  decodeField(bytes) {
    assert(Buffer.isBuffer(bytes));

    if (bytes.length !== this.fieldSize)
      throw new Error('Invalid field element size.');

    return BN.decode(bytes, this.endian);
  }

  encodeScalar(num) {
    assert(num instanceof BN);
    assert(!num.red);
    return num.encode(this.endian, this.scalarSize);
  }

  decodeScalar(bytes) {
    assert(Buffer.isBuffer(bytes));

    if (bytes.length !== this.scalarSize)
      throw new Error('Invalid scalar size.');

    return BN.decode(bytes, this.endian);
  }

  encodePoint(point, compact) {
    assert(point instanceof Point);
    return point.encode(compact);
  }

  decodePoint(bytes) {
    throw new Error('Not implemented.');
  }

  splitHash(bytes) {
    return this.mask.splitHash(bytes);
  }

  clamp(bytes) {
    return this.mask.clamp(bytes);
  }

  isClamped(bytes) {
    return this.mask.isClamped(bytes);
  }

  getBlinding() {
    if (!this.blinding)
      return [new BN(1), new BN(1)];

    return this.blinding;
  }

  _scalarBlinding(rng) {
    if (!rng)
      return null;

    // We blind scalar multiplications too.
    // Our bigint implementation is only
    // constant time for 235-285 bit ints.
    // This is only effective if an attacker
    // is not able to observe the start up.
    for (;;) {
      const blind = BN.random(rng, 1, this.n);

      try {
        return [blind, blind.invert(this.n)];
      } catch (e) {
        continue;
      }
    }
  }

  _simpleMul(p, k, initial, jacobian) {
    assert(p instanceof Point);
    assert(k instanceof BN);
    assert(!k.red);
    assert(initial == null || (initial instanceof Point));
    assert(typeof jacobian === 'boolean');

    const x = k.abs();

    let r = initial || this.jpoint();

    assert(r.type !== types.AFFINE);

    while (!x.isZero()) {
      if (x.isOdd()) {
        if (p.type === types.AFFINE)
          r = r.mixedAdd(p);
        else
          r = r.add(p);
      }

      p = p.dbl();
      x.iushrn(1);
    }

    if (k.sign() < 0)
      r = r.neg();

    if (jacobian)
      return r;

    return p.type === types.AFFINE ? r.toP() : r;
  }

  _fixedNafMul(p, k, initial, jacobian) {
    assert(p instanceof Point);
    assert(k instanceof BN);
    assert(initial == null || (initial instanceof Point));
    assert(typeof jacobian === 'boolean');
    assert(p.precomputed);

    const {step, points} = p._getDoubles(0, 0);
    const naf = getNAF(k, 1, this.n);
    const I = ((1 << (step + 1)) - (step % 2 === 0 ? 2 : 1)) / 3;

    // Translate into more windowed form.
    const repr = [];

    for (let j = 0; j < naf.length; j += step) {
      let nafW = 0;

      for (let k = j + step - 1; k >= j; k--)
        nafW = (nafW << 1) + naf[k];

      repr.push(nafW);
    }

    let a = initial || this.jpoint();
    let b = this.jpoint();

    assert(a.type !== types.AFFINE);

    for (let i = I; i > 0; i--) {
      for (let j = 0; j < repr.length; j++) {
        const nafW = repr[j];

        if (p.type === types.AFFINE) {
          if (nafW === i)
            b = b.mixedAdd(points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(points[j].neg());
        } else {
          if (nafW === i)
            b = b.add(points[j]);
          else if (nafW === -i)
            b = b.add(points[j].neg());
        }
      }

      a = a.add(b);
    }

    if (jacobian)
      return a;

    return p.type === types.AFFINE ? a.toP() : a;
  }

  _wnafMul(p, k, initial, jacobian) {
    assert(p instanceof Point);
    assert(k instanceof BN);
    assert(initial == null || (initial instanceof Point));
    assert(typeof jacobian === 'boolean');

    // Precompute window.
    const nafPoints = p._getNAFPoints(4);
    const w = nafPoints.wnd;
    const wnd = nafPoints.points;

    // Get NAF form.
    const naf = getNAF(k, w, this.n);

    // Add `this`*(N+1) for every w-NAF index.
    let acc = this.jpoint();

    for (let i = naf.length - 1; i >= 0; i--) {
      // Count zeroes.
      let k = 0;

      for (; i >= 0 && naf[i] === 0; i--)
        k += 1;

      if (i >= 0)
        k += 1;

      acc = acc.dblp(k);

      if (i < 0)
        break;

      const z = naf[i];

      assert(z !== 0);

      if (p.type === types.AFFINE) {
        // J +- P
        if (z > 0)
          acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
        else
          acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
      } else {
        // J +- J
        if (z > 0)
          acc = acc.add(wnd[(z - 1) >> 1]);
        else
          acc = acc.add(wnd[(-z - 1) >> 1].neg());
      }
    }

    if (initial)
      acc = acc.add(initial);

    if (jacobian)
      return acc;

    return p.type === types.AFFINE ? acc.toP() : acc;
  }

  _wnafMulAdd(defW, points, coeffs, initial, jacobian) {
    assert((defW >>> 0) === defW);
    assert(Array.isArray(points));
    assert(Array.isArray(coeffs));
    assert(initial == null || (initial instanceof Point));
    assert(typeof jacobian === 'boolean');
    assert(points.length === coeffs.length);

    // Type checking.
    const type = points.length > 0
      ? points[0].type
      : types.AFFINE;

    // Pad to even.
    if (points.length & 1) {
      if (type === types.AFFINE)
        points.push(this.point());
      else
        points.push(this.jpoint());

      coeffs.push(new BN(0));
    }

    const len = points.length;
    const width = new Array(len);
    const wnd = new Array(len);
    const naf = new Array(len);

    let max = 0;

    // Fill all arrays.
    for (let i = 0; i < len; i++) {
      const point = points[i];

      assert(point instanceof Point);

      if (point.type !== type)
        throw new Error('Cannot mix points.');

      const nafPoints = point._getNAFPoints(defW);

      width[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
      naf[i] = null;
    }

    // Comb small window NAFs.
    for (let i = len - 1; i >= 1; i -= 2) {
      const a = i - 1;
      const b = i;

      if (width[a] !== 1 || width[b] !== 1) {
        naf[a] = getNAF(coeffs[a], width[a], this.n);
        naf[b] = getNAF(coeffs[b], width[b], this.n);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }

      const comb = [
        points[a], // 1
        null, // 3
        null, // 5
        points[b] // 7
      ];

      if (type === types.AFFINE) {
        // Try to avoid Projective points, if possible.
        if ((points[a].inf | points[b].inf) === 0) {
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          }
        }

        if (comb[1] === null) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
      } else {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].add(points[b].neg());
      }

      const jsf = getJSF(coeffs[a], coeffs[b], this.n);

      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);

      for (let j = 0; j < max; j++) {
        const ja = jsf[0][j] | 0;
        const jb = jsf[1][j] | 0;

        naf[a][j] = jsfIndex[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }

    const tmp = new Array(len);

    let acc = this.jpoint();

    for (let i = max; i >= 0; i--) {
      let k = 0;

      while (i >= 0) {
        let zero = true;

        for (let j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }

        if (!zero)
          break;

        k += 1;
        i -= 1;
      }

      if (i >= 0)
        k += 1;

      acc = acc.dblp(k);

      if (i < 0)
        break;

      for (let j = 0; j < len; j++) {
        const z = tmp[j];

        if (z === 0)
          continue;

        let p = null;

        if (z > 0)
          p = wnd[j][(z - 1) >> 1];
        else if (z < 0)
          p = wnd[j][(-z - 1) >> 1].neg();

        if (p.type === types.AFFINE)
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }

    if (initial)
      acc = acc.add(initial);

    if (jacobian)
      return acc;

    return type === types.AFFINE ? acc.toP() : acc;
  }

  mulAll(points, coeffs) {
    return this._mulAll(points, coeffs, null, false);
  }

  jmulAll(points, coeffs) {
    return this._mulAll(points, coeffs, null, true);
  }
}

/**
 * Mask
 */

class Mask {
  constructor(curve) {
    assert(curve instanceof Curve);

    const bytes = curve.p.byteLength();
    const bits = Math.max(8, (bytes - 1) * 8);

    // Our curve.
    this.curve = curve;

    // Cofactor mask (p25519=-8, p448=-4).
    this.h = -curve.h.toNumber() & 0xff;

    // Group order top byte (p25519=0x7f, p448=0xff).
    // In theory we should get this from the
    // _real_ order, not the prime.
    this.n = curve.p.ushrn(bits).toNumber();

    // High bit (p25519=0x40, p448=0x80).
    this.b = (this.n + 1) >>> 1;

    // AND mask (p25519=0x7fff...f8, p448=0xffff...fc).
    this.and = BN.shift(this.n + 1, bits - 8).isubn(1);
    this.and.iushln(8).iuorn(this.h);

    // OR mask (p25519=0x4000..., p448=0x8000...).
    this.or = BN.shift(this.b, bits);

    // Verify clamping constants.
    if (curve.id === 'ed25519' || curve.id === 'x25519') {
      assert(this.h === (-8 & 0xff));
      assert(this.n === 0x7f);
      assert(this.b === 0x40);
    } else if (curve.id === 'ed448' || curve.id === 'x448') {
      assert(this.h === (-4 & 0xff));
      assert(this.n === 0xff);
      assert(this.b === 0x80);
    }
  }

  reduce(num) {
    assert(num instanceof BN);
    assert(!num.red);

    num.iuand(this.and);
    num.iuor(this.or);

    return num;
  }

  splitHash(bytes) {
    assert(Buffer.isBuffer(bytes));
    assert(bytes.length === this.curve.fieldSize * 2);

    const scalar = bytes.slice(0, this.curve.scalarSize);
    const prefix = bytes.slice(this.curve.fieldSize);

    this.clamp(scalar);

    return [scalar, prefix];
  }

  clamp(bytes) {
    assert(Buffer.isBuffer(bytes));
    assert(bytes.length === this.curve.scalarSize);

    let i = 0;
    let j = this.curve.scalarSize - 1;

    if (this.curve.endian === 'be')
      [i, j] = [j, i];

    // Ensure a multiple of the cofactor.
    bytes[i] &= this.h;

    // Clamp to the group order.
    bytes[j] &= this.n;

    // Set the high bit.
    bytes[j] |= this.b;

    return bytes;
  }

  isClamped(bytes) {
    assert(Buffer.isBuffer(bytes));

    if (bytes.length !== this.curve.scalarSize)
      return false;

    let i = 0;
    let j = this.curve.scalarSize - 1;

    if (this.curve.endian === 'be')
      [i, j] = [j, i];

    // Must be a multiple of the cofactor.
    if (bytes[i] & ~this.h)
      return false;

    // Must be clamped to the group order.
    if (bytes[j] & ~this.n)
      return false;

    // Must have high bit set.
    if (!(bytes[j] & this.b))
      return false;

    return true;
  }
}

/**
 * Point
 */

class Point {
  constructor(curve, type) {
    assert(curve instanceof Curve);
    assert((type >>> 0) === type);

    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }

  init() {
    throw new Error('Not implemented.');
  }

  eq(point) {
    throw new Error('Not implemented.');
  }

  validate() {
    return this.curve.validate(this);
  }

  encode(compact) {
    throw new Error('Not implemented.');
  }

  precompute(power, rng) {
    assert((power >>> 0) === power);

    if (!this.precomputed) {
      this.precomputed = {
        naf: null,
        doubles: null,
        beta: null,
        blinding: null
      };
    }

    if (!this.precomputed.naf)
      this.precomputed.naf = this._getNAFPoints(8);

    if (!this.precomputed.doubles)
      this.precomputed.doubles = this._getDoubles(4, power);

    if (!this.precomputed.beta)
      this.precomputed.beta = this._getBeta();

    if (!this.precomputed.blinding)
      this.precomputed.blinding = this._getBlinding(rng);

    return this;
  }

  _getNAFPoints(wnd) {
    assert((wnd >>> 0) === wnd);

    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;

    const points = [this];
    const max = (1 << wnd) - 1;
    const dbl = max === 1 ? null : this.dbl();

    for (let i = 1; i < max; i++)
      points.push(points[i - 1].add(dbl));

    return { wnd, points };
  }

  _getDoubles(step, power) {
    assert((step >>> 0) === step);
    assert((power >>> 0) === power);

    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;

    const points = [this];

    let acc = this;

    for (let i = 0; i < power; i += step) {
      for (let j = 0; j < step; j++)
        acc = acc.dbl();

      points.push(acc);
    }

    return { step, points };
  }

  _getBeta() {
    return null;
  }

  _getBlinding(rng) {
    if (this.precomputed && this.precomputed.blinding)
      return this.precomputed.blinding;

    if (!rng)
      return null;

    for (;;) {
      const blind = BN.random(rng, 1, this.curve.n);
      const unblind = this.jmul(blind.neg().imod(this.curve.n));

      if (unblind.isInfinity())
        continue;

      return { blind, unblind };
    }
  }

  _hasDoubles(k) {
    assert(k instanceof BN);

    if (!this.precomputed)
      return false;

    const {doubles} = this.precomputed;

    if (!doubles)
      return false;

    const {points, step} = doubles;

    if (k.sign() < 0)
      k = this.curve.n;

    return points.length >= Math.ceil((k.bitLength() + 1) / step);
  }

  _mulBlind(k, rng = null, jacobian) {
    assert(k instanceof BN);
    assert(!k.red);

    const blinding = this._getBlinding(rng);

    if (!blinding)
      return this._mul(k, null, jacobian);

    const {blind, unblind} = blinding;
    const t = k.add(blind).imod(this.curve.n);

    return this._mul(t, unblind, jacobian);
  }

  mul(k) {
    return this._mul(k, null, false);
  }

  jmul(k) {
    return this._mul(k, null, true);
  }

  mulAdd(k1, p2, k2) {
    return this._mulAdd(k1, p2, k2, null, false);
  }

  jmulAdd(k1, p2, k2) {
    return this._mulAdd(k1, p2, k2, null, true);
  }

  mulBlind(k, rng = null) {
    return this._mulBlind(k, rng, false);
  }

  jmulBlind(k, rng = null) {
    return this._mulBlind(k, rng, true);
  }

  mulSlow(k) {
    return this.curve._simpleMul(this, k, null, false);
  }

  jmulSlow(k) {
    return this.curve._simpleMul(this, k, null, true);
  }

  dblp(k) {
    assert((k >>> 0) === k);

    let r = this;

    for (let i = 0; i < k; i++)
      r = r.dbl();

    return r;
  }
}

/**
 * ShortCurve
 */

class ShortCurve extends Curve {
  constructor(conf) {
    super('short', conf);

    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvert();

    this.zeroA = this.a.sign() === 0;
    this.threeA = this.a.cmp(this.three.redNeg()) === 0;

    // If the curve is endomorphic, precalculate beta and lambda.
    this.endo = this._getEndomorphism(conf);
  }

  _getEndomorphism(conf) {
    assert(conf && typeof conf === 'object');

    // No efficient endomorphism.
    if (!this.zeroA || !this.g || !this.n || this.p.modrn(3) !== 1)
      return null;

    // Compute beta and lambda, that lambda * P = (beta * Px; Py).
    let beta;
    let lambda;

    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      const betas = this._getEndoRoots(this.p);

      // Choose the smallest beta.
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }

    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      // Choose the lambda that is matching selected beta.
      const lambdas = this._getEndoRoots(this.n);

      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }

    // Get basis vectors, used for balanced length-two representation.
    let basis;
    if (conf.basis) {
      basis = conf.basis.map(({a, b}) => {
        return {
          a: new BN(a, 16),
          b: new BN(b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }

    return { beta, lambda, basis };
  }

  _getEndoRoots(num) {
    assert(num instanceof BN);
    assert(!num.red);

    // Find roots of for x^2 + x + 1 in F.
    // Root = (-1 +- Sqrt(-3)) / 2
    const red = num === this.p ? this.red : BN.mont(num);
    const tinv = new BN(2).toRed(red).redInvert();
    const ntinv = tinv.redNeg();

    const s = new BN(3).toRed(red).redINeg().redSqrt().redMul(tinv);

    const l1 = ntinv.redAdd(s).fromRed();
    const l2 = ntinv.redISub(s).fromRed();

    return [l1, l2];
  }

  _getEndoBasis(lambda) {
    assert(lambda instanceof BN);
    assert(!lambda.red);

    // aprxSqrt >= sqrt(this.n)
    const aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt.
    let u = lambda;
    let v = this.n.clone();
    let x1 = new BN(1);
    let y1 = new BN(0);
    let x2 = new BN(0);
    let y2 = new BN(1);

    // All vectors are roots of: a + b * lambda = 0 (mod n).
    let a0;
    let b0;

    // First vector.
    let a1;
    let b1;

    // Second vector.
    let a2;
    let b2;

    let prevR;
    let i = 0;
    let r;
    let x;

    while (u.sign() !== 0) {
      assert(v.sign() >= 0);

      const q = v.div(u);

      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));

      const y = y2.sub(q.mul(y1));

      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }

      prevR = r;

      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }

    a2 = r.neg();
    b2 = x;

    const len1 = a1.sqr().iadd(b1.sqr());
    const len2 = a2.sqr().iadd(b2.sqr());

    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }

    // Normalize signs.
    if (a1.sign() < 0) {
      a1 = a1.neg();
      b1 = b1.neg();
    }

    if (a2.sign() < 0) {
      a2 = a2.neg();
      b2 = b2.neg();
    }

    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  }

  _endoSplit(k) {
    assert(k instanceof BN);
    assert(!k.red);

    if (k.sign() < 0)
      k = k.mod(this.n);

    const [v1, v2] = this.endo.basis;

    const c1 = v2.b.mul(k).divRound(this.n);
    const c2 = v1.b.neg().imul(k).divRound(this.n);

    const p1 = c1.mul(v1.a);
    const p2 = c2.mul(v2.a);
    const q1 = c1.mul(v1.b);
    const q2 = c2.mul(v2.b);

    // Calculate answer.
    const k1 = k.sub(p1).isub(p2);
    const k2 = q1.add(q2).ineg();

    return [k1, k2];
  }

  pointFromX(x, odd) {
    assert(x instanceof BN);

    if (!x.red)
      x = x.toRed(this.red);

    assert(x.red === this.red);

    const ax = this.a.redMul(x);
    const y2 = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    const y = y2.redSqrt();

    if (y.fromRed().isOdd() !== Boolean(odd))
      y.redINeg();

    return this.point(x, y);
  }

  pointFromR(x) {
    assert(x instanceof BN);

    if (!x.red)
      x = x.toRed(this.red);

    assert(x.red === this.red);

    const ax = this.a.redMul(x);
    const y2 = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    const y = y2.redSqrt();

    return this.point(x, y);
  }

  validate(point) {
    assert(point instanceof ShortPoint);

    if (point.inf)
      return true;

    const {x, y} = point;
    const ax = this.a.redMul(x);
    const y2 = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);

    return y.redSqr().cmp(y2) === 0;
  }

  decodePoint(bytes) {
    assert(Buffer.isBuffer(bytes));

    const len = this.fieldSize;

    if (bytes.length < 1 + len)
      throw new Error('Not a point.');

    const first = bytes[0];
    const last = bytes[bytes.length - 1];

    switch (first) {
      case 0x02:
      case 0x03: {
        if (bytes.length !== 1 + len)
          throw new Error('Invalid point size for compressed.');

        const x = this.decodeField(bytes.slice(1, 1 + len));

        if (x.cmp(this.p) >= 0)
          throw new Error('Invalid point.');

        const p = this.pointFromX(x, first === 0x03);

        assert(!p.isInfinity());

        return p;
      }

      case 0x04:
      case 0x06:
      case 0x07: {
        if (bytes.length !== 1 + len * 2)
          throw new Error('Invalid point size for uncompressed.');

        if (first !== 0x04 && (last & 1) !== (first & 1))
          throw new Error('Invalid hybrid encoding.');

        const x = this.decodeField(bytes.slice(1, 1 + len));
        const y = this.decodeField(bytes.slice(1 + len, 1 + 2 * len));

        if (x.cmp(this.p) >= 0 || y.cmp(this.p) >= 0)
          throw new Error('Invalid point.');

        const p = this.point(x, y);

        if (!p.validate())
          throw new Error('Invalid point.');

        assert(!p.isInfinity());

        return p;
      }

      default: {
        throw new Error('Unknown point format.');
      }
    }
  }

  _endoWnafMulAdd(points, coeffs, initial, jacobian) {
    assert(Array.isArray(points));
    assert(Array.isArray(coeffs));
    assert(initial == null || (initial instanceof JPoint));
    assert(typeof jacobian === 'boolean');
    assert(points.length === coeffs.length);
    assert(this.endo != null);

    const len = points.length;
    const npoints = new Array(len * 2);
    const ncoeffs = new Array(len * 2);

    for (let i = 0; i < len; i++) {
      const point = points[i];
      const coeff = coeffs[i];

      assert(point instanceof ShortPoint);

      let p1 = point;
      let p2 = p1._getBeta();

      assert(p2 != null);

      const [k1, k2] = this._endoSplit(coeff);

      if (k1.sign() < 0) {
        p1 = p1.neg(true);
        k1.ineg();
      }

      if (k2.sign() < 0) {
        p2 = p2.neg(true);
        k2.ineg();
      }

      npoints[i * 2 + 0] = p1;
      ncoeffs[i * 2 + 0] = k1;
      npoints[i * 2 + 1] = p2;
      ncoeffs[i * 2 + 1] = k2;
    }

    return this._wnafMulAdd(1, npoints, ncoeffs, initial, jacobian);
  }

  _mulAll(points, coeffs, initial, jacobian) {
    assert(Array.isArray(points));
    assert(Array.isArray(coeffs));
    assert(points.length === coeffs.length);

    if (this.endo && points.length > 0 && points[0].type === types.AFFINE)
      return this._endoWnafMulAdd(points, coeffs, initial, jacobian);

    return this._wnafMulAdd(1, points, coeffs, initial, jacobian);
  }

  point(x, y) {
    return new ShortPoint(this, x, y);
  }

  pointFromJSON(json) {
    return ShortPoint.fromJSON(this, json);
  }

  jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  }
}

/**
 * ShortPoint
 */

class ShortPoint extends Point {
  constructor(curve, x, y) {
    assert(curve instanceof ShortCurve);

    super(curve, types.AFFINE);

    this.x = null;
    this.y = null;
    this.inf = true;

    if (x != null)
      this.init(x, y);
  }

  init(x, y) {
    assert(x != null);
    assert(y != null);

    this.x = BN.cast(x, 16);
    this.y = BN.cast(y, 16);

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    this.inf = false;
  }

  _getBeta() {
    if (!this.curve.endo)
      return null;

    const pre = this.precomputed;

    if (pre && pre.beta)
      return pre.beta;

    const beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

    if (pre) {
      const curve = this.curve;
      const endoMul = p =>
        curve.point(p.x.redMul(curve.endo.beta), p.y);

      pre.beta = beta;

      beta.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        },
        beta: null,
        blinding: null
      };
    }

    return beta;
  }

  encode(compact) {
    if (compact == null)
      compact = true;

    assert(typeof compact === 'boolean');

    const {fieldSize} = this.curve;

    if (compact) {
      const p = Buffer.allocUnsafe(1 + fieldSize);
      const x = this.curve.encodeField(this.getX());

      p[0] = 0x02 | this.getY().isOdd();
      x.copy(p, 1);

      return p;
    }

    const p = Buffer.allocUnsafe(1 + fieldSize * 2);
    const x = this.curve.encodeField(this.getX());
    const y = this.curve.encodeField(this.getY());

    p[0] = 0x04;
    x.copy(p, 1);
    y.copy(p, 1 + fieldSize);

    return p;
  }

  toJSON() {
    const x = this.x.fromRed();
    const y = this.y.fromRed();

    if (!this.precomputed)
      return [x, y];

    return [x, y, {
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      },
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      }
    }];
  }

  isInfinity() {
    return this.inf;
  }

  add(p) {
    assert(p instanceof ShortPoint);

    // O + P = P
    if (this.inf)
      return p;

    // P + O = P
    if (p.inf)
      return this;

    // P + P = 2P
    if (this.eq(p))
      return this.dbl();

    // P + (-P) = O
    if (this.neg().eq(p))
      return this.curve.point();

    // P + Q = O
    if (this.x.cmp(p.x) === 0)
      return this.curve.point();

    let c = this.y.redSub(p.y);

    if (c.sign() !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvert());

    const nx = c.redSqr().redISub(this.x).redISub(p.x);
    const ny = c.redMul(this.x.redSub(nx)).redISub(this.y);

    return this.curve.point(nx, ny);
  }

  mixedAdd(p) {
    assert(p instanceof JPoint);
    return p.mixedAdd(this).toP();
  }

  dbl() {
    if (this.inf)
      return this;

    // 2P = O
    const ys1 = this.y.redAdd(this.y);

    if (ys1.sign() === 0)
      return this.curve.point();

    const a = this.curve.a;

    const x2 = this.x.redSqr();
    const dyinv = ys1.redInvert();
    const c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

    const nx = c.redSqr().redISub(this.x.redAdd(this.x));
    const ny = c.redMul(this.x.redSub(nx)).redISub(this.y);

    return this.curve.point(nx, ny);
  }

  getX() {
    if (this.inf)
      throw new Error('Invalid point.');

    return this.x.fromRed();
  }

  getY() {
    if (this.inf)
      throw new Error('Invalid point.');

    return this.y.fromRed();
  }

  _mul(k, initial, jacobian) {
    assert(k instanceof BN);
    assert(!k.red);
    assert(initial == null || (initial instanceof JPoint));

    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k, initial, jacobian);

    if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k], initial, jacobian);

    return this.curve._wnafMul(this, k, initial, jacobian);
  }

  _mulAdd(k1, p2, k2, initial, jacobian) {
    assert(k1 instanceof BN);
    assert(p2 instanceof ShortPoint);
    assert(k2 instanceof BN);
    assert(initial == null || (initial instanceof JPoint));

    const points = [this, p2];
    const coeffs = [k1, k2];

    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, initial, jacobian);

    return this.curve._wnafMulAdd(1, points, coeffs, initial, jacobian);
  }

  eq(p) {
    assert(p instanceof ShortPoint);

    if (this === p)
      return true;

    if (this.inf !== p.inf)
      return false;

    if (this.inf)
      return true;

    return this.x.cmp(p.x) === 0
        && this.y.cmp(p.y) === 0;
  }

  hasQuadY() {
    if (this.inf)
      return false;

    return this.y.redJacobi() === 1;
  }

  eqX(x) {
    assert(x instanceof BN);
    assert(!x.red);

    if (this.inf)
      return false;

    return this.getX().cmp(x) === 0;
  }

  eqXToP(x) {
    assert(x instanceof BN);
    assert(!x.red);

    if (this.inf)
      return false;

    return this.getX().mod(this.curve.n).cmp(x) === 0;
  }

  neg(precomp = false) {
    assert(typeof precomp === 'boolean');

    if (this.inf)
      return this;

    const res = this.curve.point(this.x, this.y.redNeg());

    if (precomp && this.precomputed) {
      const pre = this.precomputed;
      const negate = p => p.neg();

      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        },
        beta: null,
        blinding: null
      };
    }

    return res;
  }

  toJ() {
    if (this.inf)
      return this.curve.jpoint();

    return this.curve.jpoint(this.x, this.y, this.curve.one);
  }

  [custom]() {
    if (this.isInfinity())
      return '<ShortPoint: Infinity>';

    return '<ShortPoint:'
         + ' x=' + this.x.fromRed().toString(16, 2)
         + ' y=' + this.y.fromRed().toString(16, 2)
         + '>';
  }

  static fromJSON(curve, json) {
    assert(curve instanceof ShortCurve);
    assert(Array.isArray(json));

    const [x, y, pre] = json;
    const point = curve.point(x, y);

    if (!pre)
      return point;

    const {naf, doubles} = pre;
    const convert = ([x, y]) => curve.point(x, y);

    point.precomputed = {
      naf: naf && {
        wnd: naf.wnd,
        points: [point, ...naf.points.map(convert)]
      },
      doubles: doubles && {
        step: doubles.step,
        points: [point, ...doubles.points.map(convert)]
      },
      beta: null,
      blinding: null
    };

    return point;
  }
}

/**
 * JPoint
 */

class JPoint extends Point {
  constructor(curve, x, y, z) {
    assert(curve instanceof ShortCurve);

    super(curve, types.JACOBIAN);

    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = this.curve.zero;
    this.zOne = false;

    if (x != null)
      this.init(x, y, z);
  }

  init(x, y, z) {
    assert(x != null);
    assert(y != null);

    this.x = BN.cast(x, 16);
    this.y = BN.cast(y, 16);
    this.z = z != null ? BN.cast(z, 16) : this.curve.one;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);

    this.zOne = this.z.eq(this.curve.one);
  }

  validate() {
    return this.curve.validate(this.toP());
  }

  toJ() {
    return this.curve.point(this.x, this.y, this.z);
  }

  toP() {
    if (this.isInfinity())
      return this.curve.point();

    const zinv = this.z.redInvert();
    const zinv2 = zinv.redSqr();
    const ax = this.x.redMul(zinv2);
    const ay = this.y.redMul(zinv2).redMul(zinv);

    return this.curve.point(ax, ay);
  }

  neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }

  add(p) {
    assert(p instanceof JPoint);

    // O + P = P
    if (this.isInfinity())
      return p;

    // P + O = P
    if (p.isInfinity())
      return this;

    // 12M + 4S + 7A
    const pz2 = p.z.redSqr();
    const z2 = this.z.redSqr();
    const u1 = this.x.redMul(pz2);
    const u2 = p.x.redMul(z2);
    const s1 = this.y.redMul(pz2.redMul(p.z));
    const s2 = p.y.redMul(z2.redMul(this.z));

    const h = u1.redSub(u2);
    const r = s1.redSub(s2);

    if (h.sign() === 0) {
      if (r.sign() !== 0)
        return this.curve.jpoint();

      return this.dbl();
    }

    const h2 = h.redSqr();
    const h3 = h2.redMul(h);
    const v = u1.redMul(h2);

    const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    const nz = this.z.redMul(p.z).redMul(h);

    return this.curve.jpoint(nx, ny, nz);
  }

  mixedAdd(p) {
    assert(p instanceof ShortPoint);

    // O + P = P
    if (this.isInfinity())
      return p.toJ();

    // P + O = P
    if (p.isInfinity())
      return this;

    // 8M + 3S + 7A
    const z2 = this.z.redSqr();
    const u1 = this.x;
    const u2 = p.x.redMul(z2);
    const s1 = this.y;
    const s2 = p.y.redMul(z2).redMul(this.z);

    const h = u1.redSub(u2);
    const r = s1.redSub(s2);

    if (h.sign() === 0) {
      if (r.sign() !== 0)
        return this.curve.jpoint();
      return this.dbl();
    }

    const h2 = h.redSqr();
    const h3 = h2.redMul(h);
    const v = u1.redMul(h2);

    const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    const nz = this.z.redMul(h);

    return this.curve.jpoint(nx, ny, nz);
  }

  dblp(pow) {
    assert((pow >>> 0) === pow);

    if (pow === 0)
      return this;

    if (this.isInfinity())
      return this;

    if (!pow)
      return this.dbl();

    if (this.curve.zeroA || this.curve.threeA) {
      let r = this;

      for (let i = 0; i < pow; i++)
        r = r.dbl();

      return r;
    }

    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    const a = this.curve.a;
    const tinv = this.curve.tinv;

    let jx = this.x;
    const jy = this.y;
    let jz = this.z;
    let jz4 = jz.redSqr().redSqr();

    // Reuse results
    let jyd = jy.redAdd(jy);

    for (let i = 0; i < pow; i++) {
      const jx2 = jx.redSqr();
      const jyd2 = jyd.redSqr();
      const jyd4 = jyd2.redSqr();
      const c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

      const t1 = jx.redMul(jyd2);
      const nx = c.redSqr().redISub(t1.redAdd(t1));
      const t2 = t1.redISub(nx);

      let dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);

      const nz = jyd.redMul(jz);

      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);

      jx = nx;
      jz = nz;
      jyd = dny;
    }

    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  }

  dbl() {
    if (this.isInfinity())
      return this;

    if (this.curve.zeroA)
      return this._zeroDbl();

    if (this.curve.threeA)
      return this._threeDbl();

    return this._dbl();
  }

  _zeroDbl() {
    let nx;
    let ny;
    let nz;

    // Z = 1
    if (this.zOne) {
      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 14A

      // XX = X1^2
      const xx = this.x.redSqr();

      // YY = Y1^2
      const yy = this.y.redSqr();

      // YYYY = YY^2
      const yyyy = yy.redSqr();

      // S = 2 * ((X1 + YY)^2 - XX - YYYY)
      let s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);

      // M = 3 * XX + a; a = 0
      const m = xx.redAdd(xx).redIAdd(xx);

      // T = M ^ 2 - 2*S
      const t = m.redSqr().redISub(s).redISub(s);

      // 8 * YYYY
      let yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);

      // X3 = T
      nx = t;

      // Y3 = M * (S - T) - 8 * YYYY
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);

      // Z3 = 2*Y1
      nz = this.y.redAdd(this.y);
    } else {
      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-dbl-2009-l
      // 2M + 5S + 13A

      // A = X1^2
      const a = this.x.redSqr();

      // B = Y1^2
      const b = this.y.redSqr();

      // C = B^2
      const c = b.redSqr();

      // D = 2 * ((X1 + B)^2 - A - C)
      let d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);

      // E = 3 * A
      const e = a.redAdd(a).redIAdd(a);

      // F = E^2
      const f = e.redSqr();

      // 8 * C
      let c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);

      // X3 = F - 2 * D
      nx = f.redISub(d).redISub(d);

      // Y3 = E * (D - X3) - 8 * C
      ny = e.redMul(d.redISub(nx)).redISub(c8);

      // Z3 = 2 * Y1 * Z1
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }

    return this.curve.jpoint(nx, ny, nz);
  }

  _threeDbl() {
    let nx;
    let ny;
    let nz;

    // Z = 1
    if (this.zOne) {
      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 15A

      // XX = X1^2
      const xx = this.x.redSqr();

      // YY = Y1^2
      const yy = this.y.redSqr();

      // YYYY = YY^2
      const yyyy = yy.redSqr();

      // S = 2 * ((X1 + YY)^2 - XX - YYYY)
      let s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);

      // M = 3 * XX + a
      const m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);

      // T = M^2 - 2 * S
      const t = m.redSqr().redISub(s).redISub(s);

      // X3 = T
      nx = t;

      // Y3 = M * (S - T) - 8 * YYYY
      let yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);

      // Z3 = 2 * Y1
      nz = this.y.redAdd(this.y);
    } else {
      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
      // 3M + 5S

      // delta = Z1^2
      const delta = this.z.redSqr();

      // gamma = Y1^2
      const gamma = this.y.redSqr();

      // beta = X1 * gamma
      const beta = this.x.redMul(gamma);

      // alpha = 3 * (X1 - delta) * (X1 + delta)
      let alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);

      // X3 = alpha^2 - 8 * beta
      let beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);

      const beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);

      // Z3 = (Y1 + Z1)^2 - gamma - delta
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);

      // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
      let ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }

    return this.curve.jpoint(nx, ny, nz);
  }

  _dbl() {
    const a = this.curve.a;

    // 4M + 6S + 10A
    const jx = this.x;
    const jy = this.y;
    const jz = this.z;
    const jz4 = jz.redSqr().redSqr();

    const jx2 = jx.redSqr();
    const jy2 = jy.redSqr();

    const c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    let jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);

    const t1 = jxd4.redMul(jy2);
    const nx = c.redSqr().redISub(t1.redAdd(t1));
    const t2 = t1.redISub(nx);

    let jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);

    const ny = c.redMul(t2).redISub(jyd8);
    const nz = jy.redAdd(jy).redMul(jz);

    return this.curve.jpoint(nx, ny, nz);
  }

  trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);

    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...

    // XX = X1^2
    const xx = this.x.redSqr();

    // YY = Y1^2
    const yy = this.y.redSqr();

    // ZZ = Z1^2
    const zz = this.z.redSqr();

    // YYYY = YY^2
    const yyyy = yy.redSqr();

    // M = 3 * XX + a * ZZ2; a = 0
    const m = xx.redAdd(xx).redIAdd(xx);

    // MM = M^2
    const mm = m.redSqr();

    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    let e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);

    // EE = E^2
    const ee = e.redSqr();

    // T = 16*YYYY
    let t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);

    // U = (M + E)^2 - MM - EE - T
    const u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);

    // X3 = 4 * (X1 * EE - 4 * YY * U)
    let yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);

    let nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);

    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    let ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);

    // Z3 = (Z1 + E)^2 - ZZ - EE
    const nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

    return this.curve.jpoint(nx, ny, nz);
  }

  _mul(k, initial, jacobian) {
    assert(k instanceof BN);
    assert(initial == null || (initial instanceof JPoint));

    return this.curve._wnafMul(this, k, initial, jacobian);
  }

  _mulAdd(k1, p2, k2, initial, jacobian) {
    assert(k1 instanceof BN);
    assert(p2 instanceof JPoint);
    assert(k2 instanceof BN);
    assert(initial == null || (initial instanceof JPoint));

    return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], initial, jacobian);
  }

  eq(p) {
    assert(p instanceof JPoint);

    if (this === p)
      return true;

    // x1 * z2^2 == x2 * z1^2
    const z2 = this.z.redSqr();
    const pz2 = p.z.redSqr();

    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).sign() !== 0)
      return false;

    // y1 * z2^3 == y2 * z1^3
    const z3 = z2.redMul(this.z);
    const pz3 = pz2.redMul(p.z);

    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).sign() === 0;
  }

  hasQuadY() {
    return this.y.redMul(this.z).redJacobi() === 1;
  }

  eqX(x) {
    assert(x instanceof BN);

    const zs = this.z.redSqr();
    const rx = x.toRed(this.curve.red).redMul(zs);

    return this.x.cmp(rx) === 0;
  }

  eqXToP(x) {
    assert(x instanceof BN);

    const zs = this.z.redSqr();
    const rx = x.toRed(this.curve.red).redMul(zs);

    if (this.x.cmp(rx) === 0)
      return true;

    const xc = x.clone();
    const t = this.curve.redN.redMul(zs);

    for (;;) {
      xc.iadd(this.curve.n);

      if (xc.cmp(this.curve.p) >= 0)
        return false;

      rx.redIAdd(t);

      if (this.x.cmp(rx) === 0)
        break;
    }

    return true;
  }

  isInfinity() {
    // This code assumes that zero is always zero in red.
    return this.z.sign() === 0;
  }

  encode(compact) {
    return this.toP().encode(compact);
  }

  toJSON() {
    return this.toP().toJSON();
  }

  [custom]() {
    if (this.isInfinity())
      return '<JPoint: Infinity>';

    return '<JPoint:'
         + ' x=' + this.x.fromRed().toString(16, 2)
         + ' y=' + this.y.fromRed().toString(16, 2)
         + ' z=' + this.z.fromRed().toString(16, 2)
         + '>';
  }

  static fromJSON(curve, json) {
    return ShortPoint.fromJSON(curve, json).toJ();
  }
}

/**
 * MontCurve
 */

class MontCurve extends Curve {
  constructor(conf) {
    super('mont', conf);

    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.binv = this.b.redInvert();
    this.i4 = new BN(4).toRed(this.red).redInvert();
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }

  decodePoint(bytes) {
    const x = this.decodeField(bytes);

    // We're supposed to ignore the hi bit
    // on montgomery points... I think. If
    // we don't, the X25519 test vectors
    // break, which is pretty convincing
    // evidence. This is a no-op for X448.
    x.setn(this.signBit, 0);

    // Note: montgomery points are meant to be
    // reduced by the prime and do not have to
    // be explicitly validated in order to do
    // the montgomery ladder (see rfc7748,
    // section 5).
    const p = this.point(x, this.one);

    assert(!p.isInfinity());

    return p;
  }

  pointFromX(x, odd) {
    assert(x instanceof BN);
    assert(odd == null);

    if (!x.red)
      x = x.toRed(this.red);

    assert(x.red === this.red);

    return this.point(x, this.one);
  }

  pointFromEdwards(point) {
    assert(point instanceof EdwardsPoint);

    if (point.isInfinity())
      return this.point();

    point.normalize();

    // Edwards point.
    const {x, y, z} = point;

    // Montgomery `u`.
    let nx = null;

    if (point.curve.twisted) {
      // Birational maps:
      //   u = (1+y)/(1-y)
      //   v = sqrt(-486664)*u/x
      const lhs = z.redAdd(y);
      const rhs = z.redSub(y);

      nx = lhs.redMul(rhs.redInvert());
    } else {
      // Birational maps:
      //   u = (y-1)/(y+1)
      //   v = sqrt(156324)*u/x
      //
      // 4-isogeny maps:
      //   u = y^2/x^2
      //   v = (2 - x^2 - y^2)*y/x^3
      const lhs = y.redSqr();
      const rhs = x.redSqr();

      nx = lhs.redMul(rhs.redInvert());
    }

    // Montgomery point.
    return this.point(nx.fromRed(), this.one);
  }

  validate(point) {
    assert(point instanceof MontPoint);

    if (point.isInfinity())
      return true;

    // b*y^2 = x^3 + a*x^2 + x
    const x = point.normalize().x;
    const x2 = x.redSqr();
    const by2 = x2.redMul(x).redIAdd(this.a.redMul(x2)).redIAdd(x);
    const y2 = by2.redMul(this.binv);

    return y2.redJacobi() !== -1;
  }

  _mulAll(points, coeffs, initial, jacobian) {
    throw new Error('Not supported on Montgomery curve.');
  }

  _simpleMul(p, k, initial, jacobian) {
    throw new Error('Not supported on Montgomery curve.');
  }

  point(x, z) {
    return new MontPoint(this, x, z);
  }

  jpoint(x, y, z) {
    assert(x == null && y == null && z == null);
    return this.point();
  }

  pointFromJSON(json) {
    return MontPoint.fromJSON(this, json);
  }
}

/**
 * MontPoint
 */

class MontPoint extends Point {
  constructor(curve, x, z) {
    assert(curve instanceof MontCurve);

    super(curve, types.PROJECTIVE);

    this.x = this.curve.one;
    this.z = this.curve.zero;

    if (x != null)
      this.init(x, z);
  }

  init(x, z) {
    assert(x != null);

    this.x = BN.cast(x, 16);
    this.z = z != null ? BN.cast(z, 16) : this.curve.one;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }

  precompute(power, rng) {
    // No-op.
    return this;
  }

  encode() {
    return this.curve.encodeField(this.getX());
  }

  isInfinity() {
    // This code assumes that zero is always zero in red.
    return this.z.sign() === 0;
  }

  dbl() {
    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A

    // A = X1 + Z1
    const a = this.x.redAdd(this.z);

    // AA = A^2
    const aa = a.redSqr();

    // B = X1 - Z1
    const b = this.x.redSub(this.z);

    // BB = B^2
    const bb = b.redSqr();

    // C = AA - BB
    const c = aa.redSub(bb);

    // X3 = AA * BB
    const nx = aa.redMul(bb);

    // Z3 = C * (BB + A24 * C)
    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));

    return this.curve.point(nx, nz);
  }

  add() {
    throw new Error('Not supported on Montgomery curve.');
  }

  diffAdd(p, diff) {
    assert(p instanceof MontPoint);
    assert(diff instanceof MontPoint);

    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A

    // A = X2 + Z2
    const a = this.x.redAdd(this.z);

    // B = X2 - Z2
    const b = this.x.redSub(this.z);

    // C = X3 + Z3
    const c = p.x.redAdd(p.z);

    // D = X3 - Z3
    const d = p.x.redSub(p.z);

    // DA = D * A
    const da = d.redMul(a);

    // CB = C * B
    const cb = c.redMul(b);

    // X5 = Z1 * (DA + CB)^2
    const nx = diff.z.redMul(da.redAdd(cb).redSqr());

    // Z5 = X1 * (DA - CB)^2
    const nz = diff.x.redMul(da.redISub(cb).redSqr());

    return this.curve.point(nx, nz);
  }

  _mul(k, initial, jacobian) {
    assert(k instanceof BN);
    assert(!k.red && k.sign() >= 0);
    assert(initial == null || (initial instanceof MontPoint));

    const s = this.curve.mask.reduce(k.clone());
    const bits = this.curve.p.bitLength();

    let a = this; // (N / 2) * Q + Q
    let b = initial || this.curve.point(); // (N / 2) * Q

    const c = this; // Q

    // Montgomery ladder.
    // https://tools.ietf.org/html/rfc7748#section-5
    for (let i = bits - 1; i >= 0; i--) {
      const bit = s.testn(i) | 0;

      if (bit === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
      } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = b.diffAdd(a, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
      }
    }

    return b;
  }

  _mulBlind(k, rng = null, jacobian) {
    // Can't do this due to the clamping.
    throw new Error('Not supported on Montgomery curve.');
  }

  _mulAdd(k1, p2, k2, initial, jacobian) {
    throw new Error('Not supported on Montgomery curve.');
  }

  eq(other) {
    assert(other instanceof MontPoint);

    if (this === other)
      return true;

    if (this.isInfinity())
      return other.isInfinity();

    if (other.isInfinity())
      return false;

    return this.getX().cmp(other.getX()) === 0;
  }

  normalize() {
    if (this.isInfinity())
      return this;

    this.x = this.x.redMul(this.z.redInvert());
    this.z = this.curve.one;

    return this;
  }

  getX() {
    // Throw if the point is at
    // infinity (z=0 is not invertible).
    if (this.isInfinity())
      throw new Error('Invalid point.');

    this.normalize();

    return this.x.fromRed();
  }

  getY() {
    // Throw if the point is at
    // infinity (z=0 is not invertible).
    if (this.isInfinity())
      throw new Error('Invalid point.');

    // b*y^2 = x^3 + a*x^2 + x
    const x = this.normalize().x;
    const x2 = x.redSqr();
    const by2 = x2.redMul(x).redIAdd(this.curve.a.redMul(x2)).redIAdd(x);
    const y2 = by2.redMul(this.curve.binv);
    const y = y2.redSqrt();

    // Note: the `v` values in RFC 7748 are negated.
    // This tends not to matter if we are squaring.
    return y.fromRed();
  }

  mixedAdd(p) {
    throw new Error('Not supported on Montgomery curve.');
  }

  toP() {
    return this.normalize();
  }

  toJ() {
    return this.curve.point(this.x, this.z);
  }

  toJSON() {
    return [this.getX()];
  }

  [custom]() {
    if (this.isInfinity())
      return '<MontPoint: Infinity>';

    return '<MontPoint:'
        + ' x=' + this.x.fromRed().toString(16, 2)
        + ' z=' + this.z.fromRed().toString(16, 2)
        + '>';
  }

  static fromJSON(curve, json) {
    assert(curve instanceof MontCurve);
    assert(Array.isArray(json));

    const [x, z] = json;

    return curve.point(x, z || curve.one);
  }
}

/**
 * EdwardsCurve
 */

class EdwardsCurve extends Curve {
  constructor(conf) {
    super('edwards', conf);

    this.a = new BN(conf.a, 16).toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.d = new BN(conf.d, 16).toRed(this.red);

    this.c2 = this.c.redSqr();
    this.dd = this.d.redAdd(this.d);

    this.mOneA = this.a.cmp(this.one.redNeg()) === 0;
    this.oneC = this.c.cmp(this.one) === 0;

    assert(!this.twisted || this.c.cmp(this.one) === 0);
    assert(!this.twisted || this.a.cmp(this.one) !== 0);
    assert(!this.extended || this.a.cmp(this.one.redNeg()) === 0);
  }

  _mulA(num) {
    assert(num instanceof BN);

    if (this.mOneA)
      return num.redNeg();

    return this.a.redMul(num);
  }

  _mulC(num) {
    assert(num instanceof BN);

    if (this.oneC)
      return num;

    return this.c.redMul(num);
  }

  jpoint(x, y, z) {
    assert(x == null && y == null && z == null);
    return this.point();
  }

  pointFromX(x, odd) {
    assert(x instanceof BN);

    if (!x.red)
      x = x.toRed(this.red);

    assert(x.red === this.red);

    const x2 = x.redSqr();
    const lhs = this.c2.redSub(this.a.redMul(x2));
    const rhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    const y2 = lhs.redMul(rhs.redInvert());
    const y = y2.redSqrt();

    if (y.fromRed().isOdd() !== Boolean(odd))
      y.redINeg();

    return this.point(x, y);
  }

  pointFromY(y, odd) {
    assert(y instanceof BN);

    if (!y.red)
      y = y.toRed(this.red);

    assert(y.red === this.red);

    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    const y2 = y.redSqr();
    const lhs = y2.redSub(this.c2);
    const rhs = y2.redMul(this.d).redMul(this.c2).redISub(this.a);
    const x2 = lhs.redMul(rhs.redInvert());

    if (x2.sign() === 0) {
      if (odd)
        throw new Error('Invalid point.');
      return this.point(this.zero, y);
    }

    const x = x2.redSqrt();

    if (x.fromRed().isOdd() !== Boolean(odd))
      x.redINeg();

    return this.point(x, y);
  }

  pointFromMont(point, odd) {
    assert(point instanceof MontPoint);

    if (point.isInfinity()) {
      if (odd)
        throw new Error('Invalid point.');
      return this.point();
    }

    point.normalize();

    // Montgomery point.
    const {x, z} = point;

    // Edwards `y`.
    let ny = null;

    if (this.twisted) {
      // Birational maps:
      //   x = sqrt(-486664)*u/v
      //   y = (u-1)/(u+1)
      const lhs = x.redSub(z);
      const rhs = x.redAdd(z);

      ny = lhs.redMul(rhs.redInvert());
    } else {
      // Birational maps:
      //   x = sqrt(156324)*u/v
      //   y = (1+u)/(1-u)
      //
      // 4-isogeny maps:
      //   x = 4*v*(u^2 - 1)/(u^4 - 2*u^2 + 4*v^2 + 1)
      //   y = -(u^5 - 2*u^3 - 4*u*v^2 + u)/
      //        (u^5 - 2*u^2*v^2 - 2*u^3 - 2*v^2 + u)
      throw new Error('Not implemented.');
    }

    // Edwards point.
    return this.pointFromY(ny.fromRed(), odd);
  }

  validate(point) {
    assert(point instanceof EdwardsPoint);

    if (point.isInfinity())
      return true;

    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();

    const x2 = point.x.redSqr();
    const y2 = point.y.redSqr();
    const lhs = x2.redMul(this.a).redIAdd(y2);
    const rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

    return lhs.cmp(rhs) === 0;
  }

  decodePoint(bytes) {
    const y = this.decodeField(bytes);
    const xIsOdd = y.testn(this.signBit);

    y.setn(this.signBit, 0);

    if (y.cmp(this.p) >= 0)
      throw new Error('Invalid point.');

    const p = this.pointFromY(y, xIsOdd);

    // Note that it _is_ possible to serialize
    // points at infinity for edwards curves.
    if (p.isInfinity())
      throw new Error('Invalid point.');

    return p;
  }

  _mulAll(points, coeffs, initial, jacobian) {
    assert(Array.isArray(points));
    assert(Array.isArray(coeffs));
    assert(points.length === coeffs.length);

    return this._wnafMulAdd(1, points, coeffs, initial, jacobian);
  }

  pointFromJSON(json) {
    return EdwardsPoint.fromJSON(this, json);
  }

  point(x, y, z, t) {
    return new EdwardsPoint(this, x, y, z, t);
  }
}

/**
 * EdwardsPoint
 */

class EdwardsPoint extends Point {
  constructor(curve, x, y, z, t) {
    assert(curve instanceof EdwardsCurve);

    super(curve, types.PROJECTIVE);

    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;

    if (x != null)
      this.init(x, y, z, t);
  }

  init(x, y, z, t) {
    assert(x != null);
    assert(y != null);

    this.x = BN.cast(x, 16);
    this.y = BN.cast(y, 16);
    this.z = z != null ? BN.cast(z, 16) : this.curve.one;
    this.t = t != null ? BN.cast(t, 16) : null;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);

    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);

    this.zOne = this.z.eq(this.curve.one);

    // Use extended coordinates.
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvert());
    }
  }

  encode() {
    if (this.isInfinity())
      throw new Error('Invalid point.');

    const y = this.getY();

    y.setn(this.curve.signBit,
           this.getX().isOdd());

    return this.curve.encodeField(y);
  }

  isInfinity() {
    // This code assumes that zero is always zero in red.
    if (this.x.sign() !== 0)
      return false;

    if (this.y.cmp(this.z) === 0)
      return true;

    if (this.zOne && this.y.cmp(this.curve.c) === 0)
      return true;

    return false;
  }

  _extDbl() {
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S

    // A = X1^2
    const a = this.x.redSqr();

    // B = Y1^2
    const b = this.y.redSqr();

    // C = 2 * Z1^2
    let c = this.z.redSqr();
    c = c.redIAdd(c);

    // D = a * A
    const d = this.curve._mulA(a);

    // E = (X1 + Y1)^2 - A - B
    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);

    // G = D + B
    const g = d.redAdd(b);

    // F = G - C
    const f = g.redSub(c);

    // H = D - B
    const h = d.redISub(b);

    // X3 = E * F
    const nx = e.redMul(f);

    // Y3 = G * H
    const ny = g.redMul(h);

    // T3 = E * H
    const nt = e.redMul(h);

    // Z3 = F * G
    const nz = f.redMul(g);

    return this.curve.point(nx, ny, nz, nt);
  }

  _projDbl() {
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S

    // B = (X1 + Y1)^2
    const b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    const c = this.x.redSqr();
    // D = Y1^2
    const d = this.y.redSqr();

    let nx;
    let ny;
    let nz;

    if (this.curve.twisted) {
      // E = a * C
      const e = this.curve._mulA(c);
      // F = E + D
      const f = e.redAdd(d);

      if (this.zOne) {
        // X3 = (B - C - D) * (F - 2)
        nx = b.redSub(c).redISub(d).redMul(f.redSub(this.curve.two));

        // Y3 = F * (E - D)
        ny = f.redMul(e.redISub(d));

        // Z3 = F^2 - 2 * F
        nz = f.redSqr().redISub(f).redISub(f);
      } else {
        // H = Z1^2
        const h = this.z.redSqr();

        // J = F - 2 * H
        const j = f.redSub(h).redISub(h);

        // X3 = (B-C-D)*J
        nx = b.redISub(c).redISub(d).redMul(j);

        // Y3 = F * (E - D)
        ny = f.redMul(e.redISub(d));

        // Z3 = F * J
        nz = f.redMul(j);
      }
    } else {
      // E = C + D
      const e = c.redAdd(d);

      // H = (c * Z1)^2
      const h = this.curve._mulC(this.z).redSqr();

      // J = E - 2 * H
      const j = e.redSub(h).redISub(h);

      // X3 = c * (B - E) * J
      nx = this.curve._mulC(b.redISub(e)).redMul(j);

      // Y3 = c * E * (C - D)
      ny = this.curve._mulC(e).redMul(c.redISub(d));

      // Z3 = E * J
      nz = e.redMul(j);
    }

    return this.curve.point(nx, ny, nz);
  }

  dbl() {
    if (this.isInfinity())
      return this;

    // Double in extended coordinates
    if (this.curve.extended)
      return this._extDbl();

    return this._projDbl();
  }

  _extAdd(p) {
    assert(p instanceof EdwardsPoint);

    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M

    // A = (Y1 - X1) * (Y2 - X2)
    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));

    // B = (Y1 + X1) * (Y2 + X2)
    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));

    // C = T1 * k * T2
    const c = this.t.redMul(this.curve.dd).redMul(p.t);

    // D = Z1 * 2 * Z2
    const d = this.z.redMul(p.z.redAdd(p.z));

    // E = B - A
    const e = b.redSub(a);

    // F = D - C
    const f = d.redSub(c);

    // G = D + C
    const g = d.redIAdd(c);

    // H = B + A
    const h = b.redIAdd(a);

    // X3 = E * F
    const nx = e.redMul(f);

    // Y3 = G * H
    const ny = g.redMul(h);

    // T3 = E * H
    const nt = e.redMul(h);

    // Z3 = F * G
    const nz = f.redMul(g);

    return this.curve.point(nx, ny, nz, nt);
  }

  _projAdd(p) {
    assert(p instanceof EdwardsPoint);

    // https://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S

    // A = Z1 * Z2
    const a = this.z.redMul(p.z);

    // B = A^2
    const b = a.redSqr();

    // C = X1 * X2
    const c = this.x.redMul(p.x);

    // D = Y1 * Y2
    const d = this.y.redMul(p.y);

    // E = d * C * D
    const e = this.curve.d.redMul(c).redMul(d);

    // F = B - E
    const f = b.redSub(e);

    // G = B + E
    const g = b.redIAdd(e);

    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    const tmp = this.x.redAdd(this.y)
                      .redMul(p.x.redAdd(p.y))
                      .redISub(c)
                      .redISub(d);

    const nx = a.redMul(f).redMul(tmp);

    let ny;
    let nz;

    if (this.curve.twisted) {
      // Y3 = A * G * (D - a * C)
      ny = a.redMul(g).redMul(d.redISub(this.curve._mulA(c)));
      // Z3 = F * G
      nz = f.redMul(g);
    } else {
      // Y3 = A * G * (D - C)
      ny = a.redMul(g).redMul(d.redISub(c));
      // Z3 = c * F * G
      nz = this.curve._mulC(f).redMul(g);
    }

    return this.curve.point(nx, ny, nz);
  }

  add(p) {
    assert(p instanceof EdwardsPoint);

    if (this.isInfinity())
      return p;

    if (p.isInfinity())
      return this;

    if (this.curve.extended)
      return this._extAdd(p);

    return this._projAdd(p);
  }

  _mul(k, initial, jacobian) {
    assert(k instanceof BN);
    assert(!k.red);
    assert(initial == null || (initial instanceof EdwardsPoint));

    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k, initial, jacobian);

    return this.curve._wnafMul(this, k, initial, jacobian);
  }

  _mulAdd(k1, p2, k2, initial, jacobian) {
    assert(k1 instanceof BN);
    assert(p2 instanceof EdwardsPoint);
    assert(k2 instanceof BN);
    assert(initial == null || (initial instanceof EdwardsPoint));

    return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], initial, jacobian);
  }

  normalize() {
    if (this.zOne)
      return this;

    // Normalize coordinates.
    const zi = this.z.redInvert();

    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);

    if (this.t)
      this.t = this.t.redMul(zi);

    this.z = this.curve.one;
    this.zOne = true;

    return this;
  }

  neg() {
    return this.curve.point(this.x.redNeg(),
                            this.y,
                            this.z,
                            this.t && this.t.redNeg());
  }

  getX() {
    this.normalize();
    return this.x.fromRed();
  }

  getY() {
    this.normalize();
    return this.y.fromRed();
  }

  eq(other) {
    assert(other instanceof EdwardsPoint);

    if (this === other)
      return true;

    return this.getX().cmp(other.getX()) === 0
        && this.getY().cmp(other.getY()) === 0;
  }

  hasQuadY() {
    return this.y.redMul(this.z).redJacobi() === 1;
  }

  eqX(x) {
    assert(x instanceof BN);

    const rx = x.toRed(this.curve.red).redMul(this.z);

    return this.x.cmp(rx) === 0;
  }

  eqXToP(x) {
    assert(x instanceof BN);

    const rx = x.toRed(this.curve.red).redMul(this.z);

    if (this.x.cmp(rx) === 0)
      return true;

    const xc = x.clone();
    const t = this.curve.redN.redMul(this.z);

    for (;;) {
      xc.iadd(this.curve.n);

      if (xc.cmp(this.curve.p) >= 0)
        return false;

      rx.redIAdd(t);

      if (this.x.cmp(rx) === 0)
        break;
    }

    return true;
  }

  mixedAdd(p) {
    return this.add(p);
  }

  toP() {
    return this.normalize();
  }

  toJ() {
    return this.curve.point(this.x, this.y, this.z, this.t);
  }

  toJSON() {
    const x = this.getX();
    const y = this.getY();

    if (!this.precomputed)
      return [x, y];

    return [x, y, {
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      },
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      }
    }];
  }

  [custom]() {
    if (this.isInfinity())
      return '<EdwardsPoint: Infinity>';

    return '<EdwardsPoint:'
        + ' x=' + this.x.fromRed().toString(16, 2)
        + ' y=' + this.y.fromRed().toString(16, 2)
        + ' z=' + this.z.fromRed().toString(16, 2)
        + '>';
  }

  static fromJSON(curve, json) {
    assert(curve instanceof EdwardsCurve);
    assert(Array.isArray(json));

    const [x, y, pre] = json;
    const point = curve.point(x, y);

    if (!pre)
      return point;

    const {naf, doubles} = pre;
    const convert = ([x, y]) => curve.point(x, y);

    point.precomputed = {
      naf: naf && {
        wnd: naf.wnd,
        points: [point, ...naf.points.map(convert)]
      },
      doubles: doubles && {
        step: doubles.step,
        points: [point, ...doubles.points.map(convert)]
      },
      beta: null,
      blinding: null
    };

    return point;
  }
}

/**
 * P192
 */

class P192 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P192',
      ossl: 'prime192v1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prefix: null,
      context: false,
      seed: '3045ae6f c8422f64 ed579528 d38120ea'
          + 'e12196d5',
      prime: 'p192',
      p: 'ffffffff ffffffff ffffffff fffffffe'
       + 'ffffffff ffffffff',
      a: 'ffffffff ffffffff ffffffff fffffffe'
       + 'ffffffff fffffffc',
      b: '64210519 e59c80e7 0fa7e9ab 72243049'
       + 'feb8deec c146b9b1',
      n: 'ffffffff ffffffff ffffffff 99def836'
       + '146bc9b1 b4d22831',
      h: '1',
      g: [
        ['188da80e b03090f6 7cbf20eb 43a18800',
         'f4ff0afd 82ff1012'].join(''),
        ['07192b95 ffc8da78 631011ed 6b24cdd5',
         '73f977a1 1e794811'].join(''),
        pre
      ]
    });
  }
}

/**
 * P224
 */

class P224 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P224',
      ossl: 'secp224r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prefix: null,
      context: false,
      seed: 'bd713447 99d5c7fc dc45b59f a3b9ab8f'
          + '6a948bc5',
      prime: 'p224',
      p: 'ffffffff ffffffff ffffffff ffffffff'
       + '00000000 00000000 00000001',
      a: 'ffffffff ffffffff ffffffff fffffffe'
       + 'ffffffff ffffffff fffffffe',
      b: 'b4050a85 0c04b3ab f5413256 5044b0b7'
       + 'd7bfd8ba 270b3943 2355ffb4',
      n: 'ffffffff ffffffff ffffffff ffff16a2'
       + 'e0b8f03e 13dd2945 5c5c2a3d',
      h: '1',
      g: [
        ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3',
         '56c21122 343280d6 115c1d21'].join(''),
        ['bd376388 b5f723fb 4c22dfe6 cd4375a0',
         '5a074764 44d58199 85007e34'].join(''),
        pre
      ]
    });
  }
}

/**
 * P256
 */

class P256 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P256',
      ossl: 'prime256v1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prefix: null,
      context: false,
      seed: 'c49d3608 86e70493 6a6678e1 139d26b7'
          + '819f7e90',
      prime: null,
      p: 'ffffffff 00000001 00000000 00000000'
       + '00000000 ffffffff ffffffff ffffffff',
      a: 'ffffffff 00000001 00000000 00000000'
       + '00000000 ffffffff ffffffff fffffffc',
      b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc'
       + '651d06b0 cc53b0f6 3bce3c3e 27d2604b',
      n: 'ffffffff 00000000 ffffffff ffffffff'
       + 'bce6faad a7179e84 f3b9cac2 fc632551',
      h: '1',
      g: [
        ['6b17d1f2 e12c4247 f8bce6e5 63a440f2',
         '77037d81 2deb33a0 f4a13945 d898c296'].join(''),
        ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16',
         '2bce3357 6b315ece cbb64068 37bf51f5'].join(''),
        pre
      ]
    });
  }
}

/**
 * P384
 */

class P384 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P384',
      ossl: 'secp384r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA384',
      prefix: null,
      context: false,
      seed: 'a335926a a319a27a 1d00896a 6773a482'
          + '7acdac73',
      prime: null,
      p: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff fffffffe'
       + 'ffffffff 00000000 00000000 ffffffff',
      a: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff fffffffe'
       + 'ffffffff 00000000 00000000 fffffffc',
      b: 'b3312fa7 e23ee7e4 988e056b e3f82d19'
       + '181d9c6e fe814112 0314088f 5013875a'
       + 'c656398d 8a2ed19d 2a85c8ed d3ec2aef',
      n: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff c7634d81 f4372ddf'
       + '581a0db2 48b0a77a ecec196a ccc52973',
      h: '1',
      g: [
        ['aa87ca22 be8b0537 8eb1c71e f320ad74',
         '6e1d3b62 8ba79b98 59f741e0 82542a38',
         '5502f25d bf55296c 3a545e38 72760ab7'].join(''),
        ['3617de4a 96262c6f 5d9e98bf 9292dc29',
         'f8f41dbd 289a147c e9da3113 b5f0b8c0',
         '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'].join(''),
        pre
      ]
    });
  }
}

/**
 * P521
 */

class P521 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P521',
      ossl: 'secp521r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA512',
      prefix: null,
      context: false,
      seed: 'd09e8800 291cb853 96cc6717 393284aa'
          + 'a0da64ba',
      prime: 'p521',
      p: '000001ff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff',
      a: '000001ff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'fffffffc',
      b: '00000051 953eb961 8e1c9a1f 929a21a0'
       + 'b68540ee a2da725b 99b315f3 b8b48991'
       + '8ef109e1 56193951 ec7e937b 1652c0bd'
       + '3bb1bf07 3573df88 3d2c34f1 ef451fd4'
       + '6b503f00',
      n: '000001ff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'fffffffa 51868783 bf2f966b 7fcc0148'
       + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e'
       + '91386409',
      h: '1',
      g: [
        ['000000c6 858e06b7 0404e9cd 9e3ecb66',
         '2395b442 9c648139 053fb521 f828af60',
         '6b4d3dba a14b5e77 efe75928 fe1dc127',
         'a2ffa8de 3348b3c1 856a429b f97e7e31',
         'c2e5bd66'].join(''),
        ['00000118 39296a78 9a3bc004 5c8a5fb4',
         '2c7d1bd9 98f54449 579b4468 17afbd17',
         '273e662c 97ee7299 5ef42640 c550b901',
         '3fad0761 353c7086 a272c240 88be9476',
         '9fd16650'].join(''),
        pre
      ]
    });
  }
}

/**
 * SECP256K1
 */

class SECP256K1 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'SECP256K1',
      ossl: 'secp256k1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prefix: null,
      context: false,
      prime: 'k256',
      p: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff fffffffe fffffc2f',
      a: '0',
      b: '7',
      n: 'ffffffff ffffffff ffffffff fffffffe'
       + 'baaedce6 af48a03b bfd25e8c d0364141',
      h: '1',
      g: [
        ['79be667e f9dcbbac 55a06295 ce870b07',
         '029bfcdb 2dce28d9 59f2815b 16f81798'].join(''),
        ['483ada77 26a3c465 5da4fbfc 0e1108a8',
         'fd17b448 a6855419 9c47d08f fb10d4b8'].join(''),
        pre
      ],
      // Precomputed endomorphism.
      beta: '7ae96a2b 657c0710 6e64479e ac3434e9'
          + '9cf04975 12f58995 c1396c28 719501ee',
      lambda: '5363ad4c c05c30e0 a5261c02 8812645a'
            + '122e22ea 20816678 df02967c 1b23bd72',
      basis: [
        {
          a: '3086d221a7d46bcde86c90e49284eb15',
          b: '-e4437ed6010e88286f547fa90abfe4c3'
        },
        {
          a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
          b: '3086d221a7d46bcde86c90e49284eb15'
        }
      ]
    });
  }
}

/**
 * X25519
 */

class X25519 extends MontCurve {
  constructor() {
    super({
      id: 'X25519',
      ossl: 'X25519',
      type: 'mont',
      endian: 'le',
      hash: 'SHA512',
      prefix: null,
      context: false,
      prime: 'p25519',
      // 2^255 - 19
      p: '7fffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffed',
      a: '76d06',
      b: '1',
      n: '10000000 00000000 00000000 00000000'
       + '14def9de a2f79cd6 5812631a 5cf5d3ed',
      h: '8',
      g: [
        '9'
      ]
    });
  }
}

/**
 * ED25519
 */

class ED25519 extends EdwardsCurve {
  constructor(pre) {
    super({
      id: 'ED25519',
      ossl: 'ED25519',
      type: 'edwards',
      endian: 'le',
      hash: 'SHA512',
      prefix: 'SigEd25519 no Ed25519 collisions',
      context: false,
      prime: 'p25519',
      // 2^255 - 19
      p: '7fffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffed',
      a: '-1',
      c: '1',
      // (-121665 * 121666^-1) mod p
      d: '52036cee 2b6ffe73 8cc74079 7779e898'
       + '00700a4d 4141d8ab 75eb4dca 135978a3',
      n: '10000000 00000000 00000000 00000000'
       + '14def9de a2f79cd6 5812631a 5cf5d3ed',
      h: '8', // c=3
      g: [
        ['216936d3 cd6e53fe c0a4e231 fdd6dc5c',
         '692cc760 9525a7b2 c9562d60 8f25d51a'].join(''),
        // 4/5
        ['66666666 66666666 66666666 66666666',
         '66666666 66666666 66666666 66666658'].join(''),
        pre
      ]
    });
  }
}

/**
 * X448
 */

class X448 extends MontCurve {
  constructor() {
    super({
      id: 'X448',
      ossl: 'X448',
      type: 'mont',
      endian: 'le',
      hash: 'SHAKE256',
      prefix: null,
      context: false,
      prime: 'p448',
      // 2^448 - 2^224 - 1
      p: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff fffffffe ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff',
      a: '262a6',
      b: '1',
      n: '3fffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff 7cca23e9'
       + 'c44edb49 aed63690 216cc272 8dc58f55'
       + '2378c292 ab5844f3',
      h: '4',
      g: [
        '5'
      ]
    });
  }
}

/**
 * ED448
 */

class ED448 extends EdwardsCurve {
  constructor(pre) {
    super({
      id: 'ED448',
      ossl: 'ED448',
      type: 'edwards',
      endian: 'le',
      hash: 'SHAKE256',
      prefix: 'SigEd448',
      context: true,
      prime: 'p448',
      // 2^448 - 2^224 - 1
      p: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff fffffffe ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff',
      a: '1',
      c: '1',
      // -39081 mod p
      d: 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff fffffffe ffffffff'
       + 'ffffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffff6756',
      n: '3fffffff ffffffff ffffffff ffffffff'
       + 'ffffffff ffffffff ffffffff 7cca23e9'
       + 'c44edb49 aed63690 216cc272 8dc58f55'
       + '2378c292 ab5844f3',
      h: '4', // c=2
      g: [
        ['4f1970c6 6bed0ded 221d15a6 22bf36da',
         '9e146570 470f1767 ea6de324 a3d3a464',
         '12ae1af7 2ab66511 433b80e1 8b00938e',
         '2626a82b c70cc05e'].join(''),
        ['693f4671 6eb6bc24 88762037 56c9c762',
         '4bea7373 6ca39840 87789c1e 05a0c2d7',
         '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad',
         '9808795b f230fa14'].join(''),
        pre
      ]
    });
  }
}

/*
 * Helpers
 */

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

function getNAF(c, w, n) {
  assert(c instanceof BN);
  assert(!c.red);
  assert((w >>> 0) === w);
  assert(n instanceof BN);

  const naf = [];
  const ws = 1 << (w + 1);
  const k = c.clone();

  if (k.sign() < 0)
    k.imod(n);

  while (k.cmpn(1) >= 0) {
    let z = 0;

    if (k.isOdd()) {
      const mod = k.andln(ws - 1);

      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;

      k.isubn(z);
    }

    naf.push(z);

    // Optimization, shift by word if possible.
    const shift = (k.sign() !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;

    for (let i = 1; i < shift; i++)
      naf.push(0);

    k.iushrn(shift);
  }

  return naf;
}

function getJSF(c1, c2, n) {
  assert(c1 instanceof BN);
  assert(c2 instanceof BN);
  assert(!c1.red);
  assert(!c2.red);
  assert(n instanceof BN);

  const jsf = [[], []];
  const k1 = c1.clone();
  const k2 = c2.clone();

  let d1 = 0;
  let d2 = 0;

  if (k1.sign() < 0)
    k1.imod(n);

  if (k2.sign() < 0)
    k2.imod(n);

  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase.
    let m14 = (k1.andln(3) + d1) & 3;
    let m24 = (k2.andln(3) + d2) & 3;

    if (m14 === 3)
      m14 = -1;

    if (m24 === 3)
      m24 = -1;

    let u1 = 0;

    if (m14 & 1) {
      const m8 = (k1.andln(7) + d1) & 7;

      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }

    jsf[0].push(u1);

    let u2 = 0;

    if (m24 & 1) {
      const m8 = (k2.andln(7) + d2) & 7;

      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }

    jsf[1].push(u2);

    // Second phase.
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;

    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;

    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}

/*
 * Expose
 */

exports.Curve = Curve;
exports.Point = Point;
exports.ShortCurve = ShortCurve;
exports.ShortPoint = ShortPoint;
exports.JPoint = JPoint;
exports.MontCurve = MontCurve;
exports.MontPoint = MontPoint;
exports.EdwardsCurve = EdwardsCurve;
exports.EdwardsPoint = EdwardsPoint;
exports.P192 = P192;
exports.P224 = P224;
exports.P256 = P256;
exports.P384 = P384;
exports.P521 = P521;
exports.SECP256K1 = SECP256K1;
exports.X25519 = X25519;
exports.ED25519 = ED25519;
exports.X448 = X448;
exports.ED448 = ED448;

}).call(this,req("buffer").Buffer)
},{"../bn.js":31,"../internal/custom":73,"buffer":303}],104:[function(req,module,exports){
(function (Buffer){
/*!
 * dsa.js - DSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Digital_Signature_Algorithm
 *   http://csrc.nist.gov/publications/fips/archive/fips186-2/fips186-2.pdf
 *   http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 *   https://tools.ietf.org/html/rfc6979
 *   https://github.com/openssl/openssl/blob/master/crypto/dsa/dsa_ossl.c
 *   https://github.com/golang/go/blob/master/src/crypto/dsa/dsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 */

/* eslint func-name-matching: "off" */

'use strict';

const assert = req('bsert');
const BN = req('../bn.js');
const rng = req('../random');
const HmacDRBG = req('../hmac-drbg');
const SHA256 = req('../sha256');
const {countLeft, compareLeft} = req('../encoding/util');
const {probablyPrime} = req('../internal/primes');
const dsakey = req('../internal/dsakey');
const Signature = req('../internal/signature');
const asn1 = req('../encoding/asn1');
const openssl = req('../encoding/openssl');
const pkcs8 = req('../encoding/pkcs8');
const rfc3279 = req('../encoding/rfc3279');
const x509 = req('../encoding/x509');

const {
  DEFAULT_BITS,
  MIN_BITS,
  MAX_BITS,
  DSAKey,
  DSAParams,
  DSAPublicKey,
  DSAPrivateKey
} = dsakey;

/**
 * Generate params.
 * @param {Number} [bits=2048]
 * @returns {DSAParams}
 */

function paramsGenerate(bits) {
  if (bits == null)
    bits = DEFAULT_BITS;

  assert((bits >>> 0) === bits);

  if (bits < MIN_BITS || bits > MAX_BITS)
    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

  // OpenSSL behavior.
  const L = bits;
  const N = bits < 2048 ? 160 : 256;

  return generateParams(L, N);
}

/**
 * Generate params.
 * @param {Number} [bits=2048]
 * @returns {DSAParams}
 */

async function paramsGenerateAsync(bits) {
  return paramsGenerate(bits);
}

/**
 * Verify params.
 * @param {DSAParams} params
 * @returns {Boolean}
 */

function paramsVerify(params) {
  assert(params instanceof DSAParams);

  if (!isSaneParams(params))
    return false;

  const p = BN.decode(params.p);
  const q = BN.decode(params.q);
  const g = BN.decode(params.g);

  return g.powm(q, p).cmpn(1) === 0;
}

/**
 * Export params in OpenSSL ASN.1 format.
 * @param {DSAParams} params
 * @returns {Buffer}
 */

function paramsExport(params) {
  assert(params instanceof DSAParams);

  if (!isSaneParams(params))
    throw new Error('Invalid DSA parameters.');

  return new openssl.DSAParams(
    params.p,
    params.q,
    params.g
  ).encode();
}

/**
 * Import params in OpenSSL ASN.1 format.
 * @param {Buffer} raw
 * @returns {DSAParams}
 */

function paramsImport(raw) {
  const params = openssl.DSAParams.decode(raw);

  return new DSAPrivateKey(
    params.p.value,
    params.q.value,
    params.g.value
  );
}

/**
 * Export a public key to JWK JSON format.
 * @param {DSAParams} key
 * @returns {Object}
 */

function paramsExportJWK(key) {
  assert(key instanceof DSAParams);
  return key.toParams().toJSON();
}

/**
 * Import a public key from JWK JSON format.
 * @param {Object} json
 * @returns {DSAPublicKey}
 */

function paramsImportJWK(json) {
  return DSAParams.fromJSON(json);
}

/**
 * Generate private key from params.
 * @param {DSAParams} params
 * @returns {DSAPrivateKey}
 */

function privateKeyCreate(params) {
  assert(params instanceof DSAParams);

  if (!isSaneParams(params))
    throw new Error('Invalid DSA parameters.');

  const q = BN.decode(params.q);
  const p = BN.decode(params.p);
  const g = BN.decode(params.g);
  const x = BN.random(rng, 1, q);
  const y = powBlind(g, x, p, q);
  const key = new DSAPrivateKey();

  key.setParams(params);
  key.x = x.encode();
  key.y = y.encode();

  return key;
}

/**
 * Generate private key.
 * @param {Number} [bits=2048]
 * @returns {DSAPrivateKey}
 */

function privateKeyGenerate(bits) {
  const params = paramsGenerate(bits);
  return privateKeyCreate(params);
}

/**
 * Generate private key.
 * @param {Number} [bits=2048]
 * @returns {DSAPrivateKey}
 */

async function privateKeyGenerateAsync(bits) {
  const params = await paramsGenerateAsync(bits);
  return privateKeyCreate(params);
}

/**
 * Pre-compute a private key.
 * @param {DSAPrivateKey}
 * @returns {DSAPrivateKey}
 */

function privateKeyCompute(key) {
  assert(key instanceof DSAPrivateKey);

  if (!isSaneCompute(key))
    throw new Error('Invalid DSA private key.');

  if (!needsCompute(key))
    return key;

  const p = BN.decode(key.p);
  const q = BN.decode(key.q);
  const g = BN.decode(key.g);
  const x = BN.decode(key.x);
  const y = powBlind(g, x, p, q);

  key.y = y.encode();

  return key;
}

/**
 * Verify a private key.
 * @param {DSAPrivateKey} key
 * @returns {Boolean}
 */

function privateKeyVerify(key) {
  assert(key instanceof DSAPrivateKey);

  if (!isSanePrivateKey(key))
    return false;

  if (!publicKeyVerify(key))
    return false;

  const p = BN.decode(key.p);
  const q = BN.decode(key.q);
  const g = BN.decode(key.g);
  const x = BN.decode(key.x);
  const y = powBlind(g, x, p, q);

  return BN.decode(key.y).eq(y);
}

/**
 * Export a private key in OpenSSL ASN.1 format.
 * @param {DSAPrivateKey} key
 * @returns {Buffer}
 */

function privateKeyExport(key) {
  assert(key instanceof DSAPrivateKey);

  if (!isSanePrivateKey(key))
    throw new Error('Invalid DSA private key.');

  return new openssl.DSAPrivateKey(
    0,
    key.p,
    key.q,
    key.g,
    key.y,
    key.x
  ).encode();
}

/**
 * Import a private key in OpenSSL ASN.1 format.
 * @param {Buffer} raw
 * @returns {DSAPrivateKey}
 */

function privateKeyImport(raw) {
  const key = openssl.DSAPrivateKey.decode(raw);

  assert(key.version.toNumber() === 0);

  return new DSAPrivateKey(
    key.p.value,
    key.q.value,
    key.g.value,
    key.y.value,
    key.x.value
  );
}

/**
 * Export a private key in PKCS8 ASN.1 format.
 * @param {DSAPrivateKey} key
 * @returns {Buffer}
 */

function privateKeyExportPKCS8(key) {
  assert(key instanceof DSAPrivateKey);

  if (!isSanePrivateKey(key))
    throw new Error('Invalid DSA private key.');

  return new pkcs8.PrivateKeyInfo(
    0,
    asn1.objects.keyAlgs.DSA,
    new rfc3279.DSAParams(key.p, key.q, key.g),
    new asn1.Unsigned(key.x).encode()
  ).encode();
}

/**
 * Import a private key in PKCS8 ASN.1 format.
 * @param {Buffer} key
 * @returns {DSAPrivateKey}
 */

function privateKeyImportPKCS8(raw) {
  const pki = pkcs8.PrivateKeyInfo.decode(raw);
  const {algorithm, parameters} = pki.algorithm;

  assert(pki.version.toNumber() === 0);
  assert(algorithm.toString() === asn1.objects.keyAlgs.DSA);
  assert(parameters.node.type === asn1.types.SEQUENCE);

  const {p, q, g} = rfc3279.DSAParams.decodeBody(parameters.node.value);
  const x = asn1.Unsigned.decode(pki.privateKey.value);

  const key = new DSAPrivateKey(
    p.value,
    q.value,
    g.value,
    null,
    x.value
  );

  privateKeyCompute(key);

  return key;
}

/**
 * Export a private key to JWK JSON format.
 * @param {DSAPrivateKey} key
 * @returns {Object}
 */

function privateKeyExportJWK(key) {
  assert(key instanceof DSAPrivateKey);
  return key.toJSON();
}

/**
 * Import a private key from JWK JSON format.
 * @param {Object} json
 * @returns {DSAPrivateKey}
 */

function privateKeyImportJWK(json) {
  const key = DSAPrivateKey.fromJSON(json);

  privateKeyCompute(key);

  return key;
}

/**
 * Create a public key from a private key.
 * @param {DSAPrivateKey} key
 * @returns {DSAPublicKey}
 */

function publicKeyCreate(key) {
  assert(key instanceof DSAPrivateKey);

  const pub = new DSAPublicKey();

  pub.p = key.p;
  pub.q = key.q;
  pub.g = key.g;
  pub.y = key.y;

  return pub;
}

/**
 * Verify a public key.
 * @param {DSAKey} key
 * @returns {Boolean}
 */

function publicKeyVerify(key) {
  assert(key instanceof DSAKey);

  if (!paramsVerify(key))
    return false;

  if (!isSanePublicKey(key))
    return false;

  const p = BN.decode(key.p);
  const q = BN.decode(key.q);
  const y = BN.decode(key.y);

  return y.powm(q, p).cmpn(1) === 0;
}

/**
 * Export a public key to OpenSSL ASN.1 format.
 * @param {DSAKey} key
 * @returns {Buffer}
 */

function publicKeyExport(key) {
  assert(key instanceof DSAKey);

  if (!isSanePublicKey(key))
    throw new Error('Invalid DSA public key.');

  return new openssl.DSAPublicKey(
    key.y,
    key.p,
    key.q,
    key.g
  ).encode();
}

/**
 * Import a public key from OpenSSL ASN.1 format.
 * @param {Buffer} raw
 * @returns {DSAPublicKey}
 */

function publicKeyImport(raw) {
  const key = openssl.DSAPublicKey.decode(raw);

  return new DSAPublicKey(
    key.p.value,
    key.q.value,
    key.g.value,
    key.y.value
  );
}

/**
 * Export a public key to SubjectPublicKeyInfo ASN.1 format.
 * @param {DSAKey} key
 * @returns {Buffer}
 */

function publicKeyExportSPKI(key) {
  assert(key instanceof DSAKey);

  if (!isSanePublicKey(key))
    throw new Error('Invalid DSA public key.');

  // https://tools.ietf.org/html/rfc3279#section-2.3.2
  return new x509.SubjectPublicKeyInfo(
    asn1.objects.keyAlgs.DSA,
    new rfc3279.DSAParams(key.p, key.q, key.g),
    new asn1.Unsigned(key.y).encode()
  ).encode();
}

/**
 * Import a public key from SubjectPublicKeyInfo ASN.1 format.
 * @param {Buffer} raw
 * @returns {DSAPublicKey}
 */

function publicKeyImportSPKI(raw) {
  const spki = x509.SubjectPublicKeyInfo.decode(raw);
  const {algorithm, parameters} = spki.algorithm;

  assert(algorithm.toString() === asn1.objects.keyAlgs.DSA);
  assert(parameters.node.type === asn1.types.SEQUENCE);

  const {p, q, g} = rfc3279.DSAParams.decodeBody(parameters.node.value);
  const y = asn1.Unsigned.decode(spki.publicKey.rightAlign());

  return new DSAPublicKey(
    p.value,
    q.value,
    g.value,
    y.value
  );
}

/**
 * Export a public key to JWK JSON format.
 * @param {DSAKey} key
 * @returns {Object}
 */

function publicKeyExportJWK(key) {
  assert(key instanceof DSAKey);
  return key.toPublic().toJSON();
}

/**
 * Import a public key from JWK JSON format.
 * @param {Object} json
 * @returns {DSAPublicKey}
 */

function publicKeyImportJWK(json) {
  return DSAPublicKey.fromJSON(json);
}

/**
 * Convert R/S signature to DER.
 * @param {Buffer} sig
 * @param {Number} size
 * @returns {Buffer} DER-formatted signature.
 */

function signatureExport(sig, size) {
  if (size == null) {
    assert(Buffer.isBuffer(sig));
    assert((sig.length & 1) === 0);
    size = sig.length >>> 1;
  }

  return Signature.toDER(sig, size);
}

/**
 * Convert DER signature to R/S.
 * @param {Buffer} sig
 * @param {Number} size
 * @returns {Buffer} R/S-formatted signature.
 */

function signatureImport(sig, size) {
  return Signature.toRS(sig, size);
}

/**
 * Sign a message (R/S).
 * @param {Buffer} msg
 * @param {DSAPrivateKey} key - Private key.
 * @returns {Buffer} R/S-formatted signature.
 */

function sign(msg, key) {
  const sig = _sign(msg, key);
  return sig.encode(key.size());
}

/**
 * Sign a message (DER).
 * @param {Buffer} msg
 * @param {DSAPrivateKey} key - Private key.
 * @returns {Buffer} DER-formatted signature.
 */

function signDER(msg, key) {
  const sig = _sign(msg, key);
  return sig.toDER(key.size());
}

/**
 * Sign a message.
 * @private
 * @param {Buffer} msg
 * @param {DSAPrivateKey} key
 * @returns {Signature}
 */

function _sign(msg, key) {
  assert(Buffer.isBuffer(msg));
  assert(key instanceof DSAPrivateKey);

  if (!isSanePrivateKey(key))
    throw new Error('Invalid DSA private key.');

  const p = BN.decode(key.p);
  const q = BN.decode(key.q);
  const g = BN.decode(key.g);
  const x = BN.decode(key.x);
  const bytes = q.byteLength();

  // https://tools.ietf.org/html/rfc6979#section-3.2
  const m = reduce(msg, q);
  const keyX = x.encode('be', bytes);
  const nonce = m.encode('be', bytes);
  const drbg = new HmacDRBG(SHA256, keyX, nonce);

  for (;;) {
    const k = truncate(drbg.generate(bytes), q);

    if (k.isZero() || k.cmp(q) >= 0)
      continue;

    // r := (g^k mod p) mod q
    // Note: we could in theory cache the
    // blinding factor on the key object.
    // This would prevent an attacker from
    // gaining information from the initial
    // modular exponentiation.
    const r = powBlind(g, k, p, q).imod(q);

    if (r.isZero())
      continue;

    // Reasoning: fermat's little theorem
    // has better constant-time properties
    // than an EGCD.
    const ki = k.fermat(q);

    // Scalar blinding factor.
    const [blind, unblind] = getBlinding(q);

    // Blind.
    const bx = x.mul(blind).imod(q);
    const bm = m.mul(blind).imod(q);

    // s := ((r * x + m) * k^-1) mod q
    const s = r.mul(bx).imod(q)
               .iadd(bm).imod(q)
               .imul(ki).imod(q);

    // Unblind.
    s.imul(unblind).imod(q);

    if (s.isZero())
      continue;

    const sig = new Signature();

    sig.r = r.encode('be', bytes);
    sig.s = s.encode('be', bytes);

    return sig;
  }
}

/**
 * Verify a signature (R/S).
 * @private
 * @param {Buffer} msg
 * @param {Buffer} sig - R/S-formatted.
 * @param {DSAKey} key
 * @returns {Boolean}
 */

function verify(msg, sig, key) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(key instanceof DSAKey);

  if (sig.length !== key.size() * 2)
    return false;

  const s = Signature.decode(sig, key.size());

  try {
    return _verify(msg, s, key);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature.
 * @private
 * @param {Buffer} msg
 * @param {Signature} sig
 * @param {DSAKey} key
 * @returns {Boolean}
 */

function _verify(msg, sig, key) {
  assert(Buffer.isBuffer(msg));
  assert(sig instanceof Signature);
  assert(key instanceof DSAKey);

  const k = key.size();

  if (sig.r.length !== k)
    return false;

  if (sig.s.length !== k)
    return false;

  if (!isSanePublicKey(key))
    return false;

  const p = BN.decode(key.p);
  const q = BN.decode(key.q);
  const g = BN.decode(key.g);
  const y = BN.decode(key.y);
  const r = BN.decode(sig.r);
  const s = BN.decode(sig.s);

  if (r.isZero() || r.cmp(q) >= 0)
    return false;

  if (s.isZero() || s.cmp(q) >= 0)
    return false;

  const m = reduce(msg, q);
  const si = s.invert(q);
  const u1 = m.imul(si).imod(q);
  const u2 = r.mul(si).imod(q);
  const re = g.powm(u1, p)
              .imul(y.powm(u2, p))
              .imod(p)
              .imod(q);

  return re.cmp(r) === 0;
}

/**
 * Verify a signature (DER).
 * @param {Buffer} msg
 * @param {Buffer} sig - DER-formatted.
 * @param {DSAKey} key
 * @returns {Boolean}
 */

function verifyDER(msg, sig, key) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(key instanceof DSAKey);

  let s;
  try {
    s = Signature.fromDER(sig, key.size());
  } catch (e) {
    return false;
  }

  return _verify(msg, s, key);
}

/**
 * Perform a diffie-hellman.
 * @param {DSAKey} pub
 * @param {DSAPrivateKey} priv
 * @returns {Buffer}
 */

function derive(pub, priv) {
  assert(pub instanceof DSAKey);
  assert(priv instanceof DSAPrivateKey);

  if (!isSanePublicKey(pub))
    throw new Error('Invalid DSA public key.');

  if (!isSanePrivateKey(priv))
    throw new Error('Invalid DSA private key.');

  const pp = BN.decode(pub.p);
  const pq = BN.decode(pub.q);
  const pg = BN.decode(pub.g);
  const p = BN.decode(priv.p);
  const q = BN.decode(priv.q);
  const g = BN.decode(priv.g);

  if (!pp.eq(p) || !pq.eq(q) || !pg.eq(g))
    throw new Error('Incompatible DSA parameters.');

  const x = BN.decode(priv.x);
  const y = BN.decode(pub.y);

  // s := y^x mod p
  const s = powBlind(y, x, p, q);

  if (s.isZero())
    throw new Error('Invalid secret.');

  return s.encode('be', p.byteLength());
}

/**
 * Generate params from L and N.
 * @private
 * @param {Number} L
 * @param {Number} N
 * @returns {DSAParams}
 */

function generateParams(L, N) {
  assert((L >>> 0) === L);
  assert((N >>> 0) === N);

  if (!(L === 1024 && N === 160)
      && !(L === 2048 && N === 224)
      && !(L === 2048 && N === 256)
      && !(L === 3072 && N === 256)) {
    throw new Error('Invalid parameter sizes.');
  }

  if (L < MIN_BITS || L > MAX_BITS || (N & 7) !== 0)
    throw new Error('Invalid parameter sizes.');

  const qb = Buffer.alloc(N >>> 3);
  const pb = Buffer.alloc((L + 7) >>> 3);

  let q = null;
  let p = null;

generate:
  for (;;) {
    rng.randomFill(qb, 0, qb.length);

    qb[0] |= 0x80;
    qb[qb.length - 1] |= 1;

    q = BN.decode(qb);

    if (!probablyPrime(q, 64))
      continue;

    for (let i = 0; i < 4 * L; i++) {
      rng.randomFill(pb, 0, pb.length);

      pb[0] |= 0x80;
      pb[pb.length - 1] |= 1;

      p = BN.decode(pb);

      const rem = p.mod(q);
      rem.isubn(1);
      p.isub(rem);

      const bits = p.bitLength();

      if (bits < L || bits > MAX_BITS)
        continue;

      if (!probablyPrime(p, 64))
        continue;

      break generate;
    }
  }

  const h = new BN(2);
  const pm1 = p.subn(1);
  const e = pm1.div(q);

  for (;;) {
    const g = h.powm(e, p);

    if (g.cmpn(1) === 0) {
      h.iaddn(1);
      continue;
    }

    const params = new DSAParams();

    params.p = p.encode();
    params.q = q.encode();
    params.g = g.encode();

    return params;
  }
}

/*
 * Sanity Checking
 */

function isSaneParams(params) {
  assert(params instanceof DSAParams);

  const pb = countLeft(params.p);
  const qb = countLeft(params.q);
  const gb = countLeft(params.g);

  if (pb < MIN_BITS || pb > MAX_BITS)
    return false;

  if (qb !== 160 && qb !== 224 && qb !== 256)
    return false;

  if (gb < 2 || gb > pb)
    return false;

  if ((params.p[params.p.length - 1] & 1) === 0)
    return false;

  if ((params.q[params.q.length - 1] & 1) === 0)
    return false;

  if (compareLeft(params.g, params.p) >= 0)
    return false;

  return true;
}

function isSanePublicKey(key) {
  assert(key instanceof DSAKey);

  if (!isSaneParams(key))
    return false;

  const pb = countLeft(key.p);
  const yb = countLeft(key.y);

  if (yb === 0 || yb > pb)
    return false;

  if (compareLeft(key.y, key.p) >= 0)
    return false;

  return true;
}

function isSanePrivateKey(key) {
  assert(key instanceof DSAPrivateKey);

  if (!isSanePublicKey(key))
    return false;

  const qb = countLeft(key.q);
  const xb = countLeft(key.x);

  if (xb === 0 || xb > qb)
    return false;

  if (compareLeft(key.x, key.q) >= 0)
    return false;

  return true;
}

function isSaneCompute(key) {
  assert(key instanceof DSAPrivateKey);

  const pb = countLeft(key.p);
  const qb = countLeft(key.q);
  const gb = countLeft(key.g);
  const yb = countLeft(key.y);
  const xb = countLeft(key.x);

  if (pb < MIN_BITS || pb > MAX_BITS)
    return false;

  if (qb !== 160 && qb !== 224 && qb !== 256)
    return false;

  if (gb < 2 || gb > pb)
    return false;

  if ((key.p[key.p.length - 1] & 1) === 0)
    return false;

  if ((key.q[key.q.length - 1] & 1) === 0)
    return false;

  if (yb > pb)
    return false;

  if (xb === 0 || xb > qb)
    return false;

  if (compareLeft(key.g, key.p) >= 0)
    return false;

  if (compareLeft(key.y, key.p) >= 0)
    return false;

  if (compareLeft(key.x, key.q) >= 0)
    return false;

  return true;
}

function needsCompute(key) {
  assert(key instanceof DSAPrivateKey);
  return countLeft(key.y) === 0;
}

/*
 * Helpers
 */

function truncate(msg, q) {
  assert(Buffer.isBuffer(msg));
  assert(q instanceof BN);

  const bits = q.bitLength();

  assert((bits & 7) === 0);

  const bytes = bits >>> 3;

  if (msg.length > bytes)
    msg = msg.slice(0, bytes);

  return BN.decode(msg);
}

function reduce(msg, q) {
  return truncate(msg, q).imod(q);
}

function powBlind(y, x, p, q) {
  assert(y instanceof BN);
  assert(x instanceof BN);
  assert(p instanceof BN);
  assert(q instanceof BN);

  // Idea: exponentiate by scalar with a
  // blinding factor, similar to how we
  // blind multiplications in EC. Note
  // that it would be safer if we had the
  // blinding factor pregenerated for each
  // key:
  //   blind := rand(1..q-1)
  //   unblind := y^(-blind mod q) mod p
  //   scalar := (x + blind) mod q
  //   blinded := y^scalar mod p
  //   secret := (blinded * unblind) mod p
  const blind = BN.random(rng, 1, q);
  const unblind = y.powm(blind.neg().imod(q), p);
  const scalar = x.add(blind).imod(q);
  const blinded = y.powm(scalar, p);

  return blinded.imul(unblind).imod(p);
}

function getBlinding(q) {
  assert(q instanceof BN);

  // Scalar blinding factor.
  const blind = BN.random(rng, 1, q);
  const unblind = blind.fermat(q);

  return [blind, unblind];
}

/*
 * Expose
 */

exports.native = 0;
exports.DSAParams = DSAParams;
exports.DSAKey = DSAKey;
exports.DSAPublicKey = DSAPublicKey;
exports.DSAPrivateKey = DSAPrivateKey;
exports.paramsGenerate = paramsGenerate;
exports.paramsGenerateAsync = paramsGenerateAsync;
exports.paramsVerify = paramsVerify;
exports.paramsExport = paramsExport;
exports.paramsImport = paramsImport;
exports.paramsExportJWK = paramsExportJWK;
exports.paramsImportJWK = paramsImportJWK;
exports.privateKeyCreate = privateKeyCreate;
exports.privateKeyGenerate = privateKeyGenerate;
exports.privateKeyGenerateAsync = privateKeyGenerateAsync;
exports.privateKeyCompute = privateKeyCompute;
exports.privateKeyVerify = privateKeyVerify;
exports.privateKeyExport = privateKeyExport;
exports.privateKeyImport = privateKeyImport;
exports.privateKeyExportPKCS8 = privateKeyExportPKCS8;
exports.privateKeyImportPKCS8 = privateKeyImportPKCS8;
exports.privateKeyExportJWK = privateKeyExportJWK;
exports.privateKeyImportJWK = privateKeyImportJWK;
exports.publicKeyCreate = publicKeyCreate;
exports.publicKeyVerify = publicKeyVerify;
exports.publicKeyExport = publicKeyExport;
exports.publicKeyImport = publicKeyImport;
exports.publicKeyExportSPKI = publicKeyExportSPKI;
exports.publicKeyImportSPKI = publicKeyImportSPKI;
exports.publicKeyExportJWK = publicKeyExportJWK;
exports.publicKeyImportJWK = publicKeyImportJWK;
exports.signatureExport = signatureExport;
exports.signatureImport = signatureImport;
exports.sign = sign;
exports.signDER = signDER;
exports.verify = verify;
exports.verifyDER = verifyDER;
exports.derive = derive;

}).call(this,req("buffer").Buffer)
},{"../bn.js":31,"../encoding/asn1":46,"../encoding/openssl":55,"../encoding/pkcs8":60,"../encoding/rfc3279":61,"../encoding/util":63,"../encoding/x509":64,"../hmac-drbg":70,"../internal/dsakey":74,"../internal/primes":79,"../internal/signature":81,"../random":162,"../sha256":174,"bsert":190,"buffer":303}],105:[function(req,module,exports){
(function (Buffer){
/*!
 * ecdsa.js - wrapper for elliptic
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/ECDSA
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */

'use strict';

const assert = req('bsert');
const BN = req('../bn.js');
const eckey = req('../internal/eckey');
const Signature = req('../internal/signature');
const asn1 = req('../encoding/asn1');
const sec1 = req('../encoding/sec1');
const pkcs8 = req('../encoding/pkcs8');
const x509 = req('../encoding/x509');
const rng = req('../random');
const Schnorr = req('./schnorr');
const HmacDRBG = req('../hmac-drbg');
const curves = req('./curves');

/**
 * ECDSA
 */

class ECDSA {
  constructor(name, hash, pre) {
    assert(typeof name === 'string');
    assert(hash);

    this.id = name;
    this.type = 'short';
    this.hash = hash;
    this.native = 0;

    this._pre = pre || null;
    this._curve = null;
    this._schnorr = null;
  }

  get curve() {
    if (!this._curve) {
      this._curve = new curves[this.id](this._pre);
      this._curve.precompute(rng);
      this._pre = null;
    }
    return this._curve;
  }

  get schnorr() {
    if (!this._schnorr)
      this._schnorr = new Schnorr(this.curve, this.hash);
    return this._schnorr;
  }

  get size() {
    return this.curve.fieldSize;
  }

  get bits() {
    return this.curve.fieldBits;
  }

  privateKeyGenerate() {
    const a = BN.random(rng, 1, this.curve.n);
    return this.curve.encodeScalar(a);
  }

  privateKeyVerify(key) {
    assert(Buffer.isBuffer(key));

    let a = null;

    try {
      a = this.curve.decodeScalar(key);
    } catch (e) {
      return false;
    }

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      return false;

    return true;
  }

  privateKeyExport(key, compress) {
    const pub = this.publicKeyCreate(key, compress);
    return new sec1.ECPrivateKey(1, key, this.id, pub).encode();
  }

  privateKeyImport(raw) {
    const key = sec1.ECPrivateKey.decode(raw);
    const curve = key.namedCurveOID.toString();

    assert(key.version.toNumber() === 1);
    assert(curve === asn1.objects.curves[this.id]
        || curve === asn1.objects.NONE);

    const {value} = key.privateKey;

    if (value.length > this.curve.scalarSize)
      throw new Error('Invalid private key.');

    const a = BN.decode(value, this.curve.endian);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(a);
  }

  privateKeyExportPKCS8(key, compress) {
    const pub = this.publicKeyCreate(key, compress);
    const curve = asn1.objects.NONE;

    // https://tools.ietf.org/html/rfc5915
    return new pkcs8.PrivateKeyInfo(
      0,
      asn1.objects.keyAlgs.ECDSA,
      new asn1.OID(asn1.objects.curves[this.id]),
      new sec1.ECPrivateKey(1, key, curve, pub).encode()
    ).encode();
  }

  privateKeyImportPKCS8(raw) {
    const pki = pkcs8.PrivateKeyInfo.decode(raw);
    const {algorithm, parameters} = pki.algorithm;

    assert(pki.version.toNumber() === 0);
    assert(algorithm.toString() === asn1.objects.keyAlgs.ECDSA);
    assert(parameters.node.type === asn1.types.OID);
    assert(parameters.node.toString() === asn1.objects.curves[this.id]);

    return this.privateKeyImport(pki.privateKey.value);
  }

  privateKeyExportJWK(key) {
    return eckey.privateKeyExportJWK(this, key);
  }

  privateKeyImportJWK(json) {
    return eckey.privateKeyImportJWK(this, json);
  }

  privateKeyTweakAdd(key, tweak) {
    const t = this.curve.decodeScalar(tweak);

    if (t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const T = a.iadd(t).imod(this.curve.n);

    if (T.isZero())
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(T);
  }

  privateKeyTweakMul(key, tweak) {
    const t = this.curve.decodeScalar(tweak);

    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const T = a.imul(t).imod(this.curve.n);

    if (T.isZero())
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(T);
  }

  privateKeyReduce(key) {
    assert(Buffer.isBuffer(key));

    if (key.length > this.curve.scalarSize)
      key = key.slice(0, this.curve.scalarSize);

    const a = BN.decode(key, this.curve.endian).imod(this.curve.n);

    return this.curve.encodeScalar(a);
  }

  privateKeyNegate(key) {
    const a = this.curve.decodeScalar(key);

    if (a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const T = a.ineg().imod(this.curve.n);

    return this.curve.encodeScalar(T);
  }

  privateKeyInvert(key) {
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const T = a.invert(this.curve.n);

    if (T.isZero())
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(T);
  }

  publicKeyCreate(key, compress) {
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const A = this.curve.g.mulBlind(a);

    return A.encode(compress);
  }

  publicKeyConvert(key, compress) {
    const A = this.curve.decodePoint(key);
    return A.encode(compress);
  }

  publicKeyVerify(key) {
    assert(Buffer.isBuffer(key));

    try {
      this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return true;
  }

  publicKeyExport(key) {
    return this.publicKeyConvert(key, false).slice(1);
  }

  publicKeyImport(raw, compress) {
    assert(Buffer.isBuffer(raw));
    assert(raw.length === this.curve.fieldSize * 2);

    const key = Buffer.allocUnsafe(1 + raw.length);
    key[0] = 0x04;
    raw.copy(key, 1);

    return this.publicKeyConvert(key, compress);
  }

  publicKeyExportSPKI(key, compress) {
    // https://tools.ietf.org/html/rfc5480
    return new x509.SubjectPublicKeyInfo(
      asn1.objects.keyAlgs.ECDSA,
      new asn1.OID(asn1.objects.curves[this.id]),
      this.publicKeyConvert(key, compress)
    ).encode();
  }

  publicKeyImportSPKI(raw, compress) {
    const spki = x509.SubjectPublicKeyInfo.decode(raw);
    const {algorithm, parameters} = spki.algorithm;

    assert(algorithm.toString() === asn1.objects.keyAlgs.ECDSA);
    assert(parameters.node.type === asn1.types.OID);
    assert(parameters.node.toString() === asn1.objects.curves[this.id]);

    return this.publicKeyConvert(spki.publicKey.rightAlign(), compress);
  }

  publicKeyExportJWK(key) {
    return eckey.publicKeyExportJWK(this, key);
  }

  publicKeyImportJWK(json, compress) {
    return eckey.publicKeyImportJWK(this, json, compress);
  }

  publicKeyTweakAdd(key, tweak, compress) {
    const t = this.curve.decodeScalar(tweak);

    if (t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const A = this.curve.decodePoint(key);
    const T = this.curve.g.mul(t).add(A);

    return T.encode(compress);
  }

  publicKeyTweakMul(key, tweak, compress) {
    const t = this.curve.decodeScalar(tweak);

    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const A = this.curve.decodePoint(key);
    const T = A.mul(t);

    return T.encode(compress);
  }

  publicKeyAdd(key1, key2, compress) {
    const A1 = this.curve.decodePoint(key1);
    const A2 = this.curve.decodePoint(key2);
    const T = A1.add(A2);

    return T.encode(compress);
  }

  publicKeyCombine(keys, compress) {
    assert(Array.isArray(keys));

    let acc = this.curve.jpoint();

    for (const key of keys) {
      const point = this.curve.decodePoint(key);

      acc = acc.mixedAdd(point);
    }

    return acc.encode(compress);
  }

  publicKeyNegate(key, compress) {
    const A = this.curve.decodePoint(key);
    const T = A.neg();

    return T.encode(compress);
  }

  _signatureNormalize(sig) {
    const r = this.curve.decodeScalar(sig.r);
    const s = this.curve.decodeScalar(sig.s);

    if (r.isZero() || r.cmp(this.curve.n) >= 0)
      throw new Error('Invalid R value.');

    if (s.isZero() || s.cmp(this.curve.n) >= 0)
      throw new Error('Invalid S value.');

    if (s.cmp(this.curve.nh) > 0)
      sig.s = this.curve.encodeScalar(s.ineg().imod(this.curve.n));

    return sig;
  }

  signatureNormalize(raw) {
    const sig = Signature.decode(raw, this.curve.scalarSize);
    this._signatureNormalize(sig);
    return sig.encode(this.curve.scalarSize);
  }

  signatureNormalizeDER(raw) {
    const sig = Signature.fromDER(raw, this.curve.scalarSize);
    this._signatureNormalize(sig);
    return sig.toDER(this.curve.scalarSize);
  }

  signatureExport(sig) {
    return Signature.toDER(sig, this.curve.scalarSize);
  }

  signatureImport(sig) {
    return Signature.toRS(sig, this.curve.scalarSize);
  }

  _isLowS(sig) {
    const r = this.curve.decodeScalar(sig.r);
    const s = this.curve.decodeScalar(sig.s);

    if (r.isZero() || r.cmp(this.curve.n) >= 0)
      return false;

    if (s.isZero() || s.cmp(this.curve.n) >= 0)
      return false;

    return s.cmp(this.curve.nh) <= 0;
  }

  isLowS(sig) {
    assert(Buffer.isBuffer(sig));

    if (sig.length !== this.curve.scalarSize * 2)
      return false;

    const s = Signature.decode(sig, this.curve.scalarSize);

    return this._isLowS(s);
  }

  isLowDER(sig) {
    assert(Buffer.isBuffer(sig));

    let s;
    try {
      s = Signature.fromDER(sig, this.curve.scalarSize);
    } catch (e) {
      return false;
    }

    return this._isLowS(s);
  }

  _sign(msg, key) {
    assert(Buffer.isBuffer(msg));

    const N = this.curve.n;
    const Nh = this.curve.nh;
    const G = this.curve.g;
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(N) >= 0)
      throw new Error('Invalid private key.');

    // https://tools.ietf.org/html/rfc6979#section-3.2
    const m = this._reduce(msg);
    const nonce = this.curve.encodeScalar(m);
    const drbg = new HmacDRBG(this.hash, key, nonce);

    for (;;) {
      const bytes = drbg.generate(this.curve.scalarSize);
      const k = this._truncate(bytes);

      if (k.isZero() || k.cmp(N) >= 0)
        continue;

      const kp = G.mulBlind(k);

      if (kp.isInfinity())
        continue;

      const x = kp.getX();
      const r = x.mod(N);

      if (r.isZero())
        continue;

      // Reasoning: fermat's little theorem
      // has better constant-time properties
      // than an EGCD.
      const ki = k.fermat(N);

      // Scalar blinding factor.
      const [blind, unblind] = this.curve.getBlinding();

      // Blind.
      const ba = a.mul(blind).imod(N);
      const bm = m.mul(blind).imod(N);

      // s := ((r * a + m) * k^-1) mod n
      const s = r.mul(ba).imod(N)
                 .iadd(bm).imod(N)
                 .imul(ki).imod(N);

      // Unblind.
      s.imul(unblind).imod(N);

      if (s.isZero())
        continue;

      let param = (kp.getY().isOdd() ? 1 : 0)
                | (x.cmp(r) !== 0 ? 2 : 0);

      // Use complement of `s`, if it is > `n / 2`.
      if (s.cmp(Nh) > 0) {
        s.ineg().imod(N);
        param ^= 1;
      }

      const sig = new Signature();

      sig.r = this.curve.encodeScalar(r);
      sig.s = this.curve.encodeScalar(s);
      sig.param = param;

      return sig;
    }
  }

  sign(msg, key) {
    const sig = this._sign(msg, key);
    return sig.encode(this.curve.scalarSize);
  }

  signRecoverable(msg, key) {
    const sig = this._sign(msg, key);
    return [sig.encode(this.curve.scalarSize), sig.param];
  }

  signDER(msg, key) {
    const sig = this._sign(msg, key);
    return sig.toDER(this.curve.scalarSize);
  }

  signRecoverableDER(msg, key) {
    const sig = this._sign(msg, key);
    return [sig.toDER(this.curve.scalarSize), sig.param];
  }

  _verify(msg, sig, key) {
    const N = this.curve.n;
    const G = this.curve.g;
    const m = this._reduce(msg);
    const A = this.curve.decodePoint(key);
    const r = this.curve.decodeScalar(sig.r);
    const s = this.curve.decodeScalar(sig.s);

    if (r.isZero() || r.cmp(N) >= 0)
      return false;

    if (s.isZero() || s.cmp(N) >= 0)
      return false;

    const si = s.invert(N);
    const u1 = m.imul(si).imod(N);
    const u2 = r.mul(si).imod(N);

    if (this.curve.maxwellTrick) {
      // Greg Maxwell's trick, inspired by:
      // https://git.io/vad3K
      const p = G.jmulAdd(u1, A, u2);

      if (p.isInfinity())
        return false;

      // Compare `p.x` of Jacobian point with `r`,
      // this will do `p.x == r * p.z^2` instead
      // of multiplying `p.x` by the inverse of
      // `p.z^2`.
      return p.eqXToP(r);
    }

    const p = G.mulAdd(u1, A, u2);

    if (p.isInfinity())
      return false;

    return p.getX().mod(N).cmp(r) === 0;
  }

  verify(msg, sig, key) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert(Buffer.isBuffer(key));

    if (sig.length !== this.curve.scalarSize * 2)
      return false;

    const s = Signature.decode(sig, this.curve.scalarSize);

    try {
      return this._verify(msg, s, key);
    } catch (e) {
      return false;
    }
  }

  verifyDER(msg, sig, key) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert(Buffer.isBuffer(key));

    let s;
    try {
      s = Signature.fromDER(sig, this.curve.scalarSize);
    } catch (e) {
      return false;
    }

    try {
      return this._verify(msg, s, key);
    } catch (e) {
      return false;
    }
  }

  _recover(msg, sig, param) {
    const P = this.curve.p;
    const N = this.curve.n;
    const G = this.curve.g;
    const m = this._reduce(msg);
    const r = this.curve.decodeScalar(sig.r);
    const s = this.curve.decodeScalar(sig.s);

    if (r.isZero() || r.cmp(N) >= 0)
      throw new Error('Invalid R value.');

    if (s.isZero() || s.cmp(N) >= 0)
      throw new Error('Invalid S value.');

    const sign = param & 1;
    const high = param >>> 1;

    let x = r;

    if (high) {
      if (x.cmp(P.mod(N)) >= 0)
        throw new Error('Invalid R value.');

      x = x.add(N);
    }

    const kp = this.curve.pointFromX(x, sign);
    const ri = r.invert(N);
    const s1 = m.imul(ri).ineg().imod(N);
    const s2 = s.imul(ri).imod(N);
    const A = G.mulAdd(s1, kp, s2);

    if (A.isInfinity())
      throw new Error('Invalid point.');

    return A;
  }

  recover(msg, sig, param, compress) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert((param >>> 0) === param);
    assert((param & 3) === param, 'The recovery param is more than two bits.');

    if (sig.length !== this.curve.scalarSize * 2)
      return null;

    const s = Signature.decode(sig, this.curve.scalarSize);

    let point;
    try {
      point = this._recover(msg, s, param);
    } catch (e) {
      return null;
    }

    return point.encode(compress);
  }

  recoverDER(msg, sig, param, compress) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert((param >>> 0) === param);
    assert((param & 3) === param, 'The recovery param is more than two bits.');

    let s;
    try {
      s = Signature.fromDER(sig, this.curve.scalarSize);
    } catch (e) {
      return null;
    }

    let point;
    try {
      point = this._recover(msg, s, param);
    } catch (e) {
      return null;
    }

    return point.encode(compress);
  }

  derive(pub, priv, compress) {
    const a = this.curve.decodeScalar(priv);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const A = this.curve.decodePoint(pub);
    const point = A.mulBlind(a, rng);

    return point.encode(compress);
  }

  /*
   * Schnorr
   */

  schnorrSign(msg, key) {
    return this.schnorr.sign(msg, key);
  }

  schnorrVerify(msg, sig, key) {
    return this.schnorr.verify(msg, sig, key);
  }

  schnorrVerifyBatch(batch) {
    return this.schnorr.verifyBatch(batch);
  }

  /*
   * Helpers
   */

  _truncate(msg) {
    assert(Buffer.isBuffer(msg));

    const bits = this.curve.n.bitLength();
    const bytes = (bits + 7) >>> 3;

    if (msg.length > bytes)
      msg = msg.slice(0, bytes);

    const m = BN.decode(msg, this.curve.endian);
    const d = msg.length * 8 - bits;

    if (d > 0)
      m.iushrn(d);

    return m;
  }

  _reduce(msg) {
    return this._truncate(msg).imod(this.curve.n);
  }
}

/*
 * Expose
 */

module.exports = ECDSA;

}).call(this,req("buffer").Buffer)
},{"../bn.js":31,"../encoding/asn1":46,"../encoding/pkcs8":60,"../encoding/sec1":62,"../encoding/x509":64,"../hmac-drbg":70,"../internal/eckey":75,"../internal/signature":81,"../random":162,"./curves":103,"./schnorr":128,"bsert":190,"buffer":303}],106:[function(req,module,exports){
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/EdDSA
 *   https://en.wikipedia.org/wiki/EdDSA#Ed25519
 *   https://en.wikipedia.org/wiki/Curve25519
 *   https://tools.ietf.org/html/rfc7748
 *   https://tools.ietf.org/html/rfc7748#section-5
 *   https://tools.ietf.org/html/rfc8032
 *   https://tools.ietf.org/html/rfc8032#appendix-A
 *   https://tools.ietf.org/html/rfc8032#appendix-B
 */

'use strict';

const EDDSA = req('./eddsa');
const SHA512 = req('../sha512');
const pre = req('./precomputed/ed25519.json');

/*
 * Expose
 */

module.exports = new EDDSA('ED25519', 'X25519', SHA512, pre);

},{"../sha512":181,"./eddsa":108,"./precomputed/ed25519.json":122}],107:[function(req,module,exports){
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/EdDSA
 *   https://en.wikipedia.org/wiki/Curve448
 *   https://eprint.iacr.org/2015/625.pdf
 *   https://tools.ietf.org/html/rfc7748
 *   https://tools.ietf.org/html/rfc7748#section-5
 *   https://tools.ietf.org/html/rfc8032
 *   https://tools.ietf.org/html/rfc8032#appendix-A
 *   https://tools.ietf.org/html/rfc8032#appendix-B
 *   http://ed448goldilocks.sourceforge.net/
 *   git://git.code.sf.net/p/ed448goldilocks/code
 *   https://git.zx2c4.com/goldilocks/tree/src
 */

'use strict';

const EDDSA = req('./eddsa');
const SHAKE256 = req('../shake256');

/*
 * Expose
 */

module.exports = new EDDSA('ED448', 'X448', SHAKE256);

},{"../shake256":184,"./eddsa":108}],108:[function(req,module,exports){
(function (Buffer){
/*!
 * eddsa.js - ed25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/EdDSA
 *   https://tools.ietf.org/html/rfc7748
 *   https://tools.ietf.org/html/rfc7748#section-5
 *   https://tools.ietf.org/html/rfc8032
 *   https://tools.ietf.org/html/rfc8032#appendix-A
 *   https://tools.ietf.org/html/rfc8032#appendix-B
 *   https://eprint.iacr.org/2015/625.pdf
 *   http://ed448goldilocks.sourceforge.net/
 *   git://git.code.sf.net/p/ed448goldilocks/code
 *   https://git.zx2c4.com/goldilocks/tree/src
 */

'use strict';

const assert = req('bsert');
const curves = req('./curves');
const eckey = req('../internal/eckey');
const asn1 = req('../encoding/asn1');
const pkcs8 = req('../encoding/pkcs8');
const x509 = req('../encoding/x509');
const BN = req('../bn.js');
const rng = req('../random');

/*
 * Constants
 */

const SLAB = Buffer.alloc(1);

/*
 * EDDSA
 */

class EDDSA {
  constructor(id, xid, hash, pre) {
    assert(typeof id === 'string');
    assert(typeof xid === 'string');
    assert(hash);

    this.id = id;
    this.type = 'edwards';
    this.xid = xid;
    this.hash = hash;
    this._pre = pre || null;
    this._curve = null;
    this._x = null;
    this.native = 0;
  }

  get curve() {
    if (!this._curve) {
      this._curve = new curves[this.id](this._pre);
      this._curve.precompute(rng);
      this._pre = null;
    }
    return this._curve;
  }

  get x() {
    if (!this._x) {
      this._x = new curves[this.xid]();
      this._x.precompute(rng);
    }
    return this._x;
  }

  get size() {
    return this.curve.fieldSize;
  }

  get bits() {
    return this.curve.fieldBits;
  }

  hashInt(ph, ctx, ...items) {
    assert(ph == null || typeof ph === 'boolean');
    assert(ctx == null || Buffer.isBuffer(ctx));
    assert(!ctx || ctx.length <= 255);

    // eslint-disable-next-line
    const h = new this.hash();

    h.init();

    if (this.curve.context || ph != null) {
      // Prefix.
      h.update(this.curve.prefix);

      // Pre-hash Flag.
      SLAB[0] = ph & 0xff;
      h.update(SLAB);

      // Context.
      if (ctx) {
        SLAB[0] = ctx.length;
        h.update(SLAB);
        h.update(ctx);
      } else {
        SLAB[0] = 0x00;
        h.update(SLAB);
      }
    } else {
      assert(ctx == null, 'Must pass pre-hash flag with context.');
    }

    // Integers.
    for (const item of items)
      h.update(item);

    const hash = h.final(this.curve.fieldSize * 2);
    const num = BN.decode(hash, this.curve.endian);

    return num.imod(this.curve.n);
  }

  privateKeyGenerate() {
    return rng.randomBytes(this.curve.fieldSize);
  }

  scalarGenerate() {
    const scalar = rng.randomBytes(this.curve.scalarSize);
    return this.curve.clamp(scalar);
  }

  privateKeyExpand(secret) {
    assert(Buffer.isBuffer(secret));
    assert(secret.length === this.curve.fieldSize);

    const hash = this.hash.digest(secret, this.curve.fieldSize * 2);

    return this.curve.splitHash(hash);
  }

  privateKeyConvert(secret) {
    const [key] = this.privateKeyExpand(secret);
    return key;
  }

  privateKeyVerify(secret) {
    assert(Buffer.isBuffer(secret));
    return secret.length === this.curve.fieldSize;
  }

  scalarVerify(scalar) {
    return this.curve.isClamped(scalar);
  }

  scalarClamp(scalar) {
    assert(Buffer.isBuffer(scalar));
    assert(scalar.length === this.curve.scalarSize);

    if (!this.scalarVerify(scalar)) {
      scalar = Buffer.from(scalar);
      scalar = this.curve.clamp(scalar);
    }

    return scalar;
  }

  privateKeyExport(secret) {
    if (!this.privateKeyVerify(secret))
      throw new Error('Invalid private key.');

    return new asn1.OctString(secret).encode();
  }

  privateKeyImport(raw) {
    const secret = asn1.OctString.decode(raw);

    if (!this.privateKeyVerify(secret.value))
      throw new Error('Invalid private key.');

    return secret.value;
  }

  privateKeyExportPKCS8(secret) {
    // https://tools.ietf.org/html/draft-ietf-curdle-pkix-eddsa-00
    // https://tools.ietf.org/html/rfc8410
    // https://tools.ietf.org/html/rfc5958
    // https://tools.ietf.org/html/rfc7468
    return new pkcs8.PrivateKeyInfo(
      0,
      asn1.objects.curves[this.id],
      new asn1.Null(),
      this.privateKeyExport(secret)
    ).encode();
  }

  privateKeyImportPKCS8(raw) {
    const pki = pkcs8.PrivateKeyInfo.decode(raw);
    const version = pki.version.toNumber();
    const {algorithm, parameters} = pki.algorithm;

    assert(version === 0 || version === 1);
    assert(algorithm.toString() === asn1.objects.curves[this.id]);
    assert(parameters.node.type === asn1.types.NULL);

    return this.privateKeyImport(pki.privateKey.value);
  }

  privateKeyExportJWK(secret) {
    return eckey.privateKeyExportJWK(this, secret);
  }

  privateKeyImportJWK(json) {
    return eckey.privateKeyImportJWK(this, json);
  }

  scalarTweakAdd(scalar, tweak) {
    const a = this.curve.decodeScalar(scalar);
    const t = this.curve.decodeScalar(tweak);
    const s = a.iadd(t).imod(this.curve.n);

    if (s.isZero())
      throw new Error('Invalid scalar.');

    return this.curve.encodeScalar(s);
  }

  scalarTweakMul(scalar, tweak) {
    const a = this.curve.decodeScalar(scalar);
    const t = this.curve.decodeScalar(tweak);
    const s = a.imul(t).imod(this.curve.n);

    if (s.isZero())
      throw new Error('Invalid scalar.');

    return this.curve.encodeScalar(s);
  }

  scalarReduce(scalar) {
    assert(Buffer.isBuffer(scalar));

    if (scalar.length > this.curve.scalarSize)
      scalar = scalar.slice(0, this.curve.scalarSize);

    const s = BN.decode(scalar, this.curve.endian).imod(this.curve.n);

    return this.curve.encodeScalar(s);
  }

  scalarNegate(scalar) {
    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);
    const s = a.ineg().imod(this.curve.n);

    return this.curve.encodeScalar(s);
  }

  scalarInvert(scalar) {
    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);

    if (a.isZero())
      throw new Error('Invalid scalar.');

    const s = a.invert(this.curve.n);

    if (s.isZero())
      throw new Error('Invalid scalar.');

    return this.curve.encodeScalar(s);
  }

  publicKeyCreate(secret) {
    const key = this.privateKeyConvert(secret);
    return this.publicKeyFromScalar(key);
  }

  publicKeyFromScalar(scalar) {
    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);
    const A = this.curve.g.mulBlind(a);

    return A.encode();
  }

  publicKeyConvert(key) {
    const point = this.curve.decodePoint(key);
    return this.x.pointFromEdwards(point).encode();
  }

  publicKeyDeconvert(key, sign = false) {
    const point = this.x.decodePoint(key);
    return this.curve.pointFromMont(point, sign).encode();
  }

  publicKeyVerify(key) {
    assert(Buffer.isBuffer(key));

    try {
      this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return true;
  }

  publicKeyExport(key) {
    if (!this.publicKeyVerify(key))
      throw new Error('Invalid public key.');

    return Buffer.from(key);
  }

  publicKeyImport(raw) {
    if (!this.publicKeyVerify(raw))
      throw new Error('Invalid public key.');

    return Buffer.from(raw);
  }

  publicKeyExportSPKI(key) {
    // https://tools.ietf.org/html/rfc8410
    return new x509.SubjectPublicKeyInfo(
      asn1.objects.curves[this.id],
      new asn1.Null(),
      this.publicKeyExport(key)
    ).encode();
  }

  publicKeyImportSPKI(raw) {
    const spki = x509.SubjectPublicKeyInfo.decode(raw);
    const {algorithm, parameters} = spki.algorithm;

    assert(algorithm.toString() === asn1.objects.curves[this.id]);
    assert(parameters.node.type === asn1.types.NULL);

    return this.publicKeyImport(spki.publicKey.rightAlign());
  }

  publicKeyExportJWK(key) {
    return eckey.publicKeyExportJWK(this, key);
  }

  publicKeyImportJWK(json) {
    return eckey.publicKeyImportJWK(this, json, false);
  }

  publicKeyTweakAdd(key, tweak) {
    const t = this.curve.decodeScalar(tweak).imod(this.curve.n);
    const A = this.curve.decodePoint(key);
    const T = this.curve.g.mul(t);
    const point = T.add(A);

    return point.encode();
  }

  publicKeyTweakMul(key, tweak) {
    const t = this.curve.decodeScalar(tweak).imod(this.curve.n);
    const A = this.curve.decodePoint(key);
    const point = A.mul(t);

    return point.encode();
  }

  publicKeyAdd(key1, key2) {
    const A1 = this.curve.decodePoint(key1);
    const A2 = this.curve.decodePoint(key2);
    const point = A1.add(A2);

    return point.encode();
  }

  publicKeyCombine(keys) {
    assert(Array.isArray(keys));

    let acc = this.curve.point();

    for (const key of keys) {
      const point = this.curve.decodePoint(key);

      acc = acc.add(point);
    }

    return acc.encode();
  }

  publicKeyNegate(key) {
    const A = this.curve.decodePoint(key);
    const point = A.neg();

    return point.encode();
  }

  sign(msg, secret, ph, ctx) {
    const [key, prefix] = this.privateKeyExpand(secret);
    return this.signWithScalar(msg, key, prefix, ph, ctx);
  }

  signWithScalar(msg, scalar, prefix, ph, ctx) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(prefix));
    assert(prefix.length === this.curve.fieldSize);

    const N = this.curve.n;
    const G = this.curve.g;
    const k = this.hashInt(ph, ctx, prefix, msg);
    const Rraw = G.mulBlind(k).encode();
    const a = this.curve.decodeScalar(scalar);
    const Araw = G.mulBlind(a).encode();
    const e = this.hashInt(ph, ctx, Rraw, Araw, msg);

    // Scalar blinding factor.
    const [blind, unblind] = this.curve.getBlinding();

    // Blind.
    a.imul(blind).imod(N);
    k.imul(blind).imod(N);

    // S := (k + e * a) mod n
    const S = k.iadd(e.imul(a)).imod(N);

    // Unblind.
    S.imul(unblind).imod(N);

    // Note: S is technically a scalar, but
    // decode as field due to the useless byte.
    return Buffer.concat([Rraw, this.curve.encodeField(S)]);
  }

  signTweakAdd(msg, secret, tweak, ph, ctx) {
    const [key_, prefix_] = this.privateKeyExpand(secret);
    const key = this.scalarTweakAdd(key_, tweak);
    const expanded = this.hash.multi(prefix_, tweak, null,
                                     this.curve.fieldSize * 2);
    const prefix = expanded.slice(0, this.curve.fieldSize);

    return this.signWithScalar(msg, key, prefix, ph, ctx);
  }

  signTweakMul(msg, secret, tweak, ph, ctx) {
    const [key_, prefix_] = this.privateKeyExpand(secret);
    const key = this.scalarTweakMul(key_, tweak);
    const expanded = this.hash.multi(prefix_, tweak, null,
                                     this.curve.fieldSize * 2);
    const prefix = expanded.slice(0, this.curve.fieldSize);

    return this.signWithScalar(msg, key, prefix, ph, ctx);
  }

  verify(msg, sig, key, ph, ctx) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert(Buffer.isBuffer(key));
    assert(ph == null || typeof ph === 'boolean');
    assert(ctx == null || Buffer.isBuffer(ctx));
    assert(!ctx || ctx.length <= 255);

    if (!this.curve.context && ctx != null)
      assert(ph != null, 'Must pass pre-hash flag with context.');

    if (sig.length !== this.curve.fieldSize * 2)
      return false;

    if (key.length !== this.curve.fieldSize)
      return false;

    try {
      return this._verify(msg, sig, key, ph, ctx);
    } catch (e) {
      return false;
    }
  }

  _verify(msg, sig, key, ph, ctx) {
    const N = this.curve.n;
    const G = this.curve.g;
    const Rraw = sig.slice(0, this.curve.fieldSize);
    const Sraw = sig.slice(this.curve.fieldSize);
    const R = this.curve.decodePoint(Rraw);
    const S = this.curve.decodeField(Sraw);
    const A = this.curve.decodePoint(key);

    // Note: S is technically a scalar, but
    // decode as field due to the useless byte.
    if (S.cmp(N) >= 0)
      return false;

    // e = H(R, A, m).
    const e = this.hashInt(ph, ctx, Rraw, key, msg);

    // The spec says to check:
    //   G*S == R + A*e
    // But we can use shamir's trick to check:
    //   R == G*S - A*e
    const Rp = G.mulAdd(S, A, e.ineg().imod(N));

    // We don't allow points at infinity.
    // This is technically enforced by the
    // decodePoint call above, but put it
    // here to be more explicit.
    if (Rp.isInfinity())
      return false;

    return Rp.eq(R);
  }

  verifyBatch(batch, ph, ctx) {
    assert(Array.isArray(batch));
    assert(ph == null || typeof ph === 'boolean');
    assert(ctx == null || Buffer.isBuffer(ctx));
    assert(!ctx || ctx.length <= 255);

    if (!this.curve.context && ctx != null)
      assert(ph != null, 'Must pass pre-hash flag with context.');

    for (const item of batch) {
      assert(Array.isArray(item) && item.length === 3);

      const [msg, sig, key] = item;

      assert(Buffer.isBuffer(msg));
      assert(Buffer.isBuffer(sig));
      assert(Buffer.isBuffer(key));

      if (sig.length !== this.curve.fieldSize * 2)
        return false;

      if (key.length !== this.curve.fieldSize)
        return false;
    }

    try {
      return this._verifyBatch(batch, ph, ctx);
    } catch (e) {
      return false;
    }
  }

  _verifyBatch(batch, ph, ctx) {
    const N = this.curve.n;
    const G = this.curve.g;
    const points = [];
    const coeffs = [];

    let sum = null;

    for (const [msg, sig, key] of batch) {
      const Rraw = sig.slice(0, this.curve.fieldSize);
      const Sraw = sig.slice(this.curve.fieldSize);
      const R = this.curve.decodePoint(Rraw);
      const S = this.curve.decodeField(Sraw);
      const A = this.curve.decodePoint(key);

      // Note: S is technically a scalar, but
      // decode as field due to the useless byte.
      if (S.cmp(N) >= 0)
        return false;

      const e = this.hashInt(ph, ctx, Rraw, key, msg);

      if (sum === null) {
        sum = S;
        points.push(R, A);
        coeffs.push(new BN(1), e);
        continue;
      }

      const a = BN.random(rng, 1, N);
      const ea = e.imul(a).imod(N);

      sum.iadd(S.imul(a)).imod(N);
      points.push(R, A);
      coeffs.push(a, ea);
    }

    if (sum === null)
      return true;

    const lhs = G.mul(sum);
    const rhs = this.curve.mulAll(points, coeffs);

    return lhs.eq(rhs);
  }

  derive(pub, secret) {
    const priv = this.privateKeyConvert(secret);
    return this.deriveWithScalar(pub, priv);
  }

  deriveWithScalar(pub, scalar) {
    const s = this.curve.decodeScalar(scalar).imod(this.curve.n);
    const A = this.curve.decodePoint(pub);
    const point = A.mulBlind(s, rng);

    return point.encode();
  }

  exchange(pub, secret) {
    const priv = this.privateKeyConvert(secret);
    return this.exchangeWithScalar(pub, priv);
  }

  exchangeWithScalar(pub, scalar) {
    const s = this.x.decodeScalar(scalar);
    const A = this.x.decodePoint(pub);
    const point = A.mul(s);

    return point.encode();
  }
}

/*
 * Expose
 */

module.exports = EDDSA;

}).call(this,req("buffer").Buffer)
},{"../bn.js":31,"../encoding/asn1":46,"../encoding/pkcs8":60,"../encoding/x509":64,"../internal/eckey":75,"../random":162,"./curves":103,"bsert":190,"buffer":303}],109:[function(req,module,exports){
(function (Buffer){
/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */

'use strict';

const assert = req('bsert');
const SHA256 = req('./sha256');
const RIPEMD160 = req('./ripemd160');
const HMAC = req('../internal/hmac');

const rmd = new RIPEMD160();

/**
 * Hash160
 */

class Hash160 {
  constructor() {
    this.ctx = new SHA256();
  }

  init() {
    this.ctx.init();
    return this;
  }

  update(data) {
    this.ctx.update(data);
    return this;
  }

  final() {
    const out = Buffer.allocUnsafe(32);
    this.ctx._final(out);
    rmd.init();
    rmd.update(out);
    rmd._final(out);
    return out.slice(0, 20);
  }

  static hash() {
    return new Hash160();
  }

  static hmac() {
    return new HMAC(Hash160, 64);
  }

  static digest(data) {
    return Hash160.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 20);
    assert(Buffer.isBuffer(right) && right.length === 20);
    return Hash160.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = Hash160.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return Hash160.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

Hash160.native = 0;
Hash160.id = 'HASH160';
Hash160.size = 20;
Hash160.bits = 160;
Hash160.blockSize = 64;
Hash160.zero = Buffer.alloc(20, 0x00);
Hash160.ctx = new Hash160();

/*
 * Expose
 */

module.exports = Hash160;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"./ripemd160":125,"./sha256":133,"bsert":190,"buffer":303}],110:[function(req,module,exports){
(function (Buffer){
/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */

'use strict';

const assert = req('bsert');
const SHA256 = req('./sha256');
const HMAC = req('../internal/hmac');

/**
 * Hash256
 */

class Hash256 {
  constructor() {
    this.ctx = new SHA256();
  }

  init() {
    this.ctx.init();
    return this;
  }

  update(data) {
    this.ctx.update(data);
    return this;
  }

  final() {
    const out = Buffer.allocUnsafe(32);
    this.ctx._final(out);
    this.ctx.init();
    this.ctx.update(out);
    this.ctx._final(out);
    return out;
  }

  static hash() {
    return new Hash256();
  }

  static hmac() {
    return new HMAC(Hash256, 64);
  }

  static digest(data) {
    return Hash256.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 32);
    assert(Buffer.isBuffer(right) && right.length === 32);
    return Hash256.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = Hash256.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return Hash256.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

Hash256.native = 0;
Hash256.id = 'HASH256';
Hash256.size = 32;
Hash256.bits = 256;
Hash256.blockSize = 64;
Hash256.zero = Buffer.alloc(32, 0x00);
Hash256.ctx = new Hash256();

/*
 * Expose
 */

module.exports = Hash256;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"./sha256":133,"bsert":190,"buffer":303}],111:[function(req,module,exports){
(function (Buffer){
/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = 0x80000000;

const ROUND_CONST = new Uint32Array([
  0x00000001, 0x00000000, 0x00008082, 0x00000000,
  0x0000808a, 0x80000000, 0x80008000, 0x80000000,
  0x0000808b, 0x00000000, 0x80000001, 0x00000000,
  0x80008081, 0x80000000, 0x00008009, 0x80000000,
  0x0000008a, 0x00000000, 0x00000088, 0x00000000,
  0x80008009, 0x00000000, 0x8000000a, 0x00000000,
  0x8000808b, 0x00000000, 0x0000008b, 0x80000000,
  0x00008089, 0x80000000, 0x00008003, 0x80000000,
  0x00008002, 0x80000000, 0x00000080, 0x80000000,
  0x0000800a, 0x00000000, 0x8000000a, 0x80000000,
  0x80008081, 0x80000000, 0x00008080, 0x80000000,
  0x80000001, 0x00000000, 0x80008008, 0x80000000
]);

/**
 * Keccak
 */

class Keccak {
  /**
   * Create a Keccak Context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(50);
    this.block = Buffer.allocUnsafe(168);
    this.bs = 136;
    this.pos = FINALIZED;
  }

  init(bits = 256) {
    assert((bits & 0xffff) === bits);
    assert(bits >= 128);
    assert(bits <= 512);

    const rate = 1600 - bits * 2;
    assert(rate >= 0 && (rate & 63) === 0);

    this.bs = rate / 8;
    this.pos = 0;

    return this;
  }

  update(data) {
    assert(Buffer.isBuffer(data));
    assert(!(this.pos & FINALIZED), 'Context already finalized.');

    let len = data.length;
    let pos = this.pos;
    let off = 0;

    this.pos = (this.pos + len) % this.bs;

    if (pos > 0) {
      let want = this.bs - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < this.bs)
        return this;

      this.transform(this.block, 0);
    }

    while (len >= this.bs) {
      this.transform(data, off);
      off += this.bs;
      len -= this.bs;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);

    return this;
  }

  final(pad = 0x01, len) {
    if (len == null)
      len = 0;

    if (len === 0)
      len = 100 - this.bs / 2;

    assert((pad & 0xff) === pad);
    assert((len >>> 0) === len);
    assert(!(this.pos & FINALIZED), 'Context already finalized.');

    this.block.fill(0, this.pos, this.bs);
    this.block[this.pos] |= pad;
    this.block[this.bs - 1] |= 0x80;
    this.transform(this.block, 0);
    this.pos = FINALIZED;

    assert(len < this.bs);

    const out = Buffer.allocUnsafe(len);

    for (let i = 0; i < len; i++)
      out[i] = this.state[i >>> 2] >>> (8 * (i & 3));

    for (let i = 0; i < 50; i++)
      this.state[i] = 0;

    for (let i = 0; i < this.bs; i++)
      this.block[i] = 0;

    return out;
  }

  transform(block, off) {
    const count = this.bs / 4;
    const s = this.state;

    for (let i = 0; i < count; i++)
      s[i] ^= readU32(block, off + i * 4);

    for (let n = 0; n < 48; n += 2) {
      const c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      const c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      const c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      const c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      const c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      const c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      const c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      const c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      const c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      const c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      let h, l;

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      const b0 = s[0];
      const b1 = s[1];
      const b32 = (s[11] << 4) | (s[10] >>> 28);
      const b33 = (s[10] << 4) | (s[11] >>> 28);
      const b14 = (s[20] << 3) | (s[21] >>> 29);
      const b15 = (s[21] << 3) | (s[20] >>> 29);
      const b46 = (s[31] << 9) | (s[30] >>> 23);
      const b47 = (s[30] << 9) | (s[31] >>> 23);
      const b28 = (s[40] << 18) | (s[41] >>> 14);
      const b29 = (s[41] << 18) | (s[40] >>> 14);
      const b20 = (s[2] << 1) | (s[3] >>> 31);
      const b21 = (s[3] << 1) | (s[2] >>> 31);
      const b2 = (s[13] << 12) | (s[12] >>> 20);
      const b3 = (s[12] << 12) | (s[13] >>> 20);
      const b34 = (s[22] << 10) | (s[23] >>> 22);
      const b35 = (s[23] << 10) | (s[22] >>> 22);
      const b16 = (s[33] << 13) | (s[32] >>> 19);
      const b17 = (s[32] << 13) | (s[33] >>> 19);
      const b48 = (s[42] << 2) | (s[43] >>> 30);
      const b49 = (s[43] << 2) | (s[42] >>> 30);
      const b40 = (s[5] << 30) | (s[4] >>> 2);
      const b41 = (s[4] << 30) | (s[5] >>> 2);
      const b22 = (s[14] << 6) | (s[15] >>> 26);
      const b23 = (s[15] << 6) | (s[14] >>> 26);
      const b4 = (s[25] << 11) | (s[24] >>> 21);
      const b5 = (s[24] << 11) | (s[25] >>> 21);
      const b36 = (s[34] << 15) | (s[35] >>> 17);
      const b37 = (s[35] << 15) | (s[34] >>> 17);
      const b18 = (s[45] << 29) | (s[44] >>> 3);
      const b19 = (s[44] << 29) | (s[45] >>> 3);
      const b10 = (s[6] << 28) | (s[7] >>> 4);
      const b11 = (s[7] << 28) | (s[6] >>> 4);
      const b42 = (s[17] << 23) | (s[16] >>> 9);
      const b43 = (s[16] << 23) | (s[17] >>> 9);
      const b24 = (s[26] << 25) | (s[27] >>> 7);
      const b25 = (s[27] << 25) | (s[26] >>> 7);
      const b6 = (s[36] << 21) | (s[37] >>> 11);
      const b7 = (s[37] << 21) | (s[36] >>> 11);
      const b38 = (s[47] << 24) | (s[46] >>> 8);
      const b39 = (s[46] << 24) | (s[47] >>> 8);
      const b30 = (s[8] << 27) | (s[9] >>> 5);
      const b31 = (s[9] << 27) | (s[8] >>> 5);
      const b12 = (s[18] << 20) | (s[19] >>> 12);
      const b13 = (s[19] << 20) | (s[18] >>> 12);
      const b44 = (s[29] << 7) | (s[28] >>> 25);
      const b45 = (s[28] << 7) | (s[29] >>> 25);
      const b26 = (s[38] << 8) | (s[39] >>> 24);
      const b27 = (s[39] << 8) | (s[38] >>> 24);
      const b8 = (s[48] << 14) | (s[49] >>> 18);
      const b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= ROUND_CONST[n];
      s[1] ^= ROUND_CONST[n + 1];
    }
  }

  static hash() {
    return new Keccak();
  }

  static hmac(bits = 256, pad = 0x01, len) {
    assert((bits >>> 0) === bits);
    const bs = (1600 - bits * 2) / 8;
    return new HMAC(Keccak, bs, [bits], [pad, len]);
  }

  static digest(data, bits = 256, pad = 0x01, len) {
    return Keccak.ctx.init(bits).update(data).final(pad, len);
  }

  static root(left, right, bits = 256, pad = 0x01, len) {
    if (len == null)
      len = 0;

    if (len === 0) {
      assert((bits >>> 0) === bits);
      len = bits >>> 3;
    }

    assert((len >>> 0) === len);
    assert(Buffer.isBuffer(left) && left.length === len);
    assert(Buffer.isBuffer(right) && right.length === len);

    return Keccak.ctx.init(bits).update(left).update(right).final(pad, len);
  }

  static multi(x, y, z, bits = 256, pad = 0x01, len) {
    const ctx = Keccak.ctx;
    ctx.init(bits);
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final(pad, len);
  }

  static mac(data, key, bits = 256, pad = 0x01, len) {
    return Keccak.hmac(bits, pad, len).init(key).update(data).final();
  }
}

/*
 * Static
 */

Keccak.native = 0;
Keccak.id = 'KECCAK256';
Keccak.size = 32;
Keccak.bits = 256;
Keccak.blockSize = 136;
Keccak.zero = Buffer.alloc(32, 0x00);
Keccak.ctx = new Keccak();

/*
 * Helpers
 */

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

/*
 * Expose
 */

module.exports = Keccak;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],112:[function(req,module,exports){
(function (Buffer){
/*!
 * md4.js - MD4 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD4
 *   https://tools.ietf.org/html/rfc1320
 *   https://github.com/RustCrypto/hashes/blob/master/md4/src/lib.rs
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x67452301, 0xefcdab89,
  0x98badcfe, 0x10325476
]);

/**
 * MD4
 */

class MD4 {
  /**
   * Create a MD4 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(4);
    this.msg = new Uint32Array(16);
    this.block = Buffer.allocUnsafe(64);
    this.size = FINALIZED;
  }

  /**
   * Initialize MD4 context.
   */

  init() {
    this.state[0] = K[0];
    this.state[1] = K[1];
    this.state[2] = K[2];
    this.state[3] = K[3];
    this.size = 0;
    return this;
  }

  /**
   * Update MD4 context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize MD4 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(16));
  }

  /**
   * Update MD4 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 63;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 64) {
      this.transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize MD4 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size & 63;
    const len = this.size * 8;

    writeU32(DESC, len, 0);
    writeU32(DESC, len * (1 / 0x100000000), 4);

    this._update(PADDING, 1 + ((119 - pos) & 63));
    this._update(DESC, 8);

    for (let i = 0; i < 4; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 16; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform MD4 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];

    for (let i = 0; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    // round 1
    for (const i of [0, 4, 8, 12]) {
      a = op1(a, b, c, d, W[i], 3);
      d = op1(d, a, b, c, W[i + 1], 7);
      c = op1(c, d, a, b, W[i + 2], 11);
      b = op1(b, c, d, a, W[i + 3], 19);
    }

    // round 2
    for (let i = 0; i < 4; i++) {
      a = op2(a, b, c, d, W[i], 3);
      d = op2(d, a, b, c, W[i + 4], 5);
      c = op2(c, d, a, b, W[i + 8], 9);
      b = op2(b, c, d, a, W[i + 12], 13);
    }

    // round 3
    for (const i of [0, 2, 1, 3]) {
      a = op3(a, b, c, d, W[i], 3);
      d = op3(d, a, b, c, W[i + 8], 9);
      c = op3(c, d, a, b, W[i + 4], 11);
      b = op3(b, c, d, a, W[i + 12], 15);
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
  }

  static hash() {
    return new MD4();
  }

  static hmac() {
    return new HMAC(MD4, 64);
  }

  static digest(data) {
    return MD4.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 16);
    assert(Buffer.isBuffer(right) && right.length === 16);
    return MD4.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = MD4.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return MD4.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

MD4.native = 0;
MD4.id = 'MD4';
MD4.size = 16;
MD4.bits = 128;
MD4.blockSize = 64;
MD4.zero = Buffer.alloc(16, 0x00);
MD4.ctx = new MD4();

/*
 * Helpers
 */

function f(x, y, z) {
  return (x & y) | (~x & z);
}

function g(x, y, z) {
  return (x & y) | (x & z) | (y & z);
}

function h(x, y, z) {
  return x ^ y ^ z;
}

function op1(a, b, c, d, k, s) {
  return rotl32(a + f(b, c, d) + k, s);
}

function op2(a, b, c, d, k, s) {
  return rotl32(a + g(b, c, d) + k + 0x5a827999, s);
}

function op3(a, b, c, d, k, s) {
  return rotl32(a + h(b, c, d) + k + 0x6ed9eba1, s);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = MD4;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],113:[function(req,module,exports){
(function (Buffer){
/*!
 * md5.js - MD5 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD5
 *   https://tools.ietf.org/html/rfc1321
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
]);

const S = new Uint8Array([
  7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
  7, 12, 17, 22, 5,  9, 14, 20, 5,  9, 14, 20,
  5,  9, 14, 20, 5,  9, 14, 20, 4, 11, 16, 23,
  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,
  6, 10, 15, 21
]);

/**
 * MD5
 */

class MD5 {
  /**
   * Create a MD5 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(4);
    this.msg = new Uint32Array(16);
    this.block = Buffer.allocUnsafe(64);
    this.size = FINALIZED;
  }

  /**
   * Initialize MD5 context.
   */

  init() {
    this.state[0] = 0x67452301;
    this.state[1] = 0xefcdab89;
    this.state[2] = 0x98badcfe;
    this.state[3] = 0x10325476;
    this.size = 0;
    return this;
  }

  /**
   * Update MD5 context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize MD5 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(16));
  }

  /**
   * Update MD5 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 0x3f;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 64) {
      this.transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize MD5 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size % 64;
    const len = this.size * 8;

    writeU32(DESC, len, 0);
    writeU32(DESC, len * (1 / 0x100000000), 4);

    this._update(PADDING, 1 + ((119 - pos) % 64));
    this._update(DESC, 8);

    for (let i = 0; i < 4; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 16; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform MD5 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];
    let i = 0;

    for (; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (i = 0; i < 64; i++) {
      let f, g;

       if (i < 16) {
        f = (b & c) | (~b & d);
        g = i;
      } else if (i < 32) {
        f = (d & b) | (~d & c);
        g = (5 * i + 1) & 15;
      } else if (i < 48) {
        f = b ^ c ^ d;
        g = (3 * i + 5) & 15;
      } else {
        f = c ^ (b | ~d);
        g = (7 * i) & 15;
      }

      f >>>= 0;

      f = f + a + K[i] + W[g];
      f >>>= 0;

      a = d;
      d = c;
      c = b;
      b = b + rotl32(f, S[i]);
      b >>>= 0;
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
  }

  static hash() {
    return new MD5();
  }

  static hmac() {
    return new HMAC(MD5, 64);
  }

  static digest(data) {
    return MD5.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 16);
    assert(Buffer.isBuffer(right) && right.length === 16);
    return MD5.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = MD5.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return MD5.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

MD5.native = 0;
MD5.id = 'MD5';
MD5.size = 16;
MD5.bits = 128;
MD5.blockSize = 64;
MD5.zero = Buffer.alloc(16, 0x00);
MD5.ctx = new MD5();

/*
 * Helpers
 */

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = MD5;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],114:[function(req,module,exports){
(function (Buffer){
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MurmurHash
 *   https://github.com/aappleby/smhasher
 */

'use strict';

const assert = req('bsert');

/**
 * Murmur3 hash.
 * @param {Buffer} data
 * @param {Number} seed
 * @returns {Number}
 */

function sum(data, seed) {
  assert(Buffer.isBuffer(data));
  assert(typeof seed === 'number');

  const tail = data.length - (data.length % 4);
  const c1 = 0xcc9e2d51;
  const c2 = 0x1b873593;

  let h1 = seed | 0;

  for (let i = 0; i < tail; i += 4) {
    let k1 = readU32(data, i);

    k1 = mul32(k1, c1);
    k1 = rotl32(k1, 15);
    k1 = mul32(k1, c2);
    h1 ^= k1;
    h1 = rotl32(h1, 13);
    h1 = (mul32(h1, 5) + 0xe6546b64) | 0;
  }

  let k1 = 0;

  switch (data.length & 3) {
    case 3:
      k1 ^= data[tail + 2] << 16;
    case 2:
      k1 ^= data[tail + 1] << 8;
    case 1:
      k1 ^= data[tail + 0];
      k1 = mul32(k1, c1);
      k1 = rotl32(k1, 15);
      k1 = mul32(k1, c2);
      h1 ^= k1;
  }

  h1 ^= data.length;
  h1 ^= h1 >>> 16;
  h1 = mul32(h1, 0x85ebca6b);
  h1 ^= h1 >>> 13;
  h1 = mul32(h1, 0xc2b2ae35);
  h1 ^= h1 >>> 16;

  return h1 >>> 0;
}

/**
 * Murmur3 hash.
 * @param {Buffer} data
 * @param {Number} n
 * @param {Number} tweak
 * @returns {Number}
 */

function tweak(data, n, tweak) {
  assert(typeof n === 'number');
  assert(typeof tweak === 'number');

  const seed = mul32(n, 0xfba4c795) + (tweak | 0);

  return sum(data, seed);
}

/*
 * Helpers
 */

function mul32(a, b) {
  const alo = a & 0xffff;
  const blo = b & 0xffff;
  const ahi = a >>> 16;
  const bhi = b >>> 16;
  const lo = alo * blo;
  const hi = ahi * blo + bhi * alo + (lo >>> 16);

  return (hi << 16) | (lo & 0xffff);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

/**
 * Expose
 */

exports.native = 0;
exports.sum = sum;
exports.tweak = tweak;

}).call(this,{"isBuffer":req("../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],115:[function(req,module,exports){
/*!
 * p192.js - ECDSA-P192 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const ECDSA = req('./ecdsa');
const SHA256 = req('../sha256');

/*
 * Expose
 */

module.exports = new ECDSA('P192', SHA256);

},{"../sha256":174,"./ecdsa":105}],116:[function(req,module,exports){
/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const ECDSA = req('./ecdsa');
const SHA256 = req('../sha256');

/*
 * Expose
 */

module.exports = new ECDSA('P224', SHA256);

},{"../sha256":174,"./ecdsa":105}],117:[function(req,module,exports){
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const ECDSA = req('./ecdsa');
const SHA256 = req('../sha256');

/*
 * Expose
 */

module.exports = new ECDSA('P256', SHA256);

},{"../sha256":174,"./ecdsa":105}],118:[function(req,module,exports){
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const ECDSA = req('./ecdsa');
const SHA384 = req('../sha384');

/*
 * Expose
 */

module.exports = new ECDSA('P384', SHA384);

},{"../sha384":180,"./ecdsa":105}],119:[function(req,module,exports){
/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const ECDSA = req('./ecdsa');
const SHA512 = req('../sha512');

/*
 * Expose
 */

module.exports = new ECDSA('P521', SHA512);

},{"../sha512":181,"./ecdsa":105}],120:[function(req,module,exports){
(function (global,Buffer){
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PBKDF2
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc2898#section-5.2
 *   https://tools.ietf.org/html/rfc6070
 *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf
 *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 */

'use strict';

const assert = req('bsert');
const crypto = global.crypto || global.msCrypto || {};
const subtle = crypto.subtle || {};

/**
 * Perform key derivation using PBKDF2.
 * @param {Function} hash
 * @param {Buffer} pass
 * @param {Buffer} salt
 * @param {Number} iter
 * @param {Number} len
 * @returns {Buffer}
 */

function derive(hash, pass, salt, iter, len) {
  if (typeof pass === 'string')
    pass = Buffer.from(pass, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(pass));
  assert(Buffer.isBuffer(salt));
  assert((iter >>> 0) === iter);
  assert((len >>> 0) === len);

  const size = hash.size;
  const blocks = Math.ceil(len / size);
  const out = Buffer.allocUnsafe(blocks * size);
  const state = Buffer.allocUnsafe(salt.length + 4);

  salt.copy(state, 0);

  // Preemptively shorten key.
  if (pass.length > hash.blockSize) {
    pass = hash.digest(pass);
    assert(pass.length <= hash.blockSize);
  }

  for (let i = 0; i < blocks; i++) {
    const round = i + 1;

    state[salt.length + 0] = round >>> 24;
    state[salt.length + 1] = round >>> 16;
    state[salt.length + 2] = round >>> 8;
    state[salt.length + 3] = round;

    const block = hash.mac(state, pass);

    let mac = block;

    for (let j = 1; j < iter; j++) {
      mac = hash.mac(mac, pass);
      for (let k = 0; k < size; k++)
        block[k] ^= mac[k];
    }

    block.copy(out, i * size);
  }

  return out.slice(0, len);
}

/**
 * Execute pbkdf2 asynchronously.
 * @param {Function} hash
 * @param {Buffer} pass
 * @param {Buffer} salt
 * @param {Number} iter
 * @param {Number} len
 * @returns {Promise}
 */

async function deriveAsync(hash, pass, salt, iter, len) {
  if (typeof pass === 'string')
    pass = Buffer.from(pass, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(pass));
  assert(Buffer.isBuffer(salt));
  assert((iter >>> 0) === iter);
  assert((len >>> 0) === len);

  const name = getHash(hash);

  if (!subtle.importKey || !subtle.deriveBits || !name)
    return derive(hash, pass, salt, iter, len);

  const algo = { name: 'PBKDF2' };
  const use = ['deriveBits'];

  const options = {
    name: 'PBKDF2',
    salt: salt,
    iterations: iter,
    hash: name
  };

  const key = await subtle.importKey('raw', pass, algo, false, use);
  const out = await subtle.deriveBits(options, key, len * 8);

  return Buffer.from(out);
}

/*
 * Helpers
 */

function getHash(hash) {
  switch (hash.id) {
    case 'SHA1':
      return 'SHA-1';
    case 'SHA256':
      return 'SHA-256';
    case 'SHA384':
      return 'SHA-384';
    case 'SHA512':
      return 'SHA-512';
    default:
      return null;
  }
}

/*
 * Expose
 */

exports.native = 0;
exports.derive = derive;
exports.deriveAsync = deriveAsync;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},req("buffer").Buffer)
},{"bsert":190,"buffer":303}],121:[function(req,module,exports){
(function (Buffer){
/*!
 * poly1305.js - poly1305 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on floodyberry/poly1305-donna:
 *   Placed into the public domain by Andrew Moon.
 *   https://github.com/floodyberry/poly1305-donna
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Poly1305
 *   https://cr.yp.to/mac.html
 *   https://tools.ietf.org/html/rfc7539#section-2.5
 *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h
 */

'use strict';

const assert = req('bsert');

/**
 * Poly1305
 */

class Poly1305 {
  /**
   * Create a Poly1305 context.
   * @constructor
   */

  constructor() {
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.fin = 0;
    this.leftover = 0;
    this.buffer = Buffer.allocUnsafe(16);
  }

  /**
   * Initialize poly1305 with a key.
   * @param {Buffer} key
   */

  init(key) {
    assert(Buffer.isBuffer(key) && key.length >= 32);

    // r &= 0xffffffc0ffffffc0ffffffc0fffffff
    const t0 = readU16(key, 0);
    const t1 = readU16(key, 2);
    const t2 = readU16(key, 4);
    const t3 = readU16(key, 6);
    const t4 = readU16(key, 8);
    const t5 = readU16(key, 10);
    const t6 = readU16(key, 12);
    const t7 = readU16(key, 14);

    this.r[0] = t0 & 0x1fff;
    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
    this.r[5] = (t4 >>> 1) & 0x1ffe;
    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
    this.r[9] = (t7 >>> 5) & 0x007f;

    // h = 0
    for (let i = 0; i < 10; i++)
      this.h[i] = 0;

    // save pad for later
    for (let i = 0; i < 8; i++)
      this.pad[i] = readU16(key, 16 + (2 * i));

    this.leftover = 0;
    this.fin = 0;

    return this;
  }

  /**
   * Process 16 byte blocks.
   * @param {Buffer} data - Blocks.
   * @param {Number} bytes - Size.
   * @param {Number} m - Offset pointer.
   */

  blocks(data, bytes, m) {
    const hibit = this.fin ? 0 : (1 << 11); // 1 << 128
    const d = new Uint32Array(10);

    while (bytes >= 16) {
      // h += m[i]
      const t0 = readU16(data, m + 0);
      const t1 = readU16(data, m + 2);
      const t2 = readU16(data, m + 4);
      const t3 = readU16(data, m + 6);
      const t4 = readU16(data, m + 8);
      const t5 = readU16(data, m + 10);
      const t6 = readU16(data, m + 12);
      const t7 = readU16(data, m + 14);

      this.h[0] += t0 & 0x1fff;
      this.h[1] += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
      this.h[2] += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
      this.h[3] += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
      this.h[4] += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
      this.h[5] += ((t4 >>> 1)) & 0x1fff;
      this.h[6] += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
      this.h[7] += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
      this.h[8] += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
      this.h[9] += ((t7 >>> 5)) | hibit;

      // h *= r, (partial) h %= p
      let c = 0;
      for (let i = 0; i < 10; i++) {
        d[i] = c;

        for (let j = 0; j < 10; j++) {
          let a = this.h[j];

          if (j <= i)
            a *= this.r[i - j];
          else
            a *= 5 * this.r[i + 10 - j];

          d[i] += a;

          // Sum(h[i] * r[i] * 5) will overflow slightly
          // above 6 products with an unclamped r, so
          // carry at 5
          if (j === 4) {
            c = d[i] >>> 13;
            d[i] &= 0x1fff;
          }
        }

        c += d[i] >>> 13;
        d[i] &= 0x1fff;
      }

      c = (c << 2) + c; // c *= 5
      c += d[0];
      d[0] = (c & 0x1fff);
      c = c >>> 13;
      d[1] += c;

      for (let i = 0; i < 10; i++)
        this.h[i] = d[i];

      m += 16;
      bytes -= 16;
    }
  }

  /**
   * Update the MAC with data (will be
   * processed as 16 byte blocks).
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));

    let bytes = data.length;
    let m = 0;

    // handle leftover
    if (this.leftover) {
      let want = 16 - this.leftover;

      if (want > bytes)
        want = bytes;

      for (let i = 0; i < want; i++)
        this.buffer[this.leftover + i] = data[m + i];

      bytes -= want;
      m += want;

      this.leftover += want;

      if (this.leftover < 16)
        return this;

      this.blocks(this.buffer, 16, 0);
      this.leftover = 0;
    }

    // process full blocks
    if (bytes >= 16) {
      const want = bytes & ~(16 - 1);
      this.blocks(data, want, m);
      m += want;
      bytes -= want;
    }

    // store leftover
    if (bytes) {
      for (let i = 0; i < bytes; i++)
        this.buffer[this.leftover + i] = data[m + i];
      this.leftover += bytes;
    }

    return this;
  }

  /**
   * Finalize and return a 16-byte MAC.
   * @returns {Buffer}
   */

  final() {
    const mac = Buffer.allocUnsafe(16);
    const g = new Uint16Array(10);

    // process the remaining block
    if (this.leftover) {
      let i = this.leftover;
      this.buffer[i++] = 1;
      for (; i < 16; i++)
        this.buffer[i] = 0;
      this.fin = 1;
      this.blocks(this.buffer, 16, 0);
    }

    // fully carry h
    let c = this.h[1] >>> 13;
    this.h[1] &= 0x1fff;
    for (let i = 2; i < 10; i++) {
      this.h[i] += c;
      c = this.h[i] >>> 13;
      this.h[i] &= 0x1fff;
    }
    this.h[0] += c * 5;
    c = this.h[0] >>> 13;
    this.h[0] &= 0x1fff;
    this.h[1] += c;
    c = this.h[1] >>> 13;
    this.h[1] &= 0x1fff;
    this.h[2] += c;

    // compute h + -p
    g[0] = this.h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 0x1fff;
    for (let i = 1; i < 10; i++) {
      g[i] = this.h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 0x1fff;
    }

    // select h if h < p, or h + -p if h >= p
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      this.h[i] = (this.h[i] & mask) | g[i];

    // h = h % (2^128)
    this.h[0] = ((this.h[0]) | (this.h[1] << 13)) & 0xffff;
    this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 0xffff;
    this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 0xffff;
    this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 0xffff;
    this.h[4] = ((this.h[4] >>> 12)
      | (this.h[5] << 1) | (this.h[6] << 14)) & 0xffff;
    this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 0xffff;
    this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 0xffff;
    this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 0xffff;

    // mac = (h + pad) % (2^128)
    let f = this.h[0] + this.pad[0];
    this.h[0] = f;
    for (let i = 1; i < 8; i++) {
      f = this.h[i] + this.pad[i] + (f >>> 16);
      this.h[i] = f;
    }

    for (let i = 0; i < 8; i++)
      writeU16(mac, this.h[i], i * 2);

    // zero out the state
    for (let i = 0; i < 10; i++)
      this.h[i] = 0;

    for (let i = 0; i < 10; i++)
      this.r[i] = 0;

    for (let i = 0; i < 8; i++)
      this.pad[i] = 0;

    return mac;
  }

  /**
   * Return a MAC for a message and key.
   * @param {Buffer} msg
   * @param {Buffer} key
   * @returns {Buffer} MAC
   */

  static auth(msg, key) {
    const poly = new Poly1305();
    poly.init(key);
    poly.update(msg);
    return poly.final();
  }

  /**
   * Compare two MACs in constant time.
   * @param {Buffer} mac1
   * @param {Buffer} mac2
   * @returns {Boolean}
   */

  static verify(mac1, mac2) {
    assert(Buffer.isBuffer(mac1) && mac1.length === 16);
    assert(Buffer.isBuffer(mac2) && mac2.length === 16);

    let dif = 0;

    // Compare in constant time.
    for (let i = 0; i < 16; i++)
      dif |= mac1[i] ^ mac2[i];

    dif = (dif - 1) >>> 31;

    return (dif & 1) !== 0;
  }
}

/*
 * Static
 */

Poly1305.native = 0;

/*
 * Helpers
 */

function readU16(data, off) {
  return data[off++] + data[off] * 0x100;
}

function writeU16(dst, num, off) {
  dst[off++] = num;
  dst[off++] = num >>> 8;
  return off;
}

/*
 * Expose
 */

module.exports = Poly1305;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],122:[function(req,module,exports){
module.exports={
  "naf": {
    "wnd": 8,
    "points": [
      [
        "67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c",
        "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"
      ],
      [
        "49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233",
        "5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"
      ],
      [
        "14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107",
        "31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"
      ],
      [
        "357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c",
        "7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"
      ],
      [
        "14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb",
        "2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"
      ],
      [
        "107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed",
        "12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"
      ],
      [
        "4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1",
        "12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"
      ],
      [
        "7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a",
        "6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"
      ],
      [
        "1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472",
        "3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"
      ],
      [
        "6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716",
        "6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"
      ],
      [
        "2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95",
        "23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"
      ],
      [
        "794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455",
        "71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"
      ],
      [
        "163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079",
        "631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"
      ],
      [
        "39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d",
        "4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"
      ],
      [
        "38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9",
        "42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"
      ],
      [
        "5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1",
        "54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"
      ],
      [
        "7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb",
        "01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"
      ],
      [
        "05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3",
        "6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"
      ],
      [
        "624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3",
        "5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"
      ],
      [
        "1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9",
        "5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"
      ],
      [
        "396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101",
        "7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"
      ],
      [
        "53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50",
        "2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"
      ],
      [
        "34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368",
        "299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"
      ],
      [
        "5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618",
        "680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"
      ],
      [
        "27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb",
        "0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"
      ],
      [
        "0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a",
        "42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"
      ],
      [
        "4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a",
        "5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"
      ],
      [
        "1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817",
        "0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"
      ],
      [
        "4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc",
        "503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"
      ],
      [
        "3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6",
        "62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"
      ],
      [
        "649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a",
        "1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"
      ],
      [
        "3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56",
        "15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"
      ],
      [
        "2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1",
        "08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"
      ],
      [
        "642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385",
        "21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"
      ],
      [
        "38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef",
        "458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"
      ],
      [
        "372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db",
        "32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"
      ],
      [
        "1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77",
        "42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"
      ],
      [
        "38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5",
        "1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"
      ],
      [
        "176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7",
        "7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"
      ],
      [
        "042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6",
        "42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"
      ],
      [
        "1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108",
        "1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"
      ],
      [
        "613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5",
        "3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"
      ],
      [
        "27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9",
        "16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"
      ],
      [
        "769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2",
        "22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"
      ],
      [
        "795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d",
        "756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"
      ],
      [
        "644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46",
        "173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"
      ],
      [
        "5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110",
        "4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"
      ],
      [
        "296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848",
        "0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"
      ],
      [
        "408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f",
        "4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"
      ],
      [
        "07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07",
        "6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"
      ],
      [
        "2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873",
        "215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"
      ],
      [
        "1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a",
        "5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"
      ],
      [
        "5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97",
        "69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"
      ],
      [
        "24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb",
        "6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"
      ],
      [
        "64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538",
        "513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"
      ],
      [
        "47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e",
        "7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"
      ],
      [
        "4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f",
        "4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"
      ],
      [
        "3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5",
        "689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"
      ],
      [
        "61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10",
        "63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"
      ],
      [
        "03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414",
        "74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"
      ],
      [
        "0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9",
        "1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"
      ],
      [
        "797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe",
        "5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"
      ],
      [
        "735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd",
        "384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"
      ],
      [
        "6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac",
        "61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"
      ],
      [
        "5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773",
        "7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"
      ],
      [
        "31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8",
        "1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"
      ],
      [
        "424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0",
        "34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"
      ],
      [
        "33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247",
        "37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"
      ],
      [
        "5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb",
        "382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"
      ],
      [
        "3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036",
        "09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"
      ],
      [
        "62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973",
        "5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"
      ],
      [
        "0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3",
        "6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"
      ],
      [
        "6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e",
        "74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"
      ],
      [
        "4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f",
        "41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"
      ],
      [
        "65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741",
        "67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"
      ],
      [
        "1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8",
        "7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"
      ],
      [
        "2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71",
        "7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"
      ],
      [
        "1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6",
        "153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"
      ],
      [
        "0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129",
        "7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"
      ],
      [
        "01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4",
        "60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"
      ],
      [
        "79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150",
        "53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"
      ],
      [
        "220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498",
        "05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"
      ],
      [
        "1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18",
        "22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"
      ],
      [
        "35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b",
        "155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"
      ],
      [
        "3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd",
        "379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"
      ],
      [
        "6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf",
        "1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"
      ],
      [
        "7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123",
        "34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"
      ],
      [
        "354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf",
        "7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"
      ],
      [
        "1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850",
        "2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"
      ],
      [
        "533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d",
        "6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"
      ],
      [
        "4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b",
        "1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"
      ],
      [
        "3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265",
        "025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"
      ],
      [
        "5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6",
        "5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"
      ],
      [
        "2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9",
        "2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"
      ],
      [
        "79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1",
        "6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"
      ],
      [
        "57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63",
        "14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"
      ],
      [
        "6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523",
        "2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"
      ],
      [
        "749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9",
        "7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"
      ],
      [
        "340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1",
        "64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"
      ],
      [
        "4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109",
        "3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"
      ],
      [
        "34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb",
        "7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"
      ],
      [
        "820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e",
        "756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"
      ],
      [
        "0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3",
        "34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"
      ],
      [
        "5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b",
        "54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"
      ],
      [
        "755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc",
        "0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"
      ],
      [
        "5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b",
        "6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"
      ],
      [
        "1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46",
        "5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"
      ],
      [
        "4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d",
        "45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"
      ],
      [
        "63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91",
        "46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"
      ],
      [
        "5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87",
        "3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"
      ],
      [
        "62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec",
        "562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"
      ],
      [
        "14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556",
        "447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"
      ],
      [
        "1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6",
        "52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"
      ],
      [
        "5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3",
        "41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"
      ],
      [
        "4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607",
        "3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"
      ],
      [
        "62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08",
        "4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"
      ],
      [
        "4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757",
        "2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"
      ],
      [
        "5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3",
        "547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"
      ],
      [
        "424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015",
        "74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"
      ],
      [
        "54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd",
        "6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"
      ],
      [
        "732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb",
        "1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"
      ],
      [
        "74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb",
        "501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"
      ],
      [
        "04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7",
        "71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"
      ],
      [
        "2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794",
        "2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"
      ],
      [
        "555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6",
        "6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"
      ],
      [
        "4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6",
        "2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"
      ],
      [
        "5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16",
        "315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"
      ],
      [
        "6e8ce4ff435b7f78fd959b956096f7b9dda31809cd4e948377ee6f3f24c4d7ce",
        "20ab65593c0c68857a0a0cb0a22f1625fb81e49ff0bef0b2ccabc8e4eaba452c"
      ],
      [
        "4250fb17258f29af4c8b4dd59fdee32b9ba709f667a39e7168d20e5a1e2beb3b",
        "01eaeab26460b9079013b2bac1016183a20a5e4d1fc452193e32ae05ca04b42c"
      ],
      [
        "4f66888b34279e2fb1b1c7a684b74a84f9826a8f40bdb5608f4274a65cef4972",
        "7236db5046d96a87509b3a271a8b0cb67cb770281c316672dcf1169e77f28de4"
      ],
      [
        "6d4d4504110de524c435a59ffe8b7570d77eb52507def7bb6a1596b697cfe7d5",
        "4716501651820ab2361e4535517cfdb3c1c4f44b0161e31e24b177b647c5f96c"
      ],
      [
        "6657d1f83299702a22d196577f4b85f956f29b26ebe3b39d977307eb8ddebe80",
        "6633a0e9b15e49de32cc78c9ce7e49d349d1d662459501b87c31aa243571dce5"
      ],
      [
        "799a065c3b5fef8327923afd0ffd4f2f41482948315cba84ee0c254a956ad2a5",
        "183e6517633cf5a8a6a22d3cd425ed42076bab3c3aa56f89132d31956463da88"
      ],
      [
        "0ea3069d39e3c3b5d37ca713774112fe7608c28b9bd9d2ec006427aabaa614db",
        "74e800aa5bb0bd45bafb2a9de7b70d7936d9c667db66f458ff60d261518f6cb4"
      ],
      [
        "087378259b6f5aef854b2d233f6ebe0d9fea5bd737f6c41b554abbc049e73653",
        "56aaf06f833ec39a59ebbe553ab44bfe521dbd52bdd3a4759c80755d6f870245"
      ],
      [
        "11a1f76ea5aaef7f8dd9ba44e2d4ce91e1fe18734e6f5114ce2c068561fa8f32",
        "79ad4349e3f397428aae5d69a7357de5b8e7029dd1c7035aa69ca084743f1d62"
      ],
      [
        "6ab2f1efacd864f36a9154a409fdd5f22d9a99f1086ae59da1087eceb311cb00",
        "4ed69c61dac79eee2c837be2864bee315985e19748b4ef015e768348fdf83719"
      ],
      [
        "05a2f037f5242f6af3a189741b2bbc5f7536382fbc139b39d04b5bc21fd0c500",
        "7c88548712f1a4d102da46508dde80d716859f21ad965bb3b5142da9a16b37ec"
      ],
      [
        "267b47b3ae1aa634e0284a3fd97f80bd71802e406177ce6cb719a60c3ba9aad5",
        "75165decda59f284653e68d4211472ff4ee99b066ed838f8c1b4d080d945ccf2"
      ],
      [
        "7b8341474f38fb873af66e8a28c19a58758847c3f29f74ab086f84d0cf55f6cc",
        "50b004b7426686a35fc59a7c9001345318156dbd9868eda0952c536604bbd092"
      ],
      [
        "6b52fc1f93794346dca145b7ad11792a225f8b72017627e3c6e1fbf1eeb028d6",
        "18ffbef50c105a7e05e4ae1d14f423fbe9060098b970d515bfc23e92007f16de"
      ],
      [
        "26bbf07dd431a48348119f218dc215ec7d07057ba776de108195cd95261edc0c",
        "2fce75baf11a12623cff17630192528d16c8d9b512633da8e9876014f54813ea"
      ],
      [
        "5ee6a05213bfa885934bf03f1e1ad789e5f657c77c3b881d32d5262b14130936",
        "3cbf8c36b5dc06a7e229628b200369ef48c16d1e41dddb76f8ccae305bf6a335"
      ],
      [
        "7bad3c55c8be4438e2561bba8b422c4c0f2022759266c463bb2b686f21d01dc1",
        "13904df71433a4818aea9e986587ffdf41713a89efcf3dd44c292dee313fb99a"
      ],
      [
        "1cc77f113b9551f733831c659f465e51d2f2173cd6eb5afe0cf0cbeb39a41191",
        "4b2ee65201e200448eebd3b9366ac97fcdd3594076667d812ad07954c0565b5e"
      ],
      [
        "37d0d30f69749e6e3acbc36f4ed9e1bea5416d14f96a035c1e4f22ab2dad606f",
        "69e1730dc8f89270bdfb5c56d45f86c0239e2b257d71036a992ab64d04727c40"
      ],
      [
        "4970696edc00e129e59381f93d38e656747746f38db35357fbe6cd7e70002277",
        "04b252e2d26252da31b1c3019a9f9d9d784b358542df6a87fcbdccbd85b8138c"
      ],
      [
        "19b848f4a29e0db1b0087321399a4c131d259d0eccfc12311484f58fdb3395ad",
        "11b89d71a9a42a76cb5f656484b38bc03c888826ac8a3924b176531f53e060d9"
      ],
      [
        "53ea3d68baf61983f05e8bdea8c61f093e07fe2240c932e7e9df4e70cc6f13e9",
        "5a711d3edf8376c9578205260f66182001bd5a29f97cf5ec323aa8b5ddee8f49"
      ],
      [
        "6ad9880b460638abe06b272da675f418ac18ad1cc2b2537fee29b3c974b32122",
        "0cc43f190fa9251b4be23e8d91ff2dd60536e9272bc79a08cf69e164db7a9077"
      ],
      [
        "0c7c7d16010cfd786e9beb7de27537a10d68f7029638d9618b4df2580b940320",
        "4f20b9b4c96289da15b112c0d866427a60608ec321efef708f2a5dd094cd4d1d"
      ],
      [
        "3059e553e39f89ccfbd6d615b3bc157c98a91045f9dfa0c5db3e6b8c41b2c571",
        "3616d6865b02722b4ac7fe07a0866d1f8b0b70506e441ec8605d9826eb7de139"
      ],
      [
        "713363bc28f3a5534bd7f4859695711930fca45f754fac0ff80c089443b48842",
        "33c1613ecb4c44df51ea42c8e37368dc0a4ab9e0fee91f82ea0aaa345c27a815"
      ],
      [
        "2927a4add01113ccdabf7d9c75b80b04781f339b7cc6965c9239433dee6d53fe",
        "64a2f80647c31ebc917519fe784dfc72a5b1212adfbbfd233b4e04ca136b0ecb"
      ],
      [
        "5dc7e345c4813ff5a7aa732819703dabd74dc36ea078494f2b1f853efd13c5a3",
        "207fd983969337f92efe9458cddf32ef80851c94a20b5ff42847c1950a7466eb"
      ],
      [
        "1937d869b1fc51070a63ef0e66a451c334c9abdfae7626e49b81f39c689c8fba",
        "79c917849e0e6dfa1a9d0161fef413d42f88cfad6944cd3213f4d5097c7eac29"
      ],
      [
        "5d68b8af6f6f61c35d56bc169b66ec24c3eeae95a8c3f053175b554259e390f3",
        "099f135cad79d402fe318613cb042470a83223b75d68bddb749d7bc78af70f6c"
      ],
      [
        "2a3a220ef2d953294f75a51ab00057745c57d38068ecaee616fa7706c0fea9c9",
        "369bd48c9507c664831911f77e18099ff7b75731639ed47522c73db65cd0727d"
      ],
      [
        "503c51fd46f904ac18fa130c8775f4a25c6cfd3d3e3d25856f1ac392232af3c9",
        "741ab31a98f6f6eab6b97e314a31cd68e8bd53d862fac20b76e278b111ff3d8b"
      ],
      [
        "415204ccb6618c5741ca2d0bc203ef932653df47812b8f5a601a3bf5d82c371f",
        "11dfda8f782ff4b99b3056c7dfddbbdc3d4d33bf4b61295c194d5f24a2bd4ea7"
      ],
      [
        "0b00ff26f0ec6c6a85226503da85ac58e5f25989305eb5bf4cf842091b0e8f87",
        "64867cea0bbb05bbfd558edd88593b2b8bb27b906a0547cb2f4039bac8ae83da"
      ],
      [
        "41745c098c1df1129413b1b0dd4151e120cf68643fbf0fcbc69641d07bc01332",
        "63bbe508d7e29f75cb59f20933763e9801274f7a886e600e6e663a552e72ba66"
      ],
      [
        "2f36bb8ddaaa7ca88aa51b005fb092de4400d7a29649ae6ed92da8ee6f229a2c",
        "7d421097901e302a10f7ad41dde2ed0b299326990fbcc622c314888ea98da281"
      ],
      [
        "22ad92a4e203876fc59a5c2abc623cf21745ed8be40a65cd572ddad9a2e0d293",
        "42edec13ab3355693fe424d35069923c780fcf74d826d9426fdd2a904e848541"
      ],
      [
        "51ecfc646340b6f394a013d7c208f82eea817ed8ba720d2be0934f3e26b4b5c2",
        "3dadbb892c397cd7c75161e0373fea79242782284337c90dae4a2cac7c35aa9c"
      ],
      [
        "428093a6436596b07d4a3f209631ecbea01cdf7b1a318732ed1256742fc40607",
        "645a749dbcc67aea58ed76932decf2eda13d24a0f49ff43de8a0d340441cd95a"
      ],
      [
        "2dad41ee31d775f299826e76c85adbfddd379578a86e3bbc62212f86b13fac48",
        "79790864db95dd5350e87692eb61ebc0c401c70ca33be5b56f1c58a8b66ed722"
      ],
      [
        "60fa5a6e4711090be5033571e01fad7ade416fb404e4f991264dfa0ed8aec548",
        "3445b933cdd4209fded408a1fd9874905f613f8bafa443a9923ff675feca725e"
      ],
      [
        "2173535a88c0303d3d3cf599c170d584ce7e7042ed19d9f7bb108fb34c6afeec",
        "41bd601f481f6380d9fcd0f9d97dc810b2a58bb0d10a02bf5a3029c5bc1e96dd"
      ],
      [
        "5119eacaa5a402b6339fd1a7a99d6a273efcce53c9c7b1da34c5ffb58a6a42f6",
        "4031bd9e2e6be94310511f63641ffeb8bd52d39407513a4d37157591cb7ce237"
      ],
      [
        "223fb079fcbdb4060c8eed24aeec59bf1dabde9c765ce515da7cc35e45006795",
        "3cca088c665dec3ccd46ec63c105fa919dd2d4ff282c7abf96605a2eedc22ff1"
      ],
      [
        "1d6b03dafa4f876fa70c40410da3b7d49dd9059515e33597aa1780094dd9bab1",
        "1602f28a95939e1aae57199c8bcaf889847bea3b12ddeb3240aff2813569c488"
      ],
      [
        "1c3c71f7eb9d5606d6a470b9f356b1b62af2e5ef8da8c428117776bd05a19ceb",
        "66a7d0187c66691234ed1fbb5cbb4505f179074860e942c59d9dd9ca1e605cac"
      ],
      [
        "4ae6e93c685a17a54c9d1aab5d4288e4adae2759a06ec1ade10b746820513cff",
        "64d3e1d08dfa2405d25bb3c112edbc5171dbccddb4f18c1088425c4222a56b39"
      ],
      [
        "25014b8f9e4034b0227ab5527ec965a472986fa4673eb6a7b94a2ea6f7017ba2",
        "140479af99dff25d2d8d41d2573db6cf8c2473bd0679df29b798916f83d7fa65"
      ],
      [
        "1384970d11d0d75a02a82f8ff9e8efcb98e07b68a5d50943fa7639d7a79eec39",
        "41fcf4d9dc525842afad8541493cb18fb73c875e8688c208aa1d0f907f91df76"
      ],
      [
        "15ff1e140828ed211c2b0463f8dd71997f0785e1b0e6f6f170be2c5a77cd2b15",
        "523bf8e3e47f164cfffeeea69bfaa4edbdec0ac2a2618dacfc6f4900f9aecbff"
      ],
      [
        "361abee487c370c6fb8e9468547b1ee4ef63bc23e5813ab02ff21569b7627a5e",
        "59395b5dbfa4649393e197d93ded2a2c580511e857edbab2544228747a6368a5"
      ],
      [
        "2d63ce5778496e862aaf67e3482e451eb475e4a599a5426d94d8586948cccf15",
        "1c7a0dc6a5ea7d87ae3db30e5f128d8422a1d8490150b595d03a2da181403fa5"
      ],
      [
        "5d41e43873aad9f5b7eccf2600f9185ece50d4366759ef68c0a871dddab600a0",
        "2d805422b9423d58277399d61a97b1e29c5298c8636431ad039557c8879cf742"
      ],
      [
        "36fd686c22d85a1b87cb82a64c66be41dd4daa4849b392d90478f65a80f72313",
        "088d2690f57fd54c7ea6342a0db1847cf8b72a9cb89ddb23e31b11a3e16a9639"
      ],
      [
        "10c59e8c0ceadc1e90ec536043120468e2c5ac755f1b0a37f145e59bda1c54ab",
        "661cbbea984da20c572e2c4a90b1da4bbc6673d99b259b050835fea60ac6d302"
      ],
      [
        "6c289e1a464028e8a334ffc99a4c366d221bd08e30a8c2716767e6aed46dbe92",
        "2fde05bda0b2ffc4cc8ee0838fca390cc5d127fd5d32bc7e26ba56b3bda68141"
      ],
      [
        "3f2d617357cf963e237436643118228b9bfce2cb1ceea15bc870ca20dcaac44d",
        "218cf3a58c83e48cd78f3d331c2b2af05966845ac8c1d4c6935e9ee592db9e6b"
      ],
      [
        "46c427aceb6ed69d95955192f872801295982cd8d9dc07ed995822ab7aff4ce8",
        "16177f3315fd51bcd7071b76dac4fb077097e4c3e49db91da6c5a56851ca0850"
      ],
      [
        "10135d3c155f4e8fd1a3ba60a13bbb66dad69ebc2835631ab24844e2cd379252",
        "521b9718a2dd129f5b181ec9e600e56f64835bf812842308838661b75cf0db56"
      ],
      [
        "5102ee4455c40749214231e6db132c9ffb5f8dba18d205885362711280be7259",
        "38f1a0e1940df226ca4b322fe50e4049e5073464d26210558d929771602c1a3b"
      ],
      [
        "1ac8ac23c1d799a258cdfcb676c8a57de1a3c93142b87438453fc5c8658cf248",
        "0b315142874e501640770ee7c79c0e99d68144c219df84d7179897e960ee3e67"
      ],
      [
        "209a9281ee4ddad29844847a217eab9da909e285831c9a8eaa453491fd271191",
        "5ec36dd89cf705647e31a7720f078cf6670ce770353425a24b7519998c586546"
      ],
      [
        "34861086002857e66caffd95f74cfcc527c38a038d53ac75516040ec603380a5",
        "2d19967964cb91f2086106133279fefa668138600ff7ef70540e77f3ba781533"
      ],
      [
        "4f728faeb9ca147ca7f6b667064a639b6149fa3fc2393bd6a6765579bb6f3df6",
        "4dfbcc801a49d8a599d55c6667a7255a753c4b963b65a8fb081f767ab41df75a"
      ],
      [
        "1254fe80b8bc9966cf4a0719cceb56c10510253500ec2f3f113fbee032ec3992",
        "1d1fe9b9626c893cbd5e4477789f9bd28a0eeed6fbdd6f58eba1ddc4cbae3c02"
      ],
      [
        "14bb7ca2f1307a1ade7b0f264bec342c96c274e92750d2f15700f0267b70aee4",
        "57328e3c795413e389a797df7a5e6bf9ba10b4ff46cdc82788eb267d2e1a2ae3"
      ],
      [
        "1eb6cee3fa15e87e8cb6c0137ec8e2039a136f1ba078840a1fd2ad323974a0fd",
        "1b70e4ef91f9b582c68947cbc61ecd2e97f870bfc53461cc4f9fccc21ef5a099"
      ],
      [
        "78b32ebebc865ae25cf685b15fe41976eca95bdeaf78583aadcd9b09e76e6757",
        "1f3d7c35e601521023469f6c744cad00b6017bcbcec23ab9e774e6775041aa9a"
      ],
      [
        "69aa4285fb45951143f8b2419a4cffd2401708ab3810b2cf3e6ecc333cb39375",
        "1ae53b7c42fb50bc6225b375f540f2bd3b4491a24157eaaf1167ddfd4005581d"
      ],
      [
        "6b1de2d617077dd0e1fde2d9cec2580b9847ad55c13d22f7ce87f0d60cf8e925",
        "744a9109964e53a90e82e366bbcea4a81728e4f56164b13d91b36dab22e2fa88"
      ],
      [
        "13343db20e0cc36017b78a887489c80f68e425788c171f1e80985cbe91f85b04",
        "305d5dd7aff53e84ddbf991904e61fed5435a35f423859a551f7d83b7c4b7547"
      ],
      [
        "05c98760e8aa9f5cf2d49c578f8ea79ec52869ebd49f565ef35a35140781fa2b",
        "5f500b3ca13f9dd858b38a88d3e23b37772fe3f15bcbd8ff4c496addb20c0ac6"
      ],
      [
        "09369cef8ced766f0a2d6bbc1246c56f33895e760247f2046eca0636eb559096",
        "2e593210101ec033e927d7a429dcdad89223c94fc58d60c46516d19bc5f9b291"
      ],
      [
        "62cddbe2c489f669346184c8adfd4854d336101eca02274f0969c906ccce202c",
        "27f3b2a72bd115454d259561ede525e622aaef7b492848b266268289b2bcebc6"
      ],
      [
        "79db8d361ad46f4137d995bbace2c748bcd08a0202a9c98889d7dbf230ed619d",
        "6902743d0f4e52b5f88b3da026d34e240b93e86d11bcf3c139934b83d2edf77a"
      ],
      [
        "65d642b00bb660d2ff8aaea9aadacddde94c455d3718e726df76a7c5adf68a65",
        "5dd6a994a52e8e2cd6352145a9633ce80e0d1eb7ff5beb96dbf2fe9aced57501"
      ],
      [
        "1f7bba9076b4bb291a0f345934556f8e07acfb491e08a5d9153f1ffed84f4f54",
        "43ec3b2d420bc4c2497a9e8555dba0795df72ffc1c2ed79669170b7a2b729e32"
      ],
      [
        "29830057cdf1eb14a91c8fcddbf1b8c59fde0a290ecc7331d13e5d9e747c3b73",
        "2636fc1ea36e626bb42997e758463265ce2be4063c4f6db8d977001ba0d88c0e"
      ],
      [
        "7d9f4827d737984081059ee9bdae7057c161c3143e016d8e162ec0e67b8fe03e",
        "4b67e34af0f88c20e50e8346935c1642053d454fa950691411085580052c7eb6"
      ],
      [
        "22412f5b9b34894640cc0096fd3b80be9127ecb02122a7cc89ce28814239bdae",
        "445d1a0e813c0be24fd10aec59ab487462ee0c37273d7423fca5188bf936c6cb"
      ],
      [
        "2cc084f9206f7c2f921834a57adc63bdb4da013912ccf4d933f976eae392c34d",
        "16420684ab6d78525a09035d490871551bdbe91161793c9f33e0b1c30d7a8165"
      ],
      [
        "16446f0a72776bd8dc0d54a36178b38a87a4eb0dc9549610df6a086c2ae3cb84",
        "580de994cc4a5d7d2646ee7e75fd2cdbf6a9f8e1ce039db6868e638da5dca11c"
      ],
      [
        "52af1743b86e3d17f975be6cf1cd8880f1659017fcb277f72192768736750a20",
        "477d58d8a7d9a5a5028a0bfdb76487abfbe21495b2024a28a7e9b7d551feb797"
      ],
      [
        "3e5ce21e7da3ab4135dbece3eb767cb286bf6d4b5f41ce5a35ef5186db5286bf",
        "523029705df5c8e7345ac0aa7edc59f17621b3b3557ecb5642d9459a52a06562"
      ],
      [
        "49960d6223d87de0cb6c8876603cf9288d3e90aa7da10b52c73d00d4fa675b14",
        "4c09260311ad114cf476fc1d453e7beb89c87f31d316e0a643f6681d1120194d"
      ],
      [
        "7075911872b680611fb5dca5c51772b00ffefd9d974648415dc7147ef0c7e6bb",
        "23b6f7b92b3e7dce5e6fde00fd764c50f6abb84f7f5e0dc0f5d0032115a1f120"
      ],
      [
        "6a5c1244a150904e3d4210c4bffcfae83b7b7219265018805620e41fb81d70ee",
        "7a1f791b9e0fe2be3a8aae4b0e31c609223efadf55a1ae43809917dc0d8852aa"
      ],
      [
        "51aff4505befcb944de363c8bd86ee63ac48769aad103c5424d6170b666f55c5",
        "4db47927f30da6d127bb7fab8eb59bdac00e28cbb7c7f05dff428f178a444b93"
      ],
      [
        "56e5275b977796409f7bafa5cef8f0da244e8828cb224d98400823fa59b03b29",
        "4aa592efb59e793c0bbf1a7e8ccadb52ca626ca7db597d70fa73ec77a5626252"
      ],
      [
        "58d86a25d240c7b2bd2eaeaaa84b53cbe1a9e97b35e9ae1dac6fe9b06cb30fed",
        "054cdd4d77fc85194e15be50d09c071b61fd869da587ac4d2fe30c3a255002db"
      ],
      [
        "68b4b787a32491b488acc7d88e0a2d707a53472d5e3c5e242bc2475096ccfb98",
        "2f783cffcb85e7eb63d613f7ba17b6d246305c460b2d5f392d2c7514ee6b1ad1"
      ],
      [
        "291cc4f6b8975afb30ca08b542f07a092e76a3a809bb2c929a717a4fa1d00c55",
        "6250b9415ce137dd381edda76db963cf36903f98575e326b63a8f1dc24152c9f"
      ],
      [
        "0e39aca3dd3ff7267e865692d6b38da8acdcc4fbface07fb059ec73a402db127",
        "7f35c75ad87d1db5f4b8b970c7363d5fb64280d6f04e90cfd6473817155a64bd"
      ],
      [
        "7eeb84fee483043438da6451f3a33015e13a5f2d7290b592584e9eab69091a30",
        "2f07ff406b58e49a38e4b3e3ae3013666a5655d11ecc459b29428cedb4d209d7"
      ],
      [
        "4f6bf06b632affac512b5990b09084cdb46b8b282128b24e48afaf0d2b986050",
        "5021650e557c655e4e1004602df0dec8549943c7cf791174149f6a3818b5a659"
      ],
      [
        "56ce4f996ff9b9958829658f5f84f509f5e997c14ac00855716687876c11a7e5",
        "7dcee12d62c98bd190feceea11a7789d32e2e7634899bdd5430454640e129109"
      ],
      [
        "3883ba700ba2bca283e715cf6ee29e4aa86838b61223b85d15a8b5b19129431f",
        "213b1dbb4688bc2f1bf220f9d8c30ef38aeb6bbe46925e277b86ed4a6c9f272c"
      ],
      [
        "7833d5b192b75cb178d88ecf949fc6d6dddfe609e648b51ec665b885c44fd4e5",
        "13a4100a27c27149876a3209a539441c946e0d78bb3462b2f8e1cd45944b5e93"
      ],
      [
        "474ef17c5df5652054dc1c5ba6d81a4ff3d8de6f7e48dfc0758a7ca22ba0636b",
        "0a6fd84785d6c45be2681436072b7ed914b509efa16213d8664a4a61d4bcd666"
      ],
      [
        "681cc67835f29a934c44da7ec72df40e392f357da86dad3c47aaefef11c361b4",
        "6ae7ff27fbf6fd87fd2f2574ada80381a416c6a7d22d4b6a1a572dfcff9050be"
      ],
      [
        "23a9aaa560722a38f22a685f5d75758e33abe0ae9af80d09e8109d22f0987342",
        "7f35394e0ad8dc1a54e807e7bfb985a74659a199486634d9b107c3baf4145003"
      ],
      [
        "38f0da841b2a6cf2d035eb86b4cc9b7b2f3b8ed2100b02dbe39efe8d7cfdad34",
        "07bf151a32e597897e9e54396a8a072a63b94a0d35388777d465cad4b79f7958"
      ],
      [
        "05a4bcc20a6da41c58e0ee9e468621a3565584b0b42ddf2afb39fab30c27774b",
        "314f97dd80045fe9198859f24193b42727c2bb6fbbf5faebca06f8e62b2e31f9"
      ],
      [
        "02df6760144b40e890059474a8a34fd3c36e702c32b5d60ca1e9d6fd413283d5",
        "7f395267bb23f74bfa9f7754b070c15d20e0ac11a08c00847ec4b11adb12328f"
      ],
      [
        "436eab769ceb9d0adb72427e73e8951217de6195a38b5bb91a2dcf483896297c",
        "7cf74a7399df1e983d94befd500aa939f3222b817df2afb8f8611c634ec00662"
      ],
      [
        "12051e9fce5f836d5e1fcd86af484c5a145f4f1a4324703902e78c0b29560f48",
        "0f407d043401938c60f7afc04bd4922761a8ddb060158ebb0bcab3d77408a446"
      ],
      [
        "2271b9bbda630e6223d69d01f8fd774a92675faeed9d86f9e24e20c0b239285c",
        "253ed8aa1d2ebd5fa9453bf8484d9290ff93cca9e5e63b9dce13e08222473161"
      ],
      [
        "635c9b1ed13d2a101308d86dbf3e1e901b0d81c4fa07e698d9416bc0df69514d",
        "53e499170b097288d4b50764f408ee92f95775caf98b071132769dedb64983a8"
      ],
      [
        "73d7aae51b0f1cc2d2ce9b61fa0711d66258e6ffd91323501d4ea82dc55c4700",
        "22a58bd3fd2262c04e06ef42bf272ffe8448553245a6f6d98448f858d6f0b46b"
      ],
      [
        "6222ac763ea4a02e3c156353e2ea5570b88c903f27ba8d3d282bee6c88a9c5d1",
        "2fc639678c458fab70168bbbf24e3df9788d5ee0ab9f278d8fbb7e409514dfab"
      ],
      [
        "0c937e44df313ebc4b6a3d26a6fd8ecc4d611a2c780f982cbbd4be36539250d2",
        "3badafed6119ea992aca91bdafadcb6fd9af057ec9edaf05991cd039c2306828"
      ],
      [
        "0cbc83d380b735f49c5452042d08bb70889aad64f281b43f02f165dfb63e8875",
        "6ec90d255d8465e4d7b0887cf9096a0d5730b284297eb83fcdfec427e9d13c88"
      ],
      [
        "421d88d9628b1bc9f8706535607badc67f2159866e8c86f9107923de4ec4d1cf",
        "6377757c12773b61cf8762e174388d9044cee58ada97205b15f512debe0febe0"
      ],
      [
        "61433cfdbd3baee86c1129fbfd352088e93d8958c0c4849bb892e1f53a80b348",
        "3dbd49aa3d051087d321b9dde8cfe6fbce453ca144be359af3915e50029d1022"
      ],
      [
        "462f746a5dce61a97b79e44ae35ea959210498457292a821a90a479c3499451b",
        "4b60305fc76bf46682ef319722daf676cb90488649d1b2f06b5dab271cd0305e"
      ],
      [
        "3236be915fe5626c686610ad7c1454185507dda85f4b4df1455d39056afe4c35",
        "7c359817e89a8122053cda41630e7a8f2c50fee3673a0a11cd1bc166394f99d0"
      ],
      [
        "0c91974871d7410026279e9e046a0648f91186ade3350cd08bb93ee6c169a85c",
        "0fbc963036298937d515a82c09f86d0ae50b0c33f0712b62f6d77d17bd27b730"
      ],
      [
        "2328943b564d46447982ee0417259fa964669ac4ea0d434ad2e7d4abb470aed3",
        "4776061620e4b6aa7cd558afd982a83c4c64f41e54abcfef7acd3ef7668917cb"
      ],
      [
        "1425296bb84d092a568ca4c5ec6dcf9aa350706656274fe43e76e74ad80417a6",
        "4cd43b4e74ff6e04b22bc3ca5d1582cba0fea687ae079fcc48a6f3e825d140a5"
      ],
      [
        "466e94ff9b76d434ab6f92e0d8666c172e211f53ccd3108e3545ffdeebc91f0c",
        "28647935c52cdc8551206cebb197cd41b30c6401b15c6e6745564fa5f62ce6e5"
      ],
      [
        "153c6502188a2c83fe3ae34385f915b1f02c1dac2ff05db5d55636e9db032e35",
        "0647caf8c4568934bcd46f7934879468860271cc76ca0a05cf40aa1242ef8a80"
      ],
      [
        "56154c9ef883c62e3233d2a1362be83a4469bfc6ce4e043e25c018e659cb247a",
        "344b730b93e50a9dceead7952312df69111081d40b3193a4ab977385d97e52a6"
      ],
      [
        "1e4339a9852d90defdb934eccad0103aa87aced46841630965c8dbc51a2ef8fc",
        "55b6cce5a6b68e0a4123edc1c3d35469b6e67b3e54b3b204dafeea3a4dcd974b"
      ],
      [
        "5c16b6be79f4b379768b8ce151f4bfdff4155c8022b19e1997795dd01b58565c",
        "31f8528fe4abe24879ed8fb6ac93b21aeb00ed7b7f3f9e9ee5d169ef3ef34eab"
      ],
      [
        "048406faca54999917155d10f343d555eaf3e5f69596bd839c38a2a6b0e2716c",
        "28e1cf0ea835571ec92d216a8950fda4c41f75ed653558c668d44eba10fbbf71"
      ],
      [
        "3b602a59f473100418c3ee0d66fb8e0cb12f6e4630f7a903ad843ebd1c40e53a",
        "40101cf8e94f2ecfe0f5c7209748ee0c94e69694e6d25ef19611d229cbfebbd1"
      ],
      [
        "69d7fb81fdcba378269018cfa43ba98772bf485727ee3e0034b12a03235fc762",
        "2e3b4262e2eea3aabff66076f691f8680d585fdec3ed8b33d8619a30b46d9c1a"
      ]
    ]
  },
  "doubles": {
    "step": 4,
    "points": [
      [
        "23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8",
        "709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"
      ],
      [
        "5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556",
        "0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"
      ],
      [
        "7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea",
        "59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"
      ],
      [
        "5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565",
        "2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"
      ],
      [
        "06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed",
        "07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"
      ],
      [
        "0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77",
        "21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"
      ],
      [
        "1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b",
        "0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"
      ],
      [
        "4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb",
        "6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"
      ],
      [
        "2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0",
        "7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"
      ],
      [
        "0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5",
        "3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"
      ],
      [
        "52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e",
        "7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"
      ],
      [
        "52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52",
        "50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"
      ],
      [
        "6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4",
        "727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"
      ],
      [
        "71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4",
        "39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"
      ],
      [
        "57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5",
        "6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"
      ],
      [
        "6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202",
        "0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"
      ],
      [
        "71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226",
        "3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"
      ],
      [
        "1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f",
        "779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"
      ],
      [
        "22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc",
        "631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"
      ],
      [
        "608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4",
        "3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"
      ],
      [
        "3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02",
        "0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"
      ],
      [
        "69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5",
        "3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"
      ],
      [
        "1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622",
        "295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"
      ],
      [
        "51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0",
        "35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"
      ],
      [
        "3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845",
        "7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"
      ],
      [
        "1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f",
        "0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"
      ],
      [
        "49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac",
        "3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"
      ],
      [
        "4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b",
        "6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"
      ],
      [
        "6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb",
        "2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"
      ],
      [
        "4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424",
        "314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"
      ],
      [
        "0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586",
        "47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"
      ],
      [
        "4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824",
        "5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"
      ],
      [
        "53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534",
        "5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"
      ],
      [
        "7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6",
        "1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"
      ],
      [
        "78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe",
        "0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"
      ],
      [
        "2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91",
        "7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"
      ],
      [
        "0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7",
        "16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"
      ],
      [
        "1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a",
        "7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"
      ],
      [
        "31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46",
        "77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"
      ],
      [
        "543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031",
        "0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"
      ],
      [
        "0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a",
        "187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"
      ],
      [
        "7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a",
        "0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"
      ],
      [
        "472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b",
        "10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"
      ],
      [
        "04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a",
        "3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"
      ],
      [
        "2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e",
        "653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"
      ],
      [
        "0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325",
        "3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"
      ],
      [
        "0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128",
        "1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"
      ],
      [
        "1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d",
        "61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"
      ],
      [
        "469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d",
        "0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"
      ],
      [
        "5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb",
        "505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"
      ],
      [
        "11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1",
        "43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"
      ],
      [
        "3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb",
        "2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"
      ],
      [
        "0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398",
        "54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"
      ],
      [
        "1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c",
        "299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"
      ],
      [
        "25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35",
        "179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"
      ],
      [
        "75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f",
        "696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"
      ],
      [
        "5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a",
        "10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"
      ],
      [
        "7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07",
        "604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"
      ],
      [
        "2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26",
        "68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"
      ],
      [
        "28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787",
        "552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"
      ],
      [
        "59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b",
        "3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"
      ],
      [
        "5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f",
        "67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"
      ],
      [
        "6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec",
        "5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"
      ],
      [
        "53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699",
        "404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"
      ]
    ]
  }
}

},{}],123:[function(req,module,exports){
module.exports={
  "naf": {
    "wnd": 8,
    "points": [
      [
        "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
        "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
      ],
      [
        "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
        "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
      ],
      [
        "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
        "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
      ],
      [
        "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
        "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
      ],
      [
        "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
        "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
      ],
      [
        "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
        "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
      ],
      [
        "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
        "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
      ],
      [
        "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
        "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
      ],
      [
        "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
        "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
      ],
      [
        "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
        "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
      ],
      [
        "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
        "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
      ],
      [
        "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
        "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
      ],
      [
        "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
        "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
      ],
      [
        "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
        "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
      ],
      [
        "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
        "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
      ],
      [
        "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
        "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
      ],
      [
        "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
        "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
      ],
      [
        "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
        "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
      ],
      [
        "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
        "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
      ],
      [
        "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
        "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
      ],
      [
        "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
        "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
      ],
      [
        "049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
        "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
      ],
      [
        "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
        "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
      ],
      [
        "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
        "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
      ],
      [
        "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
        "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
      ],
      [
        "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
        "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
      ],
      [
        "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
        "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
      ],
      [
        "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
        "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
      ],
      [
        "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
        "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
      ],
      [
        "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
        "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
      ],
      [
        "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
        "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
      ],
      [
        "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
        "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
      ],
      [
        "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
        "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
      ],
      [
        "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
        "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
      ],
      [
        "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
        "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
      ],
      [
        "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
        "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
      ],
      [
        "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
        "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
      ],
      [
        "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
        "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
      ],
      [
        "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
        "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
      ],
      [
        "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
        "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
      ],
      [
        "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
        "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
      ],
      [
        "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
        "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
      ],
      [
        "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
        "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
      ],
      [
        "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
        "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
      ],
      [
        "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
        "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
      ],
      [
        "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
        "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
      ],
      [
        "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
        "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
      ],
      [
        "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
        "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
      ],
      [
        "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
        "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
      ],
      [
        "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
        "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
      ],
      [
        "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
        "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
      ],
      [
        "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
        "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
      ],
      [
        "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
        "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
      ],
      [
        "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
        "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
      ],
      [
        "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
        "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
      ],
      [
        "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
        "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
      ],
      [
        "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
        "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
      ],
      [
        "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
        "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
      ],
      [
        "078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
        "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
      ],
      [
        "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
        "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
      ],
      [
        "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
        "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
      ],
      [
        "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
        "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
      ],
      [
        "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
        "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
      ],
      [
        "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
        "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
      ],
      [
        "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
        "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
      ],
      [
        "0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
        "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
      ],
      [
        "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
        "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
      ],
      [
        "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
        "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
      ],
      [
        "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
        "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
      ],
      [
        "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
        "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
      ],
      [
        "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
        "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
      ],
      [
        "04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
        "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
      ],
      [
        "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
        "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
      ],
      [
        "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
        "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
      ],
      [
        "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
        "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
      ],
      [
        "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
        "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
      ],
      [
        "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
        "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
      ],
      [
        "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
        "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
      ],
      [
        "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
        "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
      ],
      [
        "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
        "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
      ],
      [
        "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
        "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
      ],
      [
        "0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
        "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
      ],
      [
        "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
        "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
      ],
      [
        "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
        "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
      ],
      [
        "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
        "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
      ],
      [
        "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
        "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
      ],
      [
        "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
        "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
      ],
      [
        "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
        "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
      ],
      [
        "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
        "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
      ],
      [
        "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
        "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
      ],
      [
        "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
        "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
      ],
      [
        "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
        "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
      ],
      [
        "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
        "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
      ],
      [
        "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
        "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
      ],
      [
        "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
        "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
      ],
      [
        "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
        "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
      ],
      [
        "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
        "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
      ],
      [
        "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
        "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
      ],
      [
        "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
        "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
      ],
      [
        "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
        "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
      ],
      [
        "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
        "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
      ],
      [
        "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
        "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
      ],
      [
        "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
        "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
      ],
      [
        "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
        "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
      ],
      [
        "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
        "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
      ],
      [
        "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
        "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
      ],
      [
        "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
        "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
      ],
      [
        "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
        "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
      ],
      [
        "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
        "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
      ],
      [
        "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
        "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
      ],
      [
        "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
        "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
      ],
      [
        "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
        "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
      ],
      [
        "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
        "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
      ],
      [
        "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
        "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
      ],
      [
        "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
        "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
      ],
      [
        "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
        "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
      ],
      [
        "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
        "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
      ],
      [
        "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
        "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
      ],
      [
        "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
        "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
      ],
      [
        "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
        "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
      ],
      [
        "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
        "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
      ],
      [
        "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
        "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
      ],
      [
        "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
        "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
      ],
      [
        "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
        "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
      ],
      [
        "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
        "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
      ],
      [
        "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
        "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
      ],
      [
        "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
        "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
      ],
      [
        "90a80db6eb294b9eab0b4e8ddfa3efe7263458ce2d07566df4e6c58868feef23",
        "753c8b9f9754f18d87f21145d9e2936b5ee050b27bbd9681442c76e92fcf91e6"
      ],
      [
        "c2c80f844b70599812d625460f60340e3e6f36054a14546e6dc25d47376bea9b",
        "86ca160d68f4d4e718b495b891d3b1b573b871a702b4cf6123abd4483aa79c64"
      ],
      [
        "9cf606744cf4b5f3fdf989d3f19fb2652d00cfe1d5fcd692a323ce11a28e7553",
        "8147cbf7b973fcc15b57b6a3cfad6863edd0f30e3c45b85dc300c513c247759d"
      ],
      [
        "57488fa28742c6b25a493fd6060d936ea6280b0c742005abce98f5855ad82208",
        "31b3ca455073bea558adbe56c27b470baf949ae650213921dc287844f1a29574"
      ],
      [
        "f1133cbe6be8bbc8dc8df2b8d75963c2d40ed616c758cdc84edbc5eb4899447d",
        "57fc24472225b23f5714626d8d67d56110bd3a60dd7a16870cbbb893f652f50f"
      ],
      [
        "95083e753301bd787f8989c79065bb813f3d69bff3e425050f4e04175bbe89c0",
        "844adb5ce7d10de94617c73ca77040e4ee4e92e0156b3c70cc593fa494b33482"
      ],
      [
        "1a908355cbb756755e576ed29c99af638668c7b363c8d97362100443bc5c75c6",
        "d765466c6e556e352f77872225627d80a73538074b44ff27057ad22e2f2454a2"
      ],
      [
        "c5922f740bd343d5aa867308fad97f9f8a2d1f63c5f31db4f04df3bef349b648",
        "77b1f0687cfcdbe8812605e50d8b752cda811844236a4c4377f53c946e7bd648"
      ],
      [
        "64e1b1969f9102977691a40431b0b672055dcf31163897d996434420e6c95dc9",
        "c16f60c7c11fc3c9eb27fa26a9035b669bfb77d21cef371ddce94e329222550c"
      ],
      [
        "033b2e76687744ed6c521bad3333dd37c602f8a7549e9ce7808fb7ea07ce08de",
        "e1bcfe7fc8ed8ae95cf6c2437fdd94bfd742e8caa6de78114c25112a86988efd"
      ],
      [
        "20f18f4c866d8a1cc2a3103317b4ac3189fbf30ff294a75c951473be45e4f294",
        "8d6857c9d08ef7b4fd8883363d37bee70fe8529f7173f58943fcae81d2d0ea0e"
      ],
      [
        "4d1623c944c9c716a0eb4c685e2a8b9d2df3465354643befd1444176d7b69a8b",
        "ddf1b9fe8744ad03f996bf6b96ec34962b601bd5ed952f7854f583888917be80"
      ],
      [
        "a901b0dbe8ab292d280d6b36858947854faad0a4dd0da7e2d4ad0ff53db079e0",
        "3f27e7e1834f1a61af6f04dc61e7ae64716bc5e0a6b063b301d0e60e47298a9d"
      ],
      [
        "7e0af07130218ffd50bd66f4484645b12f42a24f7c80889b3031c9a6ebfc9a70",
        "50bc23f3926cd0c49f53fbb235eb1e890d579517f5bdc3ab2416db785aaedb3f"
      ],
      [
        "7ba8187e1a7b25a2c185d335440a9038b47f0528546e9da4ef82aab05aebf20d",
        "6e6aee6c9625370af866c25c7ca5dd780527efbce7d8b3a39ab249309a185187"
      ],
      [
        "8c050fc34d83b279b6000816e18fca389767b7960e92677255b84a39d93a6807",
        "986314ef75b68fb2827c2965041981395d699fcd81cf23ce7019bc4135174870"
      ],
      [
        "53b7849a78e4df8625860583a52499489d7201a2cbf506202a7b8b1bc99c2ec9",
        "4e31ea12ac607d075de4b22de1be2c52e0a44d254728d2c544d2ddf9e3e469c0"
      ],
      [
        "9bdf9e67a5d0c9956a075a010fe762beb633500431dee78efebc527e53313b33",
        "94264621a5960e0ee24c27926f16cad2907f2636762e8d5a17e94afd8e9d2bb0"
      ],
      [
        "7caa72b37a8ab3bd0bac031a47606f8917d9f42c6ec2d2fb429fd9904a381f34",
        "5b5853ab7ee5de8d34e3d6beb201094fff8fbd1e0682f7f1ef87ddd65d7303c9"
      ],
      [
        "2ef29b9f0982797579c0295fc3f48db7925d62c75532493dde16b97e3993d81a",
        "496c944dd9875ba60a537ef96bf4c714a0afff24387d95e89b42337a33110753"
      ],
      [
        "df157cad95b07875573c1860ae5d02c64029e952ec354e6a9e5c34be97317ff8",
        "f2eccac775922b50899c979a02b3cc30b629e62e85693ba470f6ee381284c162"
      ],
      [
        "dd55c150a29ca526b6182e643b9eb544e651d236b71920e7b15a987016454b1d",
        "44c757a542f4ea2eb39605d4268c2510ac685aabd77a8f5c4d95e23f4c2e9368"
      ],
      [
        "16886cf46ed42c7919147763063d3256c4d5d39387f0172325b9e4b898227f27",
        "7421a2207ee73299d46192fc93ca03dec824ed8de2f48367ec5383170a17fffb"
      ],
      [
        "6ff180fcdaa3061808e8b306d6f0acff27968c22484ff45e56aeaa7b2b60732f",
        "7d16d654f0c2aff0fc254dad063761a26c8d4022ea85b8cc22f3ea1ef69961a9"
      ],
      [
        "03ea4511a00dc2a03eb4f51f40ee677caa912b5539f685c4f8bcc8eadc395e36",
        "6c9ed1f1528b021593a39839340ddb530a2f2e365290c49824b035c673c9259d"
      ],
      [
        "0b82cd70dc3de9eab38742d8f32dfb8d53e4150a835e54b63c7cca20f253081d",
        "0e8bcbfe1f7f6e75d32e20499329765f02effc56a922f26860d4bc0aadd0e24d"
      ],
      [
        "fe2fc3e00074874584ee23bf105a69a606d056f017327d49b7b38b57a196c77f",
        "3e18941cc3c6d297cc9a32f695807b1c7da8561de4fde71d4f9bbdb6e9bf3916"
      ],
      [
        "04b90176cdaa369347e8778b12db9d6ee8b0011446ea35ec845dbf574bb7858b",
        "f60547ab6e9c5fd3eca6e349b85880c61fdad0fc2f7ab155295caaecb973c154"
      ],
      [
        "35f382511d34600b4b8c86a9f0dbc9eddefc4272f59528a0cd3ec10a5944c6d2",
        "29a835f6ef7fa1e5f6f37a80cf96ca9843762bb1b12a0daeae83234bd0b5ccd5"
      ],
      [
        "1d74b2970311b7ffa1027e26587d3f5be1d0e9ac3f0111cdf3cc2371722cb94a",
        "5c7bcf8b57f114e0b73bcfb810f5c60d35dc99ae9dc7f0e2606cc1f728c2071e"
      ],
      [
        "50a094f309c6f9560b020737b9ec722e4f75d1b7c41593e6f934a68a98450428",
        "a286e222dfe10cfd9689eaba6a81f04489c86db6869aa1b554a90f1e83778eee"
      ],
      [
        "9b65bb812129157cdfecf12e275ec38c282dbcd914b4810599b0a6d627c63db7",
        "c582db1a3f0f22421913b2e951e98a78660b4c40ad08fd65528593bc18223188"
      ],
      [
        "8b4544fc1fdfa06e456c1115a1dc831c85e7f1c5e620eca51c20802d36a4bc6b",
        "e3e77c41288f2602e722af7f4b70e64de4116fb9955b03b06ea8b19f7a20350d"
      ],
      [
        "6c709880b959eb7c5179b29cc5578fdc6cb2ae13ddcede29d5f81d95de0ab4aa",
        "c9e33faebd8eba426736c0c76f3deabaee2b59c50953fb43c2dcc5139e7c4bdc"
      ],
      [
        "77760b5137ba6a7195d891f794a087a076fc9d67802b81e7085b56773d537806",
        "f5202cf5aaeea58bf4f58c7edf4417be1b87ffdee68e77f0d7e81abe158e3a25"
      ],
      [
        "1a8bd7836a0b0c82e9a904a8a8c91a67e23cd4f8efd625d0df4c426e7e163102",
        "61fe64cab0952cae3c574f282f74a87dc2a96316b7009f2e4e9c5fcc12285844"
      ],
      [
        "fe217db659079913fb1e453ed24d91d6a3fb3099e69471d753db5390864abc30",
        "5dcf9abba9625ed680b0f20fb1f047d593a0c61c539692538cdf6b034d730b58"
      ],
      [
        "2504d63754afd5ebc38f58b65ead696d07e3abd748cb6c5f212aed49f5b33b91",
        "79a6bf4375f1469c4f5321c6c72fbbf4ba7cec105675f437b5e013ad7b5d75d4"
      ],
      [
        "0b06f702f47b22d789a9bd3f687105c36160abbf5cc8976b7fbddcafdb197b5c",
        "7669bbd419a4d491f592a35b6aa3dfe45bd2fe7fd179c7781cd5f918d732f63d"
      ],
      [
        "803b203bb31f9cf94034eeb931b54480a6f3f99ebd23d0acbc2128a60d044e23",
        "308abc8df271f75959b20c5c7fa62bafbfc9ccbf49b946a954e5381c1728d1c7"
      ],
      [
        "266a9cb4c5f5ceadbb50e5bda03a7312e52de1de8e95a8dcd57289fe0302749a",
        "9eea970ba856b2faa3e82877cc84ed4f3dc0efba1e7c3baa8b386ffc46e0ae7e"
      ],
      [
        "fd8a9d95d80c7ad52599a7ab98163df364c4c141e9abea355d7360bcf84eba94",
        "a9fb1702100953b359b2e2688ae7fd33a30377da47bfda713e2d7d73dfb1030c"
      ],
      [
        "a7322df309f28f2359fc339a8b2c80be6e84acc5b7b0b8f8f2cb6f26f9db0a7d",
        "22f6fe9d217495017fdb7f5b2f12fa57095f40e131714885c12a2ea16edb6be6"
      ],
      [
        "82a8c10f336a664963a104ddbf7f0f18bd4c461aea569ffc82c3c7e4cb052d36",
        "737ceca2c0ef72278b90501ccb71b6715e5c31d4cd0478c118fe128795f1dd0c"
      ],
      [
        "9b50d1b68e3bf795007cd12f05a60c266c4ef2b75ba5c516c54784a94f15d6df",
        "2afc8d09b79176d8d003fd2a4f18d526403fff272d47e7787376feb7cbddd8fd"
      ],
      [
        "3f9083ddc8b423fe7de3a82281d3056ab8dcb9d7ee82cb806718595fbae08d32",
        "cb13c152fd511d91a9e0ed90afa021a081f77f6d20cc1376e2195ffcf28fa758"
      ],
      [
        "c75c85c1ee17c1a256eff6bd592666cbc923170659d50bfadbd1074ef2167faf",
        "1ab4eabe5e09409d75cca8922647f48dbd698a16d4f7cc8596daf16940023a52"
      ],
      [
        "c5341feaf8a0f5d3b4d0cf0d2f7aad7c60ea8e2b3d4b7fb95c68d57698656045",
        "95f9f4e9007e5b9fa48fa422a26ab982dc48a4d54d7123986e6d3ab974e88915"
      ],
      [
        "83acda3e2a8997e0d52bd4c68705dd22220852b7752d67fd8967a03260c2d89b",
        "dce1bae1d655ba517f5b5580997117570a77cd3bdd4b8e8e330e97791bc31df0"
      ],
      [
        "5b8191468b2990745b9c4164e29d594cf1c0d5716c5d39625bd279b30025237b",
        "cc3636a03fddddfabed88daab081f3591c48d2ca71ba34fcf6989f4af7625d8e"
      ],
      [
        "64778122214e38eff8041796166104e732f5f664d38d77219b89045e2c3b0e6c",
        "329cf0497e15eec7b8eafc4a0b8a7d1cd8b632038d4aef81974cf9844611a32d"
      ],
      [
        "ed4d826afe5762f4795099099aee86642b475a9d6da1017c43d0cb9f1af12323",
        "8c6f81be3fafa5eec8296f928ac7919dc4d88c9a59442274d0531b7bf7e48e78"
      ],
      [
        "38b42924419aecc3acd6f551346fd61a4d82ac2b55f7afe97a06eb40cd109c4a",
        "7f42c0962feb2f73b2b0965a1f359a6ade49d768a2ce6b07b5acb92b73e05583"
      ],
      [
        "c3cad4a8d8bb94a7b434cf70183e8615bb2a8f6224f216e3446ac2e982138911",
        "f649be278cad976420742ce382dce3a1420e372ef1b25b2759a8ed387282765e"
      ],
      [
        "2d408ff4d3d236fd54fae40dce3ea9ecd9212e5736591a9e55588e4a54bd6538",
        "d596adf0e8692a06bc6284bf0299bef685e2a171585aa1324b9a05b50ce815b7"
      ],
      [
        "ee7adf6d247f25fb76e90cf813f888ebd67423a3a3c6fdaebafb7eaa7a33c854",
        "e077184b4ae8f7056c10dd9ef541689d143f6871789e1801deaefc1d527a8fb4"
      ],
      [
        "2f9457c8a9ffaca13d91151dc4c5e89ddd5d37a37c9a864b7c811f3e01144b34",
        "eb4c98489093d573a295407e1d6fc48a787120ceb3d3dcfbb40634e0e75e221d"
      ],
      [
        "d3f332b8a0f115821ce3478cefe18de360120483ef531c277b30c46eb7fec294",
        "ea75b9b25d717861d1af1c019c372941c8968b90ef134f9f323215e1bb0b2155"
      ],
      [
        "183408d338b05aad3521fcd86ef36dd75f3ddb8666b52f7e9a4cdf1f8e152b91",
        "669985206edf4ac6f39be21f20c98824210e204ce44998095de355371641218c"
      ],
      [
        "283fec5db1145e53ba8f1f0ff9cf89a721faffd6c25346863d3956095f40374e",
        "70b0123774af550e68e68e5f65ca6e9808846e03cf39af778511be82bc32fefe"
      ],
      [
        "0ce7570a4f943cfa413bd249d8e7dbfcebc73579770fd6daf54a0dfbdd52fa62",
        "e115b14bef4695cffb85bdf98ba3985cbd5e5b8983e053907c36f9ce8b75d41d"
      ],
      [
        "7e9c4f19c8f4ec3f1269f648cd919525df79031574cbeb1537794a4c838fd470",
        "e9d9dbfe8cf5f5cca855d6ccbd11f48060fafa8dad6bd3e9c86df5ceb0fa5270"
      ],
      [
        "e2a9bbe60d5d5bfea7c7f919df2309f90ba04f4c722a3ec23bf451b464cb001b",
        "e4177ce1c3cd6ac778925bd67e72cb77d1925b91d06a7f1698411a4786393fb0"
      ],
      [
        "504512a43e17ef50e43bf37d42a94990f55e641b1558c265e709900275271012",
        "954a5fd857ba3acf2d4b1f41e8e1f2cd1f21c4b96899781b742a49d2e61ed18b"
      ],
      [
        "81d1f013a6bb325f4b2d1d51ba72c721859945d8a17b3411cd5cbe87285f850d",
        "2d5d2fb1f0c308553b1fe249298b2059259d3d49d4d7071adce4bcc5dc937193"
      ],
      [
        "5b66c2dfc1d2826618a872767e66c33dd90dd51414a3b87ca733383d1d895022",
        "9bd0178e381895692217267b7407e98727fcaeda12d8cf5449eb5472d554e0ff"
      ],
      [
        "aeb5f70e98ec5e38dbd2d544bdbff8ab99b583d9af58c597afaf868820381186",
        "618bd6b0d25ca70df08b76929336e421691b09730f2f5a052e7adc173584427b"
      ],
      [
        "0b289effe841943b84761e3c67a9c02a557679ca76ad753a707a98212505052e",
        "07a981f0c21862a853b4f895dc62482c530ed7385e5d1e330cfb9d0fe879992c"
      ],
      [
        "abae39458b12199e6b0c8360cfd282883f585917e44e1200f81bd356f619291c",
        "adb23bcdb3d069c5e83be30b2469b0680b2a81b7b667e934233b75efb5753f28"
      ],
      [
        "4a9583a6485b5a5a81ac224a518eb29d1e0f658c8d91b0139419c80955fbacaa",
        "d8003c9ee3c842f5ede375a8a7768db4803ecf119b7b37decea15631b4e8dbca"
      ],
      [
        "d52f630edba6f7cb65fcf46544ab0d9eea236ac1460f17ae3a21010210ebc169",
        "211557489fa93b883e5bea50da005c5368e21a0c41bc83d9145c13e1370d26d0"
      ],
      [
        "0bdc523782c75858f5c50fc052e4c1e9c74a2a6335bca9bf8d10e1209add6a4d",
        "abb1d9f874637668e214efbafbf529d312ff023bc1d5723e585404366834f189"
      ],
      [
        "44770a338bf0aab83bb64e476eb6167a88156d168f13ce8626ee0912e59ad087",
        "5b5930f12e9c40bcb3393a895c2d64576a3abd23b7291b99c965c33def60a55c"
      ],
      [
        "b15e7b322e404aee319ac20323e366726503108d8ee8e1c83e32d924515e1679",
        "5246a8190bbfb2915f82ed5650796f505ced5c2587347d57a873ceaf3d997e7a"
      ],
      [
        "a1ed755705225cd0f2c50f758a1c1df9665ae108d5e0419027bbd9aeddb00f22",
        "3c83145dad9f87487b97e7464850ed02d71dbd04093281a13d2127766a791ee2"
      ],
      [
        "e8aaf3616a1bc60fd9bfc43c2c60580f479e9ec9c23a37a23cf8afb31d918af5",
        "6ce693b64a37c6727e141041ab9a0d589ab9c303a5ac3d3ec89b6f279e79827c"
      ],
      [
        "5dc6f8cd2c855e6352a4a4ef6187a6d60759c04338a3db76c5a3aa37054c20a3",
        "f602c3428593a9a8d671d1bc7c1d88340fe9f5f52e6a7f0fbb8701464e6f4838"
      ],
      [
        "6332731167bed8af68a063ef22aa489cf6563620461af26a5f1a07cb6b42f3a6",
        "b8f7c3b220701320f20ca036761d3e56bf94a7009a919f1a3ea0cb81b74424a6"
      ],
      [
        "8a40d9259a393b382305c2017e8654dbad66e50ad798a0d3535230f948080263",
        "afb6a74d9849454edd7f703a5c6616d143f9cbcc9a9a5d6f6a7b5d1f9d9fcaff"
      ],
      [
        "e714710727c7420af517fd3f9a05b7dea6a02c8bcc20b17dcdfdeaf82078645a",
        "da7d67cbc1ede9d4fedd5dcdc96b04f9a3561ba02581b055eaa144eb4217daca"
      ],
      [
        "6131291cd95fb87801e42a68553952c29922bce891c026c0cae1f69c9661c82d",
        "160e1c1c13342fd459d4f9898ae632b842b8947913733b89384fc1042d30bf01"
      ],
      [
        "4bc4f845b6764692d0a9bfa81788809efc5e2aa9da5003bfb782bcf1d1ca4951",
        "87092dcbb9c3d254e3b055ff3a76ec0564c4a7c57fb1783cefdc40fc10b751f0"
      ],
      [
        "45a880a27bbee9df29f9bff5c985f36452865b5d582a201f698e6ecaa2be67df",
        "fe49a6a8b5e46bf1ef679714dabd590ea831d46b8ee94eb613132ba37855fabb"
      ],
      [
        "6a826a38317c0c8664d6847a220145d1877e5495b21500d3f21f1a0d4af4f2a4",
        "4521954efcc98263df2f14e0e6e6b47af6b83f0bbc20722c15445f87e05f4513"
      ],
      [
        "15356506f255f7e96cc8aa1b09dce5728bd860de7c6cc75f613e8a34366a23a9",
        "cd15abbcd744d4850d5e401f1f89a5df122f37b4e362b4cee3e53b1c00110bf3"
      ],
      [
        "f3bc12aef53d9f5f6b86517802dac2eccacff3a5cca6443a2b5e1ca0f2b89b91",
        "cfd4d36beb2e11f241fd0f367a0737ad303e915ff247f131368ca50918e00957"
      ],
      [
        "7e3c8c6dfa04a536f7a26ef18b38764922320bef584533736f728297335c0fd4",
        "72ea16b532a7336d3332400b303c0236b6a1294d88ce7fe915571284d1f7c189"
      ],
      [
        "198cbfcfa0575fc2c161c696d85155fe6943ab9bd6e17223d8844608ad0369d8",
        "d5e6268b30952422be59fe0efe7ba2e703215994827a46c2f2972b26153cf7ae"
      ],
      [
        "1e056e89b68cf35a22183c089089b90d5a147caa780b1fd63aeb1350afb0e5e8",
        "b8241453abc44c57ddad6ff386d416f43e258a390c6f88379f80472b943f32b9"
      ],
      [
        "dc7ff9748d827e7ea6173b2f1a646d47d8108144ce7f98fb3fac729e72faaa21",
        "c1fdac5aef4c6f0ffcb8e1c5c4417c713e3d5f07146daa1aaaf2e7fee70c4914"
      ],
      [
        "71b95efcc4981e0705354bc11cdfbc4836b2eff0bf8f8ec29a99da1b2fd28e79",
        "fd5a31976fad6aeec304752cc3ebbc511f3695b09a737fa30af42cc6efd684cc"
      ],
      [
        "43854caf29dc2bd6c9f3e8ffa25bba83f6b96121897044ae6876883ade542b3a",
        "563651760897632f8dde31677a24f55834c5c9a55c1cbf36fd8b44803c9c6c81"
      ],
      [
        "02adfe17090e9f9c708c9b730d5fd084b6eff990fb87796145c2ecf2d427b222",
        "b5ce31605d6dd9c622cae425ccd28912c4439820c06950cd4c86d9b453abd7ed"
      ],
      [
        "a123452c2b7eaf3115b3a5343b3ff31a09f70c54ae33c620471e3e8227a9d6f9",
        "933d348378a71f443788194aafc545e7f53e37a6f779f96e8fa14ccdede3b4eb"
      ],
      [
        "9b89a3c2ca995a8186c1521761348737aab166ae7decca603d06e32ccec0a6ab",
        "2a7d3701a8724b12bd7c4830224ac083cbea83d0543b541480ba8c8ae7731232"
      ],
      [
        "64dd7457e7d9d73908e2b9a0dc45272b384b04339ed8b2edc907964611e9e9b2",
        "ea90f8aae214ee16ed608a72366998994e311dc7780ef885b29290c3823c470e"
      ],
      [
        "59227431be607c6bd327fd714eb71c8720abba421c7f550a6b35767d6fa2176c",
        "cb7571c4071c552765bd289ea3cf3f38796da2b12c953d0b8705125c4861d598"
      ],
      [
        "53d765cdadb26e9e1c80ddf199374363843b7d08a7237bdc8c5106ef795fe2c2",
        "7bbbb198eb39973b76d87f8194d45150a66d4f3b128a40bec989a405ad7c287b"
      ],
      [
        "e507de9ec16b3bf3523a989c0f5ff6c10452ee909b66ffc16d7b519a57bb66af",
        "a2f2f02a8272de6e3dc8b39508959ad251b6d3d004c8195259a501e28ff7892a"
      ],
      [
        "016f48c60eb84fb281903b8cb9f60b7a65601d76e2a579835569c98339b4a6f2",
        "8613bb848398681d66f1e75d5b6ef44fd827b6290f4956a441d8f503dd32b289"
      ],
      [
        "650471ae774265e3270b513233d12d850bb98e382a3b3af90cab6339e1446056",
        "838e779334aa6fe6cae90a62d359c339187b403215d97cda4e62724aa5a50306"
      ],
      [
        "15dea416fa34584fcc90e19d69825fae348d1ba1fd7ac821559aac2abc21dda8",
        "01fcabf21e19ce68ee12a3d284bd1304010fa5f5d45f9c15d4070243a8433047"
      ],
      [
        "b42b24954f1f70ed3db900878357ba46ee9d6a07b4f7c751dc5cba07b05b46e2",
        "e15723eb0e0bdbe6d6f28d6da0443c634851f5b4c551bec69f9196a00969ed71"
      ],
      [
        "08e9e4f5c6aeac311dab1125dec9b4606ab10b7e8e250960a17fc57fc0230f83",
        "ffb0e211c79fbb7978bd4e53a05a267ff1e32c34d6287dee64576d31ab959ab2"
      ],
      [
        "87be732373bd4b738627fb63bd4d50bfd6f2bb81f804b52829549fe93fe1ac2e",
        "f6a9186ff147b9b5ffc844b2ec0e255a1ae5537d75624288ce8421f87e94e1a4"
      ],
      [
        "43601d61c836387485e9514ab5c8924dd2cfd466af34ac95002727e1659d60f7",
        "8791c0007c09c94db328034b88c5bbbc113335366679eb099a5e75b583bc2c2a"
      ],
      [
        "341b1580f83071c5365f0bcbba66af966902e3942a2560aca0daafa32ab49d0d",
        "4b985b13c54990267ff564d2d4649c6f7e8fdbe1ba101d941c034e1464877b20"
      ],
      [
        "175e7cb3ce4a3a437c7181e2c79fb15433ac1aa8e56492eb57627171f14dad95",
        "31ce61a87834f52efcf8703f93696f425813015563ca5d9ce92d8fc281135b0d"
      ],
      [
        "5ad430cc64e61c61e3b3c8482ca3ecac89c1e4954c80ba98249e45c1307165ad",
        "bea2a060505c13bc317ca083c5a8b85c9ead5f6e1ac23fbeac7cecea9251c791"
      ],
      [
        "41dce0d96dace318988602df07fa84c1080f0ce3dd7d09f28aefefa60db8b837",
        "74962c3fed9a6e9c896635ea855323b608850091f84dee333cdff8d0d2827928"
      ],
      [
        "a5ef449887104dda103c1dc2520676439aed2d5e0432fe5ba23cc14239961bcc",
        "1cbcf83ea363e0d93e6ecc328653ba7aa165c526765b09f0696b0d61f122db3a"
      ],
      [
        "4da26ece9ad4600338bdf68b852a2cbe18225f2e2d6d5e626db57235fb3a9d45",
        "d10b5a637ab546bfcc610e2d1c3d61f461b0a806e7ba29c73d3de909e9fae659"
      ],
      [
        "6e621e6f53d2408e488d8eb16a19a4f7e9d9558511e6911129dedc69f98f4763",
        "7b148ef273e1b131341ad4779342c7bc7b945a2cb52c448e4bb5fd503cea1a19"
      ],
      [
        "ebaf57645bed74699b57ea758a395a9066bae20a8f082ab6da4554d5278be83b",
        "5847f4e06c6530335e29ea94389ee3e6d916314a60126028650ab9e0bfcfbba7"
      ],
      [
        "c0f88a71711b632d24b55dbf052b15d2faa38ca11438c17a6a6ff6353310182f",
        "2cbfad4d16c0702186611eec408082fbfb2e9898141a52481c59e44ecd0676ff"
      ],
      [
        "5d9b6c1884b79498c6244fbf262922c6dc1cddb73cf70ae01b5287b05b5c6350",
        "328e831d2f2b162c4abe1644bb54cc8518db178c5b6ae97e5e85110c7d7fdf1d"
      ],
      [
        "d1d1360f37ed6e69d4f214c6323a53b7e57d759555904016654c49f04e02e21c",
        "627eea93c6c9b53f9455941440a8b1006eba68d46c922b6a1521f3946dd15e4e"
      ],
      [
        "efc987cbf1023af558acfa1897b1b2b2ace29a8365674703e4969ccbee411731",
        "195a6a65d3790bec716429863bcef432e38242fc9f565dbbe159bc42f5740c69"
      ],
      [
        "f3026b97163df3bd61b88b7873864480968d1d7b83ef6b0131090faa18284ff0",
        "177c3a61682363abbf281615d59f06ff5f87644c84d670e9a6c56ac1b611509b"
      ],
      [
        "5d34ff5f123b5b6992ac92c68c9cff460deeecf968ff830b5622090d682c5873",
        "2d1a0b9c8eaba06543204df148eb161825443efa80f8aff3d49b6626c5955ac8"
      ],
      [
        "cbf9ba1794a95247c39da06584308cc8e0ee591d31a9b0bbdac67280468447f4",
        "549b18c310feaea10225fade934112d34058101d74f005381b82796ad0461736"
      ],
      [
        "920975ba09e2261bbf5982a6b57a73448e7747b8368d7a5379acacd4c7dcd31f",
        "e95e050881af550d09221f5ae95410316367d24bd545bdcb434e7638acb46dbd"
      ],
      [
        "815b2ae46fdcb55d926cdce82b4f25d0391323123bc180ff33fcf13207eeca64",
        "62f637c67d8863748f1e2e26865118b999285b8755f25512c968b4fe49b8c971"
      ],
      [
        "1bb9a6c28e28d4ba30ea86397a4d387e27ca8025da2319260de3c454f7e0b16e",
        "a0cbc0165e32171c8184265eac7e0147206349d541035a94f56efc49dcd7ab93"
      ],
      [
        "6f0153fedffd83eab099d29ddde278f19c05a4ba78eb4c3d34d337c6da68bc22",
        "a532d00d35013f859f4041d3aa231f2b9fc499670e0e2f824d5051f9e7f0c626"
      ],
      [
        "3454f73b3bee77a40d00d38471bf555aed23e5e6c6dae8552e9cb7a91b20258a",
        "92c20846cfdf1e8f3fe5bcaa06bdedc39926833a3f40d28f23a8f952d8d18dde"
      ],
      [
        "367807c9a3606b4e1b8c2616ad5280301dfcf68640eddf02fc59317c230e9a86",
        "1f023f2fa2bbece703dba14c124095cbfdc4f92f00281a148304a412c16ecae6"
      ]
    ]
  },
  "doubles": {
    "step": 4,
    "points": [
      [
        "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
        "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
      ],
      [
        "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
        "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
      ],
      [
        "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
        "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
      ],
      [
        "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
        "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
      ],
      [
        "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
        "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
      ],
      [
        "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
        "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
      ],
      [
        "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
        "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
      ],
      [
        "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
        "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
      ],
      [
        "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
        "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
      ],
      [
        "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
        "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
      ],
      [
        "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
        "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
      ],
      [
        "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
        "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
      ],
      [
        "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
        "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
      ],
      [
        "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
        "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
      ],
      [
        "06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
        "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
      ],
      [
        "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
        "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
      ],
      [
        "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
        "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
      ],
      [
        "0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
        "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
      ],
      [
        "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
        "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
      ],
      [
        "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
        "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
      ],
      [
        "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
        "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
      ],
      [
        "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
        "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
      ],
      [
        "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
        "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
      ],
      [
        "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
        "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
      ],
      [
        "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
        "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
      ],
      [
        "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
        "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
      ],
      [
        "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
        "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
      ],
      [
        "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
        "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
      ],
      [
        "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
        "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
      ],
      [
        "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
        "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
      ],
      [
        "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
        "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
      ],
      [
        "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
        "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
      ],
      [
        "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
        "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
      ],
      [
        "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
        "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
      ],
      [
        "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
        "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
      ],
      [
        "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
        "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
      ],
      [
        "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
        "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
      ],
      [
        "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
        "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
      ],
      [
        "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
        "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
      ],
      [
        "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
        "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
      ],
      [
        "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
        "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
      ],
      [
        "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
        "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
      ],
      [
        "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
        "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
      ],
      [
        "0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
        "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
      ],
      [
        "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
        "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
      ],
      [
        "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
        "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
      ],
      [
        "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
        "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
      ],
      [
        "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
        "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
      ],
      [
        "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
        "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
      ],
      [
        "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
        "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
      ],
      [
        "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
        "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
      ],
      [
        "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
        "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
      ],
      [
        "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
        "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
      ],
      [
        "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
        "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
      ],
      [
        "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
        "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
      ],
      [
        "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
        "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
      ],
      [
        "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
        "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
      ],
      [
        "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
        "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
      ],
      [
        "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
        "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
      ],
      [
        "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
        "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
      ],
      [
        "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
        "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
      ],
      [
        "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
        "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
      ],
      [
        "08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
        "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
      ],
      [
        "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
        "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
      ],
      [
        "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
        "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
      ]
    ]
  }
}

},{}],124:[function(req,module,exports){
(function (process,global,Buffer){
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 */

'use strict';

const assert = req('bsert');

/**
 * Generate pseudo-random bytes.
 * @param {Number} size
 * @returns {Buffer}
 */

function randomBytes(size) {
  assert((size >>> 0) === size);

  const array = new Uint8Array(size);

  getRandomValues(array);

  return Buffer.from(array.buffer,
                     array.byteOffset,
                     array.byteLength);
}

/**
 * Generate pseudo-random bytes.
 * @param {Buffer} data
 * @param {Number} [off=0]
 * @param {Number} [size=data.length-off]
 * @returns {Buffer}
 */

function randomFill(data, off, size) {
  assert(Buffer.isBuffer(data));
  assert(data.buffer instanceof ArrayBuffer);
  assert((data.byteOffset >>> 0) === data.byteOffset);

  if (off == null)
    off = 0;

  assert((off >>> 0) === off);

  if (size == null)
    size = data.length - off;

  assert((size >>> 0) === size);
  assert(off + size <= data.length);

  const array = new Uint8Array(
    data.buffer,
    data.byteOffset + off,
    size
  );

  getRandomValues(array);

  return data;
}

/**
 * Generate a random uint32.
 * @returns {Number}
 */

function randomInt() {
  const array = new Uint32Array(1);

  getRandomValues(array);

  return array[0];
}

/**
 * Generate a random uint32 within a range.
 * @param {Number} min - Inclusive.
 * @param {Number} max - Exclusive.
 * @returns {Number}
 */

function randomRange(min, max) {
  assert((min >>> 0) === min);
  assert((max >>> 0) === max);
  assert(max >= min);

  const space = max - min;

  if (space === 0)
    return min;

  const top = -space >>> 0;
  const array = new Uint32Array(1);

  let x, r;

  do {
    getRandomValues(array);

    x = array[0];
    r = x % space;
  } while (x - r > top);

  return r + min;
}

/*
 * Helpers
 */

function isTesting() {
  return typeof process === 'object'
      && process
      && process.env
      && process.env.NODE_TEST === '1'
      && !process.browser;
}

function getRandomValues(array) {
  assert(array && typeof array.constructor);

  if (array.byteLength > (2 ** 31 - 1))
    throw new RangeError('The value "size" is out of range.');

  const {BYTES_PER_ELEMENT} = array.constructor;
  const crypto = global.crypto || global.msCrypto;

  assert((BYTES_PER_ELEMENT >>> 0) === BYTES_PER_ELEMENT);
  assert(BYTES_PER_ELEMENT <= 4);

  // Native WebCrypto support.
  // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
  if (crypto && typeof crypto.getRandomValues === 'function') {
    const max = 65536 / BYTES_PER_ELEMENT;

    if (array.length > max) {
      for (let i = 0; i < array.length; i += max) {
        let j = i + max;

        if (j > array.length)
          j = array.length;

        crypto.getRandomValues(array.subarray(i, j));
      }
    } else {
      if (array.length > 0)
        crypto.getRandomValues(array);
    }

    return;
  }

  // Fallback to Math.random (FOR TESTING ONLY).
  if (isTesting()) {
    const mask = 2 ** (BYTES_PER_ELEMENT * 8);

    for (let i = 0; i < array.length; i++)
      array[i] = Math.floor(Math.random() * mask);

    return;
  }

  // Error if no randomness is available.
  // We don't want people using bad randomness
  // when keys are at stake!
  throw new Error('Entropy source not available.');
}

/*
 * Expose
 */

exports.native = 0;
exports.randomBytes = randomBytes;
exports.randomFill = randomFill;
exports.randomInt = randomInt;
exports.randomRange = randomRange;

}).call(this,req('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},req("buffer").Buffer)
},{"_process":307,"bsert":190,"buffer":303}],125:[function(req,module,exports){
(function (Buffer){
/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

const rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

const s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

const sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

/**
 * RIPEMD160
 */

class RIPEMD160 {
  /**
   * Create a RIPEMD160 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(5);
    this.msg = new Uint32Array(16);
    this.block = Buffer.allocUnsafe(64);
    this.size = FINALIZED;
  }

  /**
   * Initialize RIPEMD160 context.
   * @returns {RIPEMD160}
   */

  init() {
    this.state[0] = 0x67452301;
    this.state[1] = 0xefcdab89;
    this.state[2] = 0x98badcfe;
    this.state[3] = 0x10325476;
    this.state[4] = 0xc3d2e1f0;
    this.size = 0;
    return this;
  }

  /**
   * Update RIPEMD160 context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize RIPEMD160 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(20));
  }

  /**
   * Update RIPEMD160 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 0x3f;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 64) {
      this.transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize RIPEMD160 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size % 64;
    const len = this.size * 8;

    writeU32(DESC, len, 0);
    writeU32(DESC, len * (1 / 0x100000000), 4);

    this._update(PADDING, 1 + ((119 - pos) % 64));
    this._update(DESC, 8);

    for (let i = 0; i < 5; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 16; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform RIPEMD160 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const W = this.msg;

    let A = this.state[0];
    let B = this.state[1];
    let C = this.state[2];
    let D = this.state[3];
    let E = this.state[4];
    let Ah = A;
    let Bh = B;
    let Ch = C;
    let Dh = D;
    let Eh = E;

    for (let i = 0; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (let j = 0; j < 80; j++) {
      let a = A + f(j, B, C, D) + W[r[j]] + K(j);
      let b = rotl32(a, s[j]);
      let T = b + E;

      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;

      a = Ah + f(79 - j, Bh, Ch, Dh) + W[rh[j]] + Kh(j);
      b = rotl32(a, sh[j]);
      T = b + Eh;
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }

    const T = this.state[1] + C + Dh;

    this.state[1] = this.state[2] + D + Eh;
    this.state[2] = this.state[3] + E + Ah;
    this.state[3] = this.state[4] + A + Bh;
    this.state[4] = this.state[0] + B + Ch;
    this.state[0] = T;
  }

  static hash() {
    return new RIPEMD160();
  }

  static hmac() {
    return new HMAC(RIPEMD160, 64);
  }

  static digest(data) {
    return RIPEMD160.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 20);
    assert(Buffer.isBuffer(right) && right.length === 20);
    return RIPEMD160.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = RIPEMD160.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return RIPEMD160.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

RIPEMD160.native = 0;
RIPEMD160.id = 'RIPEMD160';
RIPEMD160.size = 20;
RIPEMD160.bits = 160;
RIPEMD160.blockSize = 64;
RIPEMD160.zero = Buffer.alloc(20, 0x00);
RIPEMD160.ctx = new RIPEMD160();

/*
 * Helpers
 */

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;

  if (j <= 31)
    return (x & y) | ((~x) & z);

  if (j <= 47)
    return (x | (~y)) ^ z;

  if (j <= 63)
    return (x & z) | (y & (~z));

  return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;

  if (j <= 31)
    return 0x5a827999;

  if (j <= 47)
    return 0x6ed9eba1;

  if (j <= 63)
    return 0x8f1bbcdc;

  return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;

  if (j <= 31)
    return 0x5c4dd124;

  if (j <= 47)
    return 0x6d703ef3;

  if (j <= 63)
    return 0x7a6d76e9;

  return 0x00000000;
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = RIPEMD160;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],126:[function(req,module,exports){
(function (global,Buffer){
/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pkcs1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */

/* eslint func-name-matching: "off" */

'use strict';

const assert = req('bsert');
const BN = req('../bn.js');
const rsakey = req('../internal/rsakey');
const rng = req('../random');
const {randomPrime} = req('../internal/primes');
const {countLeft} = req('../encoding/util');
const base64 = req('../encoding/base64');
const asn1 = req('../encoding/asn1');
const pkcs1 = req('../encoding/pkcs1');
const pkcs8 = req('../encoding/pkcs8');
const x509 = req('../encoding/x509');
const safe = req('../safe');

const {
  DEFAULT_BITS,
  DEFAULT_EXP,
  MIN_BITS,
  MAX_BITS,
  MIN_EXP,
  MAX_EXP,
  MIN_EXP_BITS,
  MAX_EXP_BITS,
  RSAKey,
  RSAPrivateKey,
  RSAPublicKey
} = rsakey;

const {
  safeEqual,
  safeEqualByte,
  safeSelect,
  safeLTE
} = safe;

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const PREFIX = Buffer.alloc(8, 0x00);

/**
 * PKCS1v1.5+ASN.1 DigestInfo prefixes.
 * @see https://www.ietf.org/rfc/rfc3447.txt - Section 9.2
 * @const {Object}
 */

const digestInfo = {
  BLAKE2B160: Buffer.from('3027300f060b2b060104018d3a0c02010505000414', 'hex'),
  BLAKE2B256: Buffer.from('3033300f060b2b060104018d3a0c02010805000420', 'hex'),
  BLAKE2B384: Buffer.from('3043300f060b2b060104018d3a0c02010c05000430', 'hex'),
  BLAKE2B512: Buffer.from('3053300f060b2b060104018d3a0c02011005000440', 'hex'),
  BLAKE2S128: Buffer.from('3023300f060b2b060104018d3a0c02020405000410', 'hex'),
  BLAKE2S160: Buffer.from('3027300f060b2b060104018d3a0c02020505000414', 'hex'),
  BLAKE2S224: Buffer.from('302f300f060b2b060104018d3a0c0202070500041c', 'hex'),
  BLAKE2S256: Buffer.from('3033300f060b2b060104018d3a0c02020805000420', 'hex'),
  GOST94: Buffer.from('302e300a06062a850302021405000420', 'hex'),
  KECCAK224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),
  KECCAK256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),
  KECCAK384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),
  KECCAK512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),
  MD2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),
  MD4: Buffer.from('3020300c06082a864886f70d020405000410', 'hex'),
  MD5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),
  MD5SHA1: Buffer.alloc(0),
  RIPEMD160: Buffer.from('3022300a060628cf0603003105000414', 'hex'),
  SHA1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),
  SHA224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),
  SHA256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),
  SHA384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),
  SHA512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),
  SHA3_224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),
  SHA3_256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),
  SHA3_384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),
  SHA3_512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),
  SHAKE128: Buffer.from('3021300d060960864801650304020b05000410', 'hex'),
  SHAKE256: Buffer.from('3031300d060960864801650304020c05000420', 'hex'),
  WHIRLPOOL: Buffer.from('304e300a060628cf0603003705000440', 'hex')
};

/**
 * Generate a private key.
 * @param {Number} [bits=2048]
 * @param {Number} [exponent=65537]
 * @returns {RSAPrivateKey} Private key.
 */

function privateKeyGenerate(bits, exponent) {
  if (bits == null)
    bits = DEFAULT_BITS;

  if (exponent == null)
    exponent = DEFAULT_EXP;

  assert((bits >>> 0) === bits);
  assert(Number.isSafeInteger(exponent) && exponent >= 0);

  if (bits < MIN_BITS || bits > MAX_BITS)
    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

  if (exponent < MIN_EXP || exponent > MAX_EXP)
    throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);

  if (exponent === 1 || (exponent % 2) === 0)
    throw new RangeError('"exponent" must be odd.');

  const [key] = generateKey(2, bits, exponent);

  return key;
}

/**
 * Generate a private key.
 * @param {Number} [bits=2048]
 * @param {Number} [exponent=65537]
 * @returns {RSAPrivateKey} Private key.
 */

async function privateKeyGenerateAsync(bits, exponent) {
  if (bits == null)
    bits = DEFAULT_BITS;

  if (exponent == null)
    exponent = DEFAULT_EXP;

  assert((bits >>> 0) === bits);
  assert(Number.isSafeInteger(exponent) && exponent >= 0);

  if (bits < MIN_BITS || bits > MAX_BITS)
    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

  if (exponent < MIN_EXP || exponent > MAX_EXP)
    throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);

  if (exponent === 1 || (exponent % 2) === 0)
    throw new RangeError('"exponent" must be odd.');

  try {
    return await generateSubtle(bits, exponent);
  } catch (e) {
    return privateKeyGenerate(bits, exponent);
  }
}

/**
 * Pre-compute a private key.
 * @param {RSAPrivateKey}
 * @returns {RSAPrivateKey}
 */

function privateKeyCompute(key) {
  assert(key instanceof RSAPrivateKey);

  if (!isSaneCompute(key))
    throw new Error('Invalid RSA private key.');

  if (!needsCompute(key))
    return key;

  const p = BN.decode(key.p);
  const q = BN.decode(key.q);

  let n = BN.decode(key.n);
  let e = BN.decode(key.e);
  let d = BN.decode(key.d);
  let dp = BN.decode(key.dp);
  let dq = BN.decode(key.dq);
  let qi = BN.decode(key.qi);

  if (n.bitLength() === 0) {
    n = p.mul(q);
    key.n = n.encode();
  }

  if (e.bitLength() === 0) {
    const t = p.subn(1).imul(q.subn(1));
    e = d.invert(t);
    key.e = e.encode();
  }

  if (d.bitLength() === 0) {
    const t = p.subn(1).imul(q.subn(1));
    d = e.invert(t);
    key.d = d.encode();
  }

  if (dp.bitLength() === 0) {
    dp = d.mod(p.subn(1));
    key.dp = dp.encode();
  }

  if (dq.bitLength() === 0) {
    dq = d.mod(q.subn(1));
    key.dq = dq.encode();
  }

  if (qi.bitLength() === 0) {
    qi = q.invert(p);
    key.qi = qi.encode();
  }

  return key;
}

/**
 * Verify a private key.
 * @param {RSAPrivateKey} key
 * @returns {Boolean}
 */

function privateKeyVerify(key) {
  assert(key instanceof RSAPrivateKey);

  if (!isSanePrivateKey(key))
    return false;

  // https://github.com/golang/go/blob/aadaec5/src/crypto/rsa/rsa.go#L169
  const mod = new BN(1);
  const primes = [
    BN.decode(key.p),
    BN.decode(key.q)
  ];

  for (const prime of primes) {
    if (prime.cmpn(1) <= 0)
      return false;

    mod.imul(prime);
  }

  const n = BN.decode(key.n);

  if (mod.cmp(n) !== 0)
    return false;

  const d = BN.decode(key.d);
  const e = BN.decode(key.e);
  const de = e.imul(d);

  for (const prime of primes) {
    const cg = de.mod(prime.subn(1));

    if (cg.cmpn(1) !== 0)
      return false;
  }

  return true;
}

/**
 * Export a private key to PKCS1 ASN.1 format.
 * @param {RSAPrivateKey} key
 * @returns {Buffer}
 */

function privateKeyExport(key) {
  assert(key instanceof RSAPrivateKey);

  if (!isSanePrivateKey(key))
    throw new Error('Invalid RSA private key.');

  return new pkcs1.RSAPrivateKey(
    0,
    key.n,
    key.e,
    key.d,
    key.p,
    key.q,
    key.dp,
    key.dq,
    key.qi
  ).encode();
}

/**
 * Import a private key from PKCS1 ASN.1 format.
 * @param {Buffer} raw
 * @returns {RSAPrivateKey}
 */

function privateKeyImport(raw) {
  const key = pkcs1.RSAPrivateKey.decode(raw);

  assert(key.version.toNumber() === 0);

  return new RSAPrivateKey(
    key.n.value,
    key.e.value,
    key.d.value,
    key.p.value,
    key.q.value,
    key.dp.value,
    key.dq.value,
    key.qi.value
  );
}

/**
 * Export a private key to PKCS8 ASN.1 format.
 * @param {RSAPrivateKey} key
 * @returns {Buffer}
 */

function privateKeyExportPKCS8(key) {
  assert(key instanceof RSAPrivateKey);

  return new pkcs8.PrivateKeyInfo(
    0,
    asn1.objects.keyAlgs.RSA,
    new asn1.Null(),
    privateKeyExport(key)
  ).encode();
}

/**
 * Import a private key from PKCS8 ASN.1 format.
 * @param {Buffer} raw
 * @returns {RSAPrivateKey}
 */

function privateKeyImportPKCS8(raw) {
  const pki = pkcs8.PrivateKeyInfo.decode(raw);
  const {algorithm, parameters} = pki.algorithm;

  assert(pki.version.toNumber() === 0);
  assert(algorithm.toString() === asn1.objects.keyAlgs.RSA);
  assert(parameters.node.type === asn1.types.NULL);

  return privateKeyImport(pki.privateKey.value);
}

/**
 * Export a private key to JWK JSON format.
 * @param {RSAPrivateKey} key
 * @returns {Object}
 */

function privateKeyExportJWK(key) {
  assert(key instanceof RSAPrivateKey);
  return key.toJSON();
}

/**
 * Import a private key from JWK JSON format.
 * @param {Object} json
 * @returns {RSAPrivateKey}
 */

function privateKeyImportJWK(json) {
  const key = RSAPrivateKey.fromJSON(json);

  privateKeyCompute(key);

  return key;
}

/**
 * Create a public key from a private key.
 * @param {RSAPrivateKey} key
 * @returns {RSAPublicKey}
 */

function publicKeyCreate(key) {
  assert(key instanceof RSAPrivateKey);

  const pub = new RSAPublicKey();

  pub.n = key.n;
  pub.e = key.e;

  return pub;
}

/**
 * Verify a public key.
 * @param {RSAKey} key
 * @returns {Boolean}
 */

function publicKeyVerify(key) {
  assert(key instanceof RSAKey);
  return isSanePublicKey(key);
}

/**
 * Export a public key to PKCS1 ASN.1 format.
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function publicKeyExport(key) {
  assert(key instanceof RSAKey);

  if (!isSanePublicKey(key))
    throw new Error('Invalid RSA public key.');

  return new pkcs1.RSAPublicKey(key.n, key.e).encode();
}

/**
 * Import a public key from PKCS1 ASN.1 format.
 * @param {Buffer} raw
 * @returns {RSAPublicKey}
 */

function publicKeyImport(raw) {
  const key = pkcs1.RSAPublicKey.decode(raw);
  return new RSAPublicKey(key.n.value, key.e.value);
}

/**
 * Export a public key to SubjectPublicKeyInfo ASN.1 format.
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function publicKeyExportSPKI(key) {
  // https://tools.ietf.org/html/rfc3279#section-2.3.1
  return new x509.SubjectPublicKeyInfo(
    asn1.objects.keyAlgs.RSA,
    new asn1.Null(),
    publicKeyExport(key)
  ).encode();
}

/**
 * Import a public key from SubjectPublicKeyInfo ASN.1 format.
 * @param {Buffer} raw
 * @returns {RSAPublicKey}
 */

function publicKeyImportSPKI(raw) {
  const spki = x509.SubjectPublicKeyInfo.decode(raw);
  const {algorithm, parameters} = spki.algorithm;

  assert(algorithm.toString() === asn1.objects.keyAlgs.RSA);
  assert(parameters.node.type === asn1.types.NULL);

  return publicKeyImport(spki.publicKey.rightAlign());
}

/**
 * Export a public key to JWK JSON format.
 * @param {RSAKey} key
 * @returns {Object}
 */

function publicKeyExportJWK(key) {
  assert(key instanceof RSAKey);
  return key.toPublic().toJSON();
}

/**
 * Import a public key from JWK JSON format.
 * @param {Object} json
 * @returns {RSAPublicKey}
 */

function publicKeyImportJWK(json) {
  return RSAPublicKey.fromJSON(json);
}

/**
 * Sign a message (PKCS1v1.5).
 * @param {Object|String|null} hash
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key - Private key.
 * @returns {Buffer} PKCS#1v1.5-formatted signature.
 */

function sign(hash, msg, key, decipher = decryptRaw) {
  if (hash && typeof hash.id === 'string')
    hash = hash.id;

  assert(hash == null || typeof hash === 'string');
  assert(Buffer.isBuffer(msg));
  assert(key instanceof RSAPrivateKey);
  assert(typeof decipher === 'function');

  const [prefix, hlen] = getDigestInfo(hash, msg);

  if (!prefix)
    throw new Error('Unknown RSA hash function.');

  if (msg.length !== hlen)
    throw new Error('Invalid RSA message size.');

  if (!isSanePrivateKey(key))
    throw new Error('Invalid RSA private key.');

  const tlen = prefix.length + hlen;
  const klen = key.size();

  if (klen < tlen + 11)
    throw new Error('Message too long.');

  // EM = 0x00 || 0x01 || PS || 0x00 || T
  const em = Buffer.allocUnsafe(klen);

  em[0] = 0x00;
  em[1] = 0x01;

  for (let i = 2; i < klen - tlen - 1; i++)
    em[i] = 0xff;

  em[klen - tlen - 1] = 0x00;

  prefix.copy(em, klen - tlen);
  msg.copy(em, klen - hlen);

  return decipher(em, key);
}

/**
 * Verify a signature (PKCS1v1.5).
 * @param {Object|String|null} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PKCS#1v1.5-formatted.
 * @param {RSAKey} key
 * @returns {Boolean}
 */

function verify(hash, msg, sig, key, encipher = encryptRaw) {
  if (hash && typeof hash.id === 'string')
    hash = hash.id;

  assert(hash == null || typeof hash === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(key instanceof RSAKey);
  assert(typeof encipher === 'function');

  try {
    return _verify(hash, msg, sig, key, encipher);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature (PKCS1v1.5).
 * @private
 * @param {Object|String|null} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PKCS#1v1.5-formatted.
 * @param {RSAKey} key
 * @returns {Boolean}
 */

function _verify(hash, msg, sig, key, encipher) {
  if (hash && typeof hash.id === 'string')
    hash = hash.id;

  assert(hash == null || typeof hash === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(key instanceof RSAKey);
  assert(typeof encipher === 'function');

  const [prefix, hlen] = getDigestInfo(hash, msg);

  if (!prefix)
    return false;

  if (msg.length !== hlen)
    return false;

  const klen = key.size();

  if (sig.length !== klen)
    return false;

  if (!isSanePublicKey(key))
    return false;

  const tlen = prefix.length + hlen;

  if (klen < tlen + 11)
    return false;

  const em = encipher(sig, key);

  // EM = 0x00 || 0x01 || PS || 0x00 || T
  let ok = 1;

  ok &= safeEqualByte(em[0], 0x00);
  ok &= safeEqualByte(em[1], 0x01);

  for (let i = 2; i < klen - tlen - 1; i++)
    ok &= safeEqualByte(em[i], 0xff);

  ok &= safeEqualByte(em[klen - tlen - 1], 0x00);
  ok &= safeEqual(em.slice(klen - tlen, klen - hlen), prefix);
  ok &= safeEqual(em.slice(klen - hlen, klen), msg);

  return ok === 1;
}

/**
 * Verify a signature (PKCS1v1.5).
 * @param {Object|String|null} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PKCS#1v1.5-formatted.
 * @param {RSAKey} key
 * @returns {Boolean}
 */

function verifyLax(hash, msg, sig, key, encipher) {
  assert(key instanceof RSAKey);
  return verify(hash, msg, key.pad(sig), key, encipher);
}

/**
 * Encrypt a message with public key (PKCS1v1.5).
 * @param {Buffer} msg
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function encrypt(msg, key, encipher = encryptRaw) {
  assert(Buffer.isBuffer(msg));
  assert(key instanceof RSAKey);
  assert(typeof encipher === 'function');

  if (!isSanePublicKey(key))
    throw new Error('Invalid RSA public key.');

  const klen = key.size();

  if (msg.length > klen - 11)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || 0x02 || PS || 0x00 || M
  const em = Buffer.allocUnsafe(klen);
  const mlen = msg.length;
  const plen = klen - mlen - 3;

  em[0] = 0x00;
  em[1] = 0x02;

  randomNonzero(em, 2, plen);

  em[klen - mlen - 1] = 0x00;

  msg.copy(em, klen - mlen);

  return encipher(em, key);
}

/**
 * Decrypt a message with private key (PKCS1v1.5).
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key
 * @returns {Buffer}
 */

function decrypt(msg, key, decipher = decryptRaw) {
  assert(Buffer.isBuffer(msg));
  assert(key instanceof RSAPrivateKey);
  assert(typeof decipher === 'function');

  const klen = key.size();

  if (msg.length !== klen)
    throw new Error('Invalid RSA message size.');

  if (!isSanePrivateKey(key))
    throw new Error('Invalid RSA private key.');

  if (klen < 11)
    throw new Error('Invalid RSA private key.');

  // EM = 0x00 || 0x02 || PS || 0x00 || M
  const em = decipher(msg, key);
  const fbiz = safeEqualByte(em[0], 0x00);
  const sbit = safeEqualByte(em[1], 0x02);

  let index = 0;
  let looking = 1;

  for (let i = 2; i < em.length; i++) {
    const equals0 = safeEqualByte(em[i], 0x00);

    index = safeSelect(looking & equals0, i, index);
    looking = safeSelect(equals0, 0, looking);
  }

  const validPS = safeLTE(2 + 8, index);
  const valid = fbiz & sbit & (~looking & 1) & validPS;

  index = safeSelect(valid, index + 1, 0);

  // Note: this line leaks timing information.
  // Nothing we can do about it (PKCS1v1.5 is broken).
  if (valid === 0)
    throw new Error('Invalid ciphertext.');

  return em.slice(index);
}

/**
 * Decrypt a message with private key (PKCS1v1.5).
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key
 * @returns {Buffer}
 */

function decryptLax(msg, key, decipher) {
  assert(key instanceof RSAKey);
  return decrypt(key.pad(msg), key, decipher);
}

/**
 * Encrypt a message with public key (OAEP).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {RSAKey} key
 * @param {Buffer?} label
 * @returns {Buffer}
 */

function encryptOAEP(hash, msg, key, label, encipher = encryptRaw) {
  if (label == null)
    label = EMPTY;

  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(label));
  assert(key instanceof RSAKey);
  assert(typeof encipher === 'function');

  if (!isSanePublicKey(key))
    throw new Error('Invalid RSA public key.');

  const klen = key.size();
  const mlen = msg.length;
  const hlen = hash.size;

  if (mlen > klen - 2 * hlen - 2)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || mgf1(SEED) || mgf1(DB)
  const em = Buffer.allocUnsafe(klen);
  const seed = em.slice(1, 1 + hlen);
  const db = em.slice(1 + hlen);
  const dlen = db.length;

  em[0] = 0x00;

  // SEED = Random Bytes
  rng.randomFill(seed, 0, seed.length);

  // DB = HASH(LABEL) || PS || 0x01 || M
  hash.digest(label).copy(db, 0);
  db.fill(0x00, hlen, dlen - mlen - 1);
  db[dlen - mlen - 1] = 0x01;
  msg.copy(db, dlen - mlen);

  mgf1XOR(hash, seed, db);
  mgf1XOR(hash, db, seed);

  return encipher(em, key);
}

/**
 * Decrypt a message with private key (OAEP).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key
 * @param {Buffer?} label
 * @returns {Buffer}
 */

function decryptOAEP(hash, msg, key, label, decipher = decryptRaw) {
  if (label == null)
    label = EMPTY;

  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(label));
  assert(key instanceof RSAPrivateKey);
  assert(typeof decipher === 'function');

  const klen = key.size();
  const mlen = msg.length;
  const hlen = hash.size;

  if (mlen !== klen)
    throw new Error('Invalid RSA message size.');

  if (!isSanePrivateKey(key))
    throw new Error('Invalid RSA private key.');

  if (klen < hlen * 2 + 2)
    throw new Error('Invalid RSA private key size.');

  const em = decipher(msg, key);
  const expect = hash.digest(label);
  const fbiz = safeEqualByte(em[0], 0x00);
  const seed = em.slice(1, hlen + 1);
  const db = em.slice(hlen + 1);

  mgf1XOR(hash, db, seed);
  mgf1XOR(hash, seed, db);

  const lhash = db.slice(0, hlen);
  const lvalid = safeEqual(lhash, expect);

  let looking = 1;
  let index = 0;
  let invalid = 0;

  const rest = db.slice(hlen);

  for (let i = 0; i < rest.length; i++) {
    const equals0 = safeEqualByte(rest[i], 0x00);
    const equals1 = safeEqualByte(rest[i], 0x01);

    index = safeSelect(looking & equals1, i, index);
    looking = safeSelect(equals1, 0, looking);
    invalid = safeSelect(looking & ~equals0, 1, invalid);
  }

  if ((fbiz & lvalid & ~invalid & ~looking) !== 1)
    throw new Error('Invalid RSA ciphertext.');

  return rest.slice(index + 1);
}

/**
 * Decrypt a message with private key (OAEP).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key
 * @param {Buffer?} label
 * @returns {Buffer}
 */

function decryptOAEPLax(hash, msg, key, label, decipher) {
  assert(key instanceof RSAKey);
  return decryptOAEP(hash, key.pad(msg), key, label, decipher);
}

/**
 * Sign a message (PSS).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key - Private key.
 * @param {Number} [saltLen=-1]
 * @returns {Buffer} PSS-formatted signature.
 */

function signPSS(hash, msg, key, saltLen = -1, decipher = decryptRaw) {
  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert(key instanceof RSAPrivateKey);
  assert(saltLen === -1 || (saltLen >>> 0) === saltLen);
  assert(typeof decipher === 'function');

  if (msg.length !== hash.size)
    throw new Error('Invalid RSA message size.');

  if (!isSanePrivateKey(key))
    throw new Error('Invalid RSA private key.');

  if (saltLen === 0) // Auto
    saltLen = key.size() - 2 - hash.size;
  else if (saltLen === -1) // Equals
    saltLen = hash.size;

  const salt = rng.randomBytes(saltLen);
  const bits = key.bits();
  const em = pssEncode(hash, msg, bits - 1, salt);

  return decipher(em, key);
}

/**
 * Verify a signature (PSS).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PSS-formatted.
 * @param {RSAKey} key
 * @param {Number} [saltLen=-1]
 * @returns {Boolean}
 */

function verifyPSS(hash, msg, sig, key, saltLen = -1, encipher = encryptRaw) {
  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(key instanceof RSAKey);
  assert(saltLen === -1 || (saltLen >>> 0) === saltLen);
  assert(typeof encipher === 'function');

  try {
    return _verifyPSS(hash, msg, sig, key, saltLen, encipher);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature (PSS).
 * @private
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PSS-formatted.
 * @param {RSAKey} key
 * @param {Number} [saltLen=-1]
 * @returns {Boolean}
 */

function _verifyPSS(hash, msg, sig, key, saltLen = -1, encipher) {
  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(sig));
  assert(key instanceof RSAKey);
  assert(saltLen === -1 || (saltLen >>> 0) === saltLen);
  assert(typeof encipher === 'function');

  if (msg.length !== hash.size)
    return false;

  if (sig.length !== key.size())
    return false;

  if (!isSanePublicKey(key))
    return false;

  const em = encipher(sig, key);
  const bits = key.bits();

  if (saltLen === -1) // Equals
    saltLen = hash.size;

  return pssVerify(hash, msg, em, bits - 1, saltLen);
}

/**
 * Verify a signature (PSS).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PSS-formatted.
 * @param {RSAKey} key
 * @param {Number} [saltLen=-1]
 * @returns {Boolean}
 */

function verifyPSSLax(hash, msg, sig, key, saltLen, encipher) {
  assert(key instanceof RSAKey);
  return verifyPSS(hash, msg, key.pad(sig), key, saltLen, encipher);
}

/**
 * Raw encryption.
 * @private
 * @param {Buffer} msg
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function encryptRaw(msg, key) {
  assert(Buffer.isBuffer(msg));
  assert(key instanceof RSAKey);

  // OpenSSL behavior for public encryption.
  if (msg.length !== key.size())
    throw new Error('Invalid RSA message size.');

  const n = BN.decode(key.n);
  const e = BN.decode(key.e);

  if (n.isZero() || e.isZero())
    throw new Error('Invalid RSA public key.');

  const m = BN.decode(msg);

  // c := m^e mod n
  const c = m.powm(e, n);

  return c.encode('be', n.byteLength());
}

/**
 * Raw decryption.
 * @private
 * @param {Buffer} msg
 * @param {RSAPrivateKey} key
 * @returns {Buffer}
 */

function decryptRaw(msg, key) {
  assert(Buffer.isBuffer(msg));
  assert(key instanceof RSAPrivateKey);

  let n = BN.decode(key.n);
  let e = BN.decode(key.e);

  // Recompute modulus.
  if (n.isZero()) {
    const p = BN.decode(key.p);
    const q = BN.decode(key.q);

    if (p.isZero() || q.isZero())
      throw new Error('Invalid RSA private key.');

    // n := p * q
    n = p.imul(q);
  }

  // Recompute public exponent.
  if (e.isZero()) {
    const d = BN.decode(key.d);
    const p = BN.decode(key.p);
    const q = BN.decode(key.q);

    if (d.isZero() || p.isZero() || q.isZero())
      throw new Error('Invalid RSA private key.');

    // t := (p - 1) * (q - 1)
    const t = p.isubn(1).imul(q.isubn(1));

    // e := d^-1 mod t
    try {
      e = d.invert(t);
    } catch (e) {
      throw new Error('Invalid RSA private key.');
    }
  }

  // Decode message.
  const c = BN.decode(msg);

  // Validate params.
  if (c.cmp(n) > 0 || n.isZero())
    throw new Error('Invalid RSA message size.');

  // Generate blinding factor.
  const [blind, unblind] = getBlinding(n, e);

  // Blind.
  c.imul(blind).imod(n);

  // Decrypt.
  let m = null;

  // Potentially use precomputed values.
  if (needsCompute(key)) {
    // Decrypt with private exponent.
    let d = BN.decode(key.d);

    // Recompute private exponent.
    if (d.isZero()) {
      const p = BN.decode(key.p);
      const q = BN.decode(key.q);

      if (p.isZero() || q.isZero())
        throw new Error('Invalid RSA private key.');

      // t := (p - 1) * (q - 1)
      const t = p.isubn(1).imul(q.isubn(1));

      // d := e^-1 mod t
      try {
        d = e.invert(t);
      } catch (e) {
        throw new Error('Invalid RSA private key.');
      }
    }

    // m := c^d mod n
    m = c.powm(d, n);
  } else {
    // Decrypt with precomputed values.
    // We can use montgomery reduction
    // here since our moduli are prime.
    const p = BN.decode(key.p);
    const q = BN.decode(key.q);
    const dp = BN.decode(key.dp);
    const dq = BN.decode(key.dq);
    const qi = BN.decode(key.qi);

    // mp := c^(d mod p-1) mod p
    // mq := c^(d mod q-1) mod q
    // md := ((mp - mq) / q) mod p
    const mp = c.powm(dp, p, true);
    const mq = c.powm(dq, q, true);
    const md = mp.isub(mq).imul(qi).imod(p);

    // m := (md * q + mq) mod n
    m = md.imul(q).iadd(mq).imod(n);

    // Check for congruency.
    // (m^e - c) mod n == 0
    const v = m.powm(e, n).isub(c).imod(n);

    // In reality we would want to
    // error here, but OpenSSL
    // swallows the error and does
    // a slower exponentation (wtf?).
    if (!v.isZero()) {
      const d = BN.decode(key.d);

      // m := c^d mod n
      m = c.powm(d, n);
    }
  }

  // Unblind.
  m.imul(unblind).imod(n);

  return m.encode('be', n.byteLength());
}

/**
 * "Veil" an RSA ciphertext to hide the key size.
 * @param {Buffer} msg
 * @param {Number} bits
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function veil(msg, bits, key) {
  assert(Buffer.isBuffer(msg));
  assert((bits >>> 0) === bits);
  assert(key instanceof RSAKey);

  if (!isSanePublicKey(key))
    throw new Error('Invalid RSA public key.');

  if (msg.length !== key.size())
    throw new Error('Invalid RSA ciphertext.');

  if (bits < key.bits())
    throw new Error('Cannot make ciphertext smaller.');

  const c0 = BN.decode(msg);
  const n = BN.decode(key.n);

  if (c0.cmp(n) >= 0)
    throw new Error('Invalid ciphertext.');

  const ctlim = new BN(1).iushln(bits);
  const rlim = ctlim.sub(c0).iadd(n).isubn(1).div(n);

  let c1 = ctlim;

  while (c1.cmp(ctlim) >= 0) {
    const cr = BN.random(rng, 0, rlim);

    if (rlim.cmpn(1) > 0 && cr.isZero())
      continue;

    c1 = c0.add(cr.imul(n));
  }

  assert(c1.mod(n).cmp(c0) === 0);
  assert(c1.bitLength() <= bits);

  return c1.encode('be', (bits + 7) >>> 3);
}

/**
 * "Veil" an RSA ciphertext to hide the key size.
 * @param {Buffer} msg
 * @param {Number} bits
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function veilLax(msg, bits, key) {
  assert(key instanceof RSAKey);
  return veil(key.pad(msg), bits, key);
}

/**
 * "Unveil" a veiled RSA ciphertext.
 * @param {Buffer} msg
 * @param {Number} bits
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function unveil(msg, bits, key) {
  assert(Buffer.isBuffer(msg));
  assert((bits >>> 0) === bits);
  assert(key instanceof RSAKey);

  if (!isSanePublicKey(key))
    throw new Error('Invalid RSA public key.');

  const klen = key.size();

  if (msg.length < klen)
    throw new Error('Invalid RSA ciphertext.');

  if (countLeft(msg) > bits)
    throw new Error('Invalid RSA ciphertext.');

  const c1 = BN.decode(msg);
  const n = BN.decode(key.n);
  const c0 = c1.imod(n);

  return c0.encode('be', klen);
}

/**
 * "Unveil" a veiled RSA ciphertext.
 * @param {Buffer} msg
 * @param {Number} bits
 * @param {RSAKey} key
 * @returns {Buffer}
 */

function unveilLax(msg, bits, key) {
  assert(key instanceof RSAKey);
  return unveil(key.pad(msg), bits, key);
}

/**
 * Generate multi-prime key.
 * @private
 * @param {Number} total
 * @param {Number} bits
 * @param {Number} exponent
 * @returns {Array}
 */

function generateKey(total, bits, exponent) {
  assert((total >>> 0) === total);
  assert((bits >>> 0) === bits);
  assert(Number.isSafeInteger(exponent) && exponent >= 0);
  assert(bits >= 4);
  assert(exponent >= 3 && (exponent % 2) !== 0);

  // https://github.com/golang/go/blob/aadaec5/src/crypto/rsa/rsa.go#L220
  // https://github.com/golang/go/blob/aadaec5/src/crypto/rsa/rsa.go#L429
  if (total < 2)
    throw new Error('RSA key reqs at least 2 primes.');

  if (bits < 64) {
    let pi = 2 ** Math.floor(bits / total);

    pi /= Math.log(pi) - 1;
    pi /= 4;
    pi /= 2;

    if (pi <= total)
      throw new Error('Too few primes for RSA key.');
  }

next:
  for (;;) {
    const primes = [];

    let todo = bits;

    if (total >= 7)
      todo += Math.floor((total - 2) / 5);

    for (let i = 0; i < total; i++) {
      const size = Math.floor(todo / (total - i));
      const prime = randomPrime(size);

      primes.push(prime);

      todo -= prime.bitLength();
    }

    for (let i = 0; i < total; i++) {
      const prime = primes[i];

      for (let j = 0; j < i; j++) {
        if (prime.cmp(primes[j]) === 0)
          continue next;
      }
    }

    const n = new BN(1);
    const t = new BN(1);

    for (const prime of primes) {
      n.imul(prime);
      t.imul(prime.subn(1));
    }

    if (n.bitLength() !== bits)
      continue;

    const e = new BN(exponent);

    let d = null;

    try {
      d = e.invert(t);
    } catch (e) {
      continue;
    }

    const [p, q] = primes;
    const dp = d.mod(p.subn(1));
    const dq = d.mod(q.subn(1));
    const qi = q.invert(p);

    const key = new RSAPrivateKey();

    key.n = n.encode();
    key.e = e.encode();
    key.d = d.encode();
    key.p = p.encode();
    key.q = q.encode();
    key.dp = dp.encode();
    key.dq = dq.encode();
    key.qi = qi.encode();

    const extra = [];

    for (let i = 2; i < primes.length; i++) {
      const prime = primes[i].encode();
      extra.push(prime);
    }

    return [key, extra];
  }
}

/*
 * Subtle
 */

async function generateSubtle(bits, exponent) {
  assert((bits >>> 0) === bits);
  assert(Number.isSafeInteger(exponent) && exponent >= 0);
  assert(bits >= 4);
  assert(exponent >= 3 && (exponent % 2) !== 0);

  const crypto = global.crypto || global.msCrypto;

  if (!crypto)
    throw new Error('Crypto API not available.');

  const subtle = crypto.subtle;

  if (!subtle)
    throw new Error('Subtle API not available.');

  if (!subtle.generateKey || !subtle.exportKey)
    throw new Error('Subtle key generation not available.');

  const hi = (exponent * (1 / 0x100000000)) >>> 0;
  const lo = exponent >>> 0;
  const exp = new Uint8Array(8);

  exp[0] = 0;
  exp[1] = 0;
  exp[2] = hi >>> 8;
  exp[3] = hi;
  exp[4] = lo >>> 24;
  exp[5] = lo >>> 16;
  exp[6] = lo >>> 8;
  exp[7] = lo;

  const algo = {
    name: 'RSASSA-PKCS1-v1_5',
    modulusLength: bits,
    publicExponent: exp,
    hash: { name: 'SHA-256' }
  };

  const ck = await subtle.generateKey(algo, true, ['sign']);
  const jwk = await subtle.exportKey('jwk', ck.privateKey);
  const key = new RSAPrivateKey();

  key.n = base64.decodeURL(jwk.n);
  key.e = base64.decodeURL(jwk.e);
  key.d = base64.decodeURL(jwk.d);
  key.p = base64.decodeURL(jwk.p);
  key.q = base64.decodeURL(jwk.q);
  key.dp = base64.decodeURL(jwk.dp);
  key.dq = base64.decodeURL(jwk.dq);
  key.qi = base64.decodeURL(jwk.qi);

  return key;
}

/*
 * Randomization
 */

function getBlinding(n, e) {
  assert(n instanceof BN);
  assert(e instanceof BN);

  // Generate blinding factor.
  let blind = null;
  let unblind = null;

  for (;;) {
    // s := rand(1..n)
    const s = BN.random(rng, 1, n);

    // unblind := s^-1 mod n
    try {
      unblind = s.invert(n);
    } catch (e) {
      continue;
    }

    // blind := s^e mod n
    blind = s.powm(e, n);

    break;
  }

  return [blind, unblind];
}

/*
 * PSS
 */

function pssEncode(hash, msg, embits, salt) {
  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert((embits >>> 0) === embits);
  assert(Buffer.isBuffer(salt));

  const hlen = hash.size;
  const slen = salt.length;
  const emlen = (embits + 7) >>> 3;

  if (msg.length !== hlen)
    throw new Error('RSA input must be hashed message.');

  if (emlen < hlen + slen + 2)
    throw new Error('RSA key size too small for PSS signature.');

  const em = Buffer.allocUnsafe(emlen);
  em.fill(0x00);

  const db = em.slice(0, emlen - slen - hlen - 2 + 1 + slen);
  const h = em.slice(emlen - slen - hlen - 2 + 1 + slen, emlen - 1);
  const h0 = hash.multi(PREFIX, msg, salt);

  h0.copy(h, 0);
  db[emlen - slen - hlen - 2] = 0x01;
  salt.copy(db, emlen - slen - hlen - 1);

  mgf1XOR(hash, h, db);

  db[0] &= 0xff >>> (8 * emlen - embits);
  em[emlen - 1] = 0xbc;

  return em;
}

function pssVerify(hash, msg, em, embits, slen) {
  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(em));
  assert((embits >>> 0) === embits);
  assert((slen >>> 0) === slen);

  const hlen = hash.size;

  if (msg.length !== hlen)
    return false;

  const emlen = (embits + 7) >>> 3;

  if (emlen < hlen + slen + 2)
    return false;

  if (em[em.length - 1] !== 0xbc)
    return false;

  const db = em.slice(0, emlen - hlen - 1);
  const h = em.slice(emlen - hlen - 1, em.length - 1);

  const bit = (0xff << (8 - (8 * emlen - embits))) & 0xff;

  if ((em[0] & bit) !== 0)
    return false;

  mgf1XOR(hash, h, db);

  db[0] &= 0xff >>> (8 * emlen - embits);

  if (slen === 0) { // Auto
    slen = emlen - (hlen + 2);

outer:
    for (; slen >= 0; slen--) {
      const e = db[emlen - hlen - slen - 2];

      switch (e) {
        case 0x01:
          break outer;
        case 0x00:
          continue;
        default:
          return false;
      }
    }

    if (slen < 0)
      return false;
  } else {
    const len = emlen - hlen - slen - 2;

    for (let i = 0; i < len; i++) {
      if (db[i] !== 0x00)
        return false;
    }

    if (db[len] !== 0x01)
      return false;
  }

  const salt = db.slice(db.length - slen);
  const h0 = hash.multi(PREFIX, msg, salt);

  return h0.equals(h);
}

/*
 * Sanity Checking
 */

function isSanePublicKey(key) {
  assert(key instanceof RSAKey);

  const nb = countLeft(key.n);

  if (nb < MIN_BITS || nb > MAX_BITS)
    return false;

  const eb = countLeft(key.e);

  if (eb < MIN_EXP_BITS || eb > MAX_EXP_BITS)
    return false;

  if ((key.e[key.e.length - 1] & 1) === 0)
    return false;

  return true;
}

function isSanePrivateKey(key) {
  assert(key instanceof RSAPrivateKey);

  if (!isSanePublicKey(key))
    return false;

  const nb = countLeft(key.n);
  const db = countLeft(key.d);

  if (db === 0 || db > nb)
    return false;

  const pb = countLeft(key.p);
  const qb = countLeft(key.q);

  if (nb > pb + qb)
    return false;

  const dpb = countLeft(key.dp);

  if (dpb === 0 || dpb > pb)
    return false;

  const dqb = countLeft(key.dq);

  if (dqb === 0 || dqb > qb)
    return false;

  const qib = countLeft(key.qi);

  if (qib === 0 || qib > pb)
    return false;

  return true;
}

function isSaneCompute(key) {
  assert(key instanceof RSAPrivateKey);

  const nb = countLeft(key.n);
  const eb = countLeft(key.e);
  const db = countLeft(key.d);
  const pb = countLeft(key.p);
  const qb = countLeft(key.q);
  const dpb = countLeft(key.dp);
  const dqb = countLeft(key.dq);
  const qib = countLeft(key.qi);

  if (pb === 0 || qb === 0)
    return false;

  if (eb === 0 && db === 0)
    return false;

  if (nb !== 0) {
    if (nb < MIN_BITS || nb > MAX_BITS)
      return false;

    if (nb > pb + qb)
      return false;
  }

  if (eb !== 0) {
    if (eb < MIN_EXP_BITS || eb > MAX_EXP_BITS)
      return false;

    if ((key.e[key.e.length - 1] & 1) === 0)
      return false;
  }

  if (db !== 0) {
    if (db > pb + qb)
      return false;
  }

  if (dpb !== 0) {
    if (dpb > pb)
      return false;
  }

  if (dqb !== 0) {
    if (dqb > qb)
      return false;
  }

  if (qib !== 0) {
    if (qib > pb)
      return false;
  }

  return true;
}

function needsCompute(key) {
  assert(key instanceof RSAPrivateKey);

  return countLeft(key.n) === 0
      || countLeft(key.e) === 0
      || countLeft(key.d) === 0
      || countLeft(key.dp) === 0
      || countLeft(key.dq) === 0
      || countLeft(key.qi) === 0;
}

/*
 * Helpers
 */

function randomNonzero(buf, offset, size) {
  assert(Buffer.isBuffer(buf));
  assert((offset >>> 0) === offset);
  assert((size >>> 0) === size);

  rng.randomFill(buf, offset, size);

  const len = offset + size;

  for (let i = offset; i < len; i++) {
    while (buf[i] === 0x00)
      rng.randomFill(buf, i, 1);
  }
}

function mgf1XOR(hash, seed, out) {
  assert(hash && typeof hash.id === 'string');
  assert(Buffer.isBuffer(seed));
  assert(Buffer.isBuffer(out));

  const counter = Buffer.allocUnsafe(4);

  counter.fill(0x00);

  let done = 0;

  while (done < out.length) {
    const digest = hash.multi(seed, counter);

    for (let i = 0; i < digest.length && done < out.length; i++) {
      out[done] ^= digest[i];
      done += 1;
    }

    for (let i = 3; i >= 0; i--) {
      if (counter[i] !== 0xff) {
        counter[i] += 1;
        break;
      }

      counter[i] = 0x00;
    }
  }
}

function getDigestInfo(name, msg) {
  assert(name == null || typeof name === 'string');
  assert(Buffer.isBuffer(msg));

  if (name == null)
    return [EMPTY, msg.length];

  const prefix = digestInfo[name];

  if (!Buffer.isBuffer(prefix))
    return [null, 0];

  return [
    prefix,
    prefix.length > 0
      ? prefix[prefix.length - 1]
      : 36
  ];
}

/*
 * Expose
 */

exports.native = 0;
exports.RSAKey = RSAKey;
exports.RSAPublicKey = RSAPublicKey;
exports.RSAPrivateKey = RSAPrivateKey;
exports.privateKeyGenerate = privateKeyGenerate;
exports.privateKeyGenerateAsync = privateKeyGenerateAsync;
exports.privateKeyCompute = privateKeyCompute;
exports.privateKeyVerify = privateKeyVerify;
exports.privateKeyExport = privateKeyExport;
exports.privateKeyImport = privateKeyImport;
exports.privateKeyExportPKCS8 = privateKeyExportPKCS8;
exports.privateKeyImportPKCS8 = privateKeyImportPKCS8;
exports.privateKeyExportJWK = privateKeyExportJWK;
exports.privateKeyImportJWK = privateKeyImportJWK;
exports.publicKeyCreate = publicKeyCreate;
exports.publicKeyVerify = publicKeyVerify;
exports.publicKeyExport = publicKeyExport;
exports.publicKeyImport = publicKeyImport;
exports.publicKeyExportSPKI = publicKeyExportSPKI;
exports.publicKeyImportSPKI = publicKeyImportSPKI;
exports.publicKeyExportJWK = publicKeyExportJWK;
exports.publicKeyImportJWK = publicKeyImportJWK;
exports.sign = sign;
exports.verify = verify;
exports.verifyLax = verifyLax;
exports.encrypt = encrypt;
exports.decrypt = decrypt;
exports.decryptLax = decryptLax;
exports.encryptOAEP = encryptOAEP;
exports.decryptOAEP = decryptOAEP;
exports.decryptOAEPLax = decryptOAEPLax;
exports.signPSS = signPSS;
exports.verifyPSS = verifyPSS;
exports.verifyPSSLax = verifyPSSLax;
exports.encryptRaw = encryptRaw;
exports.decryptRaw = decryptRaw;
exports.veil = veil;
exports.veilLax = veilLax;
exports.unveil = unveil;
exports.unveilLax = unveilLax;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},req("buffer").Buffer)
},{"../bn.js":31,"../encoding/asn1":46,"../encoding/base64":50,"../encoding/pkcs1":58,"../encoding/pkcs8":60,"../encoding/util":63,"../encoding/x509":64,"../internal/primes":79,"../internal/rsakey":80,"../random":162,"../safe":167,"bsert":190,"buffer":303}],127:[function(req,module,exports){
(function (Buffer){
/*!
 * salsa20.js - salsa20 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Salsa20
 *   https://cr.yp.to/snuffle.html
 *   https://cr.yp.to/snuffle/spec.pdf
 *   https://cr.yp.to/snuffle/812.pdf
 *   http://www.ecrypt.eu.org/stream/salsa20pf.html
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;

/**
 * Salsa20
 */

class Salsa20 {
  /**
   * Create a Salsa20 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(16);
    this.stream = new Uint32Array(16);
    this.bytes = new Uint8Array(this.stream.buffer);
    this.pos = 0;

    if (BIG_ENDIAN)
      this.bytes = Buffer.allocUnsafe(64);
  }

  /**
   * Initialize salsa20 with a key, nonce, and counter.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @param {Number} counter
   */

  init(key, nonce, counter) {
    if (counter == null)
      counter = 0;

    assert(Buffer.isBuffer(key));
    assert(Buffer.isBuffer(nonce));
    assert(Number.isSafeInteger(counter));

    if (key.length !== 16 && key.length !== 32)
      throw new RangeError('Invalid key size.');

    if (nonce.length >= 24) {
      key = Salsa20.derive(key, nonce.slice(0, 16));
      nonce = nonce.slice(16);
    }

    this.state[0] = 0x61707865;
    this.state[1] = readU32(key, 0);
    this.state[2] = readU32(key, 4);
    this.state[3] = readU32(key, 8);
    this.state[4] = readU32(key, 12);
    this.state[5] = key.length < 32 ? 0x3120646e : 0x3320646e;

    if (nonce.length === 8) {
      this.state[6] = readU32(nonce, 0);
      this.state[7] = readU32(nonce, 4);
      this.state[8] = counter >>> 0;
      this.state[9] = (counter / 0x100000000) >>> 0;
    } else if (nonce.length === 12) {
      this.state[6] = readU32(nonce, 0);
      this.state[7] = readU32(nonce, 4);
      this.state[8] = readU32(nonce, 8);
      this.state[9] = counter >>> 0;
    } else if (nonce.length === 16) {
      this.state[6] = readU32(nonce, 0);
      this.state[7] = readU32(nonce, 4);
      this.state[8] = readU32(nonce, 8);
      this.state[9] = readU32(nonce, 12);
    } else {
      throw new RangeError('Invalid nonce size.');
    }

    this.state[10] = key.length < 32 ? 0x79622d36 : 0x79622d32;
    this.state[11] = readU32(key, 16 % key.length);
    this.state[12] = readU32(key, 20 % key.length);
    this.state[13] = readU32(key, 24 % key.length);
    this.state[14] = readU32(key, 28 % key.length);
    this.state[15] = 0x6b206574;

    this.pos = 0;

    return this;
  }

  /**
   * Encrypt/decrypt data.
   * @param {Buffer} data - Will be mutated.
   * @returns {Buffer}
   */

  encrypt(data) {
    return this.crypt(data, data);
  }

  /**
   * Encrypt/decrypt data.
   * @param {Buffer} input
   * @param {Buffer} output
   * @returns {Buffer} output
   */

  crypt(input, output) {
    assert(Buffer.isBuffer(input));
    assert(Buffer.isBuffer(output));

    if (output.length < input.length)
      throw new Error('Invalid output size.');

    for (let i = 0; i < input.length; i++) {
      if ((this.pos & 63) === 0) {
        this._block();
        this.pos = 0;
      }

      output[i] = input[i] ^ this.bytes[this.pos++];
    }

    return output;
  }

  /**
   * Stir the stream.
   */

  _block() {
    for (let i = 0; i < 16; i++)
      this.stream[i] = this.state[i];

    for (let i = 0; i < 10; i++) {
      qround(this.stream, 0, 4, 8, 12);
      qround(this.stream, 5, 9, 13, 1);
      qround(this.stream, 10, 14, 2, 6);
      qround(this.stream, 15, 3, 7, 11);
      qround(this.stream, 0, 1, 2, 3);
      qround(this.stream, 5, 6, 7, 4);
      qround(this.stream, 10, 11, 8, 9);
      qround(this.stream, 15, 12, 13, 14);
    }

    for (let i = 0; i < 16; i++)
      this.stream[i] += this.state[i];

    if (BIG_ENDIAN) {
      for (let i = 0; i < 16; i++)
        writeU32(this.bytes, this.stream[i], i * 4);
    }

    this.state[8] += 1;

    if (this.state[8] === 0)
      this.state[9] += 1;
  }

  /**
   * Destroy context.
   */

  destroy() {
    for (let i = 0; i < 16; i++) {
      this.state[i] = 0;
      this.stream[i] = 0;
    }

    if (BIG_ENDIAN) {
      for (let i = 0; i < 64; i++)
        this.bytes[i] = 0;
    }

    this.pos = 0;

    return this;
  }

  /**
   * Derive key with XSalsa20.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @returns {Buffer}
   */

  static derive(key, nonce) {
    assert(Buffer.isBuffer(key));
    assert(Buffer.isBuffer(nonce));

    if (key.length !== 16 && key.length !== 32)
      throw new RangeError('Invalid key size.');

    if (nonce.length !== 16)
      throw new RangeError('Invalid nonce size.');

    const state = new Uint32Array(16);

    state[0] = 0x61707865;
    state[1] = readU32(key, 0);
    state[2] = readU32(key, 4);
    state[3] = readU32(key, 8);
    state[4] = readU32(key, 12);
    state[5] = key.length < 32 ? 0x3120646e : 0x3320646e;
    state[6] = readU32(nonce, 0);
    state[7] = readU32(nonce, 4);
    state[8] = readU32(nonce, 8);
    state[9] = readU32(nonce, 12);
    state[10] = key.length < 32 ? 0x79622d36 : 0x79622d32;
    state[11] = readU32(key, 16 % key.length);
    state[12] = readU32(key, 20 % key.length);
    state[13] = readU32(key, 24 % key.length);
    state[14] = readU32(key, 28 % key.length);
    state[15] = 0x6b206574;

    for (let j = 0; j < 10; j++) {
      qround(state, 0, 4, 8, 12);
      qround(state, 5, 9, 13, 1);
      qround(state, 10, 14, 2, 6);
      qround(state, 15, 3, 7, 11);
      qround(state, 0, 1, 2, 3);
      qround(state, 5, 6, 7, 4);
      qround(state, 10, 11, 8, 9);
      qround(state, 15, 12, 13, 14);
    }

    const out = Buffer.alloc(32);

    writeU32(out, state[0], 0);
    writeU32(out, state[5], 4);
    writeU32(out, state[10], 8);
    writeU32(out, state[15], 12);
    writeU32(out, state[6], 16);
    writeU32(out, state[7], 20);
    writeU32(out, state[8], 24);
    writeU32(out, state[9], 28);

    return out;
  }
}

/*
 * Static
 */

Salsa20.native = 0;

/*
 * Helpers
 */

function qround(x, a, b, c, d) {
  x[b] ^= rotl32(x[a] + x[d], 7);
  x[c] ^= rotl32(x[b] + x[a], 9);
  x[d] ^= rotl32(x[c] + x[b], 13);
  x[a] ^= rotl32(x[d] + x[c], 18);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = Salsa20;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],128:[function(req,module,exports){
(function (Buffer){
/*!
 * schnorr.js - bip-schnorr for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/secp256k1-zkp/src/modules/schnorrsig
 */

'use strict';

const assert = req('bsert');
const BN = req('../bn.js');
const ChaCha20 = req('../chacha20');

/**
 * Schnorr
 */

class Schnorr {
  constructor(curve, hash) {
    this.curve = curve;
    this.hash = hash;
    this.msgSize = 32;
    this.sigSize = this.curve.fieldSize + this.curve.scalarSize;
    this.supported = this.support();
    this.rng = new RNG(this);
  }

  support() {
    // In order for BIP-Schnorr's quadratic residue trick to work,
    // `-1 mod p` must _not_ be a quadratic residue itself. In
    // other words, the curve must satisfy `jacobi(-1, p) != 1`
    // (or `jacobi(-1, p) == -1` for that matter).
    //
    // For more information, see the bip-schnorr citations:
    //   https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#cite_note-4
    return this.curve.one.redNeg().redJacobi() === -1;
  }

  check() {
    if (!this.supported)
      throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
  }

  encode(key) {
    assert(Buffer.isBuffer(key));

    // Extra speedy key reserialization.
    // This function assumes the key
    // has already been validated.
    const {fieldSize} = this.curve;

    if (key.length === 1 + fieldSize)
      return key;

    if (key.length !== 1 + fieldSize * 2)
      throw new Error('Invalid point.');

    const out = Buffer.allocUnsafe(1 + fieldSize);

    out[0] = 0x02 | (key[key.length - 1] & 1);
    key.copy(out, 1, 1, 1 + fieldSize);

    return out;
  }

  hashInt(x, y, z) {
    const hash = this.hash.multi(x, y, z);
    const num = BN.decode(hash, this.curve.endian);
    return num.imod(this.curve.n);
  }

  sign(msg, key) {
    assert(Buffer.isBuffer(msg));
    assert(msg.length === this.msgSize);

    this.check();

    const N = this.curve.n;
    const G = this.curve.g;

    // The secret key d: an integer in the range 1..n-1.
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(N) >= 0)
      throw new Error('Invalid private key.');

    // Let k' = int(hash(bytes(d) || m)) mod n
    const k = this.hashInt(key, msg);

    // Fail if k' = 0.
    if (k.isZero())
      throw new Error('Signing failed (k\' = 0).');

    // Let R = k'*G.
    const R = G.mulBlind(k);

    // Encode x(R).
    const Rraw = this.curve.encodeField(R.getX());

    // Encode d*G.
    const Araw = G.mulBlind(a).encode();

    // Let e = int(hash(bytes(x(R)) || bytes(d*G) || m)) mod n.
    const e = this.hashInt(Rraw, Araw, msg);

    // Scalar blinding factor.
    const [blind, unblind] = this.curve.getBlinding();

    // Blind.
    a.imul(blind).imod(N);
    k.imul(blind).imod(N);

    // Let k = k' if jacobi(y(R)) = 1, otherwise let k = n - k'.
    if (R.y.redJacobi() !== 1)
      k.ineg().imod(N);

    // Let S = k + e*d mod n.
    const S = k.iadd(e.imul(a)).imod(N);

    // Unblind.
    S.imul(unblind).imod(N);

    // The signature is bytes(x(R)) || bytes(k + e*d mod n).
    return Buffer.concat([Rraw, this.curve.encodeScalar(S)]);
  }

  verify(msg, sig, key) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert(Buffer.isBuffer(key));

    this.check();

    if (msg.length !== this.msgSize)
      return false;

    if (sig.length !== this.sigSize)
      return false;

    try {
      return this._verify(msg, sig, key);
    } catch (e) {
      return false;
    }
  }

  _verify(msg, sig, key) {
    assert(Buffer.isBuffer(msg));
    assert(Buffer.isBuffer(sig));
    assert(Buffer.isBuffer(key));

    const P = this.curve.p;
    const N = this.curve.n;
    const G = this.curve.g;

    // Let r = int(sig[0:32]); fail if r >= p.
    // Let s = int(sig[32:64]); fail if s >= n.
    // Let P = point(pk); fail if point(pk) fails.
    const Rraw = sig.slice(0, this.curve.fieldSize);
    const Sraw = sig.slice(this.curve.fieldSize);
    const Rx = this.curve.decodeField(Rraw);
    const S = this.curve.decodeScalar(Sraw);
    const A = this.curve.decodePoint(key);

    if (Rx.cmp(P) >= 0 || S.cmp(N) >= 0)
      return false;

    // Let e = int(hash(bytes(r) || bytes(P) || m)) mod n.
    const e = this.hashInt(Rraw, this.encode(key), msg);

    // In concept, a schnorr sig can be validated with:
    //
    //   s*G == R + e*P
    //
    // But bip-schnorr optimizes for shamir's trick with:
    //
    //   r == x(s*G - e*P)
    //
    // This is even more necessary perf-wise since we only
    // encode the X coordinate as the R value (it avoids us
    // having to recalculate the Y coordinate).
    //
    // Note that we stay in the jacobian space here. This
    // avoids any unnecessary divisions by the Z coordinate.

    // Let R = s*G - e*P.
    // Fail if infinite(R) or jacobi(y(R)) != 1 or x(R) != r.
    const R = G.jmulAdd(S, A, e.ineg().imod(N));

    // Check for point at infinity.
    if (R.isInfinity())
      return false;

    // Check for quadratic residue in the jacobian space.
    // Optimized as `jacobi(y(R) * z(R)) == 1`.
    if (!R.hasQuadY())
      return false;

    // Check `x(R) == r` in the jacobian space.
    // Optimized as `x(R) == r * z(R)^2 mod p`.
    if (!R.eqX(Rx))
      return false;

    return true;
  }

  verifyBatch(batch) {
    assert(Array.isArray(batch));

    this.check();

    for (const item of batch) {
      assert(Array.isArray(item) && item.length === 3);

      const [msg, sig, key] = item;

      assert(Buffer.isBuffer(msg));
      assert(Buffer.isBuffer(sig));
      assert(Buffer.isBuffer(key));

      if (msg.length !== this.msgSize)
        return false;

      if (sig.length !== this.sigSize)
        return false;
    }

    try {
      return this._verifyBatch(batch);
    } catch (e) {
      return false;
    }
  }

  _verifyBatch(batch) {
    const P = this.curve.p;
    const N = this.curve.n;
    const G = this.curve.g;
    const points = new Array(1 + batch.length * 2);
    const coeffs = new Array(1 + batch.length * 2);
    const sum = new BN(0);

    // Seed the RNG with our batch. This
    // code assumes the signers do not
    // have complete knowledge of the
    // other signatures in the set.
    this.rng.init(batch);

    // Setup multiplication for lhs*G.
    points[0] = G;
    coeffs[0] = sum;

    // Verify all signatures.
    for (let i = 0; i < batch.length; i++) {
      const [msg, sig, key] = batch[i];

      // Let r = int(sigi[0:32]); fail if r >= p.
      // Let si = int(sigi[32:64]); fail if si >= n.
      // Let Pi = point(pki); fail if point(pki) fails.
      const Rraw = sig.slice(0, this.curve.fieldSize);
      const Sraw = sig.slice(this.curve.fieldSize);
      const Rx = this.curve.decodeField(Rraw);
      const S = this.curve.decodeScalar(Sraw);
      const A = this.curve.decodePoint(key);

      if (Rx.cmp(P) >= 0 || S.cmp(N) >= 0)
        return false;

      // Let ei = int(hash(bytes(r) || bytes(Pi) || mi)) mod n.
      const e = this.hashInt(Rraw, this.encode(key), msg);

      // Let Ri = lift_x(r); fail if lift_x(r) fails.
      const R = this.curve.pointFromR(Rx);

      // Generate u-1 random integers a2...u in the range 1...n-1.
      const a = this.rng.generate(i);
      const ea = e.imul(a).imod(N);

      // Let lhs = s1 + a2*s2 + ... + au*su.
      sum.iadd(S.imul(a)).imod(N);

      // Let rhs = R1 + a2*R2 + ... + au*Ru
      //         + e1*P1 + (a2*e2)P2 + ... + (au*eu)Pu.
      points[1 + i * 2 + 0] = R;
      coeffs[1 + i * 2 + 0] = a;
      points[1 + i * 2 + 1] = A;
      coeffs[1 + i * 2 + 1] = ea;
    }

    // To avoid affinization, we optimize the final check as:
    //
    //   (-lhs * G) + rhs == infinity
    //
    // This trick is borrowed from libsecp256k1-zkp.
    sum.ineg().imod(N);

    return this.curve.jmulAll(points, coeffs).isInfinity();
  }
}

/**
 * RNG (designed to mimic the libsecp256k1-zkp CSPRNG)
 * @see https://github.com/ElementsProject/secp256k1-zkp/blob/d5e22a5/src/modules/schnorrsig/main_impl.h#L166
 * @see https://github.com/ElementsProject/secp256k1-zkp/blob/d5e22a5/src/scalar_4x64_impl.h#L974
 * @see https://github.com/ElementsProject/secp256k1-zkp/blob/d5e22a5/src/scalar_8x32_impl.h#L749
 */

class RNG {
  constructor(schnorr) {
    this.curve = schnorr.curve;
    this.hash = schnorr.hash;
    this.encode = schnorr.encode.bind(schnorr);
    this.chacha = new ChaCha20();
    this.key = Buffer.alloc(32, 0x00);
    this.iv = Buffer.alloc(8, 0x00);
    this.cache = [new BN(1), new BN(1)];
  }

  init(batch) {
    assert(Array.isArray(batch));

    // eslint-disable-next-line
    const h = new this.hash();

    h.init();

    for (const [msg, sig, key] of batch) {
      h.update(sig);
      h.update(msg);
      h.update(this.encode(key));
    }

    let key = h.final();

    if (key.length > 32)
      key = key.slice(0, 32);

    assert(key.length === 32);

    this.key = key;
    this.cache[0] = new BN(1);
    this.cache[1] = new BN(1);

    return this;
  }

  encrypt(counter) {
    assert((counter >>> 0) === counter);

    const size = (this.curve.scalarSize * 2 + 3) & -4;
    const data = Buffer.alloc(size, 0x00);
    const left = data.slice(0, this.curve.scalarSize);
    const right = data.slice(this.curve.scalarSize);

    this.chacha.init(this.key, this.iv, counter);
    this.chacha.encrypt(data);

    // Swap endianness of each 32 bit int. This should
    // match the behavior of libsecp256k1-zkp exactly.
    // ChaCha20 writes its internal state as a series
    // of little-endian u32s, but libsecp256k1 skips
    // the serialization step and accesses the u32s
    // directly, mapping the first int to the highest
    // word of the scalar and so on (in effect, reading
    // the state as big-endian in terms of 32 bit words
    // rather than 8 bit words). Swapping the endianness
    // of each word to big-endian and reading the whole
    // thing as big-endian should give us the exact same
    // behavior.
    for (let i = 0; i < size; i += 4) {
      [data[i + 0], data[i + 3]] = [data[i + 3], data[i + 0]];
      [data[i + 1], data[i + 2]] = [data[i + 2], data[i + 1]];
    }

    return [
      this.curve.decodeScalar(left),
      this.curve.decodeScalar(right)
    ];
  }

  refresh(counter) {
    let overflow = 0;

    for (;;) {
      // First word is always zero.
      this.iv[4] = overflow;
      this.iv[5] = overflow >>> 8;
      this.iv[6] = overflow >>> 16;
      this.iv[7] = overflow >>> 24;

      overflow += 1;

      const [s1, s2] = this.encrypt(counter);

      if (s1.isZero() || s1.cmp(this.curve.n) >= 0)
        continue;

      if (s2.isZero() || s2.cmp(this.curve.n) >= 0)
        continue;

      this.cache[0] = s1;
      this.cache[1] = s2;

      break;
    }
  }

  generate(index) {
    assert((index >>> 0) === index);

    if (index & 1)
      this.refresh(index >>> 1);

    return this.cache[index & 1];
  }
}

/*
 * Expose
 */

module.exports = Schnorr;

}).call(this,req("buffer").Buffer)
},{"../bn.js":31,"../chacha20":33,"bsert":190,"buffer":303}],129:[function(req,module,exports){
(function (Buffer,setImmediate){
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.
 *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.
 *   Copyright (c) 2014, Sean Kelly. All rights reserved.
 *   https://github.com/Tarsnap/scrypt
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Scrypt
 *   http://www.tarsnap.com/scrypt.html
 *   http://www.tarsnap.com/scrypt/scrypt.pdf
 *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 */

/* eslint camelcase: "off" */

'use strict';

const assert = req('bsert');
const pbkdf2 = req('../pbkdf2');
const SHA256 = req('../sha256');

/*
 * Constants
 */

const B32 = new Uint32Array(16);
const X = new Uint32Array(16);

/**
 * Perform scrypt key derivation.
 * @param {Buffer} passwd
 * @param {Buffer} salt
 * @param {Number} N
 * @param {Number} r
 * @param {Number} p
 * @param {Number} len
 * @returns {Buffer}
 */

function derive(passwd, salt, N, r, p, len) {
  if (typeof passwd === 'string')
    passwd = Buffer.from(passwd, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(Buffer.isBuffer(passwd));
  assert(Buffer.isBuffer(salt));
  assert((N >>> 0) === N);
  assert((r >>> 0) === r);
  assert((p >>> 0) === p);
  assert((len >>> 0) === len);

  if (r * p >= (1 << 30))
    throw new Error('EFBIG');

  if ((N & (N - 1)) !== 0 || N === 0)
    throw new Error('EINVAL');

  if (N > 0xffffffff)
    throw new Error('EINVAL');

  const XY = Buffer.allocUnsafe(256 * r);
  const V = Buffer.allocUnsafe(128 * r * N);

  const B = pbkdf2.derive(SHA256, passwd, salt, 1, p * 128 * r);

  for (let i = 0; i < p; i++)
    smix(B, i * 128 * r, r, N, V, XY);

  return pbkdf2.derive(SHA256, passwd, B, 1, len);
}

/**
 * Perform scrypt key derivation (async).
 * @param {Buffer} passwd
 * @param {Buffer} salt
 * @param {Number} N
 * @param {Number} r
 * @param {Number} p
 * @param {Number} len
 * @returns {Promise}
 */

async function deriveAsync(passwd, salt, N, r, p, len) {
  if (typeof passwd === 'string')
    passwd = Buffer.from(passwd, 'utf8');

  if (typeof salt === 'string')
    salt = Buffer.from(salt, 'utf8');

  if (salt == null)
    salt = Buffer.alloc(0);

  assert(Buffer.isBuffer(passwd));
  assert(Buffer.isBuffer(salt));
  assert((N >>> 0) === N);
  assert((r >>> 0) === r);
  assert((p >>> 0) === p);
  assert((len >>> 0) === len);

  if (r * p >= (1 << 30))
    throw new Error('EFBIG');

  if ((N & (N - 1)) !== 0 || N === 0)
    throw new Error('EINVAL');

  if (N > 0xffffffff)
    throw new Error('EINVAL');

  const XY = Buffer.allocUnsafe(256 * r);
  const V = Buffer.allocUnsafe(128 * r * N);

  const B = await pbkdf2.deriveAsync(SHA256, passwd, salt, 1, p * 128 * r);

  for (let i = 0; i < p; i++)
    await smixAsync(B, i * 128 * r, r, N, V, XY);

  return pbkdf2.deriveAsync(SHA256, passwd, B, 1, len);
}

/*
 * Helpers
 */

function salsa20_8(B) {
  for (let i = 0; i < 16; i++)
    B32[i] = readU32(B, i * 4);

  for (let i = 0; i < 16; i++)
    X[i] = B32[i];

  for (let i = 0; i < 8; i += 2) {
    X[4] ^= R(X[0] + X[12], 7);
    X[8] ^= R(X[4] + X[0], 9);
    X[12] ^= R(X[8] + X[4], 13);
    X[0] ^= R(X[12] + X[8], 18);

    X[9] ^= R(X[5] + X[1], 7);
    X[13] ^= R(X[9] + X[5], 9);
    X[1] ^= R(X[13] + X[9], 13);
    X[5] ^= R(X[1] + X[13], 18);

    X[14] ^= R(X[10] + X[6], 7);
    X[2] ^= R(X[14] + X[10], 9);
    X[6] ^= R(X[2] + X[14], 13);
    X[10] ^= R(X[6] + X[2], 18);

    X[3] ^= R(X[15] + X[11], 7);
    X[7] ^= R(X[3] + X[15], 9);
    X[11] ^= R(X[7] + X[3], 13);
    X[15] ^= R(X[11] + X[7], 18);

    X[1] ^= R(X[0] + X[3], 7);
    X[2] ^= R(X[1] + X[0], 9);
    X[3] ^= R(X[2] + X[1], 13);
    X[0] ^= R(X[3] + X[2], 18);

    X[6] ^= R(X[5] + X[4], 7);
    X[7] ^= R(X[6] + X[5], 9);
    X[4] ^= R(X[7] + X[6], 13);
    X[5] ^= R(X[4] + X[7], 18);

    X[11] ^= R(X[10] + X[9], 7);
    X[8] ^= R(X[11] + X[10], 9);
    X[9] ^= R(X[8] + X[11], 13);
    X[10] ^= R(X[9] + X[8], 18);

    X[12] ^= R(X[15] + X[14], 7);
    X[13] ^= R(X[12] + X[15], 9);
    X[14] ^= R(X[13] + X[12], 13);
    X[15] ^= R(X[14] + X[13], 18);
  }

  for (let i = 0; i < 16; i++)
    B32[i] += X[i];

  for (let i = 0; i < 16; i++)
    writeU32(B, B32[i], 4 * i);
}

function R(a, b) {
  return (a << b) | (a >>> (32 - b));
}

function blockmix_salsa8(B, Y, Yo, r) {
  const X = Buffer.allocUnsafe(64);

  blkcpy(X, B, 0, (2 * r - 1) * 64, 64);

  for (let i = 0; i < 2 * r; i++) {
    blkxor(X, B, 0, i * 64, 64);
    salsa20_8(X);
    blkcpy(Y, X, Yo + i * 64, 0, 64);
  }

  for (let i = 0; i < r; i++)
    blkcpy(B, Y, i * 64, Yo + (i * 2) * 64, 64);

  for (let i = 0; i < r; i++)
    blkcpy(B, Y, (i + r) * 64, Yo + (i * 2 + 1) * 64, 64);
}

function integerify(B, r) {
  return readU32(B, (2 * r - 1) * 64);
}

function smix(B, Bo, r, N, V, XY) {
  const X = XY;
  const Y = XY;

  blkcpy(X, B, 0, Bo, 128 * r);

  for (let i = 0; i < N; i++) {
    blkcpy(V, X, i * (128 * r), 0, 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
  }

  for (let i = 0; i < N; i++) {
    const j = integerify(X, r) & (N - 1);
    blkxor(X, V, 0, j * (128 * r), 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
  }

  blkcpy(B, X, Bo, 0, 128 * r);
}

async function smixAsync(B, Bo, r, N, V, XY) {
  const X = XY;
  const Y = XY;

  blkcpy(X, B, 0, Bo, 128 * r);

  for (let i = 0; i < N; i++) {
    blkcpy(V, X, i * (128 * r), 0, 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
    await wait();
  }

  for (let i = 0; i < N; i++) {
    const j = integerify(X, r) & (N - 1);
    blkxor(X, V, 0, j * (128 * r), 128 * r);
    blockmix_salsa8(X, Y, 128 * r, r);
    await wait();
  }

  blkcpy(B, X, Bo, 0, 128 * r);
}

function blkcpy(dest, src, s1, s2, len) {
  src.copy(dest, s1, s2, s2 + len);
}

function blkxor(dest, src, s1, s2, len) {
  for (let i = 0; i < len; i++)
    dest[s1 + i] ^= src[s2 + i];
}

function wait() {
  return new Promise(r => setImmediate(r));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

exports.native = 0;
exports.derive = derive;
exports.deriveAsync = deriveAsync;

}).call(this,req("buffer").Buffer,req("timers").setImmediate)
},{"../pbkdf2":159,"../sha256":174,"bsert":190,"buffer":303,"timers":308}],130:[function(req,module,exports){
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const ECDSA = req('./ecdsa');
const SHA256 = req('../sha256');
const pre = req('./precomputed/secp256k1.json');

/*
 * Expose
 */

module.exports = new ECDSA('SECP256K1', SHA256, pre);

},{"../sha256":174,"./ecdsa":105,"./precomputed/secp256k1.json":123}],131:[function(req,module,exports){
(function (Buffer){
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */

/* eslint camelcase: "off" */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x5a827999,
  0x6ed9eba1,
  0x8f1bbcdc,
  0xca62c1d6
]);

/**
 * SHA1
 */

class SHA1 {
  /**
   * Create a SHA1 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(5);
    this.msg = new Uint32Array(80);
    this.block = Buffer.allocUnsafe(64);
    this.size = FINALIZED;
  }

  /**
   * Initialize SHA1 context.
   * @returns {SHA1}
   */

  init() {
    this.state[0] = 0x67452301;
    this.state[1] = 0xefcdab89;
    this.state[2] = 0x98badcfe;
    this.state[3] = 0x10325476;
    this.state[4] = 0xc3d2e1f0;
    this.size = 0;
    return this;
  }

  /**
   * Update SHA1 context.
   * @param {Buffer} data
   * @returns {SHA1}
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize SHA1 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(20));
  }

  /**
   * Update SHA1 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 0x3f;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 64) {
      this.transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize SHA1 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size % 64;
    const len = this.size * 8;

    writeU32(DESC, len * (1 / 0x100000000), 0);
    writeU32(DESC, len, 4);

    this._update(PADDING, 1 + ((119 - pos) % 64));
    this._update(DESC, 8);

    for (let i = 0; i < 5; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 80; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform SHA1 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];
    let e = this.state[4];
    let i = 0;

    for (; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (; i < 80; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

    for (i = 0; i < 80; i++) {
      const s = i / 20 | 0;

      let t = rotl32(a, 5);

      t += ft_1(s, b, c, d);
      t += e;
      t += W[i];
      t += K[s];

      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
    this.state[4] += e;
  }

  static hash() {
    return new SHA1();
  }

  static hmac() {
    return new HMAC(SHA1, 64);
  }

  static digest(data) {
    return SHA1.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 20);
    assert(Buffer.isBuffer(right) && right.length === 20);
    return SHA1.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = SHA1.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return SHA1.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA1.native = 0;
SHA1.id = 'SHA1';
SHA1.size = 20;
SHA1.bits = 160;
SHA1.blockSize = 64;
SHA1.zero = Buffer.alloc(20, 0x00);
SHA1.ctx = new SHA1();

/*
 * Helpers
 */

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);

  if (s === 1 || s === 3)
    return p32(x, y, z);

  if (s === 2)
    return maj32(x, y, z);

  return 0;
}

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = SHA1;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],132:[function(req,module,exports){
(function (Buffer){
/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */

'use strict';

const assert = req('bsert');
const SHA256 = req('./sha256');
const HMAC = req('../internal/hmac');

/**
 * SHA224
 */

class SHA224 extends SHA256 {
  /**
   * Create a SHA256 context.
   * @constructor
   */

  constructor() {
    super();
  }

  /**
   * Initialize SHA224 context.
   */

  init() {
    this.state[0] = 0xc1059ed8;
    this.state[1] = 0x367cd507;
    this.state[2] = 0x3070dd17;
    this.state[3] = 0xf70e5939;
    this.state[4] = 0xffc00b31;
    this.state[5] = 0x68581511;
    this.state[6] = 0x64f98fa7;
    this.state[7] = 0xbefa4fa4;
    this.size = 0;
    return this;
  }

  /**
   * Finalize SHA224 context.
   * @returns {Buffer}
   */

  final() {
    return super.final().slice(0, 28);
  }

  static hash() {
    return new SHA224();
  }

  static hmac() {
    return new HMAC(SHA224, 64);
  }

  static digest(data) {
    return SHA224.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 28);
    assert(Buffer.isBuffer(right) && right.length === 28);
    return SHA224.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = SHA224.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return SHA224.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA224.native = 0;
SHA224.id = 'SHA224';
SHA224.size = 28;
SHA224.bits = 224;
SHA224.blockSize = 64;
SHA224.zero = Buffer.alloc(28, 0x00);
SHA224.ctx = new SHA224();

/*
 * Expose
 */

module.exports = SHA224;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"./sha256":133,"bsert":190,"buffer":303}],133:[function(req,module,exports){
(function (Buffer){
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);

/**
 * SHA256
 */

class SHA256 {
  /**
   * Create a SHA256 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(8);
    this.msg = new Uint32Array(64);
    this.block = Buffer.allocUnsafe(64);
    this.size = FINALIZED;
  }

  /**
   * Initialize SHA256 context.
   */

  init() {
    this.state[0] = 0x6a09e667;
    this.state[1] = 0xbb67ae85;
    this.state[2] = 0x3c6ef372;
    this.state[3] = 0xa54ff53a;
    this.state[4] = 0x510e527f;
    this.state[5] = 0x9b05688c;
    this.state[6] = 0x1f83d9ab;
    this.state[7] = 0x5be0cd19;
    this.size = 0;
    return this;
  }

  /**
   * Update SHA256 context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize SHA256 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(32));
  }

  /**
   * Update SHA256 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 0x3f;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 64) {
      this.transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize SHA256 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size % 64;
    const len = this.size * 8;

    writeU32(DESC, len * (1 / 0x100000000), 0);
    writeU32(DESC, len, 4);

    this._update(PADDING, 1 + ((119 - pos) % 64));
    this._update(DESC, 8);

    for (let i = 0; i < 8; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 64; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform SHA256 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];
    let e = this.state[4];
    let f = this.state[5];
    let g = this.state[6];
    let h = this.state[7];
    let i = 0;

    for (; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (; i < 64; i++)
      W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];

    for (i = 0; i < 64; i++) {
      let t1 = h + Sigma1(e);

      t1 += Ch(e, f, g);
      t1 += K[i] + W[i];

      let t2 = Sigma0(a);

      t2 += Maj(a, b, c);

      h = g;
      g = f;
      f = e;

      e = d + t1;

      d = c;
      c = b;
      b = a;

      a = t1 + t2;
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
    this.state[4] += e;
    this.state[5] += f;
    this.state[6] += g;
    this.state[7] += h;
  }

  static hash() {
    return new SHA256();
  }

  static hmac() {
    return new HMAC(SHA256, 64);
  }

  static digest(data) {
    return SHA256.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 32);
    assert(Buffer.isBuffer(right) && right.length === 32);
    return SHA256.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = SHA256.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return SHA256.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA256.native = 0;
SHA256.id = 'SHA256';
SHA256.size = 32;
SHA256.bits = 256;
SHA256.blockSize = 64;
SHA256.zero = Buffer.alloc(32, 0x00);
SHA256.ctx = new SHA256();

/*
 * Helpers
 */

function Sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function Sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function sigma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);
}

function sigma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);
}

function Ch(x, y, z) {
  return z ^ (x & (y ^ z));
}

function Maj(x, y, z) {
  return (x & y) | (z & (x | y));
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = SHA256;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],134:[function(req,module,exports){
(function (Buffer){
/*!
 * sha3.js - SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */

'use strict';

const Keccak = req('./keccak');

/**
 * SHA3
 */

class SHA3 extends Keccak {
  /**
   * Create a SHA3 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  final() {
    return super.final(0x06, null);
  }

  static hash() {
    return new SHA3();
  }

  static hmac(bits = 256) {
    return super.hmac(bits, 0x06, null);
  }

  static digest(data, bits = 256) {
    return super.digest(data, bits, 0x06, null);
  }

  static root(left, right, bits = 256) {
    return super.root(left, right, bits, 0x06, null);
  }

  static multi(x, y, z, bits = 256) {
    return super.multi(x, y, z, bits, 0x06, null);
  }

  static mac(data, key, bits = 256) {
    return super.mac(data, key, bits, 0x06, null);
  }
}

/*
 * Static
 */

SHA3.native = 0;
SHA3.id = 'SHA3_256';
SHA3.size = 32;
SHA3.bits = 256;
SHA3.blockSize = 136;
SHA3.zero = Buffer.alloc(32, 0x00);
SHA3.ctx = new SHA3();

/*
 * Expose
 */

module.exports = SHA3;

}).call(this,req("buffer").Buffer)
},{"./keccak":111,"buffer":303}],135:[function(req,module,exports){
(function (Buffer){
/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */

'use strict';

const assert = req('bsert');
const SHA512 = req('./sha512');
const HMAC = req('../internal/hmac');

/**
 * SHA384
 */

class SHA384 extends SHA512 {
  /**
   * Create a SHA384 context.
   * @constructor
   */

  constructor() {
    super();
  }

  /**
   * Initialize SHA384 context.
   */

  init() {
    this.state[0] = 0xcbbb9d5d;
    this.state[1] = 0xc1059ed8;
    this.state[2] = 0x629a292a;
    this.state[3] = 0x367cd507;
    this.state[4] = 0x9159015a;
    this.state[5] = 0x3070dd17;
    this.state[6] = 0x152fecd8;
    this.state[7] = 0xf70e5939;
    this.state[8] = 0x67332667;
    this.state[9] = 0xffc00b31;
    this.state[10] = 0x8eb44a87;
    this.state[11] = 0x68581511;
    this.state[12] = 0xdb0c2e0d;
    this.state[13] = 0x64f98fa7;
    this.state[14] = 0x47b5481d;
    this.state[15] = 0xbefa4fa4;
    this.size = 0;
    return this;
  }

  /**
   * Finalize SHA384 context.
   * @returns {Buffer}
   */

  final() {
    return super.final().slice(0, 48);
  }

  static hash() {
    return new SHA384();
  }

  static hmac() {
    return new HMAC(SHA384, 128);
  }

  static digest(data) {
    return SHA384.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 48);
    assert(Buffer.isBuffer(right) && right.length === 48);
    return SHA384.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = SHA384.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return SHA384.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA384.native = 0;
SHA384.id = 'SHA384';
SHA384.size = 48;
SHA384.bits = 384;
SHA384.blockSize = 128;
SHA384.zero = Buffer.alloc(48, 0x00);
SHA384.ctx = new SHA384();

/*
 * Expose
 */

module.exports = SHA384;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"./sha512":136,"bsert":190,"buffer":303}],136:[function(req,module,exports){
(function (Buffer){
/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */

/* eslint camelcase: "off" */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(16, 0x00);
const PADDING = Buffer.alloc(128, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]);

/**
 * SHA512
 */

class SHA512 {
  /**
   * Create a SHA512 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(16);
    this.msg = new Uint32Array(160);
    this.block = Buffer.allocUnsafe(128);
    this.size = FINALIZED;
  }

  /**
   * Initialize SHA512 context.
   */

  init() {
    this.state[0] = 0x6a09e667;
    this.state[1] = 0xf3bcc908;
    this.state[2] = 0xbb67ae85;
    this.state[3] = 0x84caa73b;
    this.state[4] = 0x3c6ef372;
    this.state[5] = 0xfe94f82b;
    this.state[6] = 0xa54ff53a;
    this.state[7] = 0x5f1d36f1;
    this.state[8] = 0x510e527f;
    this.state[9] = 0xade682d1;
    this.state[10] = 0x9b05688c;
    this.state[11] = 0x2b3e6c1f;
    this.state[12] = 0x1f83d9ab;
    this.state[13] = 0xfb41bd6b;
    this.state[14] = 0x5be0cd19;
    this.state[15] = 0x137e2179;
    this.size = 0;
    return this;
  }

  /**
   * Update SHA512 context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize SHA512 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(64));
  }

  /**
   * Update SHA512 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 0x7f;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 128 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 128)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 128) {
      this.transform(data, off);
      off += 128;
      len -= 128;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize SHA512 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size % 128;
    const len = this.size * 8;

    writeU32(DESC, len * (1 / 0x100000000), 8);
    writeU32(DESC, len, 12);

    this._update(PADDING, 1 + ((239 - pos) % 128));
    this._update(DESC, 16);

    for (let i = 0; i < 16; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 160; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 128; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Prepare SHA512 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  prepare(chunk, pos) {
    const W = this.msg;

    let i = 0;

    for (; i < 32; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (; i < 160; i += 2) {
      const c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      const c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      const c1_hi = W[i - 14];
      const c1_lo = W[i - 13];
      const c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      const c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      const c3_hi = W[i - 32];
      const c3_lo = W[i - 31];

      W[i] = sum64_4_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);

      W[i + 1] = sum64_4_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
    }
  }

  /**
   * Transform SHA512 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const W = this.msg;

    this.prepare(chunk, pos);

    let ah = this.state[0];
    let al = this.state[1];
    let bh = this.state[2];
    let bl = this.state[3];
    let ch = this.state[4];
    let cl = this.state[5];
    let dh = this.state[6];
    let dl = this.state[7];
    let eh = this.state[8];
    let el = this.state[9];
    let fh = this.state[10];
    let fl = this.state[11];
    let gh = this.state[12];
    let gl = this.state[13];
    let hh = this.state[14];
    let hl = this.state[15];

    for (let i = 0; i < W.length; i += 2) {
      let c0_hi = hh;
      let c0_lo = hl;
      let c1_hi = s1_512_hi(eh, el);
      let c1_lo = s1_512_lo(eh, el);

      const c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      const c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      const c3_hi = K[i];
      const c3_lo = K[i + 1];
      const c4_hi = W[i];
      const c4_lo = W[i + 1];

      const T1_hi = sum64_5_hi(c0_hi, c0_lo,
                               c1_hi, c1_lo,
                               c2_hi, c2_lo,
                               c3_hi, c3_lo,
                               c4_hi, c4_lo);

      const T1_lo = sum64_5_lo(c0_hi, c0_lo,
                               c1_hi, c1_lo,
                               c2_hi, c2_lo,
                               c3_hi, c3_lo,
                               c4_hi, c4_lo);

      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

      const T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      const T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

      hh = gh;
      hl = gl;

      gh = fh;
      gl = fl;

      fh = eh;
      fl = el;

      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);

      dh = ch;
      dl = cl;

      ch = bh;
      cl = bl;

      bh = ah;
      bl = al;

      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }

    sum64(this.state, 0, ah, al);
    sum64(this.state, 2, bh, bl);
    sum64(this.state, 4, ch, cl);
    sum64(this.state, 6, dh, dl);
    sum64(this.state, 8, eh, el);
    sum64(this.state, 10, fh, fl);
    sum64(this.state, 12, gh, gl);
    sum64(this.state, 14, hh, hl);
  }

  static hash() {
    return new SHA512();
  }

  static hmac() {
    return new HMAC(SHA512, 128);
  }

  static digest(data) {
    return SHA512.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 64);
    assert(Buffer.isBuffer(right) && right.length === 64);
    return SHA512.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = SHA512.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return SHA512.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA512.native = 0;
SHA512.id = 'SHA512';
SHA512.size = 64;
SHA512.bits = 512;
SHA512.blockSize = 128;
SHA512.zero = Buffer.alloc(64, 0x00);
SHA512.ctx = new SHA512();

/*
 * Helpers
 */

function sum64(buf, pos, ah, al) {
  const bh = buf[pos];
  const bl = buf[pos + 1];

  const lo = (al + bl) >>> 0;
  const hi = (lo < al) + ah + bh;

  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}

function sum64_hi(ah, al, bh, bl) {
  const lo = (al + bl) >>> 0;
  const hi = (lo < al) + ah + bh;
  return hi >>> 0;
}

function sum64_lo(ah, al, bh, bl) {
  const lo = al + bl;
  return lo >>> 0;
}

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  let carry = 0;
  let lo = al;

  lo = (lo + bl) >>> 0;
  carry += (lo < al);

  lo = (lo + cl) >>> 0;
  carry += (lo < cl);

  lo = (lo + dl) >>> 0;
  carry += (lo < dl);

  const hi = ah + bh + ch + dh + carry;

  return hi >>> 0;
}

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  const lo = al + bl + cl + dl;
  return lo >>> 0;
}

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  let carry = 0;
  let lo = al;

  lo = (lo + bl) >>> 0;
  carry += (lo < al);

  lo = (lo + cl) >>> 0;
  carry += (lo < cl);

  lo = (lo + dl) >>> 0;
  carry += (lo < dl);

  lo = (lo + el) >>> 0;
  carry += (lo < el);

  const hi = ah + bh + ch + dh + eh + carry;

  return hi >>> 0;
}

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  const lo = al + bl + cl + dl + el;
  return lo >>> 0;
}

function rotr64_hi(ah, al, num) {
  const r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}

function rotr64_lo(ah, al, num) {
  const r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}

function shr64_hi(ah, al, num) {
  return ah >>> num;
}

function shr64_lo(ah, al, num) {
  const r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  const r = (xh & yh) ^ ((~xh) & zh);
  return r >>> 0;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  const r = (xl & yl) ^ ((~xl) & zl);
  return r >>> 0;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  const r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  return r >>> 0;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  const r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  return r >>> 0;
}

function s0_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 28);
  const c1_hi = rotr64_hi(xl, xh, 2); // 34
  const c2_hi = rotr64_hi(xl, xh, 7); // 39
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function s0_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 28);
  const c1_lo = rotr64_lo(xl, xh, 2); // 34
  const c2_lo = rotr64_lo(xl, xh, 7); // 39
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function s1_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 14);
  const c1_hi = rotr64_hi(xh, xl, 18);
  const c2_hi = rotr64_hi(xl, xh, 9); // 41
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function s1_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 14);
  const c1_lo = rotr64_lo(xh, xl, 18);
  const c2_lo = rotr64_lo(xl, xh, 9); // 41
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function g0_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 1);
  const c1_hi = rotr64_hi(xh, xl, 8);
  const c2_hi = shr64_hi(xh, xl, 7);
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function g0_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 1);
  const c1_lo = rotr64_lo(xh, xl, 8);
  const c2_lo = shr64_lo(xh, xl, 7);
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function g1_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 19);
  const c1_hi = rotr64_hi(xl, xh, 29); // 61
  const c2_hi = shr64_hi(xh, xl, 6);
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function g1_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 19);
  const c1_lo = rotr64_lo(xl, xh, 29); // 61
  const c2_lo = shr64_lo(xh, xl, 6);
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = SHA512;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],137:[function(req,module,exports){
(function (Buffer){
/*!
 * siphash.js - siphash for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SipHash
 *   https://131002.net/siphash/
 *   https://131002.net/siphash/siphash.pdf
 *   https://github.com/bitcoin/bitcoin/blob/master/src/crypto/siphash.cpp
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const HI = 1 / 0x100000000;

/**
 * Javascript siphash 2-4 implementation.
 * @private
 * @param {Buffer} data
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function _siphash(data, key) {
  assert(Buffer.isBuffer(data));
  assert(Buffer.isBuffer(key) && key.length >= 16);

  const blocks = data.length >>> 3;
  const c0 = new U64(0x736f6d65, 0x70736575);
  const c1 = new U64(0x646f7261, 0x6e646f6d);
  const c2 = new U64(0x6c796765, 0x6e657261);
  const c3 = new U64(0x74656462, 0x79746573);
  const f0 = new U64(data.length << 24, 0);
  const f1 = new U64(0, 0xff);
  const k0 = U64.decode(key, 0);
  const k1 = U64.decode(key, 8);

  // Init.
  const v0 = c0.ixor(k0);
  const v1 = c1.ixor(k1);
  const v2 = c2.ixor(k0);
  const v3 = c3.ixor(k1);

  // Blocks.
  let p = 0;

  for (let i = 0; i < blocks; i++) {
    const d = U64.decode(data, p);

    v3.ixor(d);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(d);

    p += 8;
  }

  // Trailing.
  switch (data.length & 7) {
    case 7:
      f0.hi |= data[p + 6] << 16;
    case 6:
      f0.hi |= data[p + 5] << 8;
    case 5:
      f0.hi |= data[p + 4];
    case 4:
      f0.lo |= data[p + 3] << 24;
    case 3:
      f0.lo |= data[p + 2] << 16;
    case 2:
      f0.lo |= data[p + 1] << 8;
    case 1:
      f0.lo |= data[p];
  }

  // Finalization.
  v3.ixor(f0);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(f0);
  v2.ixor(f1);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(v1);
  v0.ixor(v2);
  v0.ixor(v3);

  return [v0.hi, v0.lo];
}

/**
 * Javascript siphash 2-4 implementation (64 bit ints).
 * @private
 * @param {Number} hi
 * @param {Number} lo
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function _siphash64(hi, lo, key) {
  assert(typeof hi === 'number');
  assert(typeof lo === 'number');
  assert(Buffer.isBuffer(key) && key.length >= 16);

  const c0 = new U64(0x736f6d65, 0x70736575);
  const c1 = new U64(0x646f7261, 0x6e646f6d);
  const c2 = new U64(0x6c796765, 0x6e657261);
  const c3 = new U64(0x74656462, 0x79746573);
  const f0 = new U64(hi, lo);
  const f1 = new U64(0, 0xff);
  const k0 = U64.decode(key, 0);
  const k1 = U64.decode(key, 8);

  // Init.
  const v0 = c0.ixor(k0);
  const v1 = c1.ixor(k1);
  const v2 = c2.ixor(k0);
  const v3 = c3.ixor(k1);

  // Finalization.
  v3.ixor(f0);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(f0);
  v2.ixor(f1);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(v1);
  v0.ixor(v2);
  v0.ixor(v3);

  return [v0.hi, v0.lo];
}

/**
 * Javascript siphash 2-4 implementation
 * (64 bit ints with a 256 bit key).
 * @private
 * @param {Number} hi
 * @param {Number} lo
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function _siphash64k256(hi, lo, key) {
  assert(typeof hi === 'number');
  assert(typeof lo === 'number');
  assert(Buffer.isBuffer(key) && key.length >= 32);

  const f0 = new U64(hi, lo);
  const f1 = new U64(0, 0xff);
  const k0 = U64.decode(key, 0);
  const k1 = U64.decode(key, 8);
  const k2 = U64.decode(key, 16);
  const k3 = U64.decode(key, 24);

  // Init.
  const v0 = k0;
  const v1 = k1;
  const v2 = k2;
  const v3 = k3;

  // Finalization.
  v3.ixor(f0);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(f0);
  v2.ixor(f1);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  sipround(v0, v1, v2, v3);
  v0.ixor(v1);
  v0.ixor(v2);
  v0.ixor(v3);

  return [v0.hi, v0.lo];
}

/**
 * Javascript siphash 2-4 implementation.
 * Used by bitcoin for compact block relay.
 * @param {Buffer} data
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function siphash(data, key) {
  return _siphash(data, key);
}

/**
 * Javascript siphash 2-4 implementation (32 bit ints).
 * Used by legacy cuckoo cycle.
 * @param {Number} num
 * @param {Buffer} key - 128 bit key.
 * @returns {Number}
 */

function siphash32(num, key) {
  return _siphash64(0, num, key)[1];
}

/**
 * Javascript siphash 2-4 implementation (64 bit ints).
 * Used by legacy cuckoo cycle.
 * @param {Number} hi
 * @param {Number} lo
 * @param {Buffer} key - 128 bit key.
 * @returns {Array} [hi, lo]
 */

function siphash64(hi, lo, key) {
  return _siphash64(hi, lo, key);
}

/**
 * Javascript siphash 2-4 implementation
 * (32 bit ints with a 256 bit key).
 * Used by cuckoo cycle.
 * @param {Number} num
 * @param {Buffer} key - 256 bit key.
 * @returns {Number}
 */

function siphash32k256(num, key) {
  return _siphash64k256(0, num, key)[1];
}

/**
 * Javascript siphash 2-4 implementation
 * (64 bit ints with a 256 bit key).
 * Used by cuckoo cycle.
 * @param {Number} hi
 * @param {Number} lo
 * @param {Buffer} key - 256 bit key.
 * @returns {Array} [hi, lo]
 */

function siphash64k256(hi, lo, key) {
  return _siphash64k256(hi, lo, key);
}

/**
 * Javascript siphash 2-4 implementation
 * plus 128 bit reduction by a modulus.
 * Used by the neutrino protocol.
 * @param {Buffer} data
 * @param {Buffer} key - 128 bit key.
 * @param {Number} mhi - Modulus hi bits.
 * @param {Number} mlo - Modulus lo bits.
 * @returns {Array} [hi, lo]
 */

function sipmod(data, key, mhi, mlo) {
  const [hi, lo] = _siphash(data, key);
  return reduce64(hi, lo, mhi, mlo);
}

/**
 * U64
 * @ignore
 */

class U64 {
  constructor(hi, lo) {
    this.hi = hi | 0;
    this.lo = lo | 0;
  }

  isum(bhi, blo) {
    // Credit to @indutny for this method.
    const a = this;
    const lo = (a.lo + blo) | 0;
    const s = lo >> 31;
    const as = a.lo >> 31;
    const bs = blo >> 31;
    const c = ((as & bs) | (~s & (as ^ bs))) & 1;
    const hi = ((a.hi + bhi) | 0) + c;

    a.hi = hi | 0;
    a.lo = lo;

    return a;
  }

  iadd(b) {
    return this.isum(b.hi, b.lo);
  }

  ixor(b) {
    this.hi ^= b.hi;
    this.lo ^= b.lo;
    return this;
  }

  irotl(bits) {
    let ahi = this.hi;
    let alo = this.lo;
    let bhi = this.hi;
    let blo = this.lo;

    // a = x << b
    if (bits < 32) {
      ahi <<= bits;
      ahi |= alo >>> (32 - bits);
      alo <<= bits;
    } else {
      ahi = alo << (bits - 32);
      alo = 0;
    }

    bits = 64 - bits;

    // b = x >> (64 - b)
    if (bits < 32) {
      blo >>>= bits;
      blo |= bhi << (32 - bits);
      bhi >>>= bits;
    } else {
      blo = bhi >>> (bits - 32);
      bhi = 0;
    }

    // a | b
    this.hi = ahi | bhi;
    this.lo = alo | blo;

    return this;
  }

  static mul(alo, blo) {
    // u32 * u32 = u64
    const a16 = alo >>> 16;
    const a00 = alo & 0xffff;
    const b16 = blo >>> 16;
    const b00 = blo & 0xffff;

    let c48 = 0;
    let c32 = 0;
    let c16 = 0;
    let c00 = 0;

    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += c32 >>> 16;
    c48 &= 0xffff;

    const hi = (c48 << 16) | c32;
    const lo = (c16 << 16) | c00;

    return new U64(hi, lo);
  }

  static decode(data, off) {
    const lo = readU32(data, off);
    const hi = readU32(data, off + 4);

    return new U64(hi, lo);
  }
}

/*
 * Helpers
 */

function sipround(v0, v1, v2, v3) {
  v0.iadd(v1);
  v1.irotl(13);
  v1.ixor(v0);

  v0.irotl(32);

  v2.iadd(v3);
  v3.irotl(16);
  v3.ixor(v2);

  v0.iadd(v3);
  v3.irotl(21);
  v3.ixor(v0);

  v2.iadd(v1);
  v1.irotl(17);
  v1.ixor(v2);

  v2.irotl(32);
}

function reduce64(ahi, alo, bhi, blo) {
  // Compute `((uint128_t)a * b) >> 64`.
  // Start with 4 32->64 bit multiplications.
  const axbhi = U64.mul(ahi, bhi);
  const axbmid = U64.mul(ahi, blo);
  const bxamid = U64.mul(bhi, alo);
  const axblo = U64.mul(alo, blo);

  // We can safely overflow in these next steps.
  // c = (axbmid & 0xffffffff) + (bxamid & 0xffffffff) + (axblo >> 32)
  const c = (axbmid.lo >>> 0) + (bxamid.lo >>> 0) + (axblo.hi >>> 0);

  // m = (axbmid >> 32) + (bxamid >> 32) + (c >> 32)
  const m = (axbmid.hi >>> 0) + (bxamid.hi >>> 0) + ((c * HI) >>> 0);

  // axbhi + m
  const {hi, lo} = axbhi.isum((m * HI) | 0, m | 0);

  return [hi, lo];
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

/*
 * Expose
 */

exports.native = 0;
exports.siphash = siphash;
exports.siphash32 = siphash32;
exports.siphash64 = siphash64;
exports.siphash32k256 = siphash32k256;
exports.siphash64k256 = siphash64k256;
exports.sipmod = sipmod;

}).call(this,{"isBuffer":req("../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],138:[function(req,module,exports){
(function (Buffer){
/*!
 * whirlpool.js - Whirlpool implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Whirlpool_(hash_function)
 *   https://www.iso.org/standard/39876.html
 *   https://github.com/jzelinskie/whirlpool/blob/master/whirlpool.go
 *   https://github.com/RustCrypto/hashes/blob/master/whirlpool/src/consts.rs
 *   https://github.com/RustCrypto/hashes/blob/master/whirlpool/src/lib.rs
 *   https://github.com/RustCrypto/hashes/blob/master/whirlpool/src/utils.rs
 */

'use strict';

const assert = req('bsert');
const HMAC = req('../internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(32, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const RC = new Uint32Array([
  0x00000000, 0x00000000,
  0x1823c6e8, 0x87b8014f,
  0x36a6d2f5, 0x796f9152,
  0x60bc9b8e, 0xa30c7b35,
  0x1de0d7c2, 0x2e4bfe57,
  0x157737e5, 0x9ff04ada,
  0x58c9290a, 0xb1a06b85,
  0xbd5d10f4, 0xcb3e0567,
  0xe427418b, 0xa77d95d8,
  0xfbee7c66, 0xdd17479e,
  0xca2dbf07, 0xad5a8333
]);

const C0 = new Uint32Array([
  0x18186018, 0xc07830d8, 0x23238c23, 0x05af4626,
  0xc6c63fc6, 0x7ef991b8, 0xe8e887e8, 0x136fcdfb,
  0x87872687, 0x4ca113cb, 0xb8b8dab8, 0xa9626d11,
  0x01010401, 0x08050209, 0x4f4f214f, 0x426e9e0d,
  0x3636d836, 0xadee6c9b, 0xa6a6a2a6, 0x590451ff,
  0xd2d26fd2, 0xdebdb90c, 0xf5f5f3f5, 0xfb06f70e,
  0x7979f979, 0xef80f296, 0x6f6fa16f, 0x5fcede30,
  0x91917e91, 0xfcef3f6d, 0x52525552, 0xaa07a4f8,
  0x60609d60, 0x27fdc047, 0xbcbccabc, 0x89766535,
  0x9b9b569b, 0xaccd2b37, 0x8e8e028e, 0x048c018a,
  0xa3a3b6a3, 0x71155bd2, 0x0c0c300c, 0x603c186c,
  0x7b7bf17b, 0xff8af684, 0x3535d435, 0xb5e16a80,
  0x1d1d741d, 0xe8693af5, 0xe0e0a7e0, 0x5347ddb3,
  0xd7d77bd7, 0xf6acb321, 0xc2c22fc2, 0x5eed999c,
  0x2e2eb82e, 0x6d965c43, 0x4b4b314b, 0x627a9629,
  0xfefedffe, 0xa321e15d, 0x57574157, 0x8216aed5,
  0x15155415, 0xa8412abd, 0x7777c177, 0x9fb6eee8,
  0x3737dc37, 0xa5eb6e92, 0xe5e5b3e5, 0x7b56d79e,
  0x9f9f469f, 0x8cd92313, 0xf0f0e7f0, 0xd317fd23,
  0x4a4a354a, 0x6a7f9420, 0xdada4fda, 0x9e95a944,
  0x58587d58, 0xfa25b0a2, 0xc9c903c9, 0x06ca8fcf,
  0x2929a429, 0x558d527c, 0x0a0a280a, 0x5022145a,
  0xb1b1feb1, 0xe14f7f50, 0xa0a0baa0, 0x691a5dc9,
  0x6b6bb16b, 0x7fdad614, 0x85852e85, 0x5cab17d9,
  0xbdbdcebd, 0x8173673c, 0x5d5d695d, 0xd234ba8f,
  0x10104010, 0x80502090, 0xf4f4f7f4, 0xf303f507,
  0xcbcb0bcb, 0x16c08bdd, 0x3e3ef83e, 0xedc67cd3,
  0x05051405, 0x28110a2d, 0x67678167, 0x1fe6ce78,
  0xe4e4b7e4, 0x7353d597, 0x27279c27, 0x25bb4e02,
  0x41411941, 0x32588273, 0x8b8b168b, 0x2c9d0ba7,
  0xa7a7a6a7, 0x510153f6, 0x7d7de97d, 0xcf94fab2,
  0x95956e95, 0xdcfb3749, 0xd8d847d8, 0x8e9fad56,
  0xfbfbcbfb, 0x8b30eb70, 0xeeee9fee, 0x2371c1cd,
  0x7c7ced7c, 0xc791f8bb, 0x66668566, 0x17e3cc71,
  0xdddd53dd, 0xa68ea77b, 0x17175c17, 0xb84b2eaf,
  0x47470147, 0x02468e45, 0x9e9e429e, 0x84dc211a,
  0xcaca0fca, 0x1ec589d4, 0x2d2db42d, 0x75995a58,
  0xbfbfc6bf, 0x9179632e, 0x07071c07, 0x381b0e3f,
  0xadad8ead, 0x012347ac, 0x5a5a755a, 0xea2fb4b0,
  0x83833683, 0x6cb51bef, 0x3333cc33, 0x85ff66b6,
  0x63639163, 0x3ff2c65c, 0x02020802, 0x100a0412,
  0xaaaa92aa, 0x39384993, 0x7171d971, 0xafa8e2de,
  0xc8c807c8, 0x0ecf8dc6, 0x19196419, 0xc87d32d1,
  0x49493949, 0x7270923b, 0xd9d943d9, 0x869aaf5f,
  0xf2f2eff2, 0xc31df931, 0xe3e3abe3, 0x4b48dba8,
  0x5b5b715b, 0xe22ab6b9, 0x88881a88, 0x34920dbc,
  0x9a9a529a, 0xa4c8293e, 0x26269826, 0x2dbe4c0b,
  0x3232c832, 0x8dfa64bf, 0xb0b0fab0, 0xe94a7d59,
  0xe9e983e9, 0x1b6acff2, 0x0f0f3c0f, 0x78331e77,
  0xd5d573d5, 0xe6a6b733, 0x80803a80, 0x74ba1df4,
  0xbebec2be, 0x997c6127, 0xcdcd13cd, 0x26de87eb,
  0x3434d034, 0xbde46889, 0x48483d48, 0x7a759032,
  0xffffdbff, 0xab24e354, 0x7a7af57a, 0xf78ff48d,
  0x90907a90, 0xf4ea3d64, 0x5f5f615f, 0xc23ebe9d,
  0x20208020, 0x1da0403d, 0x6868bd68, 0x67d5d00f,
  0x1a1a681a, 0xd07234ca, 0xaeae82ae, 0x192c41b7,
  0xb4b4eab4, 0xc95e757d, 0x54544d54, 0x9a19a8ce,
  0x93937693, 0xece53b7f, 0x22228822, 0x0daa442f,
  0x64648d64, 0x07e9c863, 0xf1f1e3f1, 0xdb12ff2a,
  0x7373d173, 0xbfa2e6cc, 0x12124812, 0x905a2482,
  0x40401d40, 0x3a5d807a, 0x08082008, 0x40281048,
  0xc3c32bc3, 0x56e89b95, 0xecec97ec, 0x337bc5df,
  0xdbdb4bdb, 0x9690ab4d, 0xa1a1bea1, 0x611f5fc0,
  0x8d8d0e8d, 0x1c830791, 0x3d3df43d, 0xf5c97ac8,
  0x97976697, 0xccf1335b, 0x00000000, 0x00000000,
  0xcfcf1bcf, 0x36d483f9, 0x2b2bac2b, 0x4587566e,
  0x7676c576, 0x97b3ece1, 0x82823282, 0x64b019e6,
  0xd6d67fd6, 0xfea9b128, 0x1b1b6c1b, 0xd87736c3,
  0xb5b5eeb5, 0xc15b7774, 0xafaf86af, 0x112943be,
  0x6a6ab56a, 0x77dfd41d, 0x50505d50, 0xba0da0ea,
  0x45450945, 0x124c8a57, 0xf3f3ebf3, 0xcb18fb38,
  0x3030c030, 0x9df060ad, 0xefef9bef, 0x2b74c3c4,
  0x3f3ffc3f, 0xe5c37eda, 0x55554955, 0x921caac7,
  0xa2a2b2a2, 0x791059db, 0xeaea8fea, 0x0365c9e9,
  0x65658965, 0x0fecca6a, 0xbabad2ba, 0xb9686903,
  0x2f2fbc2f, 0x65935e4a, 0xc0c027c0, 0x4ee79d8e,
  0xdede5fde, 0xbe81a160, 0x1c1c701c, 0xe06c38fc,
  0xfdfdd3fd, 0xbb2ee746, 0x4d4d294d, 0x52649a1f,
  0x92927292, 0xe4e03976, 0x7575c975, 0x8fbceafa,
  0x06061806, 0x301e0c36, 0x8a8a128a, 0x249809ae,
  0xb2b2f2b2, 0xf940794b, 0xe6e6bfe6, 0x6359d185,
  0x0e0e380e, 0x70361c7e, 0x1f1f7c1f, 0xf8633ee7,
  0x62629562, 0x37f7c455, 0xd4d477d4, 0xeea3b53a,
  0xa8a89aa8, 0x29324d81, 0x96966296, 0xc4f43152,
  0xf9f9c3f9, 0x9b3aef62, 0xc5c533c5, 0x66f697a3,
  0x25259425, 0x35b14a10, 0x59597959, 0xf220b2ab,
  0x84842a84, 0x54ae15d0, 0x7272d572, 0xb7a7e4c5,
  0x3939e439, 0xd5dd72ec, 0x4c4c2d4c, 0x5a619816,
  0x5e5e655e, 0xca3bbc94, 0x7878fd78, 0xe785f09f,
  0x3838e038, 0xddd870e5, 0x8c8c0a8c, 0x14860598,
  0xd1d163d1, 0xc6b2bf17, 0xa5a5aea5, 0x410b57e4,
  0xe2e2afe2, 0x434dd9a1, 0x61619961, 0x2ff8c24e,
  0xb3b3f6b3, 0xf1457b42, 0x21218421, 0x15a54234,
  0x9c9c4a9c, 0x94d62508, 0x1e1e781e, 0xf0663cee,
  0x43431143, 0x22528661, 0xc7c73bc7, 0x76fc93b1,
  0xfcfcd7fc, 0xb32be54f, 0x04041004, 0x20140824,
  0x51515951, 0xb208a2e3, 0x99995e99, 0xbcc72f25,
  0x6d6da96d, 0x4fc4da22, 0x0d0d340d, 0x68391a65,
  0xfafacffa, 0x8335e979, 0xdfdf5bdf, 0xb684a369,
  0x7e7ee57e, 0xd79bfca9, 0x24249024, 0x3db44819,
  0x3b3bec3b, 0xc5d776fe, 0xabab96ab, 0x313d4b9a,
  0xcece1fce, 0x3ed181f0, 0x11114411, 0x88552299,
  0x8f8f068f, 0x0c890383, 0x4e4e254e, 0x4a6b9c04,
  0xb7b7e6b7, 0xd1517366, 0xebeb8beb, 0x0b60cbe0,
  0x3c3cf03c, 0xfdcc78c1, 0x81813e81, 0x7cbf1ffd,
  0x94946a94, 0xd4fe3540, 0xf7f7fbf7, 0xeb0cf31c,
  0xb9b9deb9, 0xa1676f18, 0x13134c13, 0x985f268b,
  0x2c2cb02c, 0x7d9c5851, 0xd3d36bd3, 0xd6b8bb05,
  0xe7e7bbe7, 0x6b5cd38c, 0x6e6ea56e, 0x57cbdc39,
  0xc4c437c4, 0x6ef395aa, 0x03030c03, 0x180f061b,
  0x56564556, 0x8a13acdc, 0x44440d44, 0x1a49885e,
  0x7f7fe17f, 0xdf9efea0, 0xa9a99ea9, 0x21374f88,
  0x2a2aa82a, 0x4d825467, 0xbbbbd6bb, 0xb16d6b0a,
  0xc1c123c1, 0x46e29f87, 0x53535153, 0xa202a6f1,
  0xdcdc57dc, 0xae8ba572, 0x0b0b2c0b, 0x58271653,
  0x9d9d4e9d, 0x9cd32701, 0x6c6cad6c, 0x47c1d82b,
  0x3131c431, 0x95f562a4, 0x7474cd74, 0x87b9e8f3,
  0xf6f6fff6, 0xe309f115, 0x46460546, 0x0a438c4c,
  0xacac8aac, 0x092645a5, 0x89891e89, 0x3c970fb5,
  0x14145014, 0xa04428b4, 0xe1e1a3e1, 0x5b42dfba,
  0x16165816, 0xb04e2ca6, 0x3a3ae83a, 0xcdd274f7,
  0x6969b969, 0x6fd0d206, 0x09092409, 0x482d1241,
  0x7070dd70, 0xa7ade0d7, 0xb6b6e2b6, 0xd954716f,
  0xd0d067d0, 0xceb7bd1e, 0xeded93ed, 0x3b7ec7d6,
  0xcccc17cc, 0x2edb85e2, 0x42421542, 0x2a578468,
  0x98985a98, 0xb4c22d2c, 0xa4a4aaa4, 0x490e55ed,
  0x2828a028, 0x5d885075, 0x5c5c6d5c, 0xda31b886,
  0xf8f8c7f8, 0x933fed6b, 0x86862286, 0x44a411c2
]);

const C1 = new Uint32Array([
  0xd8181860, 0x18c07830, 0x2623238c, 0x2305af46,
  0xb8c6c63f, 0xc67ef991, 0xfbe8e887, 0xe8136fcd,
  0xcb878726, 0x874ca113, 0x11b8b8da, 0xb8a9626d,
  0x09010104, 0x01080502, 0x0d4f4f21, 0x4f426e9e,
  0x9b3636d8, 0x36adee6c, 0xffa6a6a2, 0xa6590451,
  0x0cd2d26f, 0xd2debdb9, 0x0ef5f5f3, 0xf5fb06f7,
  0x967979f9, 0x79ef80f2, 0x306f6fa1, 0x6f5fcede,
  0x6d91917e, 0x91fcef3f, 0xf8525255, 0x52aa07a4,
  0x4760609d, 0x6027fdc0, 0x35bcbcca, 0xbc897665,
  0x379b9b56, 0x9baccd2b, 0x8a8e8e02, 0x8e048c01,
  0xd2a3a3b6, 0xa371155b, 0x6c0c0c30, 0x0c603c18,
  0x847b7bf1, 0x7bff8af6, 0x803535d4, 0x35b5e16a,
  0xf51d1d74, 0x1de8693a, 0xb3e0e0a7, 0xe05347dd,
  0x21d7d77b, 0xd7f6acb3, 0x9cc2c22f, 0xc25eed99,
  0x432e2eb8, 0x2e6d965c, 0x294b4b31, 0x4b627a96,
  0x5dfefedf, 0xfea321e1, 0xd5575741, 0x578216ae,
  0xbd151554, 0x15a8412a, 0xe87777c1, 0x779fb6ee,
  0x923737dc, 0x37a5eb6e, 0x9ee5e5b3, 0xe57b56d7,
  0x139f9f46, 0x9f8cd923, 0x23f0f0e7, 0xf0d317fd,
  0x204a4a35, 0x4a6a7f94, 0x44dada4f, 0xda9e95a9,
  0xa258587d, 0x58fa25b0, 0xcfc9c903, 0xc906ca8f,
  0x7c2929a4, 0x29558d52, 0x5a0a0a28, 0x0a502214,
  0x50b1b1fe, 0xb1e14f7f, 0xc9a0a0ba, 0xa0691a5d,
  0x146b6bb1, 0x6b7fdad6, 0xd985852e, 0x855cab17,
  0x3cbdbdce, 0xbd817367, 0x8f5d5d69, 0x5dd234ba,
  0x90101040, 0x10805020, 0x07f4f4f7, 0xf4f303f5,
  0xddcbcb0b, 0xcb16c08b, 0xd33e3ef8, 0x3eedc67c,
  0x2d050514, 0x0528110a, 0x78676781, 0x671fe6ce,
  0x97e4e4b7, 0xe47353d5, 0x0227279c, 0x2725bb4e,
  0x73414119, 0x41325882, 0xa78b8b16, 0x8b2c9d0b,
  0xf6a7a7a6, 0xa7510153, 0xb27d7de9, 0x7dcf94fa,
  0x4995956e, 0x95dcfb37, 0x56d8d847, 0xd88e9fad,
  0x70fbfbcb, 0xfb8b30eb, 0xcdeeee9f, 0xee2371c1,
  0xbb7c7ced, 0x7cc791f8, 0x71666685, 0x6617e3cc,
  0x7bdddd53, 0xdda68ea7, 0xaf17175c, 0x17b84b2e,
  0x45474701, 0x4702468e, 0x1a9e9e42, 0x9e84dc21,
  0xd4caca0f, 0xca1ec589, 0x582d2db4, 0x2d75995a,
  0x2ebfbfc6, 0xbf917963, 0x3f07071c, 0x07381b0e,
  0xacadad8e, 0xad012347, 0xb05a5a75, 0x5aea2fb4,
  0xef838336, 0x836cb51b, 0xb63333cc, 0x3385ff66,
  0x5c636391, 0x633ff2c6, 0x12020208, 0x02100a04,
  0x93aaaa92, 0xaa393849, 0xde7171d9, 0x71afa8e2,
  0xc6c8c807, 0xc80ecf8d, 0xd1191964, 0x19c87d32,
  0x3b494939, 0x49727092, 0x5fd9d943, 0xd9869aaf,
  0x31f2f2ef, 0xf2c31df9, 0xa8e3e3ab, 0xe34b48db,
  0xb95b5b71, 0x5be22ab6, 0xbc88881a, 0x8834920d,
  0x3e9a9a52, 0x9aa4c829, 0x0b262698, 0x262dbe4c,
  0xbf3232c8, 0x328dfa64, 0x59b0b0fa, 0xb0e94a7d,
  0xf2e9e983, 0xe91b6acf, 0x770f0f3c, 0x0f78331e,
  0x33d5d573, 0xd5e6a6b7, 0xf480803a, 0x8074ba1d,
  0x27bebec2, 0xbe997c61, 0xebcdcd13, 0xcd26de87,
  0x893434d0, 0x34bde468, 0x3248483d, 0x487a7590,
  0x54ffffdb, 0xffab24e3, 0x8d7a7af5, 0x7af78ff4,
  0x6490907a, 0x90f4ea3d, 0x9d5f5f61, 0x5fc23ebe,
  0x3d202080, 0x201da040, 0x0f6868bd, 0x6867d5d0,
  0xca1a1a68, 0x1ad07234, 0xb7aeae82, 0xae192c41,
  0x7db4b4ea, 0xb4c95e75, 0xce54544d, 0x549a19a8,
  0x7f939376, 0x93ece53b, 0x2f222288, 0x220daa44,
  0x6364648d, 0x6407e9c8, 0x2af1f1e3, 0xf1db12ff,
  0xcc7373d1, 0x73bfa2e6, 0x82121248, 0x12905a24,
  0x7a40401d, 0x403a5d80, 0x48080820, 0x08402810,
  0x95c3c32b, 0xc356e89b, 0xdfecec97, 0xec337bc5,
  0x4ddbdb4b, 0xdb9690ab, 0xc0a1a1be, 0xa1611f5f,
  0x918d8d0e, 0x8d1c8307, 0xc83d3df4, 0x3df5c97a,
  0x5b979766, 0x97ccf133, 0x00000000, 0x00000000,
  0xf9cfcf1b, 0xcf36d483, 0x6e2b2bac, 0x2b458756,
  0xe17676c5, 0x7697b3ec, 0xe6828232, 0x8264b019,
  0x28d6d67f, 0xd6fea9b1, 0xc31b1b6c, 0x1bd87736,
  0x74b5b5ee, 0xb5c15b77, 0xbeafaf86, 0xaf112943,
  0x1d6a6ab5, 0x6a77dfd4, 0xea50505d, 0x50ba0da0,
  0x57454509, 0x45124c8a, 0x38f3f3eb, 0xf3cb18fb,
  0xad3030c0, 0x309df060, 0xc4efef9b, 0xef2b74c3,
  0xda3f3ffc, 0x3fe5c37e, 0xc7555549, 0x55921caa,
  0xdba2a2b2, 0xa2791059, 0xe9eaea8f, 0xea0365c9,
  0x6a656589, 0x650fecca, 0x03babad2, 0xbab96869,
  0x4a2f2fbc, 0x2f65935e, 0x8ec0c027, 0xc04ee79d,
  0x60dede5f, 0xdebe81a1, 0xfc1c1c70, 0x1ce06c38,
  0x46fdfdd3, 0xfdbb2ee7, 0x1f4d4d29, 0x4d52649a,
  0x76929272, 0x92e4e039, 0xfa7575c9, 0x758fbcea,
  0x36060618, 0x06301e0c, 0xae8a8a12, 0x8a249809,
  0x4bb2b2f2, 0xb2f94079, 0x85e6e6bf, 0xe66359d1,
  0x7e0e0e38, 0x0e70361c, 0xe71f1f7c, 0x1ff8633e,
  0x55626295, 0x6237f7c4, 0x3ad4d477, 0xd4eea3b5,
  0x81a8a89a, 0xa829324d, 0x52969662, 0x96c4f431,
  0x62f9f9c3, 0xf99b3aef, 0xa3c5c533, 0xc566f697,
  0x10252594, 0x2535b14a, 0xab595979, 0x59f220b2,
  0xd084842a, 0x8454ae15, 0xc57272d5, 0x72b7a7e4,
  0xec3939e4, 0x39d5dd72, 0x164c4c2d, 0x4c5a6198,
  0x945e5e65, 0x5eca3bbc, 0x9f7878fd, 0x78e785f0,
  0xe53838e0, 0x38ddd870, 0x988c8c0a, 0x8c148605,
  0x17d1d163, 0xd1c6b2bf, 0xe4a5a5ae, 0xa5410b57,
  0xa1e2e2af, 0xe2434dd9, 0x4e616199, 0x612ff8c2,
  0x42b3b3f6, 0xb3f1457b, 0x34212184, 0x2115a542,
  0x089c9c4a, 0x9c94d625, 0xee1e1e78, 0x1ef0663c,
  0x61434311, 0x43225286, 0xb1c7c73b, 0xc776fc93,
  0x4ffcfcd7, 0xfcb32be5, 0x24040410, 0x04201408,
  0xe3515159, 0x51b208a2, 0x2599995e, 0x99bcc72f,
  0x226d6da9, 0x6d4fc4da, 0x650d0d34, 0x0d68391a,
  0x79fafacf, 0xfa8335e9, 0x69dfdf5b, 0xdfb684a3,
  0xa97e7ee5, 0x7ed79bfc, 0x19242490, 0x243db448,
  0xfe3b3bec, 0x3bc5d776, 0x9aabab96, 0xab313d4b,
  0xf0cece1f, 0xce3ed181, 0x99111144, 0x11885522,
  0x838f8f06, 0x8f0c8903, 0x044e4e25, 0x4e4a6b9c,
  0x66b7b7e6, 0xb7d15173, 0xe0ebeb8b, 0xeb0b60cb,
  0xc13c3cf0, 0x3cfdcc78, 0xfd81813e, 0x817cbf1f,
  0x4094946a, 0x94d4fe35, 0x1cf7f7fb, 0xf7eb0cf3,
  0x18b9b9de, 0xb9a1676f, 0x8b13134c, 0x13985f26,
  0x512c2cb0, 0x2c7d9c58, 0x05d3d36b, 0xd3d6b8bb,
  0x8ce7e7bb, 0xe76b5cd3, 0x396e6ea5, 0x6e57cbdc,
  0xaac4c437, 0xc46ef395, 0x1b03030c, 0x03180f06,
  0xdc565645, 0x568a13ac, 0x5e44440d, 0x441a4988,
  0xa07f7fe1, 0x7fdf9efe, 0x88a9a99e, 0xa921374f,
  0x672a2aa8, 0x2a4d8254, 0x0abbbbd6, 0xbbb16d6b,
  0x87c1c123, 0xc146e29f, 0xf1535351, 0x53a202a6,
  0x72dcdc57, 0xdcae8ba5, 0x530b0b2c, 0x0b582716,
  0x019d9d4e, 0x9d9cd327, 0x2b6c6cad, 0x6c47c1d8,
  0xa43131c4, 0x3195f562, 0xf37474cd, 0x7487b9e8,
  0x15f6f6ff, 0xf6e309f1, 0x4c464605, 0x460a438c,
  0xa5acac8a, 0xac092645, 0xb589891e, 0x893c970f,
  0xb4141450, 0x14a04428, 0xbae1e1a3, 0xe15b42df,
  0xa6161658, 0x16b04e2c, 0xf73a3ae8, 0x3acdd274,
  0x066969b9, 0x696fd0d2, 0x41090924, 0x09482d12,
  0xd77070dd, 0x70a7ade0, 0x6fb6b6e2, 0xb6d95471,
  0x1ed0d067, 0xd0ceb7bd, 0xd6eded93, 0xed3b7ec7,
  0xe2cccc17, 0xcc2edb85, 0x68424215, 0x422a5784,
  0x2c98985a, 0x98b4c22d, 0xeda4a4aa, 0xa4490e55,
  0x752828a0, 0x285d8850, 0x865c5c6d, 0x5cda31b8,
  0x6bf8f8c7, 0xf8933fed, 0xc2868622, 0x8644a411
]);

const C2 = new Uint32Array([
  0x30d81818, 0x6018c078, 0x46262323, 0x8c2305af,
  0x91b8c6c6, 0x3fc67ef9, 0xcdfbe8e8, 0x87e8136f,
  0x13cb8787, 0x26874ca1, 0x6d11b8b8, 0xdab8a962,
  0x02090101, 0x04010805, 0x9e0d4f4f, 0x214f426e,
  0x6c9b3636, 0xd836adee, 0x51ffa6a6, 0xa2a65904,
  0xb90cd2d2, 0x6fd2debd, 0xf70ef5f5, 0xf3f5fb06,
  0xf2967979, 0xf979ef80, 0xde306f6f, 0xa16f5fce,
  0x3f6d9191, 0x7e91fcef, 0xa4f85252, 0x5552aa07,
  0xc0476060, 0x9d6027fd, 0x6535bcbc, 0xcabc8976,
  0x2b379b9b, 0x569baccd, 0x018a8e8e, 0x028e048c,
  0x5bd2a3a3, 0xb6a37115, 0x186c0c0c, 0x300c603c,
  0xf6847b7b, 0xf17bff8a, 0x6a803535, 0xd435b5e1,
  0x3af51d1d, 0x741de869, 0xddb3e0e0, 0xa7e05347,
  0xb321d7d7, 0x7bd7f6ac, 0x999cc2c2, 0x2fc25eed,
  0x5c432e2e, 0xb82e6d96, 0x96294b4b, 0x314b627a,
  0xe15dfefe, 0xdffea321, 0xaed55757, 0x41578216,
  0x2abd1515, 0x5415a841, 0xeee87777, 0xc1779fb6,
  0x6e923737, 0xdc37a5eb, 0xd79ee5e5, 0xb3e57b56,
  0x23139f9f, 0x469f8cd9, 0xfd23f0f0, 0xe7f0d317,
  0x94204a4a, 0x354a6a7f, 0xa944dada, 0x4fda9e95,
  0xb0a25858, 0x7d58fa25, 0x8fcfc9c9, 0x03c906ca,
  0x527c2929, 0xa429558d, 0x145a0a0a, 0x280a5022,
  0x7f50b1b1, 0xfeb1e14f, 0x5dc9a0a0, 0xbaa0691a,
  0xd6146b6b, 0xb16b7fda, 0x17d98585, 0x2e855cab,
  0x673cbdbd, 0xcebd8173, 0xba8f5d5d, 0x695dd234,
  0x20901010, 0x40108050, 0xf507f4f4, 0xf7f4f303,
  0x8bddcbcb, 0x0bcb16c0, 0x7cd33e3e, 0xf83eedc6,
  0x0a2d0505, 0x14052811, 0xce786767, 0x81671fe6,
  0xd597e4e4, 0xb7e47353, 0x4e022727, 0x9c2725bb,
  0x82734141, 0x19413258, 0x0ba78b8b, 0x168b2c9d,
  0x53f6a7a7, 0xa6a75101, 0xfab27d7d, 0xe97dcf94,
  0x37499595, 0x6e95dcfb, 0xad56d8d8, 0x47d88e9f,
  0xeb70fbfb, 0xcbfb8b30, 0xc1cdeeee, 0x9fee2371,
  0xf8bb7c7c, 0xed7cc791, 0xcc716666, 0x856617e3,
  0xa77bdddd, 0x53dda68e, 0x2eaf1717, 0x5c17b84b,
  0x8e454747, 0x01470246, 0x211a9e9e, 0x429e84dc,
  0x89d4caca, 0x0fca1ec5, 0x5a582d2d, 0xb42d7599,
  0x632ebfbf, 0xc6bf9179, 0x0e3f0707, 0x1c07381b,
  0x47acadad, 0x8ead0123, 0xb4b05a5a, 0x755aea2f,
  0x1bef8383, 0x36836cb5, 0x66b63333, 0xcc3385ff,
  0xc65c6363, 0x91633ff2, 0x04120202, 0x0802100a,
  0x4993aaaa, 0x92aa3938, 0xe2de7171, 0xd971afa8,
  0x8dc6c8c8, 0x07c80ecf, 0x32d11919, 0x6419c87d,
  0x923b4949, 0x39497270, 0xaf5fd9d9, 0x43d9869a,
  0xf931f2f2, 0xeff2c31d, 0xdba8e3e3, 0xabe34b48,
  0xb6b95b5b, 0x715be22a, 0x0dbc8888, 0x1a883492,
  0x293e9a9a, 0x529aa4c8, 0x4c0b2626, 0x98262dbe,
  0x64bf3232, 0xc8328dfa, 0x7d59b0b0, 0xfab0e94a,
  0xcff2e9e9, 0x83e91b6a, 0x1e770f0f, 0x3c0f7833,
  0xb733d5d5, 0x73d5e6a6, 0x1df48080, 0x3a8074ba,
  0x6127bebe, 0xc2be997c, 0x87ebcdcd, 0x13cd26de,
  0x68893434, 0xd034bde4, 0x90324848, 0x3d487a75,
  0xe354ffff, 0xdbffab24, 0xf48d7a7a, 0xf57af78f,
  0x3d649090, 0x7a90f4ea, 0xbe9d5f5f, 0x615fc23e,
  0x403d2020, 0x80201da0, 0xd00f6868, 0xbd6867d5,
  0x34ca1a1a, 0x681ad072, 0x41b7aeae, 0x82ae192c,
  0x757db4b4, 0xeab4c95e, 0xa8ce5454, 0x4d549a19,
  0x3b7f9393, 0x7693ece5, 0x442f2222, 0x88220daa,
  0xc8636464, 0x8d6407e9, 0xff2af1f1, 0xe3f1db12,
  0xe6cc7373, 0xd173bfa2, 0x24821212, 0x4812905a,
  0x807a4040, 0x1d403a5d, 0x10480808, 0x20084028,
  0x9b95c3c3, 0x2bc356e8, 0xc5dfecec, 0x97ec337b,
  0xab4ddbdb, 0x4bdb9690, 0x5fc0a1a1, 0xbea1611f,
  0x07918d8d, 0x0e8d1c83, 0x7ac83d3d, 0xf43df5c9,
  0x335b9797, 0x6697ccf1, 0x00000000, 0x00000000,
  0x83f9cfcf, 0x1bcf36d4, 0x566e2b2b, 0xac2b4587,
  0xece17676, 0xc57697b3, 0x19e68282, 0x328264b0,
  0xb128d6d6, 0x7fd6fea9, 0x36c31b1b, 0x6c1bd877,
  0x7774b5b5, 0xeeb5c15b, 0x43beafaf, 0x86af1129,
  0xd41d6a6a, 0xb56a77df, 0xa0ea5050, 0x5d50ba0d,
  0x8a574545, 0x0945124c, 0xfb38f3f3, 0xebf3cb18,
  0x60ad3030, 0xc0309df0, 0xc3c4efef, 0x9bef2b74,
  0x7eda3f3f, 0xfc3fe5c3, 0xaac75555, 0x4955921c,
  0x59dba2a2, 0xb2a27910, 0xc9e9eaea, 0x8fea0365,
  0xca6a6565, 0x89650fec, 0x6903baba, 0xd2bab968,
  0x5e4a2f2f, 0xbc2f6593, 0x9d8ec0c0, 0x27c04ee7,
  0xa160dede, 0x5fdebe81, 0x38fc1c1c, 0x701ce06c,
  0xe746fdfd, 0xd3fdbb2e, 0x9a1f4d4d, 0x294d5264,
  0x39769292, 0x7292e4e0, 0xeafa7575, 0xc9758fbc,
  0x0c360606, 0x1806301e, 0x09ae8a8a, 0x128a2498,
  0x794bb2b2, 0xf2b2f940, 0xd185e6e6, 0xbfe66359,
  0x1c7e0e0e, 0x380e7036, 0x3ee71f1f, 0x7c1ff863,
  0xc4556262, 0x956237f7, 0xb53ad4d4, 0x77d4eea3,
  0x4d81a8a8, 0x9aa82932, 0x31529696, 0x6296c4f4,
  0xef62f9f9, 0xc3f99b3a, 0x97a3c5c5, 0x33c566f6,
  0x4a102525, 0x942535b1, 0xb2ab5959, 0x7959f220,
  0x15d08484, 0x2a8454ae, 0xe4c57272, 0xd572b7a7,
  0x72ec3939, 0xe439d5dd, 0x98164c4c, 0x2d4c5a61,
  0xbc945e5e, 0x655eca3b, 0xf09f7878, 0xfd78e785,
  0x70e53838, 0xe038ddd8, 0x05988c8c, 0x0a8c1486,
  0xbf17d1d1, 0x63d1c6b2, 0x57e4a5a5, 0xaea5410b,
  0xd9a1e2e2, 0xafe2434d, 0xc24e6161, 0x99612ff8,
  0x7b42b3b3, 0xf6b3f145, 0x42342121, 0x842115a5,
  0x25089c9c, 0x4a9c94d6, 0x3cee1e1e, 0x781ef066,
  0x86614343, 0x11432252, 0x93b1c7c7, 0x3bc776fc,
  0xe54ffcfc, 0xd7fcb32b, 0x08240404, 0x10042014,
  0xa2e35151, 0x5951b208, 0x2f259999, 0x5e99bcc7,
  0xda226d6d, 0xa96d4fc4, 0x1a650d0d, 0x340d6839,
  0xe979fafa, 0xcffa8335, 0xa369dfdf, 0x5bdfb684,
  0xfca97e7e, 0xe57ed79b, 0x48192424, 0x90243db4,
  0x76fe3b3b, 0xec3bc5d7, 0x4b9aabab, 0x96ab313d,
  0x81f0cece, 0x1fce3ed1, 0x22991111, 0x44118855,
  0x03838f8f, 0x068f0c89, 0x9c044e4e, 0x254e4a6b,
  0x7366b7b7, 0xe6b7d151, 0xcbe0ebeb, 0x8beb0b60,
  0x78c13c3c, 0xf03cfdcc, 0x1ffd8181, 0x3e817cbf,
  0x35409494, 0x6a94d4fe, 0xf31cf7f7, 0xfbf7eb0c,
  0x6f18b9b9, 0xdeb9a167, 0x268b1313, 0x4c13985f,
  0x58512c2c, 0xb02c7d9c, 0xbb05d3d3, 0x6bd3d6b8,
  0xd38ce7e7, 0xbbe76b5c, 0xdc396e6e, 0xa56e57cb,
  0x95aac4c4, 0x37c46ef3, 0x061b0303, 0x0c03180f,
  0xacdc5656, 0x45568a13, 0x885e4444, 0x0d441a49,
  0xfea07f7f, 0xe17fdf9e, 0x4f88a9a9, 0x9ea92137,
  0x54672a2a, 0xa82a4d82, 0x6b0abbbb, 0xd6bbb16d,
  0x9f87c1c1, 0x23c146e2, 0xa6f15353, 0x5153a202,
  0xa572dcdc, 0x57dcae8b, 0x16530b0b, 0x2c0b5827,
  0x27019d9d, 0x4e9d9cd3, 0xd82b6c6c, 0xad6c47c1,
  0x62a43131, 0xc43195f5, 0xe8f37474, 0xcd7487b9,
  0xf115f6f6, 0xfff6e309, 0x8c4c4646, 0x05460a43,
  0x45a5acac, 0x8aac0926, 0x0fb58989, 0x1e893c97,
  0x28b41414, 0x5014a044, 0xdfbae1e1, 0xa3e15b42,
  0x2ca61616, 0x5816b04e, 0x74f73a3a, 0xe83acdd2,
  0xd2066969, 0xb9696fd0, 0x12410909, 0x2409482d,
  0xe0d77070, 0xdd70a7ad, 0x716fb6b6, 0xe2b6d954,
  0xbd1ed0d0, 0x67d0ceb7, 0xc7d6eded, 0x93ed3b7e,
  0x85e2cccc, 0x17cc2edb, 0x84684242, 0x15422a57,
  0x2d2c9898, 0x5a98b4c2, 0x55eda4a4, 0xaaa4490e,
  0x50752828, 0xa0285d88, 0xb8865c5c, 0x6d5cda31,
  0xed6bf8f8, 0xc7f8933f, 0x11c28686, 0x228644a4
]);

const C3 = new Uint32Array([
  0x7830d818, 0x186018c0, 0xaf462623, 0x238c2305,
  0xf991b8c6, 0xc63fc67e, 0x6fcdfbe8, 0xe887e813,
  0xa113cb87, 0x8726874c, 0x626d11b8, 0xb8dab8a9,
  0x05020901, 0x01040108, 0x6e9e0d4f, 0x4f214f42,
  0xee6c9b36, 0x36d836ad, 0x0451ffa6, 0xa6a2a659,
  0xbdb90cd2, 0xd26fd2de, 0x06f70ef5, 0xf5f3f5fb,
  0x80f29679, 0x79f979ef, 0xcede306f, 0x6fa16f5f,
  0xef3f6d91, 0x917e91fc, 0x07a4f852, 0x525552aa,
  0xfdc04760, 0x609d6027, 0x766535bc, 0xbccabc89,
  0xcd2b379b, 0x9b569bac, 0x8c018a8e, 0x8e028e04,
  0x155bd2a3, 0xa3b6a371, 0x3c186c0c, 0x0c300c60,
  0x8af6847b, 0x7bf17bff, 0xe16a8035, 0x35d435b5,
  0x693af51d, 0x1d741de8, 0x47ddb3e0, 0xe0a7e053,
  0xacb321d7, 0xd77bd7f6, 0xed999cc2, 0xc22fc25e,
  0x965c432e, 0x2eb82e6d, 0x7a96294b, 0x4b314b62,
  0x21e15dfe, 0xfedffea3, 0x16aed557, 0x57415782,
  0x412abd15, 0x155415a8, 0xb6eee877, 0x77c1779f,
  0xeb6e9237, 0x37dc37a5, 0x56d79ee5, 0xe5b3e57b,
  0xd923139f, 0x9f469f8c, 0x17fd23f0, 0xf0e7f0d3,
  0x7f94204a, 0x4a354a6a, 0x95a944da, 0xda4fda9e,
  0x25b0a258, 0x587d58fa, 0xca8fcfc9, 0xc903c906,
  0x8d527c29, 0x29a42955, 0x22145a0a, 0x0a280a50,
  0x4f7f50b1, 0xb1feb1e1, 0x1a5dc9a0, 0xa0baa069,
  0xdad6146b, 0x6bb16b7f, 0xab17d985, 0x852e855c,
  0x73673cbd, 0xbdcebd81, 0x34ba8f5d, 0x5d695dd2,
  0x50209010, 0x10401080, 0x03f507f4, 0xf4f7f4f3,
  0xc08bddcb, 0xcb0bcb16, 0xc67cd33e, 0x3ef83eed,
  0x110a2d05, 0x05140528, 0xe6ce7867, 0x6781671f,
  0x53d597e4, 0xe4b7e473, 0xbb4e0227, 0x279c2725,
  0x58827341, 0x41194132, 0x9d0ba78b, 0x8b168b2c,
  0x0153f6a7, 0xa7a6a751, 0x94fab27d, 0x7de97dcf,
  0xfb374995, 0x956e95dc, 0x9fad56d8, 0xd847d88e,
  0x30eb70fb, 0xfbcbfb8b, 0x71c1cdee, 0xee9fee23,
  0x91f8bb7c, 0x7ced7cc7, 0xe3cc7166, 0x66856617,
  0x8ea77bdd, 0xdd53dda6, 0x4b2eaf17, 0x175c17b8,
  0x468e4547, 0x47014702, 0xdc211a9e, 0x9e429e84,
  0xc589d4ca, 0xca0fca1e, 0x995a582d, 0x2db42d75,
  0x79632ebf, 0xbfc6bf91, 0x1b0e3f07, 0x071c0738,
  0x2347acad, 0xad8ead01, 0x2fb4b05a, 0x5a755aea,
  0xb51bef83, 0x8336836c, 0xff66b633, 0x33cc3385,
  0xf2c65c63, 0x6391633f, 0x0a041202, 0x02080210,
  0x384993aa, 0xaa92aa39, 0xa8e2de71, 0x71d971af,
  0xcf8dc6c8, 0xc807c80e, 0x7d32d119, 0x196419c8,
  0x70923b49, 0x49394972, 0x9aaf5fd9, 0xd943d986,
  0x1df931f2, 0xf2eff2c3, 0x48dba8e3, 0xe3abe34b,
  0x2ab6b95b, 0x5b715be2, 0x920dbc88, 0x881a8834,
  0xc8293e9a, 0x9a529aa4, 0xbe4c0b26, 0x2698262d,
  0xfa64bf32, 0x32c8328d, 0x4a7d59b0, 0xb0fab0e9,
  0x6acff2e9, 0xe983e91b, 0x331e770f, 0x0f3c0f78,
  0xa6b733d5, 0xd573d5e6, 0xba1df480, 0x803a8074,
  0x7c6127be, 0xbec2be99, 0xde87ebcd, 0xcd13cd26,
  0xe4688934, 0x34d034bd, 0x75903248, 0x483d487a,
  0x24e354ff, 0xffdbffab, 0x8ff48d7a, 0x7af57af7,
  0xea3d6490, 0x907a90f4, 0x3ebe9d5f, 0x5f615fc2,
  0xa0403d20, 0x2080201d, 0xd5d00f68, 0x68bd6867,
  0x7234ca1a, 0x1a681ad0, 0x2c41b7ae, 0xae82ae19,
  0x5e757db4, 0xb4eab4c9, 0x19a8ce54, 0x544d549a,
  0xe53b7f93, 0x937693ec, 0xaa442f22, 0x2288220d,
  0xe9c86364, 0x648d6407, 0x12ff2af1, 0xf1e3f1db,
  0xa2e6cc73, 0x73d173bf, 0x5a248212, 0x12481290,
  0x5d807a40, 0x401d403a, 0x28104808, 0x08200840,
  0xe89b95c3, 0xc32bc356, 0x7bc5dfec, 0xec97ec33,
  0x90ab4ddb, 0xdb4bdb96, 0x1f5fc0a1, 0xa1bea161,
  0x8307918d, 0x8d0e8d1c, 0xc97ac83d, 0x3df43df5,
  0xf1335b97, 0x976697cc, 0x00000000, 0x00000000,
  0xd483f9cf, 0xcf1bcf36, 0x87566e2b, 0x2bac2b45,
  0xb3ece176, 0x76c57697, 0xb019e682, 0x82328264,
  0xa9b128d6, 0xd67fd6fe, 0x7736c31b, 0x1b6c1bd8,
  0x5b7774b5, 0xb5eeb5c1, 0x2943beaf, 0xaf86af11,
  0xdfd41d6a, 0x6ab56a77, 0x0da0ea50, 0x505d50ba,
  0x4c8a5745, 0x45094512, 0x18fb38f3, 0xf3ebf3cb,
  0xf060ad30, 0x30c0309d, 0x74c3c4ef, 0xef9bef2b,
  0xc37eda3f, 0x3ffc3fe5, 0x1caac755, 0x55495592,
  0x1059dba2, 0xa2b2a279, 0x65c9e9ea, 0xea8fea03,
  0xecca6a65, 0x6589650f, 0x686903ba, 0xbad2bab9,
  0x935e4a2f, 0x2fbc2f65, 0xe79d8ec0, 0xc027c04e,
  0x81a160de, 0xde5fdebe, 0x6c38fc1c, 0x1c701ce0,
  0x2ee746fd, 0xfdd3fdbb, 0x649a1f4d, 0x4d294d52,
  0xe0397692, 0x927292e4, 0xbceafa75, 0x75c9758f,
  0x1e0c3606, 0x06180630, 0x9809ae8a, 0x8a128a24,
  0x40794bb2, 0xb2f2b2f9, 0x59d185e6, 0xe6bfe663,
  0x361c7e0e, 0x0e380e70, 0x633ee71f, 0x1f7c1ff8,
  0xf7c45562, 0x62956237, 0xa3b53ad4, 0xd477d4ee,
  0x324d81a8, 0xa89aa829, 0xf4315296, 0x966296c4,
  0x3aef62f9, 0xf9c3f99b, 0xf697a3c5, 0xc533c566,
  0xb14a1025, 0x25942535, 0x20b2ab59, 0x597959f2,
  0xae15d084, 0x842a8454, 0xa7e4c572, 0x72d572b7,
  0xdd72ec39, 0x39e439d5, 0x6198164c, 0x4c2d4c5a,
  0x3bbc945e, 0x5e655eca, 0x85f09f78, 0x78fd78e7,
  0xd870e538, 0x38e038dd, 0x8605988c, 0x8c0a8c14,
  0xb2bf17d1, 0xd163d1c6, 0x0b57e4a5, 0xa5aea541,
  0x4dd9a1e2, 0xe2afe243, 0xf8c24e61, 0x6199612f,
  0x457b42b3, 0xb3f6b3f1, 0xa5423421, 0x21842115,
  0xd625089c, 0x9c4a9c94, 0x663cee1e, 0x1e781ef0,
  0x52866143, 0x43114322, 0xfc93b1c7, 0xc73bc776,
  0x2be54ffc, 0xfcd7fcb3, 0x14082404, 0x04100420,
  0x08a2e351, 0x515951b2, 0xc72f2599, 0x995e99bc,
  0xc4da226d, 0x6da96d4f, 0x391a650d, 0x0d340d68,
  0x35e979fa, 0xfacffa83, 0x84a369df, 0xdf5bdfb6,
  0x9bfca97e, 0x7ee57ed7, 0xb4481924, 0x2490243d,
  0xd776fe3b, 0x3bec3bc5, 0x3d4b9aab, 0xab96ab31,
  0xd181f0ce, 0xce1fce3e, 0x55229911, 0x11441188,
  0x8903838f, 0x8f068f0c, 0x6b9c044e, 0x4e254e4a,
  0x517366b7, 0xb7e6b7d1, 0x60cbe0eb, 0xeb8beb0b,
  0xcc78c13c, 0x3cf03cfd, 0xbf1ffd81, 0x813e817c,
  0xfe354094, 0x946a94d4, 0x0cf31cf7, 0xf7fbf7eb,
  0x676f18b9, 0xb9deb9a1, 0x5f268b13, 0x134c1398,
  0x9c58512c, 0x2cb02c7d, 0xb8bb05d3, 0xd36bd3d6,
  0x5cd38ce7, 0xe7bbe76b, 0xcbdc396e, 0x6ea56e57,
  0xf395aac4, 0xc437c46e, 0x0f061b03, 0x030c0318,
  0x13acdc56, 0x5645568a, 0x49885e44, 0x440d441a,
  0x9efea07f, 0x7fe17fdf, 0x374f88a9, 0xa99ea921,
  0x8254672a, 0x2aa82a4d, 0x6d6b0abb, 0xbbd6bbb1,
  0xe29f87c1, 0xc123c146, 0x02a6f153, 0x535153a2,
  0x8ba572dc, 0xdc57dcae, 0x2716530b, 0x0b2c0b58,
  0xd327019d, 0x9d4e9d9c, 0xc1d82b6c, 0x6cad6c47,
  0xf562a431, 0x31c43195, 0xb9e8f374, 0x74cd7487,
  0x09f115f6, 0xf6fff6e3, 0x438c4c46, 0x4605460a,
  0x2645a5ac, 0xac8aac09, 0x970fb589, 0x891e893c,
  0x4428b414, 0x145014a0, 0x42dfbae1, 0xe1a3e15b,
  0x4e2ca616, 0x165816b0, 0xd274f73a, 0x3ae83acd,
  0xd0d20669, 0x69b9696f, 0x2d124109, 0x09240948,
  0xade0d770, 0x70dd70a7, 0x54716fb6, 0xb6e2b6d9,
  0xb7bd1ed0, 0xd067d0ce, 0x7ec7d6ed, 0xed93ed3b,
  0xdb85e2cc, 0xcc17cc2e, 0x57846842, 0x4215422a,
  0xc22d2c98, 0x985a98b4, 0x0e55eda4, 0xa4aaa449,
  0x88507528, 0x28a0285d, 0x31b8865c, 0x5c6d5cda,
  0x3fed6bf8, 0xf8c7f893, 0xa411c286, 0x86228644
]);

const C4 = new Uint32Array([
  0xc07830d8, 0x18186018, 0x05af4626, 0x23238c23,
  0x7ef991b8, 0xc6c63fc6, 0x136fcdfb, 0xe8e887e8,
  0x4ca113cb, 0x87872687, 0xa9626d11, 0xb8b8dab8,
  0x08050209, 0x01010401, 0x426e9e0d, 0x4f4f214f,
  0xadee6c9b, 0x3636d836, 0x590451ff, 0xa6a6a2a6,
  0xdebdb90c, 0xd2d26fd2, 0xfb06f70e, 0xf5f5f3f5,
  0xef80f296, 0x7979f979, 0x5fcede30, 0x6f6fa16f,
  0xfcef3f6d, 0x91917e91, 0xaa07a4f8, 0x52525552,
  0x27fdc047, 0x60609d60, 0x89766535, 0xbcbccabc,
  0xaccd2b37, 0x9b9b569b, 0x048c018a, 0x8e8e028e,
  0x71155bd2, 0xa3a3b6a3, 0x603c186c, 0x0c0c300c,
  0xff8af684, 0x7b7bf17b, 0xb5e16a80, 0x3535d435,
  0xe8693af5, 0x1d1d741d, 0x5347ddb3, 0xe0e0a7e0,
  0xf6acb321, 0xd7d77bd7, 0x5eed999c, 0xc2c22fc2,
  0x6d965c43, 0x2e2eb82e, 0x627a9629, 0x4b4b314b,
  0xa321e15d, 0xfefedffe, 0x8216aed5, 0x57574157,
  0xa8412abd, 0x15155415, 0x9fb6eee8, 0x7777c177,
  0xa5eb6e92, 0x3737dc37, 0x7b56d79e, 0xe5e5b3e5,
  0x8cd92313, 0x9f9f469f, 0xd317fd23, 0xf0f0e7f0,
  0x6a7f9420, 0x4a4a354a, 0x9e95a944, 0xdada4fda,
  0xfa25b0a2, 0x58587d58, 0x06ca8fcf, 0xc9c903c9,
  0x558d527c, 0x2929a429, 0x5022145a, 0x0a0a280a,
  0xe14f7f50, 0xb1b1feb1, 0x691a5dc9, 0xa0a0baa0,
  0x7fdad614, 0x6b6bb16b, 0x5cab17d9, 0x85852e85,
  0x8173673c, 0xbdbdcebd, 0xd234ba8f, 0x5d5d695d,
  0x80502090, 0x10104010, 0xf303f507, 0xf4f4f7f4,
  0x16c08bdd, 0xcbcb0bcb, 0xedc67cd3, 0x3e3ef83e,
  0x28110a2d, 0x05051405, 0x1fe6ce78, 0x67678167,
  0x7353d597, 0xe4e4b7e4, 0x25bb4e02, 0x27279c27,
  0x32588273, 0x41411941, 0x2c9d0ba7, 0x8b8b168b,
  0x510153f6, 0xa7a7a6a7, 0xcf94fab2, 0x7d7de97d,
  0xdcfb3749, 0x95956e95, 0x8e9fad56, 0xd8d847d8,
  0x8b30eb70, 0xfbfbcbfb, 0x2371c1cd, 0xeeee9fee,
  0xc791f8bb, 0x7c7ced7c, 0x17e3cc71, 0x66668566,
  0xa68ea77b, 0xdddd53dd, 0xb84b2eaf, 0x17175c17,
  0x02468e45, 0x47470147, 0x84dc211a, 0x9e9e429e,
  0x1ec589d4, 0xcaca0fca, 0x75995a58, 0x2d2db42d,
  0x9179632e, 0xbfbfc6bf, 0x381b0e3f, 0x07071c07,
  0x012347ac, 0xadad8ead, 0xea2fb4b0, 0x5a5a755a,
  0x6cb51bef, 0x83833683, 0x85ff66b6, 0x3333cc33,
  0x3ff2c65c, 0x63639163, 0x100a0412, 0x02020802,
  0x39384993, 0xaaaa92aa, 0xafa8e2de, 0x7171d971,
  0x0ecf8dc6, 0xc8c807c8, 0xc87d32d1, 0x19196419,
  0x7270923b, 0x49493949, 0x869aaf5f, 0xd9d943d9,
  0xc31df931, 0xf2f2eff2, 0x4b48dba8, 0xe3e3abe3,
  0xe22ab6b9, 0x5b5b715b, 0x34920dbc, 0x88881a88,
  0xa4c8293e, 0x9a9a529a, 0x2dbe4c0b, 0x26269826,
  0x8dfa64bf, 0x3232c832, 0xe94a7d59, 0xb0b0fab0,
  0x1b6acff2, 0xe9e983e9, 0x78331e77, 0x0f0f3c0f,
  0xe6a6b733, 0xd5d573d5, 0x74ba1df4, 0x80803a80,
  0x997c6127, 0xbebec2be, 0x26de87eb, 0xcdcd13cd,
  0xbde46889, 0x3434d034, 0x7a759032, 0x48483d48,
  0xab24e354, 0xffffdbff, 0xf78ff48d, 0x7a7af57a,
  0xf4ea3d64, 0x90907a90, 0xc23ebe9d, 0x5f5f615f,
  0x1da0403d, 0x20208020, 0x67d5d00f, 0x6868bd68,
  0xd07234ca, 0x1a1a681a, 0x192c41b7, 0xaeae82ae,
  0xc95e757d, 0xb4b4eab4, 0x9a19a8ce, 0x54544d54,
  0xece53b7f, 0x93937693, 0x0daa442f, 0x22228822,
  0x07e9c863, 0x64648d64, 0xdb12ff2a, 0xf1f1e3f1,
  0xbfa2e6cc, 0x7373d173, 0x905a2482, 0x12124812,
  0x3a5d807a, 0x40401d40, 0x40281048, 0x08082008,
  0x56e89b95, 0xc3c32bc3, 0x337bc5df, 0xecec97ec,
  0x9690ab4d, 0xdbdb4bdb, 0x611f5fc0, 0xa1a1bea1,
  0x1c830791, 0x8d8d0e8d, 0xf5c97ac8, 0x3d3df43d,
  0xccf1335b, 0x97976697, 0x00000000, 0x00000000,
  0x36d483f9, 0xcfcf1bcf, 0x4587566e, 0x2b2bac2b,
  0x97b3ece1, 0x7676c576, 0x64b019e6, 0x82823282,
  0xfea9b128, 0xd6d67fd6, 0xd87736c3, 0x1b1b6c1b,
  0xc15b7774, 0xb5b5eeb5, 0x112943be, 0xafaf86af,
  0x77dfd41d, 0x6a6ab56a, 0xba0da0ea, 0x50505d50,
  0x124c8a57, 0x45450945, 0xcb18fb38, 0xf3f3ebf3,
  0x9df060ad, 0x3030c030, 0x2b74c3c4, 0xefef9bef,
  0xe5c37eda, 0x3f3ffc3f, 0x921caac7, 0x55554955,
  0x791059db, 0xa2a2b2a2, 0x0365c9e9, 0xeaea8fea,
  0x0fecca6a, 0x65658965, 0xb9686903, 0xbabad2ba,
  0x65935e4a, 0x2f2fbc2f, 0x4ee79d8e, 0xc0c027c0,
  0xbe81a160, 0xdede5fde, 0xe06c38fc, 0x1c1c701c,
  0xbb2ee746, 0xfdfdd3fd, 0x52649a1f, 0x4d4d294d,
  0xe4e03976, 0x92927292, 0x8fbceafa, 0x7575c975,
  0x301e0c36, 0x06061806, 0x249809ae, 0x8a8a128a,
  0xf940794b, 0xb2b2f2b2, 0x6359d185, 0xe6e6bfe6,
  0x70361c7e, 0x0e0e380e, 0xf8633ee7, 0x1f1f7c1f,
  0x37f7c455, 0x62629562, 0xeea3b53a, 0xd4d477d4,
  0x29324d81, 0xa8a89aa8, 0xc4f43152, 0x96966296,
  0x9b3aef62, 0xf9f9c3f9, 0x66f697a3, 0xc5c533c5,
  0x35b14a10, 0x25259425, 0xf220b2ab, 0x59597959,
  0x54ae15d0, 0x84842a84, 0xb7a7e4c5, 0x7272d572,
  0xd5dd72ec, 0x3939e439, 0x5a619816, 0x4c4c2d4c,
  0xca3bbc94, 0x5e5e655e, 0xe785f09f, 0x7878fd78,
  0xddd870e5, 0x3838e038, 0x14860598, 0x8c8c0a8c,
  0xc6b2bf17, 0xd1d163d1, 0x410b57e4, 0xa5a5aea5,
  0x434dd9a1, 0xe2e2afe2, 0x2ff8c24e, 0x61619961,
  0xf1457b42, 0xb3b3f6b3, 0x15a54234, 0x21218421,
  0x94d62508, 0x9c9c4a9c, 0xf0663cee, 0x1e1e781e,
  0x22528661, 0x43431143, 0x76fc93b1, 0xc7c73bc7,
  0xb32be54f, 0xfcfcd7fc, 0x20140824, 0x04041004,
  0xb208a2e3, 0x51515951, 0xbcc72f25, 0x99995e99,
  0x4fc4da22, 0x6d6da96d, 0x68391a65, 0x0d0d340d,
  0x8335e979, 0xfafacffa, 0xb684a369, 0xdfdf5bdf,
  0xd79bfca9, 0x7e7ee57e, 0x3db44819, 0x24249024,
  0xc5d776fe, 0x3b3bec3b, 0x313d4b9a, 0xabab96ab,
  0x3ed181f0, 0xcece1fce, 0x88552299, 0x11114411,
  0x0c890383, 0x8f8f068f, 0x4a6b9c04, 0x4e4e254e,
  0xd1517366, 0xb7b7e6b7, 0x0b60cbe0, 0xebeb8beb,
  0xfdcc78c1, 0x3c3cf03c, 0x7cbf1ffd, 0x81813e81,
  0xd4fe3540, 0x94946a94, 0xeb0cf31c, 0xf7f7fbf7,
  0xa1676f18, 0xb9b9deb9, 0x985f268b, 0x13134c13,
  0x7d9c5851, 0x2c2cb02c, 0xd6b8bb05, 0xd3d36bd3,
  0x6b5cd38c, 0xe7e7bbe7, 0x57cbdc39, 0x6e6ea56e,
  0x6ef395aa, 0xc4c437c4, 0x180f061b, 0x03030c03,
  0x8a13acdc, 0x56564556, 0x1a49885e, 0x44440d44,
  0xdf9efea0, 0x7f7fe17f, 0x21374f88, 0xa9a99ea9,
  0x4d825467, 0x2a2aa82a, 0xb16d6b0a, 0xbbbbd6bb,
  0x46e29f87, 0xc1c123c1, 0xa202a6f1, 0x53535153,
  0xae8ba572, 0xdcdc57dc, 0x58271653, 0x0b0b2c0b,
  0x9cd32701, 0x9d9d4e9d, 0x47c1d82b, 0x6c6cad6c,
  0x95f562a4, 0x3131c431, 0x87b9e8f3, 0x7474cd74,
  0xe309f115, 0xf6f6fff6, 0x0a438c4c, 0x46460546,
  0x092645a5, 0xacac8aac, 0x3c970fb5, 0x89891e89,
  0xa04428b4, 0x14145014, 0x5b42dfba, 0xe1e1a3e1,
  0xb04e2ca6, 0x16165816, 0xcdd274f7, 0x3a3ae83a,
  0x6fd0d206, 0x6969b969, 0x482d1241, 0x09092409,
  0xa7ade0d7, 0x7070dd70, 0xd954716f, 0xb6b6e2b6,
  0xceb7bd1e, 0xd0d067d0, 0x3b7ec7d6, 0xeded93ed,
  0x2edb85e2, 0xcccc17cc, 0x2a578468, 0x42421542,
  0xb4c22d2c, 0x98985a98, 0x490e55ed, 0xa4a4aaa4,
  0x5d885075, 0x2828a028, 0xda31b886, 0x5c5c6d5c,
  0x933fed6b, 0xf8f8c7f8, 0x44a411c2, 0x86862286
]);

const C5 = new Uint32Array([
  0x18c07830, 0xd8181860, 0x2305af46, 0x2623238c,
  0xc67ef991, 0xb8c6c63f, 0xe8136fcd, 0xfbe8e887,
  0x874ca113, 0xcb878726, 0xb8a9626d, 0x11b8b8da,
  0x01080502, 0x09010104, 0x4f426e9e, 0x0d4f4f21,
  0x36adee6c, 0x9b3636d8, 0xa6590451, 0xffa6a6a2,
  0xd2debdb9, 0x0cd2d26f, 0xf5fb06f7, 0x0ef5f5f3,
  0x79ef80f2, 0x967979f9, 0x6f5fcede, 0x306f6fa1,
  0x91fcef3f, 0x6d91917e, 0x52aa07a4, 0xf8525255,
  0x6027fdc0, 0x4760609d, 0xbc897665, 0x35bcbcca,
  0x9baccd2b, 0x379b9b56, 0x8e048c01, 0x8a8e8e02,
  0xa371155b, 0xd2a3a3b6, 0x0c603c18, 0x6c0c0c30,
  0x7bff8af6, 0x847b7bf1, 0x35b5e16a, 0x803535d4,
  0x1de8693a, 0xf51d1d74, 0xe05347dd, 0xb3e0e0a7,
  0xd7f6acb3, 0x21d7d77b, 0xc25eed99, 0x9cc2c22f,
  0x2e6d965c, 0x432e2eb8, 0x4b627a96, 0x294b4b31,
  0xfea321e1, 0x5dfefedf, 0x578216ae, 0xd5575741,
  0x15a8412a, 0xbd151554, 0x779fb6ee, 0xe87777c1,
  0x37a5eb6e, 0x923737dc, 0xe57b56d7, 0x9ee5e5b3,
  0x9f8cd923, 0x139f9f46, 0xf0d317fd, 0x23f0f0e7,
  0x4a6a7f94, 0x204a4a35, 0xda9e95a9, 0x44dada4f,
  0x58fa25b0, 0xa258587d, 0xc906ca8f, 0xcfc9c903,
  0x29558d52, 0x7c2929a4, 0x0a502214, 0x5a0a0a28,
  0xb1e14f7f, 0x50b1b1fe, 0xa0691a5d, 0xc9a0a0ba,
  0x6b7fdad6, 0x146b6bb1, 0x855cab17, 0xd985852e,
  0xbd817367, 0x3cbdbdce, 0x5dd234ba, 0x8f5d5d69,
  0x10805020, 0x90101040, 0xf4f303f5, 0x07f4f4f7,
  0xcb16c08b, 0xddcbcb0b, 0x3eedc67c, 0xd33e3ef8,
  0x0528110a, 0x2d050514, 0x671fe6ce, 0x78676781,
  0xe47353d5, 0x97e4e4b7, 0x2725bb4e, 0x0227279c,
  0x41325882, 0x73414119, 0x8b2c9d0b, 0xa78b8b16,
  0xa7510153, 0xf6a7a7a6, 0x7dcf94fa, 0xb27d7de9,
  0x95dcfb37, 0x4995956e, 0xd88e9fad, 0x56d8d847,
  0xfb8b30eb, 0x70fbfbcb, 0xee2371c1, 0xcdeeee9f,
  0x7cc791f8, 0xbb7c7ced, 0x6617e3cc, 0x71666685,
  0xdda68ea7, 0x7bdddd53, 0x17b84b2e, 0xaf17175c,
  0x4702468e, 0x45474701, 0x9e84dc21, 0x1a9e9e42,
  0xca1ec589, 0xd4caca0f, 0x2d75995a, 0x582d2db4,
  0xbf917963, 0x2ebfbfc6, 0x07381b0e, 0x3f07071c,
  0xad012347, 0xacadad8e, 0x5aea2fb4, 0xb05a5a75,
  0x836cb51b, 0xef838336, 0x3385ff66, 0xb63333cc,
  0x633ff2c6, 0x5c636391, 0x02100a04, 0x12020208,
  0xaa393849, 0x93aaaa92, 0x71afa8e2, 0xde7171d9,
  0xc80ecf8d, 0xc6c8c807, 0x19c87d32, 0xd1191964,
  0x49727092, 0x3b494939, 0xd9869aaf, 0x5fd9d943,
  0xf2c31df9, 0x31f2f2ef, 0xe34b48db, 0xa8e3e3ab,
  0x5be22ab6, 0xb95b5b71, 0x8834920d, 0xbc88881a,
  0x9aa4c829, 0x3e9a9a52, 0x262dbe4c, 0x0b262698,
  0x328dfa64, 0xbf3232c8, 0xb0e94a7d, 0x59b0b0fa,
  0xe91b6acf, 0xf2e9e983, 0x0f78331e, 0x770f0f3c,
  0xd5e6a6b7, 0x33d5d573, 0x8074ba1d, 0xf480803a,
  0xbe997c61, 0x27bebec2, 0xcd26de87, 0xebcdcd13,
  0x34bde468, 0x893434d0, 0x487a7590, 0x3248483d,
  0xffab24e3, 0x54ffffdb, 0x7af78ff4, 0x8d7a7af5,
  0x90f4ea3d, 0x6490907a, 0x5fc23ebe, 0x9d5f5f61,
  0x201da040, 0x3d202080, 0x6867d5d0, 0x0f6868bd,
  0x1ad07234, 0xca1a1a68, 0xae192c41, 0xb7aeae82,
  0xb4c95e75, 0x7db4b4ea, 0x549a19a8, 0xce54544d,
  0x93ece53b, 0x7f939376, 0x220daa44, 0x2f222288,
  0x6407e9c8, 0x6364648d, 0xf1db12ff, 0x2af1f1e3,
  0x73bfa2e6, 0xcc7373d1, 0x12905a24, 0x82121248,
  0x403a5d80, 0x7a40401d, 0x08402810, 0x48080820,
  0xc356e89b, 0x95c3c32b, 0xec337bc5, 0xdfecec97,
  0xdb9690ab, 0x4ddbdb4b, 0xa1611f5f, 0xc0a1a1be,
  0x8d1c8307, 0x918d8d0e, 0x3df5c97a, 0xc83d3df4,
  0x97ccf133, 0x5b979766, 0x00000000, 0x00000000,
  0xcf36d483, 0xf9cfcf1b, 0x2b458756, 0x6e2b2bac,
  0x7697b3ec, 0xe17676c5, 0x8264b019, 0xe6828232,
  0xd6fea9b1, 0x28d6d67f, 0x1bd87736, 0xc31b1b6c,
  0xb5c15b77, 0x74b5b5ee, 0xaf112943, 0xbeafaf86,
  0x6a77dfd4, 0x1d6a6ab5, 0x50ba0da0, 0xea50505d,
  0x45124c8a, 0x57454509, 0xf3cb18fb, 0x38f3f3eb,
  0x309df060, 0xad3030c0, 0xef2b74c3, 0xc4efef9b,
  0x3fe5c37e, 0xda3f3ffc, 0x55921caa, 0xc7555549,
  0xa2791059, 0xdba2a2b2, 0xea0365c9, 0xe9eaea8f,
  0x650fecca, 0x6a656589, 0xbab96869, 0x03babad2,
  0x2f65935e, 0x4a2f2fbc, 0xc04ee79d, 0x8ec0c027,
  0xdebe81a1, 0x60dede5f, 0x1ce06c38, 0xfc1c1c70,
  0xfdbb2ee7, 0x46fdfdd3, 0x4d52649a, 0x1f4d4d29,
  0x92e4e039, 0x76929272, 0x758fbcea, 0xfa7575c9,
  0x06301e0c, 0x36060618, 0x8a249809, 0xae8a8a12,
  0xb2f94079, 0x4bb2b2f2, 0xe66359d1, 0x85e6e6bf,
  0x0e70361c, 0x7e0e0e38, 0x1ff8633e, 0xe71f1f7c,
  0x6237f7c4, 0x55626295, 0xd4eea3b5, 0x3ad4d477,
  0xa829324d, 0x81a8a89a, 0x96c4f431, 0x52969662,
  0xf99b3aef, 0x62f9f9c3, 0xc566f697, 0xa3c5c533,
  0x2535b14a, 0x10252594, 0x59f220b2, 0xab595979,
  0x8454ae15, 0xd084842a, 0x72b7a7e4, 0xc57272d5,
  0x39d5dd72, 0xec3939e4, 0x4c5a6198, 0x164c4c2d,
  0x5eca3bbc, 0x945e5e65, 0x78e785f0, 0x9f7878fd,
  0x38ddd870, 0xe53838e0, 0x8c148605, 0x988c8c0a,
  0xd1c6b2bf, 0x17d1d163, 0xa5410b57, 0xe4a5a5ae,
  0xe2434dd9, 0xa1e2e2af, 0x612ff8c2, 0x4e616199,
  0xb3f1457b, 0x42b3b3f6, 0x2115a542, 0x34212184,
  0x9c94d625, 0x089c9c4a, 0x1ef0663c, 0xee1e1e78,
  0x43225286, 0x61434311, 0xc776fc93, 0xb1c7c73b,
  0xfcb32be5, 0x4ffcfcd7, 0x04201408, 0x24040410,
  0x51b208a2, 0xe3515159, 0x99bcc72f, 0x2599995e,
  0x6d4fc4da, 0x226d6da9, 0x0d68391a, 0x650d0d34,
  0xfa8335e9, 0x79fafacf, 0xdfb684a3, 0x69dfdf5b,
  0x7ed79bfc, 0xa97e7ee5, 0x243db448, 0x19242490,
  0x3bc5d776, 0xfe3b3bec, 0xab313d4b, 0x9aabab96,
  0xce3ed181, 0xf0cece1f, 0x11885522, 0x99111144,
  0x8f0c8903, 0x838f8f06, 0x4e4a6b9c, 0x044e4e25,
  0xb7d15173, 0x66b7b7e6, 0xeb0b60cb, 0xe0ebeb8b,
  0x3cfdcc78, 0xc13c3cf0, 0x817cbf1f, 0xfd81813e,
  0x94d4fe35, 0x4094946a, 0xf7eb0cf3, 0x1cf7f7fb,
  0xb9a1676f, 0x18b9b9de, 0x13985f26, 0x8b13134c,
  0x2c7d9c58, 0x512c2cb0, 0xd3d6b8bb, 0x05d3d36b,
  0xe76b5cd3, 0x8ce7e7bb, 0x6e57cbdc, 0x396e6ea5,
  0xc46ef395, 0xaac4c437, 0x03180f06, 0x1b03030c,
  0x568a13ac, 0xdc565645, 0x441a4988, 0x5e44440d,
  0x7fdf9efe, 0xa07f7fe1, 0xa921374f, 0x88a9a99e,
  0x2a4d8254, 0x672a2aa8, 0xbbb16d6b, 0x0abbbbd6,
  0xc146e29f, 0x87c1c123, 0x53a202a6, 0xf1535351,
  0xdcae8ba5, 0x72dcdc57, 0x0b582716, 0x530b0b2c,
  0x9d9cd327, 0x019d9d4e, 0x6c47c1d8, 0x2b6c6cad,
  0x3195f562, 0xa43131c4, 0x7487b9e8, 0xf37474cd,
  0xf6e309f1, 0x15f6f6ff, 0x460a438c, 0x4c464605,
  0xac092645, 0xa5acac8a, 0x893c970f, 0xb589891e,
  0x14a04428, 0xb4141450, 0xe15b42df, 0xbae1e1a3,
  0x16b04e2c, 0xa6161658, 0x3acdd274, 0xf73a3ae8,
  0x696fd0d2, 0x066969b9, 0x09482d12, 0x41090924,
  0x70a7ade0, 0xd77070dd, 0xb6d95471, 0x6fb6b6e2,
  0xd0ceb7bd, 0x1ed0d067, 0xed3b7ec7, 0xd6eded93,
  0xcc2edb85, 0xe2cccc17, 0x422a5784, 0x68424215,
  0x98b4c22d, 0x2c98985a, 0xa4490e55, 0xeda4a4aa,
  0x285d8850, 0x752828a0, 0x5cda31b8, 0x865c5c6d,
  0xf8933fed, 0x6bf8f8c7, 0x8644a411, 0xc2868622
]);

const C6 = new Uint32Array([
  0x6018c078, 0x30d81818, 0x8c2305af, 0x46262323,
  0x3fc67ef9, 0x91b8c6c6, 0x87e8136f, 0xcdfbe8e8,
  0x26874ca1, 0x13cb8787, 0xdab8a962, 0x6d11b8b8,
  0x04010805, 0x02090101, 0x214f426e, 0x9e0d4f4f,
  0xd836adee, 0x6c9b3636, 0xa2a65904, 0x51ffa6a6,
  0x6fd2debd, 0xb90cd2d2, 0xf3f5fb06, 0xf70ef5f5,
  0xf979ef80, 0xf2967979, 0xa16f5fce, 0xde306f6f,
  0x7e91fcef, 0x3f6d9191, 0x5552aa07, 0xa4f85252,
  0x9d6027fd, 0xc0476060, 0xcabc8976, 0x6535bcbc,
  0x569baccd, 0x2b379b9b, 0x028e048c, 0x018a8e8e,
  0xb6a37115, 0x5bd2a3a3, 0x300c603c, 0x186c0c0c,
  0xf17bff8a, 0xf6847b7b, 0xd435b5e1, 0x6a803535,
  0x741de869, 0x3af51d1d, 0xa7e05347, 0xddb3e0e0,
  0x7bd7f6ac, 0xb321d7d7, 0x2fc25eed, 0x999cc2c2,
  0xb82e6d96, 0x5c432e2e, 0x314b627a, 0x96294b4b,
  0xdffea321, 0xe15dfefe, 0x41578216, 0xaed55757,
  0x5415a841, 0x2abd1515, 0xc1779fb6, 0xeee87777,
  0xdc37a5eb, 0x6e923737, 0xb3e57b56, 0xd79ee5e5,
  0x469f8cd9, 0x23139f9f, 0xe7f0d317, 0xfd23f0f0,
  0x354a6a7f, 0x94204a4a, 0x4fda9e95, 0xa944dada,
  0x7d58fa25, 0xb0a25858, 0x03c906ca, 0x8fcfc9c9,
  0xa429558d, 0x527c2929, 0x280a5022, 0x145a0a0a,
  0xfeb1e14f, 0x7f50b1b1, 0xbaa0691a, 0x5dc9a0a0,
  0xb16b7fda, 0xd6146b6b, 0x2e855cab, 0x17d98585,
  0xcebd8173, 0x673cbdbd, 0x695dd234, 0xba8f5d5d,
  0x40108050, 0x20901010, 0xf7f4f303, 0xf507f4f4,
  0x0bcb16c0, 0x8bddcbcb, 0xf83eedc6, 0x7cd33e3e,
  0x14052811, 0x0a2d0505, 0x81671fe6, 0xce786767,
  0xb7e47353, 0xd597e4e4, 0x9c2725bb, 0x4e022727,
  0x19413258, 0x82734141, 0x168b2c9d, 0x0ba78b8b,
  0xa6a75101, 0x53f6a7a7, 0xe97dcf94, 0xfab27d7d,
  0x6e95dcfb, 0x37499595, 0x47d88e9f, 0xad56d8d8,
  0xcbfb8b30, 0xeb70fbfb, 0x9fee2371, 0xc1cdeeee,
  0xed7cc791, 0xf8bb7c7c, 0x856617e3, 0xcc716666,
  0x53dda68e, 0xa77bdddd, 0x5c17b84b, 0x2eaf1717,
  0x01470246, 0x8e454747, 0x429e84dc, 0x211a9e9e,
  0x0fca1ec5, 0x89d4caca, 0xb42d7599, 0x5a582d2d,
  0xc6bf9179, 0x632ebfbf, 0x1c07381b, 0x0e3f0707,
  0x8ead0123, 0x47acadad, 0x755aea2f, 0xb4b05a5a,
  0x36836cb5, 0x1bef8383, 0xcc3385ff, 0x66b63333,
  0x91633ff2, 0xc65c6363, 0x0802100a, 0x04120202,
  0x92aa3938, 0x4993aaaa, 0xd971afa8, 0xe2de7171,
  0x07c80ecf, 0x8dc6c8c8, 0x6419c87d, 0x32d11919,
  0x39497270, 0x923b4949, 0x43d9869a, 0xaf5fd9d9,
  0xeff2c31d, 0xf931f2f2, 0xabe34b48, 0xdba8e3e3,
  0x715be22a, 0xb6b95b5b, 0x1a883492, 0x0dbc8888,
  0x529aa4c8, 0x293e9a9a, 0x98262dbe, 0x4c0b2626,
  0xc8328dfa, 0x64bf3232, 0xfab0e94a, 0x7d59b0b0,
  0x83e91b6a, 0xcff2e9e9, 0x3c0f7833, 0x1e770f0f,
  0x73d5e6a6, 0xb733d5d5, 0x3a8074ba, 0x1df48080,
  0xc2be997c, 0x6127bebe, 0x13cd26de, 0x87ebcdcd,
  0xd034bde4, 0x68893434, 0x3d487a75, 0x90324848,
  0xdbffab24, 0xe354ffff, 0xf57af78f, 0xf48d7a7a,
  0x7a90f4ea, 0x3d649090, 0x615fc23e, 0xbe9d5f5f,
  0x80201da0, 0x403d2020, 0xbd6867d5, 0xd00f6868,
  0x681ad072, 0x34ca1a1a, 0x82ae192c, 0x41b7aeae,
  0xeab4c95e, 0x757db4b4, 0x4d549a19, 0xa8ce5454,
  0x7693ece5, 0x3b7f9393, 0x88220daa, 0x442f2222,
  0x8d6407e9, 0xc8636464, 0xe3f1db12, 0xff2af1f1,
  0xd173bfa2, 0xe6cc7373, 0x4812905a, 0x24821212,
  0x1d403a5d, 0x807a4040, 0x20084028, 0x10480808,
  0x2bc356e8, 0x9b95c3c3, 0x97ec337b, 0xc5dfecec,
  0x4bdb9690, 0xab4ddbdb, 0xbea1611f, 0x5fc0a1a1,
  0x0e8d1c83, 0x07918d8d, 0xf43df5c9, 0x7ac83d3d,
  0x6697ccf1, 0x335b9797, 0x00000000, 0x00000000,
  0x1bcf36d4, 0x83f9cfcf, 0xac2b4587, 0x566e2b2b,
  0xc57697b3, 0xece17676, 0x328264b0, 0x19e68282,
  0x7fd6fea9, 0xb128d6d6, 0x6c1bd877, 0x36c31b1b,
  0xeeb5c15b, 0x7774b5b5, 0x86af1129, 0x43beafaf,
  0xb56a77df, 0xd41d6a6a, 0x5d50ba0d, 0xa0ea5050,
  0x0945124c, 0x8a574545, 0xebf3cb18, 0xfb38f3f3,
  0xc0309df0, 0x60ad3030, 0x9bef2b74, 0xc3c4efef,
  0xfc3fe5c3, 0x7eda3f3f, 0x4955921c, 0xaac75555,
  0xb2a27910, 0x59dba2a2, 0x8fea0365, 0xc9e9eaea,
  0x89650fec, 0xca6a6565, 0xd2bab968, 0x6903baba,
  0xbc2f6593, 0x5e4a2f2f, 0x27c04ee7, 0x9d8ec0c0,
  0x5fdebe81, 0xa160dede, 0x701ce06c, 0x38fc1c1c,
  0xd3fdbb2e, 0xe746fdfd, 0x294d5264, 0x9a1f4d4d,
  0x7292e4e0, 0x39769292, 0xc9758fbc, 0xeafa7575,
  0x1806301e, 0x0c360606, 0x128a2498, 0x09ae8a8a,
  0xf2b2f940, 0x794bb2b2, 0xbfe66359, 0xd185e6e6,
  0x380e7036, 0x1c7e0e0e, 0x7c1ff863, 0x3ee71f1f,
  0x956237f7, 0xc4556262, 0x77d4eea3, 0xb53ad4d4,
  0x9aa82932, 0x4d81a8a8, 0x6296c4f4, 0x31529696,
  0xc3f99b3a, 0xef62f9f9, 0x33c566f6, 0x97a3c5c5,
  0x942535b1, 0x4a102525, 0x7959f220, 0xb2ab5959,
  0x2a8454ae, 0x15d08484, 0xd572b7a7, 0xe4c57272,
  0xe439d5dd, 0x72ec3939, 0x2d4c5a61, 0x98164c4c,
  0x655eca3b, 0xbc945e5e, 0xfd78e785, 0xf09f7878,
  0xe038ddd8, 0x70e53838, 0x0a8c1486, 0x05988c8c,
  0x63d1c6b2, 0xbf17d1d1, 0xaea5410b, 0x57e4a5a5,
  0xafe2434d, 0xd9a1e2e2, 0x99612ff8, 0xc24e6161,
  0xf6b3f145, 0x7b42b3b3, 0x842115a5, 0x42342121,
  0x4a9c94d6, 0x25089c9c, 0x781ef066, 0x3cee1e1e,
  0x11432252, 0x86614343, 0x3bc776fc, 0x93b1c7c7,
  0xd7fcb32b, 0xe54ffcfc, 0x10042014, 0x08240404,
  0x5951b208, 0xa2e35151, 0x5e99bcc7, 0x2f259999,
  0xa96d4fc4, 0xda226d6d, 0x340d6839, 0x1a650d0d,
  0xcffa8335, 0xe979fafa, 0x5bdfb684, 0xa369dfdf,
  0xe57ed79b, 0xfca97e7e, 0x90243db4, 0x48192424,
  0xec3bc5d7, 0x76fe3b3b, 0x96ab313d, 0x4b9aabab,
  0x1fce3ed1, 0x81f0cece, 0x44118855, 0x22991111,
  0x068f0c89, 0x03838f8f, 0x254e4a6b, 0x9c044e4e,
  0xe6b7d151, 0x7366b7b7, 0x8beb0b60, 0xcbe0ebeb,
  0xf03cfdcc, 0x78c13c3c, 0x3e817cbf, 0x1ffd8181,
  0x6a94d4fe, 0x35409494, 0xfbf7eb0c, 0xf31cf7f7,
  0xdeb9a167, 0x6f18b9b9, 0x4c13985f, 0x268b1313,
  0xb02c7d9c, 0x58512c2c, 0x6bd3d6b8, 0xbb05d3d3,
  0xbbe76b5c, 0xd38ce7e7, 0xa56e57cb, 0xdc396e6e,
  0x37c46ef3, 0x95aac4c4, 0x0c03180f, 0x061b0303,
  0x45568a13, 0xacdc5656, 0x0d441a49, 0x885e4444,
  0xe17fdf9e, 0xfea07f7f, 0x9ea92137, 0x4f88a9a9,
  0xa82a4d82, 0x54672a2a, 0xd6bbb16d, 0x6b0abbbb,
  0x23c146e2, 0x9f87c1c1, 0x5153a202, 0xa6f15353,
  0x57dcae8b, 0xa572dcdc, 0x2c0b5827, 0x16530b0b,
  0x4e9d9cd3, 0x27019d9d, 0xad6c47c1, 0xd82b6c6c,
  0xc43195f5, 0x62a43131, 0xcd7487b9, 0xe8f37474,
  0xfff6e309, 0xf115f6f6, 0x05460a43, 0x8c4c4646,
  0x8aac0926, 0x45a5acac, 0x1e893c97, 0x0fb58989,
  0x5014a044, 0x28b41414, 0xa3e15b42, 0xdfbae1e1,
  0x5816b04e, 0x2ca61616, 0xe83acdd2, 0x74f73a3a,
  0xb9696fd0, 0xd2066969, 0x2409482d, 0x12410909,
  0xdd70a7ad, 0xe0d77070, 0xe2b6d954, 0x716fb6b6,
  0x67d0ceb7, 0xbd1ed0d0, 0x93ed3b7e, 0xc7d6eded,
  0x17cc2edb, 0x85e2cccc, 0x15422a57, 0x84684242,
  0x5a98b4c2, 0x2d2c9898, 0xaaa4490e, 0x55eda4a4,
  0xa0285d88, 0x50752828, 0x6d5cda31, 0xb8865c5c,
  0xc7f8933f, 0xed6bf8f8, 0x228644a4, 0x11c28686
]);

const C7 = new Uint32Array([
  0x186018c0, 0x7830d818, 0x238c2305, 0xaf462623,
  0xc63fc67e, 0xf991b8c6, 0xe887e813, 0x6fcdfbe8,
  0x8726874c, 0xa113cb87, 0xb8dab8a9, 0x626d11b8,
  0x01040108, 0x05020901, 0x4f214f42, 0x6e9e0d4f,
  0x36d836ad, 0xee6c9b36, 0xa6a2a659, 0x0451ffa6,
  0xd26fd2de, 0xbdb90cd2, 0xf5f3f5fb, 0x06f70ef5,
  0x79f979ef, 0x80f29679, 0x6fa16f5f, 0xcede306f,
  0x917e91fc, 0xef3f6d91, 0x525552aa, 0x07a4f852,
  0x609d6027, 0xfdc04760, 0xbccabc89, 0x766535bc,
  0x9b569bac, 0xcd2b379b, 0x8e028e04, 0x8c018a8e,
  0xa3b6a371, 0x155bd2a3, 0x0c300c60, 0x3c186c0c,
  0x7bf17bff, 0x8af6847b, 0x35d435b5, 0xe16a8035,
  0x1d741de8, 0x693af51d, 0xe0a7e053, 0x47ddb3e0,
  0xd77bd7f6, 0xacb321d7, 0xc22fc25e, 0xed999cc2,
  0x2eb82e6d, 0x965c432e, 0x4b314b62, 0x7a96294b,
  0xfedffea3, 0x21e15dfe, 0x57415782, 0x16aed557,
  0x155415a8, 0x412abd15, 0x77c1779f, 0xb6eee877,
  0x37dc37a5, 0xeb6e9237, 0xe5b3e57b, 0x56d79ee5,
  0x9f469f8c, 0xd923139f, 0xf0e7f0d3, 0x17fd23f0,
  0x4a354a6a, 0x7f94204a, 0xda4fda9e, 0x95a944da,
  0x587d58fa, 0x25b0a258, 0xc903c906, 0xca8fcfc9,
  0x29a42955, 0x8d527c29, 0x0a280a50, 0x22145a0a,
  0xb1feb1e1, 0x4f7f50b1, 0xa0baa069, 0x1a5dc9a0,
  0x6bb16b7f, 0xdad6146b, 0x852e855c, 0xab17d985,
  0xbdcebd81, 0x73673cbd, 0x5d695dd2, 0x34ba8f5d,
  0x10401080, 0x50209010, 0xf4f7f4f3, 0x03f507f4,
  0xcb0bcb16, 0xc08bddcb, 0x3ef83eed, 0xc67cd33e,
  0x05140528, 0x110a2d05, 0x6781671f, 0xe6ce7867,
  0xe4b7e473, 0x53d597e4, 0x279c2725, 0xbb4e0227,
  0x41194132, 0x58827341, 0x8b168b2c, 0x9d0ba78b,
  0xa7a6a751, 0x0153f6a7, 0x7de97dcf, 0x94fab27d,
  0x956e95dc, 0xfb374995, 0xd847d88e, 0x9fad56d8,
  0xfbcbfb8b, 0x30eb70fb, 0xee9fee23, 0x71c1cdee,
  0x7ced7cc7, 0x91f8bb7c, 0x66856617, 0xe3cc7166,
  0xdd53dda6, 0x8ea77bdd, 0x175c17b8, 0x4b2eaf17,
  0x47014702, 0x468e4547, 0x9e429e84, 0xdc211a9e,
  0xca0fca1e, 0xc589d4ca, 0x2db42d75, 0x995a582d,
  0xbfc6bf91, 0x79632ebf, 0x071c0738, 0x1b0e3f07,
  0xad8ead01, 0x2347acad, 0x5a755aea, 0x2fb4b05a,
  0x8336836c, 0xb51bef83, 0x33cc3385, 0xff66b633,
  0x6391633f, 0xf2c65c63, 0x02080210, 0x0a041202,
  0xaa92aa39, 0x384993aa, 0x71d971af, 0xa8e2de71,
  0xc807c80e, 0xcf8dc6c8, 0x196419c8, 0x7d32d119,
  0x49394972, 0x70923b49, 0xd943d986, 0x9aaf5fd9,
  0xf2eff2c3, 0x1df931f2, 0xe3abe34b, 0x48dba8e3,
  0x5b715be2, 0x2ab6b95b, 0x881a8834, 0x920dbc88,
  0x9a529aa4, 0xc8293e9a, 0x2698262d, 0xbe4c0b26,
  0x32c8328d, 0xfa64bf32, 0xb0fab0e9, 0x4a7d59b0,
  0xe983e91b, 0x6acff2e9, 0x0f3c0f78, 0x331e770f,
  0xd573d5e6, 0xa6b733d5, 0x803a8074, 0xba1df480,
  0xbec2be99, 0x7c6127be, 0xcd13cd26, 0xde87ebcd,
  0x34d034bd, 0xe4688934, 0x483d487a, 0x75903248,
  0xffdbffab, 0x24e354ff, 0x7af57af7, 0x8ff48d7a,
  0x907a90f4, 0xea3d6490, 0x5f615fc2, 0x3ebe9d5f,
  0x2080201d, 0xa0403d20, 0x68bd6867, 0xd5d00f68,
  0x1a681ad0, 0x7234ca1a, 0xae82ae19, 0x2c41b7ae,
  0xb4eab4c9, 0x5e757db4, 0x544d549a, 0x19a8ce54,
  0x937693ec, 0xe53b7f93, 0x2288220d, 0xaa442f22,
  0x648d6407, 0xe9c86364, 0xf1e3f1db, 0x12ff2af1,
  0x73d173bf, 0xa2e6cc73, 0x12481290, 0x5a248212,
  0x401d403a, 0x5d807a40, 0x08200840, 0x28104808,
  0xc32bc356, 0xe89b95c3, 0xec97ec33, 0x7bc5dfec,
  0xdb4bdb96, 0x90ab4ddb, 0xa1bea161, 0x1f5fc0a1,
  0x8d0e8d1c, 0x8307918d, 0x3df43df5, 0xc97ac83d,
  0x976697cc, 0xf1335b97, 0x00000000, 0x00000000,
  0xcf1bcf36, 0xd483f9cf, 0x2bac2b45, 0x87566e2b,
  0x76c57697, 0xb3ece176, 0x82328264, 0xb019e682,
  0xd67fd6fe, 0xa9b128d6, 0x1b6c1bd8, 0x7736c31b,
  0xb5eeb5c1, 0x5b7774b5, 0xaf86af11, 0x2943beaf,
  0x6ab56a77, 0xdfd41d6a, 0x505d50ba, 0x0da0ea50,
  0x45094512, 0x4c8a5745, 0xf3ebf3cb, 0x18fb38f3,
  0x30c0309d, 0xf060ad30, 0xef9bef2b, 0x74c3c4ef,
  0x3ffc3fe5, 0xc37eda3f, 0x55495592, 0x1caac755,
  0xa2b2a279, 0x1059dba2, 0xea8fea03, 0x65c9e9ea,
  0x6589650f, 0xecca6a65, 0xbad2bab9, 0x686903ba,
  0x2fbc2f65, 0x935e4a2f, 0xc027c04e, 0xe79d8ec0,
  0xde5fdebe, 0x81a160de, 0x1c701ce0, 0x6c38fc1c,
  0xfdd3fdbb, 0x2ee746fd, 0x4d294d52, 0x649a1f4d,
  0x927292e4, 0xe0397692, 0x75c9758f, 0xbceafa75,
  0x06180630, 0x1e0c3606, 0x8a128a24, 0x9809ae8a,
  0xb2f2b2f9, 0x40794bb2, 0xe6bfe663, 0x59d185e6,
  0x0e380e70, 0x361c7e0e, 0x1f7c1ff8, 0x633ee71f,
  0x62956237, 0xf7c45562, 0xd477d4ee, 0xa3b53ad4,
  0xa89aa829, 0x324d81a8, 0x966296c4, 0xf4315296,
  0xf9c3f99b, 0x3aef62f9, 0xc533c566, 0xf697a3c5,
  0x25942535, 0xb14a1025, 0x597959f2, 0x20b2ab59,
  0x842a8454, 0xae15d084, 0x72d572b7, 0xa7e4c572,
  0x39e439d5, 0xdd72ec39, 0x4c2d4c5a, 0x6198164c,
  0x5e655eca, 0x3bbc945e, 0x78fd78e7, 0x85f09f78,
  0x38e038dd, 0xd870e538, 0x8c0a8c14, 0x8605988c,
  0xd163d1c6, 0xb2bf17d1, 0xa5aea541, 0x0b57e4a5,
  0xe2afe243, 0x4dd9a1e2, 0x6199612f, 0xf8c24e61,
  0xb3f6b3f1, 0x457b42b3, 0x21842115, 0xa5423421,
  0x9c4a9c94, 0xd625089c, 0x1e781ef0, 0x663cee1e,
  0x43114322, 0x52866143, 0xc73bc776, 0xfc93b1c7,
  0xfcd7fcb3, 0x2be54ffc, 0x04100420, 0x14082404,
  0x515951b2, 0x08a2e351, 0x995e99bc, 0xc72f2599,
  0x6da96d4f, 0xc4da226d, 0x0d340d68, 0x391a650d,
  0xfacffa83, 0x35e979fa, 0xdf5bdfb6, 0x84a369df,
  0x7ee57ed7, 0x9bfca97e, 0x2490243d, 0xb4481924,
  0x3bec3bc5, 0xd776fe3b, 0xab96ab31, 0x3d4b9aab,
  0xce1fce3e, 0xd181f0ce, 0x11441188, 0x55229911,
  0x8f068f0c, 0x8903838f, 0x4e254e4a, 0x6b9c044e,
  0xb7e6b7d1, 0x517366b7, 0xeb8beb0b, 0x60cbe0eb,
  0x3cf03cfd, 0xcc78c13c, 0x813e817c, 0xbf1ffd81,
  0x946a94d4, 0xfe354094, 0xf7fbf7eb, 0x0cf31cf7,
  0xb9deb9a1, 0x676f18b9, 0x134c1398, 0x5f268b13,
  0x2cb02c7d, 0x9c58512c, 0xd36bd3d6, 0xb8bb05d3,
  0xe7bbe76b, 0x5cd38ce7, 0x6ea56e57, 0xcbdc396e,
  0xc437c46e, 0xf395aac4, 0x030c0318, 0x0f061b03,
  0x5645568a, 0x13acdc56, 0x440d441a, 0x49885e44,
  0x7fe17fdf, 0x9efea07f, 0xa99ea921, 0x374f88a9,
  0x2aa82a4d, 0x8254672a, 0xbbd6bbb1, 0x6d6b0abb,
  0xc123c146, 0xe29f87c1, 0x535153a2, 0x02a6f153,
  0xdc57dcae, 0x8ba572dc, 0x0b2c0b58, 0x2716530b,
  0x9d4e9d9c, 0xd327019d, 0x6cad6c47, 0xc1d82b6c,
  0x31c43195, 0xf562a431, 0x74cd7487, 0xb9e8f374,
  0xf6fff6e3, 0x09f115f6, 0x4605460a, 0x438c4c46,
  0xac8aac09, 0x2645a5ac, 0x891e893c, 0x970fb589,
  0x145014a0, 0x4428b414, 0xe1a3e15b, 0x42dfbae1,
  0x165816b0, 0x4e2ca616, 0x3ae83acd, 0xd274f73a,
  0x69b9696f, 0xd0d20669, 0x09240948, 0x2d124109,
  0x70dd70a7, 0xade0d770, 0xb6e2b6d9, 0x54716fb6,
  0xd067d0ce, 0xb7bd1ed0, 0xed93ed3b, 0x7ec7d6ed,
  0xcc17cc2e, 0xdb85e2cc, 0x4215422a, 0x57846842,
  0x985a98b4, 0xc22d2c98, 0xa4aaa449, 0x0e55eda4,
  0x28a0285d, 0x88507528, 0x5c6d5cda, 0x31b8865c,
  0xf8c7f893, 0x3fed6bf8, 0x86228644, 0xa411c286
]);

/**
 * Whirlpool
 */

class Whirlpool {
  /**
   * Create a Whirlpool context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(16);
    this.msg = new Uint32Array(16);
    this.block = Buffer.allocUnsafe(64);
    this.size = FINALIZED;
  }

  /**
   * Initialize Whirlpool context.
   */

  init() {
    for (let i = 0; i < 16; i++)
      this.state[i] = 0;
    this.size = 0;
    return this;
  }

  /**
   * Update Whirlpool context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize Whirlpool context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(64));
  }

  /**
   * Update Whirlpool context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 63;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 64) {
      this.transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize Whirlpool context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size & 63;
    const len = this.size * 8;

    writeU32(DESC, len * (1 / 0x100000000), 24);
    writeU32(DESC, len, 28);

    this._update(PADDING, 1 + ((95 - pos) & 63));
    this._update(DESC, 32);

    for (let i = 0; i < 16; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 16; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform Whirlpool block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    const block = this.msg;

    for (let i = 0; i < 16; i++)
      block[i] = readU32(chunk, pos + i * 4);

    const K = new Uint32Array(16);
    const L = new Uint32Array(16);
    const state = new Uint32Array(16);

    for (let i = 0; i < 16; i++) {
      K[i] = this.state[i];
      state[i] = block[i] ^ K[i];
    }

    for (let r = 1; r < 10 + 1; r++) {
      for (let i = 0; i < 8; i++) {
        L[i * 2 + 0] = 0
          ^ C0[((K[(0 + i) % 8 * 2 + 0] >>> 24) & 0xff) * 2 + 0]
          ^ C1[((K[(7 + i) % 8 * 2 + 0] >>> 16) & 0xff) * 2 + 0]
          ^ C2[((K[(6 + i) % 8 * 2 + 0] >>>  8) & 0xff) * 2 + 0]
          ^ C3[((K[(5 + i) % 8 * 2 + 0] >>>  0) & 0xff) * 2 + 0]
          ^ C4[((K[(4 + i) % 8 * 2 + 1] >>> 24) & 0xff) * 2 + 0]
          ^ C5[((K[(3 + i) % 8 * 2 + 1] >>> 16) & 0xff) * 2 + 0]
          ^ C6[((K[(2 + i) % 8 * 2 + 1] >>>  8) & 0xff) * 2 + 0]
          ^ C7[((K[(1 + i) % 8 * 2 + 1] >>>  0) & 0xff) * 2 + 0]
          ^ (i === 0 ? RC[r * 2 + 0] : 0);

        L[i * 2 + 1] = 0
          ^ C0[((K[(0 + i) % 8 * 2 + 0] >>> 24) & 0xff) * 2 + 1]
          ^ C1[((K[(7 + i) % 8 * 2 + 0] >>> 16) & 0xff) * 2 + 1]
          ^ C2[((K[(6 + i) % 8 * 2 + 0] >>>  8) & 0xff) * 2 + 1]
          ^ C3[((K[(5 + i) % 8 * 2 + 0] >>>  0) & 0xff) * 2 + 1]
          ^ C4[((K[(4 + i) % 8 * 2 + 1] >>> 24) & 0xff) * 2 + 1]
          ^ C5[((K[(3 + i) % 8 * 2 + 1] >>> 16) & 0xff) * 2 + 1]
          ^ C6[((K[(2 + i) % 8 * 2 + 1] >>>  8) & 0xff) * 2 + 1]
          ^ C7[((K[(1 + i) % 8 * 2 + 1] >>>  0) & 0xff) * 2 + 1]
          ^ (i === 0 ? RC[r * 2 + 1] : 0);
      }

      for (let i = 0; i < 16; i++)
        K[i] = L[i];

      for (let i = 0; i < 8; i++) {
        L[i * 2 + 0] = 0
          ^ C0[((state[(0 + i) % 8 * 2 + 0] >>> 24) & 0xff) * 2 + 0]
          ^ C1[((state[(7 + i) % 8 * 2 + 0] >>> 16) & 0xff) * 2 + 0]
          ^ C2[((state[(6 + i) % 8 * 2 + 0] >>>  8) & 0xff) * 2 + 0]
          ^ C3[((state[(5 + i) % 8 * 2 + 0] >>>  0) & 0xff) * 2 + 0]
          ^ C4[((state[(4 + i) % 8 * 2 + 1] >>> 24) & 0xff) * 2 + 0]
          ^ C5[((state[(3 + i) % 8 * 2 + 1] >>> 16) & 0xff) * 2 + 0]
          ^ C6[((state[(2 + i) % 8 * 2 + 1] >>>  8) & 0xff) * 2 + 0]
          ^ C7[((state[(1 + i) % 8 * 2 + 1] >>>  0) & 0xff) * 2 + 0]
          ^ K[i * 2 + 0];

        L[i * 2 + 1] = 0
          ^ C0[((state[(0 + i) % 8 * 2 + 0] >>> 24) & 0xff) * 2 + 1]
          ^ C1[((state[(7 + i) % 8 * 2 + 0] >>> 16) & 0xff) * 2 + 1]
          ^ C2[((state[(6 + i) % 8 * 2 + 0] >>>  8) & 0xff) * 2 + 1]
          ^ C3[((state[(5 + i) % 8 * 2 + 0] >>>  0) & 0xff) * 2 + 1]
          ^ C4[((state[(4 + i) % 8 * 2 + 1] >>> 24) & 0xff) * 2 + 1]
          ^ C5[((state[(3 + i) % 8 * 2 + 1] >>> 16) & 0xff) * 2 + 1]
          ^ C6[((state[(2 + i) % 8 * 2 + 1] >>>  8) & 0xff) * 2 + 1]
          ^ C7[((state[(1 + i) % 8 * 2 + 1] >>>  0) & 0xff) * 2 + 1]
          ^ K[i * 2 + 1];
      }

      for (let i = 0; i < 16; i++)
        state[i] = L[i];
    }

    for (let i = 0; i < 16; i++)
      this.state[i] ^= state[i] ^ block[i];
  }

  static hash() {
    return new Whirlpool();
  }

  static hmac() {
    return new HMAC(Whirlpool, 64);
  }

  static digest(data) {
    return Whirlpool.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 64);
    assert(Buffer.isBuffer(right) && right.length === 64);
    return Whirlpool.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = Whirlpool.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return Whirlpool.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

Whirlpool.native = 0;
Whirlpool.id = 'WHIRLPOOL';
Whirlpool.size = 64;
Whirlpool.bits = 512;
Whirlpool.blockSize = 64;
Whirlpool.zero = Buffer.alloc(64, 0x00);
Whirlpool.ctx = new Whirlpool();

/*
 * Helpers
 */

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = Whirlpool;

}).call(this,req("buffer").Buffer)
},{"../internal/hmac":76,"bsert":190,"buffer":303}],139:[function(req,module,exports){
/*!
 * keccak.js - keccak for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/keccak');

},{"./js/keccak":111}],140:[function(req,module,exports){
(function (Buffer){
/*!
 * keccak224.js - Keccak-224 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const Keccak = req('./keccak');

/**
 * Keccak224
 */

class Keccak224 extends Keccak {
  /**
   * Create a Keccak224 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(224);
  }

  final() {
    return super.final(0x01, null);
  }

  static hash() {
    return new Keccak224();
  }

  static hmac() {
    return super.hmac(224, 0x01, null);
  }

  static digest(data) {
    return super.digest(data, 224, 0x01, null);
  }

  static root(left, right) {
    return super.root(left, right, 224, 0x01, null);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 224, 0x01, null);
  }

  static mac(data, key) {
    return super.mac(data, key, 224, 0x01, null);
  }
}

Keccak224.native = Keccak.native;
Keccak224.id = 'KECCAK224';
Keccak224.size = 28;
Keccak224.bits = 224;
Keccak224.blockSize = 144;
Keccak224.zero = Buffer.alloc(28, 0x00);
Keccak224.ctx = new Keccak224();

/*
 * Expose
 */

module.exports = Keccak224;

}).call(this,req("buffer").Buffer)
},{"./keccak":139,"buffer":303}],141:[function(req,module,exports){
(function (Buffer){
/*!
 * keccak256.js - Keccak-256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const Keccak = req('./keccak');

/**
 * Keccak256
 */

class Keccak256 extends Keccak {
  /**
   * Create a Keccak256 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(256);
  }

  final() {
    return super.final(0x01, null);
  }

  static hash() {
    return new Keccak256();
  }

  static hmac() {
    return super.hmac(256, 0x01, null);
  }

  static digest(data) {
    return super.digest(data, 256, 0x01, null);
  }

  static root(left, right) {
    return super.root(left, right, 256, 0x01, null);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 256, 0x01, null);
  }

  static mac(data, key) {
    return super.mac(data, key, 256, 0x01, null);
  }
}

Keccak256.native = Keccak.native;
Keccak256.id = 'KECCAK256';
Keccak256.size = 32;
Keccak256.bits = 256;
Keccak256.blockSize = 136;
Keccak256.zero = Buffer.alloc(32, 0x00);
Keccak256.ctx = new Keccak256();

/*
 * Expose
 */

module.exports = Keccak256;

}).call(this,req("buffer").Buffer)
},{"./keccak":139,"buffer":303}],142:[function(req,module,exports){
(function (Buffer){
/*!
 * keccak384.js - Keccak-384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const Keccak = req('./keccak');

/**
 * Keccak384
 */

class Keccak384 extends Keccak {
  /**
   * Create a Keccak384 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(384);
  }

  final() {
    return super.final(0x01, null);
  }

  static hash() {
    return new Keccak384();
  }

  static hmac() {
    return super.hmac(384, 0x01, null);
  }

  static digest(data) {
    return super.digest(data, 384, 0x01, null);
  }

  static root(left, right) {
    return super.root(left, right, 384, 0x01, null);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 384, 0x01, null);
  }

  static mac(data, key) {
    return super.mac(data, key, 384, 0x01, null);
  }
}

Keccak384.native = Keccak.native;
Keccak384.id = 'KECCAK384';
Keccak384.size = 48;
Keccak384.bits = 384;
Keccak384.blockSize = 104;
Keccak384.zero = Buffer.alloc(48, 0x00);
Keccak384.ctx = new Keccak384();

/*
 * Expose
 */

module.exports = Keccak384;

}).call(this,req("buffer").Buffer)
},{"./keccak":139,"buffer":303}],143:[function(req,module,exports){
(function (Buffer){
/*!
 * keccak512.js - Keccak-512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const Keccak = req('./keccak');

/**
 * Keccak512
 */

class Keccak512 extends Keccak {
  /**
   * Create a Keccak512 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(512);
  }

  final() {
    return super.final(0x01, null);
  }

  static hash() {
    return new Keccak512();
  }

  static hmac() {
    return super.hmac(512, 0x01, null);
  }

  static digest(data) {
    return super.digest(data, 512, 0x01, null);
  }

  static root(left, right) {
    return super.root(left, right, 512, 0x01, null);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 512, 0x01, null);
  }

  static mac(data, key) {
    return super.mac(data, key, 512, 0x01, null);
  }
}

Keccak512.native = Keccak.native;
Keccak512.id = 'KECCAK512';
Keccak512.size = 32;
Keccak512.bits = 512;
Keccak512.blockSize = 72;
Keccak512.zero = Buffer.alloc(32, 0x00);
Keccak512.ctx = new Keccak512();

/*
 * Expose
 */

module.exports = Keccak512;

}).call(this,req("buffer").Buffer)
},{"./keccak":139,"buffer":303}],144:[function(req,module,exports){
(function (Buffer){
/*!
 * kmac.js - KMAC implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.inc
 *   https://github.com/XKCP/XKCP/blob/8f447eb/lib/high/Keccak/SP800-185/SP800-185.c
 *   https://github.com/XKCP/XKCP/blob/8f447eb/tests/UnitTests/testSP800-185.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */

'use strict';

const assert = req('bsert');
const CSHAKE = req('./cshake');
const HMAC = req('./internal/hmac');

/*
 * Constants
 */

const PREFIX = Buffer.from('KMAC', 'binary');
const EMPTY = Buffer.alloc(0);

/*
 * KMAC
 */

class KMAC extends CSHAKE {
  constructor() {
    super();
  }

  init(bits, key, pers) {
    if (key == null)
      key = EMPTY;

    assert(Buffer.isBuffer(key));

    super.init(bits, PREFIX, pers);
    super.bytePad([key], this.rate / 8);

    return this;
  }

  final(len) {
    if (len == null) {
      const size = this.rate / 8;
      len = 100 - size / 2;
    }

    super.rightEncode(len * 8);

    return super.final(len);
  }

  static hash() {
    return new KMAC();
  }

  static hmac(bits = 256, key, pers, len) {
    assert((bits >>> 0) === bits);
    assert(bits === 128 || bits === 256);
    const bs = (1600 - bits * 2) / 8;
    return new HMAC(KMAC, bs, [bits, key, pers], [len]);
  }

  static digest(data, bits = 256, key, pers, len) {
    return KMAC.ctx.init(bits, key, pers).update(data).final(len);
  }

  static root(left, right, bits = 256, key, pers, len) {
    if (len == null)
      len = 0;

    if (len === 0) {
      assert((bits >>> 0) === bits);
      len = bits >>> 3;
    }

    assert((len >>> 0) === len);
    assert(Buffer.isBuffer(left) && left.length === len);
    assert(Buffer.isBuffer(right) && right.length === len);

    const ctx = KMAC.ctx;

    ctx.init(bits, key, pers);
    ctx.update(left);
    ctx.update(right);

    return ctx.final(len);
  }

  static multi(x, y, z, bits = 256, key, pers, len) {
    const ctx = KMAC.ctx;
    ctx.init(bits, key, pers);
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final(len);
  }

  static mac(data, salt, bits = 256, key, pers, len) {
    return KMAC.hmac(bits, key, pers, len).init(salt).update(data).final();
  }
}

/*
 * Static
 */

KMAC.native = CSHAKE.native;
KMAC.id = 'KMAC256';
KMAC.size = 32;
KMAC.bits = 256;
KMAC.blockSize = 136;
KMAC.zero = Buffer.alloc(32, 0x00);
KMAC.ctx = new KMAC();

/*
 * Expose
 */

module.exports = KMAC;

}).call(this,req("buffer").Buffer)
},{"./cshake":36,"./internal/hmac":76,"bsert":190,"buffer":303}],145:[function(req,module,exports){
(function (Buffer){
/*!
 * kmac128.js - KMAC128 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const KMAC = req('./kmac');

/**
 * KMAC128
 */

class KMAC128 extends KMAC {
  /**
   * Create a KMAC128 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key, pers) {
    return super.init(128, key, pers);
  }

  static hash() {
    return new KMAC128();
  }

  static hmac(key, pers, len) {
    return super.hmac(128, key, pers, len);
  }

  static digest(data, key, pers, len) {
    return super.digest(data, 128, key, pers, len);
  }

  static root(left, right, key, pers, len) {
    return super.root(left, right, 128, key, pers, len);
  }

  static multi(x, y, z, key, pers, len) {
    return super.multi(x, y, z, 128, key, pers, len);
  }

  static mac(data, salt, key, pers, len) {
    return super.mac(data, salt, 128, key, pers, len);
  }
}

KMAC128.native = KMAC.native;
KMAC128.id = 'KMAC128';
KMAC128.size = 16;
KMAC128.bits = 128;
KMAC128.blockSize = 168;
KMAC128.zero = Buffer.alloc(16, 0x00);
KMAC128.ctx = new KMAC128();

/*
 * Expose
 */

module.exports = KMAC128;

}).call(this,req("buffer").Buffer)
},{"./kmac":144,"buffer":303}],146:[function(req,module,exports){
(function (Buffer){
/*!
 * kmac256.js - KMAC256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const KMAC = req('./kmac');

/**
 * KMAC256
 */

class KMAC256 extends KMAC {
  /**
   * Create a KMAC256 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  init(key, pers) {
    return super.init(256, key, pers);
  }

  static hash() {
    return new KMAC256();
  }

  static hmac(key, pers, len) {
    return super.hmac(256, key, pers, len);
  }

  static digest(data, key, pers, len) {
    return super.digest(data, 256, key, pers, len);
  }

  static root(left, right, key, pers, len) {
    return super.root(left, right, 256, key, pers, len);
  }

  static multi(x, y, z, key, pers, len) {
    return super.multi(x, y, z, 256, key, pers, len);
  }

  static mac(data, salt, key, pers, len) {
    return super.mac(data, salt, 256, key, pers, len);
  }
}

KMAC256.native = KMAC.native;
KMAC256.id = 'KMAC256';
KMAC256.size = 32;
KMAC256.bits = 256;
KMAC256.blockSize = 136;
KMAC256.zero = Buffer.alloc(32, 0x00);
KMAC256.ctx = new KMAC256();

/*
 * Expose
 */

module.exports = KMAC256;

}).call(this,req("buffer").Buffer)
},{"./kmac":144,"buffer":303}],147:[function(req,module,exports){
(function (Buffer){
/*!
 * md2.js - MD2 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD2_(hash_function)
 *   https://tools.ietf.org/html/rfc1319
 *   https://github.com/RustCrypto/hashes/blob/master/md2/src/lib.rs
 */

'use strict';

const assert = req('bsert');
const HMAC = req('./internal/hmac');

/*
 * Constants
 */

const FINALIZED = -1;

const S = new Uint8Array([
  41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19, 98, 167,
  5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202, 30, 155,
  87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18, 190, 78, 196,
  214, 218, 158, 222, 73, 160, 251, 245, 142, 187, 47, 238, 122, 169, 104, 121,
  145, 21, 178, 7, 63, 148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154,
  90, 144, 50, 39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72,
  165, 181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210, 150,
  164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157, 112, 89, 100,
  113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27, 96, 37, 173, 174, 176,
  185, 246, 28, 70, 97, 105, 52, 64, 126, 15, 85, 71, 163, 35, 221, 81, 175,
  58, 195, 92, 249, 206, 186, 197, 234, 38, 44, 83, 13, 110, 133, 40, 132, 9,
  211, 223, 205, 244, 65, 129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250,
  36, 225, 123, 8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109,
  233, 203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228, 166,
  119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237, 31, 26, 219, 153,
  141, 51, 159, 17, 131, 20
]);

/**
 * MD2
 */

class MD2 {
  /**
   * Create a MD2 context.
   * @constructor
   */

  constructor() {
    this.state = Buffer.allocUnsafe(48);
    this.checksum = Buffer.allocUnsafe(16);
    this.block = Buffer.allocUnsafe(16);
    this.size = FINALIZED;
  }

  /**
   * Initialize MD2 context.
   */

  init() {
    this.state.fill(0x00);
    this.checksum.fill(0x00);
    this.size = 0;
    return this;
  }

  /**
   * Update MD2 context.
   * @param {Buffer} data
   */

  update(data) {
    assert(Buffer.isBuffer(data));
    this._update(data, data.length);
    return this;
  }

  /**
   * Finalize MD2 context.
   * @returns {Buffer}
   */

  final() {
    return this._final(Buffer.allocUnsafe(16));
  }

  /**
   * Update MD2 context.
   * @private
   * @param {Buffer} data
   * @param {Number} len
   */

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    let pos = this.size & 15;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 16 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 16)
        return;

      this.transform(this.block, 0);
    }

    while (len >= 16) {
      this.transform(data, off);
      off += 16;
      len -= 16;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize MD2 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context already finalized.');

    const pos = this.size & 15;
    const left = 16 - pos;
    const pad = Buffer.allocUnsafe(left);

    for (let i = 0; i < pad.length; i++)
      pad[i] = left;

    this._update(pad, left);
    this._update(this.checksum, 16);

    this.state.copy(out, 0, 0, 16);

    this.state.fill(0x00);
    this.checksum.fill(0x00);
    this.block.fill(0x00);

    this.size = FINALIZED;

    return out;
  }

  /**
   * Transform MD2 block.
   * @param {Buffer} chunk
   * @param {Number} pos
   */

  transform(chunk, pos) {
    for (let j = 0; j < 16; j++) {
      this.state[16 + j] = chunk[pos + j];
      this.state[32 + j] = this.state[16 + j] ^ this.state[j];
    }

    let t = 0;

    for (let j = 0; j < 18; j++) {
      for (let k = 0; k < 48; k++) {
        this.state[k] ^= S[t];
        t = this.state[k];
      }
      t = (t + j) & 0xff;
    }

    let l = this.checksum[15];

    for (let j = 0; j < 16; j++) {
      this.checksum[j] ^= S[chunk[pos + j] ^ l];
      l = this.checksum[j];
    }
  }

  static hash() {
    return new MD2();
  }

  static hmac() {
    return new HMAC(MD2, 16);
  }

  static digest(data) {
    return MD2.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 16);
    assert(Buffer.isBuffer(right) && right.length === 16);
    return MD2.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = MD2.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return MD2.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

MD2.native = 0;
MD2.id = 'MD2';
MD2.size = 16;
MD2.bits = 128;
MD2.blockSize = 16;
MD2.zero = Buffer.alloc(16, 0x00);
MD2.ctx = new MD2();

/*
 * Expose
 */

module.exports = MD2;

}).call(this,req("buffer").Buffer)
},{"./internal/hmac":76,"bsert":190,"buffer":303}],148:[function(req,module,exports){
/*!
 * md4.js - md4 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/md4');

},{"./js/md4":112}],149:[function(req,module,exports){
/*!
 * md5.js - MD5 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/md5');

},{"./js/md5":113}],150:[function(req,module,exports){
(function (Buffer){
/*!
 * md5sha1.js - MD5-SHA1 implementation for bcoin
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');
const MD5 = req('./md5');
const SHA1 = req('./sha1');
const HMAC = req('./internal/hmac');

/**
 * MD5SHA1
 */

class MD5SHA1 {
  constructor() {
    this.md5 = new MD5();
    this.sha1 = new SHA1();
  }

  init() {
    this.md5.init();
    this.sha1.init();
    return this;
  }

  update(data) {
    this.md5.update(data);
    this.sha1.update(data);
    return this;
  }

  final() {
    const md = Buffer.allocUnsafe(36);

    this.md5.final().copy(md, 0);
    this.sha1.final().copy(md, 16);

    return md;
  }

  static hash() {
    return new MD5SHA1();
  }

  static hmac() {
    return new HMAC(MD5SHA1, 64);
  }

  static digest(data) {
    return MD5SHA1.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert(Buffer.isBuffer(left) && left.length === 36);
    assert(Buffer.isBuffer(right) && right.length === 36);
    return MD5SHA1.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const ctx = MD5SHA1.ctx;
    ctx.init();
    ctx.update(x);
    ctx.update(y);
    if (z)
      ctx.update(z);
    return ctx.final();
  }

  static mac(data, key) {
    return MD5SHA1.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

MD5SHA1.native = MD5.native;
MD5SHA1.id = 'MD5SHA1';
MD5SHA1.size = 36;
MD5SHA1.bits = 288;
MD5SHA1.blockSize = 64;
MD5SHA1.zero = Buffer.alloc(36, 0x00);
MD5SHA1.ctx = new MD5SHA1();

/*
 * Expose
 */

module.exports = MD5SHA1;

}).call(this,req("buffer").Buffer)
},{"./internal/hmac":76,"./md5":149,"./sha1":172,"bsert":190,"buffer":303}],151:[function(req,module,exports){
(function (Buffer){
/*!
 * merkle.js - merkle trees for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 */

'use strict';

const assert = req('bsert');

// Notes about unbalanced merkle trees:
//
// Bitcoin hashes odd nodes with themselves,
// allowing an attacker to add a duplicate
// TXID, creating an even number of leaves
// and computing the same root (CVE-2012-2459).
// In contrast, RFC 6962 simply propagates
// odd nodes up.
//
// RFC 6962:
//
//              R
//             / \
//            /   \
//           /     \
//          /       \
//         /         \
//        k           j <-- same as below
//       / \          |
//      /   \         |
//     /     \        |
//    h       i       j
//   / \     / \     / \
//  a   b   c   d   e   f
//
// Bitcoin Behavior:
//
//              R
//             / \
//            /   \
//           /     \
//          /       \
//         /         \
//        k           l <-- HASH(j || j)
//       / \          |
//      /   \         |
//     /     \        |
//    h       i       j
//   / \     / \     / \
//  a   b   c   d   e   f
//
// This creates a situation where these leaves:
//
//        R
//       / \
//      /   \
//     /     \
//    d       e <-- HASH(c || c)
//   / \     / \
//  a   b   c   c
//
// Compute the same root as:
//
//       R
//      / \
//     /   \
//    d     e <-- HASH(c || c)
//   / \    |
//  a   b   c
//
// Why does this matter? Duplicate TXIDs are
// invalid right? They're spending the same
// inputs! The problem arises in certain
// implementation optimizations which may
// mark a block hash invalid. In other words,
// an invalid block shares the same block
// hash as a valid one!
//
// See:
//   https://tools.ietf.org/html/rfc6962#section-2.1
//   https://nvd.nist.gov/vuln/detail/CVE-2012-2459
//   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459
//   https://bitcointalk.org/?topic=81749

/**
 * Build a merkle tree from leaves.
 * Note that this will mutate the `leaves` array!
 * @param {Object} alg
 * @param {Buffer[]} leaves
 * @returns {Array} [nodes, malleated]
 */

function createTree(alg, leaves) {
  assert(alg && typeof alg.root === 'function');
  assert(Array.isArray(leaves));

  const nodes = leaves;

  let size = leaves.length;
  let malleated = false;
  let i = 0;

  if (size === 0) {
    nodes.push(alg.zero);
    return [nodes, malleated];
  }

  while (size > 1) {
    for (let j = 0; j < size; j += 2) {
      const k = Math.min(j + 1, size - 1);
      const left = nodes[i + j];
      const right = nodes[i + k];

      if (k === j + 1 && k + 1 === size
          && left.equals(right)) {
        malleated = true;
      }

      const hash = alg.root(left, right);

      nodes.push(hash);
    }

    i += size;

    size = (size + 1) >>> 1;
  }

  return [nodes, malleated];
}

/**
 * Calculate merkle root from leaves.
 * @param {Object} alg
 * @param {Buffer[]} leaves
 * @returns {Array} [root, malleated]
 */

function createRoot(alg, leaves) {
  assert(alg && typeof alg.root === 'function');
  assert(Array.isArray(leaves));

  const [nodes, malleated] = createTree(alg, leaves);
  const root = nodes[nodes.length - 1];

  return [root, malleated];
}

/**
 * Collect a merkle branch from vector index.
 * @param {Object} alg
 * @param {Number} index
 * @param {Buffer[]} leaves
 * @returns {Buffer[]} branch
 */

function createBranch(alg, index, leaves) {
  assert(alg && typeof alg.root === 'function');
  assert((index >>> 0) === index);
  assert(Array.isArray(leaves));
  assert(index < leaves.length);

  let size = leaves.length;

  const [nodes] = createTree(alg, leaves);
  const branch = [];

  let i = 0;

  while (size > 1) {
    const j = Math.min(index ^ 1, size - 1);

    branch.push(nodes[i + j]);

    index >>>= 1;

    i += size;

    size = (size + 1) >>> 1;
  }

  return branch;
}

/**
 * Derive merkle root from branch.
 * @param {Object} alg
 * @param {Buffer} hash
 * @param {Buffer[]} branch
 * @param {Number} index
 * @returns {Buffer} root
 */

function deriveRoot(alg, hash, branch, index) {
  assert(alg && typeof alg.root === 'function');
  assert(Buffer.isBuffer(hash));
  assert(Array.isArray(branch));
  assert((index >>> 0) === index);

  let root = hash;

  for (const hash of branch) {
    if (index & 1)
      root = alg.root(hash, root);
    else
      root = alg.root(root, hash);

    index >>>= 1;
  }

  return root;
}

/*
 * Expose
 */

exports.createTree = createTree;
exports.createRoot = createRoot;
exports.createBranch = createBranch;
exports.deriveRoot = deriveRoot;

}).call(this,{"isBuffer":req("../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],152:[function(req,module,exports){
(function (Buffer){
/*!
 * mrkl.js - merkle trees for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const INTERNAL = Buffer.from([0x01]);
const LEAF = Buffer.from([0x00]);

/**
 * Build a merkle tree from leaves.
 * @param {Object} alg
 * @param {Buffer[]} leaves
 * @returns {Buffer[]} nodes
 */

function createTree(alg, leaves) {
  assert(alg && typeof alg.multi === 'function');
  assert(Array.isArray(leaves));

  const nodes = [];
  const sentinel = hashEmpty(alg);

  for (const data of leaves) {
    const leaf = hashLeaf(alg, data);
    nodes.push(leaf);
  }

  let size = nodes.length;
  let i = 0;

  if (size === 0) {
    nodes.push(sentinel);
    return nodes;
  }

  while (size > 1) {
    for (let j = 0; j < size; j += 2) {
      const l = j;
      const r = j + 1;
      const left = nodes[i + l];

      let right;

      if (r < size)
        right = nodes[i + r];
      else
        right = sentinel;

      const hash = hashInternal(alg, left, right);
      nodes.push(hash);
    }

    i += size;

    size = (size + 1) >>> 1;
  }

  return nodes;
}

/**
 * Calculate merkle root from leaves.
 * @param {Object} alg
 * @param {Buffer[]} leaves
 * @returns {Buffer} root
 */

function createRoot(alg, leaves) {
  const nodes = createTree(alg, leaves);
  const root = nodes[nodes.length - 1];
  return root;
}

/**
 * Collect a merkle branch from vector index.
 * @param {Object} alg
 * @param {Number} index
 * @param {Buffer[]} leaves
 * @returns {Buffer[]} branch
 */

function createBranch(alg, index, leaves) {
  assert((index >>> 0) === index);

  const nodes = createTree(alg, leaves);
  const sentinel = hashEmpty(alg);
  const branch = [];

  let size = leaves.length;
  let i = 0;

  assert(index < leaves.length);

  while (size > 1) {
    const j = index ^ 1;

    if (j < size)
      branch.push(nodes[i + j]);
    else
      branch.push(sentinel);

    index >>>= 1;

    i += size;

    size = (size + 1) >>> 1;
  }

  return branch;
}

/**
 * Derive merkle root from branch.
 * @param {Object} alg
 * @param {Buffer} leaf
 * @param {Buffer[]} branch
 * @param {Number} index
 * @returns {Buffer} root
 */

function deriveRoot(alg, leaf, branch, index) {
  assert(alg && typeof alg.multi === 'function');
  assert(Buffer.isBuffer(leaf));
  assert(Array.isArray(branch));
  assert((index >>> 0) === index);

  let root = hashLeaf(alg, leaf);

  for (const hash of branch) {
    if (index & 1)
      root = hashInternal(alg, hash, root);
    else
      root = hashInternal(alg, root, hash);

    index >>>= 1;
  }

  return root;
}

/**
 * Get sentinel hash.
 * @param {Object} alg
 * @returns {Buffer}
 */

function hashEmpty(alg) {
  return alg.digest(EMPTY);
}

/**
 * Hash a leaf node.
 * @param {Object} alg
 * @param {Buffer} data
 * @returns {Buffer}
 */

function hashLeaf(alg, data) {
  return alg.multi(LEAF, data);
}

/**
 * Hash an internal node.
 * @param {Object} alg
 * @param {Buffer} left
 * @param {Buffer} right
 * @returns {Buffer}
 */

function hashInternal(alg, left, right) {
  assert(right != null);
  return alg.multi(INTERNAL, left, right);
}

/*
 * Expose
 */

exports.createTree = createTree;
exports.createRoot = createRoot;
exports.createBranch = createBranch;
exports.deriveRoot = deriveRoot;
exports.hashEmpty = hashEmpty;
exports.hashLeaf = hashLeaf;
exports.hashInternal = hashInternal;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],153:[function(req,module,exports){
/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/murmur3');

},{"./js/murmur3":114}],154:[function(req,module,exports){
/*!
 * p192.js - p192 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/p192');

},{"./js/p192":115}],155:[function(req,module,exports){
/*!
 * p224.js - p224 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/p224');

},{"./js/p224":116}],156:[function(req,module,exports){
/*!
 * p256.js - p256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/p256');

},{"./js/p256":117}],157:[function(req,module,exports){
/*!
 * p384.js - p384 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/p384');

},{"./js/p384":118}],158:[function(req,module,exports){
/*!
 * p521.js - p521 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/p521');

},{"./js/p521":119}],159:[function(req,module,exports){
/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/pbkdf2');

},{"./js/pbkdf2":120}],160:[function(req,module,exports){
(function (Buffer){
/*!
 * pgp.js - PGP for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/crypto:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/crypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP
 *   https://tools.ietf.org/html/rfc4880
 *   https://github.com/golang/crypto/tree/master/openpgp
 *   https://github.com/gpg/gnupg/blob/master/common/openpgpdefs.h
 *   https://github.com/gpg/gnupg/blob/master/g10/parse-packet.c
 */

'use strict';

const assert = req('bsert');
const bio = req('bufio');
const {PEMBlock} = req('./encoding/pem');
const {countLeft} = req('./encoding/util');
const cipher = req('./cipher');
const MD5 = req('./md5');
const SHA1 = req('./sha1');
const RIPEMD160 = req('./ripemd160');
const SHA224 = req('./sha224');
const SHA256 = req('./sha256');
const SHA384 = req('./sha384');
const SHA512 = req('./sha512');

/*
 * Constants
 */

const packetTypes = {
  NONE: 0,
  PUBKEY_ENC: 1,
  SIGNATURE: 2,
  SYMKEY_ENC: 3,
  ONEPASS_SIG: 4,
  PRIVATE_KEY: 5,
  PUBLIC_KEY: 6,
  PRIVATE_SUBKEY: 7,
  COMPRESSED: 8,
  ENCRYPTED: 9,
  MARKER: 10,
  PLAINTEXT: 11,
  RING_TRUST: 12,
  USER_ID: 13,
  PUBLIC_SUBKEY: 14,
  OLD_COMMENT: 16,
  ATTRIBUTE: 17,
  ENCRYPTED_MDC: 18,
  MDC: 19,
  ENCRYPTED_AEAD: 20
};

const packetTypesByVal = {
  0: 'NONE',
  1: 'PUBKEY_ENC',
  2: 'SIGNATURE',
  3: 'SYMKEY_ENC',
  4: 'ONEPASS_SIG',
  5: 'PRIVATE_KEY',
  6: 'PUBLIC_KEY',
  7: 'PRIVATE_SUBKEY',
  8: 'COMPRESSED',
  9: 'ENCRYPTED',
  10: 'MARKER',
  11: 'PLAINTEXT',
  12: 'RING_TRUST',
  13: 'USER_ID',
  14: 'PUBLIC_SUBKEY',
  16: 'OLD_COMMENT',
  17: 'ATTRIBUTE',
  18: 'ENCRYPTED_MDC',
  19: 'MDC',
  20: 'ENCRYPTED_AEAD'
};

const sigTypes = {
  BINARY: 0x00,
  TEXT: 0x01,
  GENERIC_CERT: 0x10,
  PERSONA_CERT: 0x11,
  CASUAL_CERT: 0x12,
  POSITIVE_CERT: 0x13,
  SUBKEY_BINDING: 0x18,
  PRIMARY_KEY_BINDING: 0x19,
  DIRECT_SIGNATURE: 0x1f,
  KEY_REVOCATION: 0x20,
  SUBKEY_REVOCATION: 0x28
};

const sigTypesByVal = {
  0x00: 'BINARY',
  0x01: 'TEXT',
  0x10: 'GENERIC_CERT',
  0x11: 'PERSONA_CERT',
  0x12: 'CASUAL_CERT',
  0x13: 'POSITIVE_CERT',
  0x18: 'SUBKEY_BINDING',
  0x19: 'PRIMARY_KEY_BINDING',
  0x1f: 'DIRECT_SIGNATURE',
  0x20: 'KEY_REVOCATION',
  0x28: 'SUBKEY_REVOCATION'
};

const keyTypes = {
  RSA: 1,
  RSA_ENCRYPT_ONLY: 2,
  RSA_SIGN_ONLY: 3,
  ELGAMAL: 16,
  DSA: 17,
  ECDH: 18,
  ECDSA: 19,
  ELGAMAL_LEGACY: 20,
  EDDSA: 22
};

const keyTypesByVal = {
  1: 'RSA',
  2: 'RSA_ENCRYPT_ONLY',
  3: 'RSA_SIGN_ONLY',
  16: 'ELGAMAL',
  17: 'DSA',
  18: 'ECDH',
  19: 'ECDSA',
  20: 'ELGAMAL_LEGACY',
  22: 'EDDSA'
};

const cipherTypes = {
  NONE: 0,
  IDEA: 1,
  DES3: 2,
  CAST5: 3,
  BLOWFISH: 4,
  AES128: 7,
  AES192: 8,
  AES256: 9,
  TWOFISH: 10,
  CAMELLIA128: 11,
  CAMELLIA192: 12,
  CAMELLIA256: 13
};

const cipherTypesByVal = {
  0: 'NONE',
  1: 'IDEA',
  2: 'DES3',
  3: 'CAST5',
  4: 'BLOWFISH',
  7: 'AES128',
  8: 'AES192',
  9: 'AES256',
  10: 'TWOFISH',
  11: 'CAMELLIA128',
  12: 'CAMELLIA192',
  13: 'CAMELLIA256'
};

const hashTypes = {
  MD5: 1,
  SHA1: 2,
  RIPEMD160: 3,
  SHA256: 8,
  SHA384: 9,
  SHA512: 10,
  SHA224: 11
};

const hashTypesByVal = {
  1: 'MD5',
  2: 'SHA1',
  3: 'RIPEMD160',
  8: 'SHA256',
  9: 'SHA384',
  10: 'SHA512',
  11: 'SHA224'
};

const hashToHash = {
  1: MD5,
  2: SHA1,
  3: RIPEMD160,
  8: SHA256,
  9: SHA384,
  10: SHA512,
  11: SHA224
};

const compressTypes = {
  NONE: 0,
  ZIP: 1,
  ZLIB: 2,
  BZIP2: 3
};

const compressTypesByVal = {
  0: 'NONE',
  1: 'ZIP',
  2: 'ZLIB',
  3: 'BZIP2'
};

const curveTypes = {
  NONE: 0,
  P256: 1,
  P384: 2,
  P521: 3,
  SECP256K1: 4,
  X25519: 5,
  BRAINPOOLP256: 6,
  BRAINPOOLP384: 7,
  BRAINPOOLP521: 8,
  ED25519: 9
};

const curveTypesByVal = {
  0: 'NONE',
  1: 'P256',
  2: 'P384',
  3: 'P521',
  4: 'SECP256K1',
  5: 'X25519',
  6: 'BRAINPOOLP256',
  7: 'BRAINPOOLP384',
  8: 'BRAINPOOLP521',
  9: 'ED25519'
};

const oids = {
  P256: Buffer.from('2a8648ce3d030107', 'hex'),
  P384: Buffer.from('2b81040022', 'hex'),
  P521: Buffer.from('2b81040023', 'hex'),
  SECP256K1: Buffer.from('2b8104000a', 'hex'),
  X25519: Buffer.from('2b060104019755010501', 'hex'),
  BRAINPOOLP256: Buffer.from('2b2403030208010107', 'hex'),
  BRAINPOOLP384: Buffer.from('2b240303020801010b', 'hex'),
  BRAINPOOLP521: Buffer.from('2b240303020801010d', 'hex'),
  ED25519: Buffer.from('2b06010401da470f01', 'hex')
};

const EMPTY = Buffer.alloc(0);
const ZERO = Buffer.alloc(1);

/**
 * PGP Message
 */

class PGPMessage extends bio.Struct {
  constructor() {
    super();
    this.packets = [];
  }

  getSize() {
    let size = 0;

    for (const pkt of this.packets)
      size += pkt.getSize();

    return size;
  }

  write(bw) {
    for (const pkt of this.packets)
      pkt.write(bw);

    return bw;
  }

  read(br) {
    while (br.left()) {
      const pkt = PGPPacket.read(br);
      this.packets.push(pkt);
    }

    return this;
  }

  toString(type = 'PGP MESSAGE') {
    assert(typeof type === 'string');

    const block = new PEMBlock();

    block.type = type;
    block.data = this.encode();

    return block.toString(true);
  }

  fromString(str) {
    const block = PEMBlock.fromString(str, true);

    if (block.type.substring(0, 4) !== 'PGP ')
      throw new Error('PEM type mismatch.');

    return this.decode(block.data);
  }

  format() {
    return {
      packets: this.packets
    };
  }
}

/**
 * PGP Packet
 */

class PGPPacket extends bio.Struct {
  constructor() {
    super();
    this.type = 0;
    this.body = new PGPUnknown();
  }

  getSize() {
    const len = this.body.getSize();

    let size = 0;

    size += 1;

    if (len < 192) {
      size += 1;
    } else if (len < 8384) {
      size += 2;
    } else {
      size += 5;
    }

    size += len;

    return size;
  }

  write(bw) {
    let len = this.body.getSize();

    bw.writeU8(0x80 | 0x40 | this.type);

    if (len < 192) {
      bw.writeU8(len);
    } else if (len < 8384) {
      len -= 192;
      bw.writeU8(192 + (len >>> 8));
      bw.writeU8(len & 0xff);
    } else {
      bw.writeU8(255);
      bw.writeU32BE(len);
    }

    this.body.write(bw);

    return bw;
  }

  read(br) {
    const ch = br.readU8();

    if ((ch & 0x80) === 0)
      throw new Error('Hi bit unset in PGP packet header.');

    let type = 0;
    let child = null;

    if ((ch & 0x40) === 0) {
      const t = (ch & 0x3f) >>> 2;
      const s = 1 << (ch & 3);

      let size = 0;

      switch (s) {
        case 1:
          size = br.readU8();
          break;
        case 2:
          size = br.readU16BE();
          break;
        case 4:
          size = br.readU32BE();
          break;
        case 8:
          size = br.left();
          break;
      }

      type = t;
      child = br.readChild(size);
    } else {
      const t = ch & 0x3f;
      const s = br.readU8();

      let size = 0;

      if (s < 192) {
        size = s;
      } else if (s < 224) {
        size = (s - 192) * 0x100;
        size += br.readU8() + 192;
      } else if (s < 255) {
        throw new Error('Cannot handle PGP partial length.');
      } else {
        size = br.readU32BE();
      }

      type = t;
      child = br.readChild(size);
    }

    this.type = type;

    switch (this.type) {
      case packetTypes.PUBKEY_ENC:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.SIGNATURE:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.SYMKEY_ENC:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.ONEPASS_SIG:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.PRIVATE_KEY:
        this.body = PGPPrivateKey.read(child);
        break;
      case packetTypes.PUBLIC_KEY:
        this.body = PGPPublicKey.read(child);
        break;
      case packetTypes.PRIVATE_SUBKEY:
        this.body = PGPPrivateKey.read(child);
        break;
      case packetTypes.COMPRESSED:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.ENCRYPTED:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.MARKER:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.PLAINTEXT:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.RING_TRUST:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.USER_ID:
        this.body = PGPUserID.read(child);
        break;
      case packetTypes.PUBLIC_SUBKEY:
        this.body = PGPPublicKey.read(child);
        break;
      case packetTypes.OLD_COMMENT:
        this.body = PGPPublicKey.read(child);
        break;
      case packetTypes.ATTRIBUTE:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.ENCRYPTED_MDC:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.MDC:
        this.body = PGPUnknown.read(child);
        break;
      case packetTypes.ENCRYPTED_AEAD:
        this.body = PGPUnknown.read(child);
        break;
      default:
        this.body = PGPUnknown.read(child);
        break;
    }

    return this;
  }

  format() {
    return {
      type: packetTypesByVal[this.type] || 'UNKNOWN',
      body: this.body
    };
  }
}

/**
 * PGP Body
 */

class PGPBody extends bio.Struct {
  constructor() {
    super();
  }
}

/**
 * PGP Unknown
 */

class PGPUnknown extends PGPBody {
  constructor() {
    super();
    this.data = EMPTY;
  }

  getSize() {
    return this.data.length;
  }

  write(bw) {
    bw.writeBytes(this.data);
    return bw;
  }

  read(br) {
    this.data = br.readBytes(br.left());
    return this;
  }

  format() {
    return {
      data: this.data.toString('hex')
    };
  }
}

/**
 * PGP Public Key
 */

class PGPPublicKey extends PGPBody {
  constructor() {
    super();

    this.version = 4;
    this.algorithm = 0;
    this.expires = 0;
    this.timestamp = 0;

    // RSA
    this.n = new MPI();
    this.e = new MPI();

    // El Gamal
    this.p = new MPI();
    this.g = new MPI();
    this.y = new MPI();

    // DSA
    // this.p = new MPI();
    this.q = new MPI();
    // this.g = new MPI();
    // this.y = new MPI();

    // ECDH
    this.oid = EMPTY;
    this.point = new MPI();
    this.kdfHash = 0;
    this.kdfAlg = 0;

    // ECDSA
    // this.oid = EMPTY;
    // this.point = new MPI();

    // Unknown
    this.data = EMPTY;
  }

  get curve() {
    if (this.oid.equals(oids.P256))
      return curveTypes.P256;

    if (this.oid.equals(oids.P384))
      return curveTypes.P384;

    if (this.oid.equals(oids.P521))
      return curveTypes.P521;

    if (this.oid.equals(oids.SECP256K1))
      return curveTypes.SECP256K1;

    if (this.oid.equals(oids.X25519))
      return curveTypes.X25519;

    if (this.oid.equals(oids.BRAINPOOLP256))
      return curveTypes.BRAINPOOLP256;

    if (this.oid.equals(oids.BRAINPOOLP384))
      return curveTypes.BRAINPOOLP384;

    if (this.oid.equals(oids.BRAINPOOLP521))
      return curveTypes.BRAINPOOLP521;

    if (this.oid.equals(oids.ED25519))
      return curveTypes.ED25519;

    return 0;
  }

  set curve(value) {
    switch (value) {
      case curveTypes.P256:
        this.oid = oids.P256;
        break;
      case curveTypes.P384:
        this.oid = oids.P384;
        break;
      case curveTypes.P521:
        this.oid = oids.P521;
        break;
      case curveTypes.SECP256K1:
        this.oid = oids.SECP256K1;
        break;
      case curveTypes.X25519:
        this.oid = oids.X25519;
        break;
      case curveTypes.BRAINPOOLP256:
        this.oid = oids.BRAINPOOLP256;
        break;
      case curveTypes.BRAINPOOLP384:
        this.oid = oids.BRAINPOOLP384;
        break;
      case curveTypes.BRAINPOOLP521:
        this.oid = oids.BRAINPOOLP521;
        break;
      case curveTypes.ED25519:
        this.oid = oids.ED25519;
        break;
    }
  }

  isRSA() {
    switch (this.algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY:
        return true;
    }
    return false;
  }

  isElgamal() {
    switch (this.algorithm) {
      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY:
        return true;
    }
    return false;
  }

  getSize() {
    let size = 0;

    size += 1;

    switch (this.version) {
      case 2:
      case 3: {
        size += 4;
        size += 2;
        size += 1;
        break;
      }

      case 4: {
        size += 4;
        size += 1;
        break;
      }

      default: {
        throw new Error('Unknown PGP key version.');
      }
    }

    switch (this.algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        size += this.n.getSize();
        size += this.e.getSize();
        break;
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        size += this.p.getSize();
        size += this.g.getSize();
        size += this.y.getSize();
        break;
      }

      case keyTypes.DSA: {
        size += this.p.getSize();
        size += this.q.getSize();
        size += this.g.getSize();
        size += this.y.getSize();
        break;
      }

      case keyTypes.ECDH: {
        size += 1;
        size += this.oid.length;
        size += this.point.getSize();
        size += 4;
        break;
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        size += 1;
        size += this.oid.length;
        size += this.point.getSize();
        break;
      }

      default: {
        size += this.data.length;
        break;
      }
    }

    return size;
  }

  write(bw) {
    bw.writeU8(this.version);

    switch (this.version) {
      case 2:
      case 3: {
        if (!this.isRSA())
          throw new Error('Unknown PGP key algorithm.');

        bw.writeU32BE(this.timestamp);
        bw.writeU16BE(this.expires);
        bw.writeU8(this.algorithm);

        break;
      }

      case 4: {
        bw.writeU32BE(this.timestamp);
        bw.writeU8(this.algorithm);
        break;
      }

      default: {
        throw new Error('Unknown PGP key version.');
      }
    }

    switch (this.algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        this.n.write(bw);
        this.e.write(bw);
        break;
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        this.p.write(bw);
        this.g.write(bw);
        this.y.write(bw);
        break;
      }

      case keyTypes.DSA: {
        this.p.write(bw);
        this.q.write(bw);
        this.g.write(bw);
        this.y.write(bw);
        break;
      }

      case keyTypes.ECDH: {
        bw.writeU8(this.oid.length);
        bw.writeBytes(this.oid);
        this.point.write(bw);
        bw.writeU8(3);
        bw.writeU8(0x01);
        bw.writeU8(this.kdfHash);
        bw.writeU8(this.kdfAlg);
        break;
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        bw.writeU8(this.oid.length);
        bw.writeBytes(this.oid);
        this.point.write(bw);
        break;
      }

      default: {
        bw.writeBytes(this.data);
        break;
      }
    }

    return bw;
  }

  read(br) {
    this.version = br.readU8();

    switch (this.version) {
      case 2:
      case 3: {
        this.timestamp = br.readU32BE();
        this.expires = br.readU16BE();
        this.algorithm = br.readU8();

        if (!this.isRSA()) {
          if (this.version === 3 && this.isElgamal()) {
            this.expires = 0;
            this.version = 4;
          } else {
            throw new Error('Unknown PGP key algorithm.');
          }
        }

        break;
      }

      case 4: {
        this.timestamp = br.readU32BE();
        this.algorithm = br.readU8();
        break;
      }

      default: {
        throw new Error('Unknown PGP key version.');
      }
    }

    switch (this.algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        this.n.read(br);
        this.e.read(br);
        break;
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        this.p.read(br);
        this.g.read(br);
        this.y.read(br);
        break;
      }

      case keyTypes.DSA: {
        this.p.read(br);
        this.q.read(br);
        this.g.read(br);
        this.y.read(br);
        break;
      }

      case keyTypes.ECDH: {
        this.oid = br.readBytes(br.readU8());
        this.point.read(br);

        const size = br.readU8();

        if (size < 3 || size > br.left())
          throw new Error('Invalid ECDH params.');

        // Reserved.
        if (br.readU8() !== 0x01)
          throw new Error('Invalid ECDH reserved byte.');

        this.kdfHash = br.readU8();
        this.kdfAlg = br.readU8();

        break;
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        this.oid = br.readBytes(br.readU8());
        this.point.read(br);
        break;
      }

      default: {
        this.data = br.readBytes(br.left());
        break;
      }
    }

    return this;
  }

  fingerprint() {
    switch (this.version) {
      case 2:
      case 3: {
        if (!this.isRSA())
          throw new Error('Unknown PGP key algorithm.');

        const data = bio.concat(this.n.data, this.e.data);
        return MD5.digest(data);
      }

      case 4: {
        const size = this.getSize();
        const bw = bio.write(3 + size);

        bw.writeU8(0x99);
        bw.writeU16BE(size);

        this.write(bw);

        return SHA1.digest(bw.render());
      }

      default: {
        throw new Error('Unknown PGP key version.');
      }
    }
  }

  id() {
    switch (this.version) {
      case 2:
      case 3: {
        if (!this.isRSA())
          throw new Error('Unknown PGP key algorithm.');

        if (this.n.data.length < 8)
          throw new Error('Unknown PGP key algorithm.');

        return this.n.data.slice(this.n.data.length - 8);
      }

      case 4: {
        return this.fingerprint().slice(12, 20);
      }

      default: {
        throw new Error('Unknown PGP key version.');
      }
    }
  }

  long() {
    return this.id();
  }

  short() {
    return this.id().slice(4, 8);
  }

  matches(id) {
    if (typeof id === 'string')
      id = decodeID(id);

    switch (id.length) {
      case 4:
        return this.short().equals(id);
      case 8:
        return this.long().equals(id);
      case 16:
      case 20:
        return this.fingerprint().equals(id);
      default:
        return false;
    }
  }

  keyHash() {
    let size = 6;

    if (this.version !== 4)
      size += 2;

    // Create a real key hash without any bullshit.
    const raw = this.encode().slice(size - 1);

    raw[0] = this.algorithm;

    return SHA256.digest(raw);
  }

  format() {
    const algorithm = keyTypesByVal[this.algorithm] || 'UNKNOWN';
    const version = this.version;
    const timestamp = this.timestamp;
    const expires = this.expires;

    switch (this.algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        return {
          version,
          algorithm,
          timestamp,
          expires,
          n: this.n.data.toString('hex'),
          e: this.e.data.toString('hex')
        };
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        return {
          version,
          algorithm,
          timestamp,
          expires,
          p: this.p.data.toString('hex'),
          g: this.g.data.toString('hex'),
          y: this.y.data.toString('hex')
        };
      }

      case keyTypes.DSA: {
        return {
          version,
          algorithm,
          timestamp,
          expires,
          p: this.p.data.toString('hex'),
          q: this.q.data.toString('hex'),
          g: this.g.data.toString('hex'),
          y: this.y.data.toString('hex')
        };
      }

      case keyTypes.ECDH: {
        return {
          version,
          algorithm,
          timestamp,
          expires,
          curve: curveTypesByVal[this.curve] || 'UNKNOWN',
          point: this.point.data.toString('hex'),
          kdfHash: this.kdfHash,
          kdfAlg: this.kdfAlg
        };
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        return {
          version,
          algorithm,
          timestamp,
          expires,
          curve: curveTypesByVal[this.curve] || 'UNKNOWN',
          point: this.point.data.toString('hex')
        };
      }

      default: {
        return {
          version,
          algorithm,
          timestamp,
          expires,
          data: this.data.toString('hex')
        };
      }
    }
  }
}

/**
 * PGP Private Key
 */

class PGPPrivateKey extends PGPBody {
  constructor() {
    super();

    this.key = new PGPPublicKey();
    this.params = new CipherParams();
    this.data = EMPTY;
  }

  secret(passphrase) {
    let data = this.data;

    if (this.params.encrypted) {
      if (passphrase == null)
        throw new Error('Key reqs a passphrase.');

      data = this.params.decrypt(data, passphrase);
    }

    return SecretKey.decode(data, this.key.algorithm);
  }

  getSize() {
    let size = 0;

    size += this.key.getSize();
    size += this.params.getSize();
    size += this.data.length;

    return size;
  }

  write(bw) {
    this.key.write(bw);
    this.params.write(bw);
    bw.writeBytes(this.data);
    return bw;
  }

  read(br) {
    this.key.read(br);
    this.params.read(br);
    this.data = br.readBytes(br.left());
    return this;
  }

  format() {
    let params = null;
    let data = null;

    if (this.params.encrypted) {
      params = this.params;
      data = this.data.toString('hex');
    } else {
      params = null;
      data = this.secret();
    }

    return {
      key: this.key,
      params,
      data
    };
  }
}

/**
 * Cipher Params
 */

class CipherParams extends bio.Struct {
  constructor() {
    super();
    this.encrypted = false;
    this.checksum = false;
    this.cipher = 0;
    this.s2k = new S2K();
    this.iv = EMPTY;
  }

  blockSize() {
    switch (this.cipher) {
      case cipherTypes.IDEA:
      case cipherTypes.DES3:
      case cipherTypes.CAST5:
      case cipherTypes.BLOWFISH:
        return 8;
      case cipherTypes.AES128:
      case cipherTypes.AES192:
      case cipherTypes.AES256:
      case cipherTypes.TWOFISH:
      case cipherTypes.CAMELLIA128:
      case cipherTypes.CAMELLIA192:
      case cipherTypes.CAMELLIA256:
        return 16;
      default:
        throw new Error('Unknown cipher type.');
    }
  }

  keySize() {
    switch (this.cipher) {
      case cipherTypes.IDEA:
        return 16;
      case cipherTypes.DES3:
        return 24;
      case cipherTypes.CAST5:
        return 16;
      case cipherTypes.BLOWFISH:
        return 16;
      case cipherTypes.AES128:
        return 16;
      case cipherTypes.AES192:
        return 24;
      case cipherTypes.AES256:
        return 32;
      case cipherTypes.TWOFISH:
        return 32;
      case cipherTypes.CAMELLIA128:
        return 16;
      case cipherTypes.CAMELLIA192:
        return 24;
      case cipherTypes.CAMELLIA256:
        return 32;
      default:
        throw new Error('Unknown cipher type.');
    }
  }

  algName() {
    switch (this.cipher) {
      case cipherTypes.IDEA:
        return 'IDEA-CFB';
      case cipherTypes.DES3:
        return 'DES-EDE3-CFB';
      case cipherTypes.CAST5:
        return 'CAST5-CFB';
      case cipherTypes.BLOWFISH:
        return 'BF-CFB';
      case cipherTypes.AES128:
        return 'AES-128-CFB';
      case cipherTypes.AES192:
        return 'AES-192-CFB';
      case cipherTypes.AES256:
        return 'AES-256-CFB';
      case cipherTypes.TWOFISH:
        return 'TWOFISH-256-CFB';
      case cipherTypes.CAMELLIA128:
        return 'CAMELLIA-128-CFB';
      case cipherTypes.CAMELLIA192:
        return 'CAMELLIA-192-CFB';
      case cipherTypes.CAMELLIA256:
        return 'CAMELLIA-256-CFB';
      default:
        throw new Error('Unknown cipher type.');
    }
  }

  derive(passphrase) {
    if (!this.encrypted)
      throw new Error('Cannot derive passphrase.');

    return this.s2k.derive(passphrase, this.keySize());
  }

  encipher(pt, key) {
    assert(Buffer.isBuffer(pt));

    const name = this.algName();
    const add = this.checksum ? 20 : 2;
    const padded = Buffer.allocUnsafe(pt.length + add);

    pt.copy(padded, 0);

    if (this.checksum) {
      SHA1.digest(pt).copy(padded, pt.length);
    } else {
      let sum = 0;

      for (let i = 0; i < pt.length; i++) {
        sum += pt[i];
        sum &= 0xffff;
      }

      bio.writeU16BE(padded, sum, pt.length);
    }

    return cipher.encrypt(name, key, this.iv, padded);
  }

  decipher(ct, key) {
    const name = this.algName();
    const padded = cipher.decrypt(name, key, this.iv, ct);

    if (this.checksum) {
      if (padded.length < 20)
        throw new Error('Truncated data.');

      const pt = padded.slice(0, -20);
      const chk = padded.slice(-20);
      const sum = SHA1.digest(pt);

      if (!sum.equals(chk))
        throw new Error('Invalid checksum.');

      return pt;
    }

    if (padded.length < 2)
      throw new Error('Truncated data.');

    const pt = padded.slice(0, -2);
    const chk = bio.readU16BE(padded, padded.length - 2);

    let sum = 0;

    for (let i = 0; i < pt.length; i++) {
      sum += pt[i];
      sum &= 0xffff;
    }

    if (sum !== chk)
      throw new Error('Invalid checksum.');

    return pt;
  }

  encrypt(data, passphrase) {
    const key = this.derive(passphrase);
    return this.encipher(data, key);
  }

  decrypt(data, passphrase) {
    const key = this.derive(passphrase);
    return this.decipher(data, key);
  }

  getSize() {
    let size = 0;

    if (this.encrypted) {
      size += 1;
      size += 1;
      size += this.s2k.getSize();
      size += this.iv.length;
    } else {
      size += 1;
    }

    return size;
  }

  write(bw) {
    if (this.encrypted) {
      assert(this.iv.length === this.blockSize());

      bw.writeU8(this.checksum ? 0xfe : 0xff);
      bw.writeU8(this.cipher);
      this.s2k.write(bw);
      bw.writeBytes(this.iv);
    } else {
      bw.writeU8(0x00);
    }

    return bw;
  }

  read(br) {
    const type = br.readU8();

    switch (type) {
      case 0x00:
        break;
      case 0xfe:
      case 0xff:
        this.encrypted = true;
        this.checksum = type === 0xfe;
        this.cipher = br.readU8();
        this.s2k.read(br);
        this.iv = br.readBytes(this.blockSize());
        break;
      default:
        throw new Error('Unknown S2K type.');
    }

    return this;
  }

  format() {
    return {
      encrypted: this.encrypted,
      checksum: this.checksum,
      cipher: cipherTypesByVal[this.cipher] || 'UNKNOWN',
      s2k: this.s2k,
      iv: this.iv.toString('hex')
    };
  }
}

/**
 * S2K
 */

class S2K extends bio.Struct {
  constructor() {
    super();
    this.mode = 0;
    this.hash = 0;
    this.count = 0;
    this.salt = EMPTY;
  }

  derive(passphrase, size) {
    assert(typeof passphrase === 'string');
    assert((size >>> 0) === size);

    const input = Buffer.from(passphrase, 'binary');
    const hash = hashToHash[this.hash];

    if (!hash)
      throw new Error('Unknown hash.');

    switch (this.mode) {
      case 0:
        return this._simple(hash, input, size);
      case 1:
        return this._salted(hash, input, size);
      case 3:
        return this._iterated(hash, input, size);
      default:
        throw new Error('Unknown S2K mode.');
    }
  }

  _simple(hash, input, size) {
    return this._hash(hash, input, EMPTY, size);
  }

  _salted(hash, input, size) {
    return this._hash(hash, input, this.salt, size);
  }

  _hash(hash, input, salt, size) {
    assert(hash && typeof hash.id === 'string');
    assert(Buffer.isBuffer(input));
    assert(Buffer.isBuffer(salt));
    assert((size >>> 0) === size);

    const ctx = hash.ctx;
    const out = Buffer.alloc(size);

    let i = 0;
    let pos = 0;

    while (pos < size) {
      ctx.init();

      for (let j = 0; j < i; j++)
        ctx.update(ZERO);

      ctx.update(salt);
      ctx.update(input);

      pos += ctx.final().copy(out, pos);
      i += 1;
    }

    return out;
  }

  _iterated(hash, input, size) {
    assert(hash && typeof hash.id === 'string');
    assert(Buffer.isBuffer(input));
    assert((size >>> 0) === size);

    const salt = this.salt;
    const ctx = hash.ctx;
    const out = Buffer.alloc(size);
    const combined = bio.concat(salt, input);

    let count = this.count;

    if (count < combined.length)
      count = combined.length;

    let i = 0;
    let pos = 0;

    while (pos < size) {
      ctx.init();

      for (let j = 0; j < i; j++)
        ctx.update(ZERO);

      let w = 0;

      while (w < count) {
        if (w + combined.length > count) {
          const todo = count - w;
          ctx.update(combined.slice(0, todo));
          w = count;
        } else {
          ctx.update(combined);
          w += combined.length;
        }
      }

      pos += ctx.final().copy(out, pos);
      i += 1;
    }

    return out;
  }

  getSize() {
    let size = 2;

    switch (this.mode) {
      case 0:
        break;
      case 1:
        size += 8;
        break;
      case 3:
        size += 8;
        size += 1;
        break;
      default:
        throw new Error('Unknown S2K function.');
    }

    return size;
  }

  write(bw) {
    bw.writeU8(this.mode);
    bw.writeU8(this.hash);

    switch (this.mode) {
      case 0:
        break;
      case 1:
        bw.writeBytes(this.salt);
        break;
      case 3:
        bw.writeBytes(this.salt);
        bw.writeU8(encodeCount(this.count));
        break;
      default:
        throw new Error('Unknown S2K function.');
    }

    return bw;
  }

  read(br) {
    this.mode = br.readU8();
    this.hash = br.readU8();

    switch (this.mode) {
      case 0:
        break;
      case 1:
        this.salt = br.readBytes(8);
        break;
      case 3:
        this.salt = br.readBytes(8);
        this.count = decodeCount(br.readU8());
        break;
      default:
        throw new Error('Unknown S2K function.');
    }

    return this;
  }

  format() {
    return {
      mode: this.mode,
      hash: hashTypesByVal[this.hash] || 'UNKNOWN',
      count: this.count,
      salt: this.salt.toString('hex')
    };
  }
}

/**
 * Secret Key
 */

class SecretKey extends bio.Struct {
  constructor() {
    super();

    // RSA
    this.d = new MPI();
    this.q = new MPI();
    this.p = new MPI();
    this.qi = new MPI();

    // DSA
    this.x = new MPI();

    // El Gamal
    // this.x = new MPI();

    // ECDSA
    // this.d = new MPI();
  }

  getSize(algorithm) {
    assert((algorithm & 0xff) === algorithm);

    let size = 0;

    switch (algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        size += this.d.getSize();
        size += this.q.getSize();
        size += this.p.getSize();
        size += this.qi.getSize();
        break;
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        size += this.x.getSize();
        break;
      }

      case keyTypes.DSA: {
        size += this.x.getSize();
        break;
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        size += this.d.getSize();
        break;
      }

      default: {
        throw new Error('Unknown key type.');
      }
    }

    return size;
  }

  write(bw, algorithm) {
    assert((algorithm & 0xff) === algorithm);

    switch (algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        this.d.write(bw);
        this.q.write(bw);
        this.p.write(bw);
        this.qi.write(bw);
        break;
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        this.x.write(bw);
        break;
      }

      case keyTypes.DSA: {
        this.x.write(bw);
        break;
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        this.d.write(bw);
        break;
      }

      default: {
        throw new Error('Unknown key type.');
      }
    }

    return bw;
  }

  read(br, algorithm) {
    assert((algorithm & 0xff) === algorithm);

    switch (algorithm) {
      case keyTypes.RSA:
      case keyTypes.RSA_ENCRYPT_ONLY:
      case keyTypes.RSA_SIGN_ONLY: {
        this.d.read(br);
        this.q.read(br);
        this.p.read(br);
        this.qi.read(br);
        break;
      }

      case keyTypes.ELGAMAL:
      case keyTypes.ELGAMAL_LEGACY: {
        this.x.read(br);
        break;
      }

      case keyTypes.DSA: {
        this.x.read(br);
        break;
      }

      case keyTypes.ECDSA:
      case keyTypes.EDDSA: {
        this.d.read(br);
        break;
      }

      default: {
        throw new Error('Unknown key type.');
      }
    }

    return this;
  }

  format() {
    if (this.p.data.length > 0) {
      return {
        d: this.d.data.toString('hex'),
        q: this.q.data.toString('hex'),
        p: this.p.data.toString('hex'),
        qi: this.qi.data.toString('hex')
      };
    }

    if (this.x.data.length > 0) {
      return {
        x: this.x.data.toString('hex')
      };
    }

    if (this.d.data.length > 0) {
      return {
        d: this.d.data.toString('hex')
      };
    }

    return {
      d: this.d.data.toString('hex'),
      q: this.q.data.toString('hex'),
      p: this.p.data.toString('hex'),
      qi: this.qi.data.toString('hex'),
      x: this.x.data.toString('hex')
    };
  }
}

/**
 * PGP User ID
 */

class PGPUserID extends PGPBody {
  constructor() {
    super();
    this.id = '';
  }

  getSize() {
    return Buffer.byteLength(this.id, 'utf8');
  }

  write(bw) {
    bw.writeString(this.id, 'utf8');
    return bw;
  }

  read(br) {
    this.id = br.readString(br.left(), 'utf8');
    return this;
  }

  format() {
    return {
      id: this.id
    };
  }
}

/**
 * MPI
 */

class MPI extends bio.Struct {
  constructor(data) {
    super();

    this.bits = 0;
    this.data = EMPTY;

    if (data != null)
      this.fromOptions(data);
  }

  get() {
    return this.data;
  }

  set(data) {
    return this.fromOptions(data);
  }

  fromOptions(data) {
    assert(Buffer.isBuffer(data));
    this.bits = countLeft(data);
    this.data = data;
    return this;
  }

  getSize() {
    return 2 + this.data.length;
  }

  write(bw) {
    bw.writeU16BE(this.bits);
    bw.writeBytes(this.data);
    return bw;
  }

  read(br) {
    if (br.left() === 0)
      return this;

    const bits = br.readU16BE();
    const size = (bits + 7) >>> 3;
    const s = Math.min(size, br.left());
    const data = br.readBytes(s);

    this.bits = bits;
    this.data = data;

    return this;
  }
}

/*
 * ID Parsing
 */

function encodeID(raw) {
  assert(Buffer.isBuffer(raw));

  switch (raw.length) {
    case 4:
    case 8:
    case 16:
    case 20:
      break;
    default:
      throw new Error('Invalid PGP key id/fingerprint.');
  }

  const id = raw.toString('hex');

  return `0x${id.toUpperCase()}`;
}

function decodeID(id) {
  assert(typeof id === 'string');

  id = id.replace(/[\t ]/g, '');

  if (id.length >= 2
      && id.charCodeAt(0) === 0x30
      && (id.charCodeAt(1) | 0x20) === 0x78) {
    id = id.substring(2);
  }

  if (id.length > 40)
    throw new Error('Invalid PGP key id/fingerprint.');

  const raw = Buffer.from(id, 'hex');

  if (raw.length !== (id.length >>> 1))
    throw new Error('Invalid PGP key id/fingerprint.');

  switch (raw.length) {
    case 4:
    case 8:
    case 16:
    case 20:
      break;
    default:
      throw new Error('Invalid PGP key id/fingerprint.');
  }

  return raw;
}

/*
 * Helpers
 */

function encodeCount(i) {
  assert((i >>> 0) === i);

  if (i < 1024 || i > 65011712)
    throw new RangeError('Invalid iteration count.');

  for (let j = 0; j < 256; j++) {
    const c = decodeCount(j);

    if (c >= i)
      return j;
  }

  return 255;
}

function decodeCount(c) {
  assert((c & 0xff) === c);
  return (16 + (c & 15)) << ((c >>> 4) + 6);
}

/*
 * Expose
 */

exports.packetTypes = packetTypes;
exports.packetTypesByVal = packetTypesByVal;
exports.sigTypes = sigTypes;
exports.sigTypesByVal = sigTypesByVal;
exports.keyTypes = keyTypes;
exports.keyTypesByVal = keyTypesByVal;
exports.cipherTypes = cipherTypes;
exports.cipherTypesByVal = cipherTypesByVal;
exports.hashTypes = hashTypes;
exports.hashTypesByVal = hashTypesByVal;
exports.compressTypes = compressTypes;
exports.compressTypesByVal = compressTypesByVal;
exports.curveTypes = curveTypes;
exports.curveTypesByVal = curveTypesByVal;
exports.oids = oids;

exports.PGPMessage = PGPMessage;
exports.PGPPacket = PGPPacket;
exports.PGPBody = PGPBody;
exports.PGPUnknown = PGPUnknown;
exports.PGPPublicKey = PGPPublicKey;
exports.PGPPrivateKey = PGPPrivateKey;
exports.CipherParams = CipherParams;
exports.S2K = S2K;
exports.SecretKey = SecretKey;
exports.PGPUserID = PGPUserID;
exports.MPI = MPI;
exports.encodeID = encodeID;
exports.decodeID = decodeID;

}).call(this,req("buffer").Buffer)
},{"./cipher":34,"./encoding/pem":56,"./encoding/util":63,"./md5":149,"./ripemd160":164,"./sha1":172,"./sha224":173,"./sha256":174,"./sha384":180,"./sha512":181,"bsert":190,"buffer":303,"bufio":191}],161:[function(req,module,exports){
/*!
 * poly1305.js - poly1305 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/poly1305');

},{"./js/poly1305":121}],162:[function(req,module,exports){
/*!
 * random.js - random for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/random');

},{"./js/random":124}],163:[function(req,module,exports){
(function (Buffer){
/*!
 * rc4.js - RC4 for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RC4
 *   http://cypherpunks.venona.com/archive/1994/09/msg00304.html
 *   https://web.archive.org/web/20080207125928/http://cypherpunks.venona.com/archive/1994/09/msg00304.html
 *   https://tools.ietf.org/html/rfc4345
 *   https://tools.ietf.org/html/rfc6229
 *   https://github.com/golang/go/blob/master/src/crypto/rc4/rc4.go
 */

'use strict';

const assert = req('bsert');

/**
 * RC4
 */

class RC4 {
  constructor() {
    this.s = new Uint32Array(256);
    this.i = 0;
    this.j = 0;
  }

  init(key) {
    assert(Buffer.isBuffer(key));

    const k = key.length;

    if (k < 1 || k > 256)
      throw new Error('Invalid key size.');

    const s = this.s;

    for (let i = 0; i < 256; i++)
      s[i] = i;

    let j = 0;

    for (let i = 0; i < 256; i++) {
      j += s[i] + key[i % k];
      j &= 0xff;

      [s[i], s[j]] = [s[j], s[i]];
    }

    return this;
  }

  encrypt(data) {
    return this.crypt(data, data);
  }

  crypt(input, output) {
    assert(Buffer.isBuffer(input));
    assert(Buffer.isBuffer(output));

    if (output.length < input.length)
      throw new Error('Invalid output size.');

    const s = this.s;

    let {i, j} = this;
    let x, y;

    for (let k = 0; k < input.length; k++) {
      i += 1;
      i &= 0xff;
      x = s[i];

      j += x;
      j &= 0xff;
      y = s[j];

      s[i] = y;
      s[j] = x;

      output[k] = input[k] ^ s[(x + y) & 0xff];
    }

    this.i = i;
    this.j = j;

    return output;
  }

  destroy() {
    for (let i = 0; i < 256; i++)
      this.s[i] = 0;

    return this;
  }
}

/*
 * Static
 */

RC4.native = 0;

/*
 * Expose
 */

module.exports = RC4;

}).call(this,{"isBuffer":req("../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],164:[function(req,module,exports){
/*!
 * ripemd160.js - ripemd160 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/ripemd160');

},{"./js/ripemd160":125}],165:[function(req,module,exports){
/*!
 * rsa.js - RSA for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/rsa');

},{"./js/rsa":126}],166:[function(req,module,exports){
(function (Buffer){
/*!
 * rsaies.js - rsaies for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const assert = req('bsert');
const rsa = req('./rsa');
const random = req('./random');
const box = req('./secretbox');

/*
 * RSAIES
 */

const RSAIES = {
  encrypt(hash, msg, pub, size = null, label = null) {
    assert(hash && typeof hash.id === 'string');
    assert(Buffer.isBuffer(msg));

    const key = random.randomBytes(32);

    let ct = rsa.encryptOAEP(hash, key, pub, label);

    if (size != null)
      ct = rsa.veil(ct, size, pub);

    const nonce = random.randomBytes(24);
    const sealed = box.seal(msg, key, nonce);

    return Buffer.concat([ct, nonce, sealed]);
  },

  decrypt(hash, msg, priv, size = null, label = null) {
    assert(hash && typeof hash.id === 'string');
    assert(Buffer.isBuffer(msg));
    assert(priv instanceof rsa.RSAPrivateKey);

    if (size == null)
      size = priv.bits();

    assert((size >>> 0) === size);

    const bytes = (size + 7) >>> 3;

    if (msg.length < bytes + 24)
      throw new Error('Invalid ciphertext.');

    const ct = rsa.unveil(msg.slice(0, bytes), size, priv);
    const key = rsa.decryptOAEP(hash, ct, priv, label);
    const nonce = msg.slice(bytes, bytes + 24);
    const sealed = msg.slice(bytes + 24);

    return box.open(sealed, key, nonce);
  }
};

/*
 * Expose
 */

module.exports = RSAIES;

}).call(this,req("buffer").Buffer)
},{"./random":162,"./rsa":165,"./secretbox":171,"bsert":190,"buffer":303}],167:[function(req,module,exports){
(function (Buffer){
/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */

'use strict';

const assert = req('bsert');

/*
 * Safe
 */

function safeCompare(x, y) {
  assert(Buffer.isBuffer(x));
  assert(Buffer.isBuffer(y));

  if (safeEqualInt(y.length, 0))
    return safeEqualInt(x.length, 0);

  let v = x.length ^ y.length;

  for (let i = 0; i < x.length; i++)
    v |= x[i] ^ y[i % y.length];

  return safeEqualByte(v, 0);
}

function safeEqual(x, y) {
  assert(Buffer.isBuffer(x));
  assert(Buffer.isBuffer(y));

  // Assumes the lengths of both
  // `x` and `y` are not secret.
  if (x.length !== y.length)
    return 0;

  let v = 0;

  for (let i = 0; i < x.length; i++)
    v |= x[i] ^ y[i];

  return safeEqualByte(v, 0);
}

function safeEqualByte(x, y) {
  return safeEqualInt(x & 0xff, y & 0xff);
}

function safeEqualInt(x, y) {
  return ((x ^ y) - 1) >>> 31;
}

function safeSelect(v, x, y) {
  return (~(v - 1) & x) | ((v - 1) & y);
}

function safeLTE(x, y) {
  return ((x - y - 1) >>> 31) & 1;
}

function safeCopy(v, x, y) {
  assert(Number.isSafeInteger(v));
  assert(Buffer.isBuffer(x));
  assert(Buffer.isBuffer(y));
  assert(x.length === y.length);

  const xmask = (v - 1) & 0xff;
  const ymask = ~(v - 1) & 0xff;

  for (let i = 0; i < x.length; i++)
    x[i] = (x[i] & xmask) | (y[i] & ymask);
}

/*
 * Expose
 */

exports.safeCompare = safeCompare;
exports.safeEqual = safeEqual;
exports.safeEqualByte = safeEqualByte;
exports.safeEqualInt = safeEqualInt;
exports.safeSelect = safeSelect;
exports.safeLTE = safeLTE;
exports.safeCopy = safeCopy;

}).call(this,{"isBuffer":req("../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"bsert":190}],168:[function(req,module,exports){
/*!
 * salsa20.js - salsa20 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/salsa20');

},{"./js/salsa20":127}],169:[function(req,module,exports){
/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/scrypt');

},{"./js/scrypt":129}],170:[function(req,module,exports){
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/secp256k1');

},{"./js/secp256k1":130}],171:[function(req,module,exports){
(function (Buffer){
/*!
 * secretbox.js - nacl secretbox for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://nacl.cr.yp.to/secretbox.html
 *   https://github.com/golang/crypto/tree/master/nacl
 *   https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox.go
 *   https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/secretbox/example_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/box.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/box_test.go
 *   https://github.com/golang/crypto/blob/master/nacl/box/example_test.go
 */

'use strict';

const assert = req('bsert');
const Salsa20 = req('./salsa20');
const Poly1305 = req('./poly1305');

/*
 * Constants
 */

const ZERO16 = Buffer.alloc(16, 0x00);

/*
 * Secret Box
 */

function seal(msg, key, nonce) {
  assert(Buffer.isBuffer(msg));
  assert(Buffer.isBuffer(key));
  assert(Buffer.isBuffer(nonce));
  assert(key.length === 32);
  assert(nonce.length === 24);

  const box = Buffer.alloc(16 + msg.length, 0x00);
  const firstBlock = box.slice(16, 16 + 32);
  const ciphertext = box.slice(16 + 32);
  const salsa = new Salsa20();
  const poly = new Poly1305();
  const block = Buffer.alloc(64, 0x00);
  const polyKey = block.slice(0, 32);
  const rightSide = block.slice(32);

  salsa.init(key, nonce);
  salsa.encrypt(block);

  // box = tag || (first-block || msg[32:])
  msg.copy(box, 16);

  for (let i = 0; i < firstBlock.length; i++)
    firstBlock[i] ^= rightSide[i];

  if (ciphertext.length > 0) {
    salsa.init(key, nonce, 1);
    salsa.encrypt(ciphertext);
  }

  poly.init(polyKey);
  poly.update(firstBlock);
  poly.update(ciphertext);
  poly.final().copy(box, 0);

  return box;
}

function open(sealed, key, nonce) {
  assert(Buffer.isBuffer(sealed));
  assert(Buffer.isBuffer(key));
  assert(Buffer.isBuffer(nonce));
  assert(key.length === 32);
  assert(nonce.length === 24);

  if (sealed.length < 16)
    throw new Error('Invalid secret box size.');

  const input = Buffer.from(sealed);
  const tag = input.slice(0, 16);
  const firstBlock = input.slice(16, 16 + 32);
  const ciphertext = input.slice(16 + 32);
  const msg = input.slice(16);
  const salsa = new Salsa20();
  const poly = new Poly1305();
  const block = Buffer.alloc(64, 0x00);
  const polyKey = block.slice(0, 32);
  const rightSide = block.slice(32, 64);

  salsa.init(key, nonce);
  salsa.encrypt(block);

  poly.init(polyKey);
  poly.update(firstBlock);
  poly.update(ciphertext);

  const valid = Poly1305.verify(poly.final(), tag);

  if (!valid)
    throw new Error('Invalid secret box tag.');

  for (let i = 0; i < firstBlock.length; i++)
    firstBlock[i] ^= rightSide[i];

  if (ciphertext.length > 0) {
    salsa.init(key, nonce, 1);
    salsa.encrypt(ciphertext);
  }

  return msg;
}

function derive(secret, kdf) {
  const key = deriveSecret(secret, kdf);
  return Salsa20.derive(key, ZERO16);
}

/*
 * Helpers
 */

function deriveSecret(secret, kdf) {
  assert(Buffer.isBuffer(secret));

  if (kdf == null) {
    if (secret.length !== 32)
      throw new Error('Invalid secret size for secret box.');

    return secret;
  }

  if (typeof kdf.digest === 'function') {
    if (kdf.size < 32)
      throw new Error('Hash is too small for secret box.');

    return kdf.digest(secret).slice(0, 32);
  }

  assert(typeof kdf === 'function');

  const key = kdf(secret);

  assert(Buffer.isBuffer(key));

  if (key.length < 32)
    throw new Error('Key is too small for secret box.');

  return key.slice(0, 32);
}

/*
 * Expose
 */

exports.native = 0;
exports.seal = seal;
exports.open = open;
exports.derive = derive;

}).call(this,req("buffer").Buffer)
},{"./poly1305":161,"./salsa20":168,"bsert":190,"buffer":303}],172:[function(req,module,exports){
/*!
 * sha1.js - sha1 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/sha1');

},{"./js/sha1":131}],173:[function(req,module,exports){
/*!
 * sha224.js - SHA224 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/sha224');

},{"./js/sha224":132}],174:[function(req,module,exports){
/*!
 * sha256.js - sha256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/sha256');

},{"./js/sha256":133}],175:[function(req,module,exports){
(function (Buffer){
/*!
 * sha3-224.js - sha3-224 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const SHA3 = req('./sha3');

/**
 * SHA3-224
 */

class SHA3_224 extends SHA3 {
  /**
   * Create a SHA3-224 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(224);
  }

  static hash() {
    return new SHA3_224();
  }

  static hmac() {
    return super.hmac(224);
  }

  static digest(data) {
    return super.digest(data, 224);
  }

  static root(left, right) {
    return super.root(left, right, 224);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 224);
  }

  static mac(data, key) {
    return super.mac(data, key, 224);
  }
}

/*
 * Static
 */

SHA3_224.native = SHA3.native;
SHA3_224.id = 'SHA3_224';
SHA3_224.size = 28;
SHA3_224.bits = 224;
SHA3_224.blockSize = 144;
SHA3_224.zero = Buffer.alloc(28, 0x00);
SHA3_224.ctx = new SHA3_224();

/*
 * Expose
 */

module.exports = SHA3_224;

}).call(this,req("buffer").Buffer)
},{"./sha3":179,"buffer":303}],176:[function(req,module,exports){
(function (Buffer){
/*!
 * sha3-256.js - sha3-256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const SHA3 = req('./sha3');

/**
 * SHA3-256
 */

class SHA3_256 extends SHA3 {
  /**
   * Create a SHA3-256 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(256);
  }

  static hash() {
    return new SHA3_256();
  }

  static hmac() {
    return super.hmac(256);
  }

  static digest(data) {
    return super.digest(data, 256);
  }

  static root(left, right) {
    return super.root(left, right, 256);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 256);
  }

  static mac(data, key) {
    return super.mac(data, key, 256);
  }
}

/*
 * Static
 */

SHA3_256.native = SHA3.native;
SHA3_256.id = 'SHA3_256';
SHA3_256.size = 32;
SHA3_256.bits = 256;
SHA3_256.blockSize = 136;
SHA3_256.zero = Buffer.alloc(32, 0x00);
SHA3_256.ctx = new SHA3_256();

/*
 * Expose
 */

module.exports = SHA3_256;

}).call(this,req("buffer").Buffer)
},{"./sha3":179,"buffer":303}],177:[function(req,module,exports){
(function (Buffer){
/*!
 * sha3-384.js - sha3-384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const SHA3 = req('./sha3');

/**
 * SHA3-384
 */

class SHA3_384 extends SHA3 {
  /**
   * Create a SHA3-384 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(384);
  }

  static hash() {
    return new SHA3_384();
  }

  static hmac() {
    return super.hmac(384);
  }

  static digest(data) {
    return super.digest(data, 384);
  }

  static root(left, right) {
    return super.root(left, right, 384);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 384);
  }

  static mac(data, key) {
    return super.mac(data, key, 384);
  }
}

/*
 * Static
 */

SHA3_384.native = SHA3.native;
SHA3_384.id = 'SHA3_384';
SHA3_384.size = 48;
SHA3_384.bits = 384;
SHA3_384.blockSize = 104;
SHA3_384.zero = Buffer.alloc(48, 0x00);
SHA3_384.ctx = new SHA3_384();

/*
 * Expose
 */

module.exports = SHA3_384;

}).call(this,req("buffer").Buffer)
},{"./sha3":179,"buffer":303}],178:[function(req,module,exports){
(function (Buffer){
/*!
 * sha3-512.js - sha3-512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const SHA3 = req('./sha3');

/**
 * SHA3-512
 */

class SHA3_512 extends SHA3 {
  /**
   * Create a SHA3-512 context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(512);
  }

  static hash() {
    return new SHA3_512();
  }

  static hmac() {
    return super.hmac(512);
  }

  static digest(data) {
    return super.digest(data, 512);
  }

  static root(left, right) {
    return super.root(left, right, 512);
  }

  static multi(x, y, z) {
    return super.multi(x, y, z, 512);
  }

  static mac(data, key) {
    return super.mac(data, key, 512);
  }
}

/*
 * Static
 */

SHA3_512.native = SHA3.native;
SHA3_512.id = 'SHA3_512';
SHA3_512.size = 64;
SHA3_512.bits = 512;
SHA3_512.blockSize = 72;
SHA3_512.zero = Buffer.alloc(64, 0x00);
SHA3_512.ctx = new SHA3_512();

/*
 * Expose
 */

module.exports = SHA3_512;

}).call(this,req("buffer").Buffer)
},{"./sha3":179,"buffer":303}],179:[function(req,module,exports){
/*!
 * sha3.js - sha3 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/sha3');

},{"./js/sha3":134}],180:[function(req,module,exports){
/*!
 * sha384.js - SHA384 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/sha384');

},{"./js/sha384":135}],181:[function(req,module,exports){
/*!
 * sha512.js - sha512 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/sha512');

},{"./js/sha512":136}],182:[function(req,module,exports){
(function (Buffer){
/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */

'use strict';

const Keccak = req('./keccak');

/**
 * SHAKE
 */

class SHAKE extends Keccak {
  /**
   * Create a SHAKE Context.
   * @constructor
   */

  constructor() {
    super();
  }

  final(len) {
    return super.final(0x1f, len);
  }

  static hash() {
    return new SHAKE();
  }

  static hmac(bits = 256, len) {
    return super.hmac(bits, 0x1f, len);
  }

  static digest(data, bits = 256, len) {
    return super.digest(data, bits, 0x1f, len);
  }

  static root(left, right, bits = 256, len) {
    return super.root(left, right, bits, 0x1f, len);
  }

  static multi(x, y, z, bits = 256, len) {
    return super.multi(x, y, z, bits, 0x1f, len);
  }

  static mac(data, key, bits = 256, len) {
    return super.mac(data, key, bits, 0x1f, len);
  }
}

/*
 * Static
 */

SHAKE.native = Keccak.native;
SHAKE.id = 'SHAKE256';
SHAKE.size = 32;
SHAKE.bits = 256;
SHAKE.blockSize = 136;
SHAKE.zero = Buffer.alloc(32, 0x00);
SHAKE.ctx = new SHAKE();

/*
 * Expose
 */

module.exports = SHAKE;

}).call(this,req("buffer").Buffer)
},{"./keccak":139,"buffer":303}],183:[function(req,module,exports){
(function (Buffer){
/*!
 * shake128.js - SHAKE128 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const SHAKE = req('./shake');

/**
 * SHAKE128
 */

class SHAKE128 extends SHAKE {
  /**
   * Create a SHAKE128 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(128);
  }

  static hash() {
    return new SHAKE128();
  }

  static hmac(len) {
    return super.hmac(128, len);
  }

  static digest(data, len) {
    return super.digest(data, 128, len);
  }

  static root(left, right, len) {
    return super.root(left, right, 128, len);
  }

  static multi(x, y, z, len) {
    return super.multi(x, y, z, 128, len);
  }

  static mac(data, key, len) {
    return super.mac(data, key, 128, len);
  }
}

/*
 * Static
 */

SHAKE128.native = SHAKE.native;
SHAKE128.id = 'SHAKE128';
SHAKE128.size = 16;
SHAKE128.bits = 128;
SHAKE128.blockSize = 168;
SHAKE128.zero = Buffer.alloc(16, 0x00);
SHAKE128.ctx = new SHAKE128();

/*
 * Expose
 */

module.exports = SHAKE128;

}).call(this,req("buffer").Buffer)
},{"./shake":182,"buffer":303}],184:[function(req,module,exports){
(function (Buffer){
/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const SHAKE = req('./shake');

/**
 * SHAKE256
 */

class SHAKE256 extends SHAKE {
  /**
   * Create a SHAKE256 Context.
   * @constructor
   */

  constructor() {
    super();
  }

  init() {
    return super.init(256);
  }

  static hash() {
    return new SHAKE256();
  }

  static hmac(len) {
    return super.hmac(256, len);
  }

  static digest(data, len) {
    return super.digest(data, 256, len);
  }

  static root(left, right, len) {
    return super.root(left, right, 256, len);
  }

  static multi(x, y, z, len) {
    return super.multi(x, y, z, 256, len);
  }

  static mac(data, key, len) {
    return super.mac(data, key, 256, len);
  }
}

/*
 * Static
 */

SHAKE256.native = SHAKE.native;
SHAKE256.id = 'SHAKE256';
SHAKE256.size = 32;
SHAKE256.bits = 256;
SHAKE256.blockSize = 136;
SHAKE256.zero = Buffer.alloc(32, 0x00);
SHAKE256.ctx = new SHAKE256();

/*
 * Expose
 */

module.exports = SHAKE256;

}).call(this,req("buffer").Buffer)
},{"./shake":182,"buffer":303}],185:[function(req,module,exports){
/*!
 * siphash.js - siphash for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/siphash');

},{"./js/siphash":137}],186:[function(req,module,exports){
(function (Buffer){
/*!
 * ssh.js - SSH keys for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/openssh/openssh-portable/blob/master/cipher.c
 *   https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key
 */

/* eslint no-prototype-builtins: "off" */

'use strict';

const assert = req('bsert');
const bio = req('bufio');
const base64 = req('./encoding/base64');
const {padLeft, padRight} = req('./encoding/util');
const bcrypt = req('./bcrypt');
const cipher = req('./cipher');
const random = req('./random');
const openssl = req('./encoding/openssl');
const {PEMBlock} = req('./encoding/pem');
const pemcrypt = req('./encoding/pemcrypt');
const pkcs1 = req('./encoding/pkcs1');
const sec1 = req('./encoding/sec1');
const p256 = req('./p256');
const p384 = req('./p384');
const p521 = req('./p521');
const ed25519 = req('./ed25519');
const rsa = req('./rsa');

/*
 * Constants
 */

const keyTypes = {
  DSA: 'ssh-dss',
  RSA: 'ssh-rsa',
  P256: 'ecdsa-sha2-nistp256',
  P384: 'ecdsa-sha2-nistp384',
  P521: 'ecdsa-sha2-nistp521',
  ED25519: 'ssh-ed25519'
};

const keyTypesByVal = {
  [keyTypes.DSA]: 'DSA',
  [keyTypes.RSA]: 'RSA',
  [keyTypes.P256]: 'P256',
  [keyTypes.P384]: 'P384',
  [keyTypes.P521]: 'P521',
  [keyTypes.ED25519]: 'ED25519'
};

const typeToCurve = {
  [keyTypes.P256]: 'nistp256',
  [keyTypes.P384]: 'nistp384',
  [keyTypes.P521]: 'nistp521'
};

const cipherToName = {
  '3des-cbc': 'DES-EDE3-CBC',
  'aes128-cbc': 'AES-128-CBC',
  'aes192-cbc': 'AES-192-CBC',
  'aes256-cbc': 'AES-256-CBC',
  'rijndael-cbc@lysator.liu.se': 'AES-256-CBC',
  'aes128-ctr': 'AES-128-CTR',
  'aes192-ctr': 'AES-192-CTR',
  'aes256-ctr': 'AES-256-CTR'
};

const AUTH_MAGIC = 'openssh-key-v1';

const EMPTY = Buffer.alloc(0);
const ZERO32 = Buffer.alloc(32, 0x00);

/**
 * SSHPublicKey
 */

class SSHPublicKey extends bio.Struct {
  constructor() {
    super();

    this.type = keyTypes.ED25519;

    // DSA
    this.p = EMPTY;
    this.q = EMPTY;
    this.g = EMPTY;
    this.y = EMPTY;

    // RSA
    this.n = EMPTY;
    this.e = EMPTY;

    // ECDSA / EDDSA
    this.point = ZERO32;

    // Comment
    this.comment = '';
  }

  getCurve() {
    if (!typeToCurve.hasOwnProperty(this.type))
      throw new Error('No curve available.');

    return typeToCurve[this.type];
  }

  getSize() {
    let size = 0;

    size += sizeString(this.type);

    switch (this.type) {
      case keyTypes.DSA: {
        size += sizeBytes(this.p);
        size += sizeBytes(this.q);
        size += sizeBytes(this.g);
        size += sizeBytes(this.y);
        break;
      }

      case keyTypes.RSA: {
        size += sizeBytes(this.e);
        size += sizeBytes(this.n);
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        size += sizeBytes(this.getCurve());
        size += sizeBytes(this.point);
        break;
      }

      case keyTypes.ED25519: {
        size += sizeBytes(this.point);
        break;
      }

      default: {
        throw new assert.AssertionError('Invalid key.');
      }
    }

    return size;
  }

  write(bw) {
    writeString(bw, this.type);

    switch (this.type) {
      case keyTypes.DSA: {
        writeBytes(bw, this.p);
        writeBytes(bw, this.q);
        writeBytes(bw, this.g);
        writeBytes(bw, this.y);
        break;
      }

      case keyTypes.RSA: {
        writeBytes(bw, this.e);
        writeBytes(bw, this.n);
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        writeString(bw, this.getCurve());
        writeBytes(bw, this.point);
        break;
      }

      case keyTypes.ED25519: {
        writeBytes(bw, this.point);
        break;
      }

      default: {
        throw new assert.AssertionError('Invalid key.');
      }
    }

    return bw;
  }

  read(br) {
    this.type = readString(br);

    switch (this.type) {
      case keyTypes.DSA: {
        this.p = readBytes(br);
        this.q = readBytes(br);
        this.g = readBytes(br);
        this.y = readBytes(br);
        break;
      }

      case keyTypes.RSA: {
        this.e = readBytes(br);
        this.n = readBytes(br);
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        if (readString(br) !== this.getCurve())
          throw new Error('Invalid curve prefix.');

        this.point = readBytes(br);

        break;
      }

      case keyTypes.ED25519: {
        this.point = readBytes(br);
        break;
      }

      default: {
        throw new Error('Invalid key type.');
      }
    }

    return this;
  }

  toString() {
    const raw = this.encode();

    let comment = this.comment;

    if (comment.length > 0)
      comment = ' ' + comment;

    return `${this.type} ${base64.encode(raw)}${comment}`;
  }

  fromString(str) {
    assert(typeof str === 'string');

    const parts = str.split(' ', 3);

    if (parts.length < 2)
      throw new Error('Invalid SSH key text.');

    const [type, rest] = parts;

    if (!keyTypesByVal.hasOwnProperty(type))
      throw new Error(`Unknown SSH public key type: ${type}.`);

    const data = base64.decode(rest);

    this.decode(data);

    if (this.type !== type)
      throw new Error('Key type mismatch.');

    if (parts.length > 2)
      this.comment = parts[2].trim();

    return this;
  }

  format() {
    switch (this.type) {
      case keyTypes.DSA: {
        return {
          type: this.type,
          p: this.p.toString('hex'),
          q: this.q.toString('hex'),
          g: this.g.toString('hex'),
          y: this.y.toString('hex'),
          comment: this.comment
        };
      }

      case keyTypes.RSA: {
        return {
          type: this.type,
          n: this.n.toString('hex'),
          e: this.e.toString('hex'),
          comment: this.comment
        };
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521:
      case keyTypes.ED25519: {
        return {
          type: this.type,
          point: this.point.toString('hex'),
          comment: this.comment
        };
      }

      default: {
        return this;
      }
    }
  }
}

/**
 * SSHPrivateKey
 */

class SSHPrivateKey extends bio.Struct {
  constructor() {
    super();

    this.type = keyTypes.ED25519;

    // DSA
    this.p = EMPTY;
    this.q = EMPTY;
    this.g = EMPTY;
    this.y = EMPTY;
    this.x = EMPTY;

    // RSA
    this.n = EMPTY;
    this.e = EMPTY;
    this.d = EMPTY;
    this.p = EMPTY;
    this.q = EMPTY;
    this.dp = EMPTY;
    this.dq = EMPTY;
    this.qi = EMPTY;

    // ECDSA / EDDSA
    this.key = ZERO32;

    // Comment
    this.comment = '';
    this.modern = false;
  }

  getCurve() {
    if (!typeToCurve.hasOwnProperty(this.type))
      throw new Error('No curve available.');

    return typeToCurve[this.type];
  }

  encodeSSH(passwd) {
    assert(passwd == null || typeof passwd === 'string');

    const kdf = new KDFOptions();
    const pub = new SSHPublicKey();
    const priv = new RawPrivateKey();

    const bw = bio.write(8192);

    bw.writeString(AUTH_MAGIC);
    bw.writeU8(0);

    if (passwd != null) {
      kdf.name = 'bcrypt';
      kdf.salt = random.randomBytes(16);
      kdf.rounds = 16;

      writeString(bw, 'aes256-ctr');
    } else {
      writeString(bw, 'none');
    }

    kdf.write(bw);

    writeInt(bw, 1);

    pub.type = this.type;

    writeBytes(bw, pub.encode());

    priv.type = this.type;

    switch (this.type) {
      case keyTypes.DSA: {
        priv.p = this.p;
        priv.q = this.q;
        priv.g = this.g;
        priv.y = this.y;
        priv.x = this.x;
        break;
      }

      case keyTypes.RSA: {
        priv.n = this.n;
        priv.e = this.e;
        priv.d = this.d;
        priv.p = this.p;
        priv.q = this.q;
        priv.qi = this.qi;
        break;
      }

      case keyTypes.P256: {
        priv.point = p256.publicKeyCreate(this.key, false);
        priv.key = this.key;
        break;
      }

      case keyTypes.P384: {
        priv.point = p384.publicKeyCreate(this.key, false);
        priv.key = this.key;
        break;
      }

      case keyTypes.P521: {
        priv.point = p521.publicKeyCreate(this.key, false);
        priv.key = this.key;
        break;
      }

      case keyTypes.ED25519: {
        priv.point = ed25519.publicKeyCreate(this.key);
        priv.key = this.key;
        break;
      }

      default: {
        throw new assert.AssertionError('Invalid key.');
      }
    }

    priv.comment = this.comment;

    let raw = priv.encode(passwd != null);

    if (passwd != null)
      raw = encrypt(raw, 'aes256-ctr', passwd, kdf.salt, kdf.rounds);

    writeBytes(bw, raw);

    return bw.slice();
  }

  decodeSSH(data, passwd) {
    const br = bio.read(data);
    const magic = br.readString(14, 'binary');

    if (magic !== AUTH_MAGIC || br.readU8() !== 0)
      throw new Error('Invalid magic prefix for SSH key.');

    const cipher = readString(br);
    const kdf = KDFOptions.read(br);

    if (readInt(br) !== 1)
      throw new Error('Too many SSH keys.');

    const pubRaw = readBytes(br);
    const publicKey = SSHPublicKey.decode(pubRaw);

    let privRaw = readBytes(br);

    if (cipher !== 'none') {
      if (passwd == null)
        throw new Error('Cannot decrypt without passphrase.');

      if (kdf.name !== 'bcrypt')
        throw new Error('Invalid KDF.');

      privRaw = decrypt(privRaw, cipher, passwd, kdf.salt, kdf.rounds);
    }

    const priv = RawPrivateKey.decode(privRaw);

    if (priv.type !== publicKey.type)
      throw new Error('Public/private mismatch.');

    this.type = publicKey.type;

    switch (this.type) {
      case keyTypes.DSA: {
        this.p = priv.p;
        this.q = priv.q;
        this.g = priv.g;
        this.y = priv.y;
        this.x = priv.x;
        break;
      }

      case keyTypes.RSA: {
        this.n = priv.n;
        this.e = priv.e;
        this.d = priv.d;
        this.p = priv.p;
        this.q = priv.q;
        this.qi = priv.qi;
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521:
      case keyTypes.ED25519: {
        this.key = priv.key;
        break;
      }

      default: {
        throw new assert.AssertionError('Invalid key.');
      }
    }

    // Recompute dp and dq.
    if (this.type === keyTypes.RSA) {
      const key = new rsa.RSAPrivateKey(
        this.n,
        this.e,
        this.d,
        this.p,
        this.q,
        null,
        null,
        this.qi
      );

      rsa.privateKeyCompute(key);

      if (!rsa.privateKeyVerify(key))
        throw new Error('Invalid RSA private key.');

      this.dp = key.dp;
      this.dq = key.dq;
    }

    this.comment = priv.comment;
    this.modern = true;

    return this;
  }

  encode(passwd) {
    // Ed25519 can _only_ use the new school encoding.
    if (this.modern || this.type === keyTypes.ED25519)
      return this.encodeSSH(passwd);

    switch (this.type) {
      case keyTypes.DSA: {
        const key = new openssl.DSAPrivateKey(0,
          this.p,
          this.q,
          this.g,
          this.y,
          this.x
        );

        return key.encode();
      }

      case keyTypes.RSA: {
        const key = new pkcs1.RSAPrivateKey(0,
          this.n,
          this.e,
          this.d,
          this.p,
          this.q,
          this.dp,
          this.dq,
          this.qi
        );

        return key.encode();
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        let curve = null;
        let pub = null;

        switch (this.type) {
          case keyTypes.P256:
            curve = 'P256';
            pub = p256.publicKeyCreate(this.key, false);
            break;
          case keyTypes.P384:
            curve = 'P384';
            pub = p384.publicKeyCreate(this.key, false);
            break;
          case keyTypes.P521:
            curve = 'P521';
            pub = p521.publicKeyCreate(this.key, false);
            break;
        }

        const key = new sec1.ECPrivateKey(1, this.key, curve, pub);

        return key.encode();
      }

      default: {
        throw new assert.AssertionError('Invalid key.');
      }
    }
  }

  toString(passwd) {
    const block = new PEMBlock();

    // Ed25519 can _only_ use the new school encoding.
    if (this.modern || this.type === keyTypes.ED25519) {
      block.type = 'OPENSSH PRIVATE KEY';
      block.data = this.encode(passwd);
      return block.toString();
    }

    switch (this.type) {
      case keyTypes.DSA: {
        block.type = 'DSA PRIVATE KEY';
        break;
      }

      case keyTypes.RSA: {
        block.type = 'RSA PRIVATE KEY';
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        block.type = 'EC PRIVATE KEY';
        break;
      }

      default: {
        throw new assert.AssertionError('Invalid key.');
      }
    }

    block.data = this.encode(null);

    if (passwd != null)
      pemcrypt.encrypt(block, 'AES-128-CBC', passwd);

    return block.toString();
  }

  fromString(str, passwd) {
    const block = PEMBlock.fromString(str);

    if (block.isEncrypted()) {
      if (passwd == null)
        throw new Error('Private key reqs a passphrase.');

      pemcrypt.decrypt(block, passwd);
    }

    switch (block.type) {
      case 'DSA PRIVATE KEY': { // OpenSSL PKCS1-like format
        const key = openssl.DSAPrivateKey.decode(block.data);

        this.type = keyTypes.DSA;
        this.p = key.p.value;
        this.q = key.q.value;
        this.g = key.g.value;
        this.y = key.y.value;
        this.x = key.x.value;

        return this;
      }

      case 'RSA PRIVATE KEY': { // PKCS1
        const key = pkcs1.RSAPrivateKey.decode(block.data);

        this.type = keyTypes.RSA;
        this.n = key.n.value;
        this.e = key.e.value;
        this.d = key.d.value;
        this.p = key.p.value;
        this.q = key.q.value;
        this.dp = key.dp.value;
        this.dq = key.dq.value;
        this.qi = key.qi.value;

        return this;
      }

      case 'EC PRIVATE KEY': { // SEC1
        const key = sec1.ECPrivateKey.decode(block.data);
        const curve = key.namedCurveOID.getCurveName();

        if (!curve)
          throw new Error(`Unknown curve: ${key.namedCurveOID.toString()}.`);

        let type = null;
        let size = 0;

        switch (curve) {
          case 'P256':
            type = keyTypes.P256;
            size = 32;
            break;
          case 'P384':
            type = keyTypes.P384;
            size = 48;
            break;
          case 'P521':
            type = keyTypes.P521;
            size = 66;
            break;
          case 'ED25519':
            type = keyTypes.ED25519;
            size = 32;
            break;
          default:
            throw new Error(`Unsupported curve: ${curve}.`);
        }

        this.type = type;
        this.key = curve === 'ED25519'
          ? padRight(key.privateKey.value, size)
          : padLeft(key.privateKey.value, size);

        return this;
      }

      case 'OPENSSH PRIVATE KEY': { // OpenSSH format
        return this.decodeSSH(block.data, passwd);
      }

      default: {
        throw new Error(`Unknown private key type: ${block.type}.`);
      }
    }
  }

  format() {
    switch (this.type) {
      case keyTypes.DSA: {
        return {
          type: this.type,
          p: this.p.toString('hex'),
          q: this.q.toString('hex'),
          g: this.g.toString('hex'),
          y: this.y.toString('hex'),
          x: this.x.toString('hex'),
          comment: this.comment,
          modern: this.modern
        };
      }

      case keyTypes.RSA: {
        return {
          type: this.type,
          n: this.n.toString('hex'),
          e: this.q.toString('hex'),
          d: this.d.toString('hex'),
          p: this.p.toString('hex'),
          q: this.q.toString('hex'),
          dp: this.dp.toString('hex'),
          dq: this.dq.toString('hex'),
          qi: this.qi.toString('hex'),
          comment: this.comment,
          modern: this.modern
        };
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521:
      case keyTypes.ED25519: {
        return {
          type: this.type,
          key: this.key.toString('hex'),
          comment: this.comment,
          modern: this.modern
        };
      }

      default: {
        return this;
      }
    }
  }
}

/**
 * KDFOptions
 */

class KDFOptions extends bio.Struct {
  constructor() {
    super();
    this.name = 'none';
    this.salt = EMPTY;
    this.rounds = 0;
  }

  getBodySize() {
    let size = 0;

    switch (this.name) {
      case 'none':
        break;
      case 'bcrypt':
        size += sizeBytes(this.salt);
        size += sizeInt(this.rounds);
        break;
      default:
        throw new Error(`Unknown KDF: ${this.name}.`);
    }

    return size;
  }

  getSize() {
    let size = 0;
    size += sizeString(this.name);
    size += sizeInt(0);
    size += this.getBodySize();
    return size;
  }

  write(bw) {
    writeString(bw, this.name);
    writeInt(bw, this.getBodySize());

    switch (this.name) {
      case 'none':
        break;
      case 'bcrypt':
        writeBytes(bw, this.salt);
        writeInt(bw, this.rounds);
        break;
      default:
        throw new Error(`Unknown KDF: ${this.name}.`);
    }

    return bw;
  }

  read(br) {
    this.name = readString(br);

    const child = readChild(br);

    switch (this.name) {
      case 'none':
        break;
      case 'bcrypt':
        this.salt = readBytes(child);
        this.rounds = readInt(child);
        break;
      default:
        throw new Error(`Unknown KDF: ${this.name}.`);
    }

    return this;
  }
}

/**
 * RawPrivateKey
 */

class RawPrivateKey extends bio.Struct {
  constructor() {
    super();

    this.type = keyTypes.ED25519;

    // DSA
    this.p = EMPTY;
    this.q = EMPTY;
    this.g = EMPTY;
    this.y = EMPTY;
    this.x = EMPTY;

    // RSA
    this.n = EMPTY;
    this.e = EMPTY;
    this.d = EMPTY;
    this.p = EMPTY;
    this.q = EMPTY;
    this.qi = EMPTY;

    // ECDSA / EDDSA
    this.point = ZERO32;
    this.key = ZERO32;

    this.comment = '';
  }

  getSize(useNonce) {
    let size = 0;

    size += sizeInt(0);
    size += sizeInt(0);
    size += sizeString(this.type);

    switch (this.type) {
      case keyTypes.DSA: {
        size += sizeBytes(this.p);
        size += sizeBytes(this.q);
        size += sizeBytes(this.g);
        size += sizeBytes(this.y);
        size += sizeBytes(this.x);
        break;
      }

      case keyTypes.RSA: {
        size += sizeBytes(this.n);
        size += sizeBytes(this.e);
        size += sizeBytes(this.d);
        size += sizeBytes(this.qi);
        size += sizeBytes(this.p);
        size += sizeBytes(this.q);
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        size += sizeString(typeToCurve[this.type]);
        size += sizeBytes(this.point);
        size += sizeBytes(this.key);
        break;
      }

      case keyTypes.ED25519: {
        size += sizeBytes(this.point);
        size += sizeInt(0);
        size += this.key.length;
        size += this.point.length;
        break;
      }

      default: {
        throw new Error('Invalid key.');
      }
    }

    size += sizeString(this.comment);
    size += 8 - (size & 7);

    return size;
  }

  write(bw, useNonce) {
    const offset = bw.offset;

    let n = 0;

    if (useNonce)
      n = (Math.random() * 0x100000000) >>> 0;

    writeInt(bw, n);
    writeInt(bw, n);
    writeString(bw, this.type);

    switch (this.type) {
      case keyTypes.DSA: {
        writeBytes(bw, this.p);
        writeBytes(bw, this.q);
        writeBytes(bw, this.g);
        writeBytes(bw, this.y);
        writeBytes(bw, this.x);
        break;
      }

      case keyTypes.RSA: {
        writeBytes(bw, this.n);
        writeBytes(bw, this.e);
        writeBytes(bw, this.d);
        writeBytes(bw, this.qi);
        writeBytes(bw, this.p);
        writeBytes(bw, this.q);
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        writeString(bw, typeToCurve[this.type]);
        writeBytes(bw, this.point);
        writeBytes(bw, this.key);
        break;
      }

      case keyTypes.ED25519: {
        writeBytes(bw, this.point);
        writeBytes(bw, bio.concat(this.key, this.point));
        break;
      }

      default: {
        throw new Error('Invalid key.');
      }
    }

    writeString(bw, this.comment);

    let size = bw.offset - offset;
    let i = 1;

    while (size & 7) {
      bw.writeU8(i);
      size += 1;
      i += 1;
    }

    return bw;
  }

  read(br) {
    if ((br.left() & 7) !== 0)
      throw new Error('Invalid padding.');

    if (readInt(br) !== readInt(br))
      throw new Error('Decryption failed.');

    this.type = readString(br);

    switch (this.type) {
      case keyTypes.DSA: {
        this.p = readBytes(br);
        this.q = readBytes(br);
        this.g = readBytes(br);
        this.y = readBytes(br);
        this.x = readBytes(br);
        break;
      }

      case keyTypes.RSA: {
        this.n = readBytes(br);
        this.e = readBytes(br);
        this.d = readBytes(br);
        this.qi = readBytes(br);
        this.p = readBytes(br);
        this.q = readBytes(br);
        break;
      }

      case keyTypes.P256:
      case keyTypes.P384:
      case keyTypes.P521: {
        const curve = readString(br);

        if (curve !== typeToCurve[this.type])
          throw new Error('Invalid curve.');

        this.point = readBytes(br);
        this.key = readBytes(br);

        if (this.type === keyTypes.P256)
          this.key = padLeft(this.key, 32);
        else if (this.type === keyTypes.P384)
          this.key = padLeft(this.key, 48);
        else
          this.key = padLeft(this.key, 66);

        break;
      }

      case keyTypes.ED25519: {
        const point = readBytes(br);
        const blob = readBytes(br);

        if (blob.length !== 64)
          throw new Error('Invalid key pair.');

        const key = blob.slice(0, 32);
        const pub = blob.slice(32, 64);

        if (!point.equals(pub))
          throw new Error('Public key mismatch.');

        this.point = point;
        this.key = key;

        break;
      }

      default: {
        throw new Error('Invalid key.');
      }
    }

    this.comment = readString(br);

    const padding = br.readBytes(br.left(), true);

    for (let i = 0; i < padding.length; i++) {
      if (padding[i] !== i + 1)
        throw new Error('Invalid padding.');
    }

    return this;
  }
}

/*
 * Encryption
 */

function derive(sname, passwd, salt, rounds) {
  assert(typeof sname === 'string');
  assert(typeof passwd === 'string');
  assert(Buffer.isBuffer(salt));
  assert((rounds >>> 0) === rounds);

  if (!cipherToName.hasOwnProperty(sname))
    throw new Error(`Unknown cipher: ${sname}.`);

  const name = cipherToName[sname];
  const {keySize, ivSize} = cipher.get(name);

  const size = keySize + ivSize;
  const secret = bcrypt.pbkdf(passwd, salt, rounds, size);

  const key = secret.slice(0, keySize);
  const iv = secret.slice(keySize, keySize + ivSize);

  return [name, key, iv];
}

function encrypt(data, sname, passwd, salt, rounds) {
  const [name, key, iv] = derive(sname, passwd, salt, rounds);
  return cipher.encrypt(name, key, iv, data);
}

function decrypt(data, sname, passwd, salt, rounds) {
  const [name, key, iv] = derive(sname, passwd, salt, rounds);
  return cipher.decrypt(name, key, iv, data);
}

/*
 * Encoding
 */

function readString(br) {
  return br.readString(br.readU32BE(), 'binary');
}

function readBytes(br) {
  return br.readBytes(br.readU32BE());
}

function readChild(br) {
  return br.readChild(br.readU32BE());
}

function readInt(br) {
  return br.readU32BE();
}

function sizeString(str) {
  return 4 + str.length;
}

function writeString(bw, str) {
  bw.writeU32BE(str.length);
  bw.writeString(str, 'binary');
  return bw;
}

function sizeBytes(data) {
  return 4 + data.length;
}

function writeBytes(bw, data) {
  bw.writeU32BE(data.length);
  bw.writeBytes(data);
  return bw;
}

function sizeInt(num) {
  return 4;
}

function writeInt(bw, num) {
  bw.writeU32BE(num);
  return bw;
}

/*
 * Expose
 */

exports.keyTypes = keyTypes;
exports.keyTypesByVal = keyTypesByVal;
exports.SSHPublicKey = SSHPublicKey;
exports.SSHPrivateKey = SSHPrivateKey;
exports.KDFOptions = KDFOptions;
exports.RawPrivateKey = RawPrivateKey;

}).call(this,req("buffer").Buffer)
},{"./bcrypt":19,"./cipher":34,"./ed25519":44,"./encoding/base64":50,"./encoding/openssl":55,"./encoding/pem":56,"./encoding/pemcrypt":57,"./encoding/pkcs1":58,"./encoding/sec1":62,"./encoding/util":63,"./p256":156,"./p384":157,"./p521":158,"./random":162,"./rsa":165,"bsert":190,"buffer":303,"bufio":191}],187:[function(req,module,exports){
/*!
 * whirlpool.js - whirlpool for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

module.exports = req('./js/whirlpool');

},{"./js/whirlpool":138}],188:[function(req,module,exports){
/*!
 * x25519.js - x25519 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const Mont = req('./internal/mont');
const ed25519 = req('./ed25519');

/*
 * Expose
 */

module.exports = new Mont('X25519', 253, 32, '2b656e', ed25519);

},{"./ed25519":44,"./internal/mont":77}],189:[function(req,module,exports){
/*!
 * x448.js - x448 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

'use strict';

const Mont = req('./internal/mont');
const ed448 = req('./ed448');

/*
 * Expose
 */

module.exports = new Mont('X448', 446, 56, '2b656f', ed448);

},{"./ed448":45,"./internal/mont":77}],190:[function(req,module,exports){
/*!
 * assert.js - assertions for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bsert
 */

'use strict';

/**
 * AssertionError
 */

class AssertionError extends Error {
  constructor(options) {
    if (typeof options === 'string')
      options = { message: options };

    if (options === null || typeof options !== 'object')
      options = {};

    let message = null;
    let operator = 'fail';
    let generatedMessage = Boolean(options.generatedMessage);

    if (options.message != null)
      message = toString(options.message);

    if (typeof options.operator === 'string')
      operator = options.operator;

    if (message == null) {
      if (operator === 'fail') {
        message = 'Assertion failed.';
      } else {
        const a = stringify(options.actual);
        const b = stringify(options.expected);

        message = `${a} ${operator} ${b}`;
      }

      generatedMessage = true;
    }

    super(message);

    let start = this.constructor;

    if (typeof options.stackStartFunction === 'function')
      start = options.stackStartFunction;
    else if (typeof options.stackStartFn === 'function')
      start = options.stackStartFn;

    this.type = 'AssertionError';
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
    this.generatedMessage = generatedMessage;
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = operator;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, start);
  }
}

/*
 * Assert
 */

function assert(value, message) {
  if (!value) {
    let generatedMessage = false;

    if (arguments.length === 0) {
      message = 'No value argument passed to `assert()`.';
      generatedMessage = true;
    } else if (message == null) {
      message = 'Assertion failed.';
      generatedMessage = true;
    } else if (isError(message)) {
      throw message;
    }

    throw new AssertionError({
      message,
      actual: value,
      expected: true,
      operator: '==',
      generatedMessage,
      stackStartFn: assert
    });
  }
}

function equal(actual, expected, message) {
  if (!Object.is(actual, expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'strictEqual',
      stackStartFn: equal
    });
  }
}

function notEqual(actual, expected, message) {
  if (Object.is(actual, expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'notStrictEqual',
      stackStartFn: notEqual
    });
  }
}

function fail(message) {
  let generatedMessage = false;

  if (isError(message))
    throw message;

  if (message == null) {
    message = 'Assertion failed.';
    generatedMessage = true;
  }

  throw new AssertionError({
    message,
    actual: false,
    expected: true,
    operator: 'fail',
    generatedMessage,
    stackStartFn: fail
  });
}

function throws(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  enforce(typeof func === 'function', 'func', 'function');

  try {
    func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Missing expected exception.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: undefined,
      expected,
      operator: 'throws',
      generatedMessage,
      stackStartFn: throws
    });
  }

  if (!testError(err, expected, message, throws))
    throw err;
}

function doesNotThrow(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  enforce(typeof func === 'function', 'func', 'function');

  try {
    func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown)
    return;

  if (testError(err, expected, message, doesNotThrow)) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Got unwanted exception.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: err,
      expected,
      operator: 'doesNotThrow',
      generatedMessage,
      stackStartFn: doesNotThrow
    });
  }

  throw err;
}

async function rejects(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  if (typeof func !== 'function')
    enforce(isPromise(func), 'func', 'promise');

  try {
    if (isPromise(func))
      await func;
    else
      await func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Missing expected rejection.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: undefined,
      expected,
      operator: 'rejects',
      generatedMessage,
      stackStartFn: rejects
    });
  }

  if (!testError(err, expected, message, rejects))
    throw err;
}

async function doesNotReject(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  if (typeof func !== 'function')
    enforce(isPromise(func), 'func', 'promise');

  try {
    if (isPromise(func))
      await func;
    else
      await func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown)
    return;

  if (testError(err, expected, message, doesNotReject)) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Got unwanted rejection.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: undefined,
      expected,
      operator: 'doesNotReject',
      generatedMessage,
      stackStartFn: doesNotReject
    });
  }

  throw err;
}

function ifError(err) {
  if (err != null) {
    let message = 'ifError got unwanted exception: ';

    if (typeof err === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor)
        message += err.constructor.name;
      else
        message += err.message;
    } else {
      message += stringify(err);
    }

    throw new AssertionError({
      message,
      actual: err,
      expected: null,
      operator: 'ifError',
      generatedMessage: true,
      stackStartFn: ifError
    });
  }
}

function deepEqual(actual, expected, message) {
  if (!isDeepEqual(actual, expected, false)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'deepStrictEqual',
      stackStartFn: deepEqual
    });
  }
}

function notDeepEqual(actual, expected, message) {
  if (isDeepEqual(actual, expected, true)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepEqual
    });
  }
}

function bufferEqual(actual, expected, enc, message) {
  if (!isEncoding(enc)) {
    message = enc;
    enc = null;
  }

  if (enc == null)
    enc = 'hex';

  expected = bufferize(actual, expected, enc);

  enforce(isBuffer(actual), 'actual', 'buffer');
  enforce(isBuffer(expected), 'expected', 'buffer');

  if (actual !== expected && !actual.equals(expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual: actual.toString(enc),
      expected: expected.toString(enc),
      operator: 'bufferEqual',
      stackStartFn: bufferEqual
    });
  }
}

function notBufferEqual(actual, expected, enc, message) {
  if (!isEncoding(enc)) {
    message = enc;
    enc = null;
  }

  if (enc == null)
    enc = 'hex';

  expected = bufferize(actual, expected, enc);

  enforce(isBuffer(actual), 'actual', 'buffer');
  enforce(isBuffer(expected), 'expected', 'buffer');

  if (actual === expected || actual.equals(expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual: actual.toString(enc),
      expected: expected.toString(enc),
      operator: 'notBufferEqual',
      stackStartFn: notBufferEqual
    });
  }
}

function enforce(value, name, type) {
  if (!value) {
    let msg;

    if (name == null) {
      msg = 'Invalid type for parameter.';
    } else {
      if (type == null)
        msg = `Invalid type for "${name}".`;
      else
        msg = `"${name}" must be a(n) ${type}.`;
    }

    const err = new TypeError(msg);

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, enforce);

    throw err;
  }
}

function range(value, name) {
  if (!value) {
    const msg = name != null
      ? `"${name}" is out of range.`
      : 'Parameter is out of range.';

    const err = new RangeError(msg);

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, range);

    throw err;
  }
}

/*
 * Stringification
 */

function stringify(value) {
  switch (typeof value) {
    case 'undefined':
      return 'undefined';
    case 'object':
      if (value === null)
        return 'null';
      return `[${objectName(value)}]`;
    case 'boolean':
      return `${value}`;
    case 'number':
      return `${value}`;
    case 'string':
      if (value.length > 80)
        value = `${value.substring(0, 77)}...`;
      return JSON.stringify(value);
    case 'symbol':
      return tryString(value);
    case 'function':
      return `[${funcName(value)}]`;
    case 'bigint':
      return `${value}n`;
    default:
      return `[${typeof value}]`;
  }
}

function toString(value) {
  if (typeof value === 'string')
    return value;

  if (isError(value))
    return tryString(value);

  return stringify(value);
}

function tryString(value) {
  try {
    return String(value);
  } catch (e) {
    return 'Object';
  }
}

/*
 * Error Testing
 */

function testError(err, expected, message, func) {
  if (expected == null)
    return true;

  if (isRegExp(expected))
    return expected.test(err);

  if (typeof expected !== 'function') {
    if (func === doesNotThrow || func === doesNotReject)
      throw new TypeError('"expected" must not be an object.');

    if (typeof expected !== 'object')
      throw new TypeError('"expected" must be an object.');

    let generatedMessage = false;

    if (message == null) {
      const name = func === rejects ? 'rejection' : 'exception';
      message = `Missing expected ${name}.`;
      generatedMessage = true;
    }

    if (err == null || typeof err !== 'object') {
      throw new AssertionError({
        actual: err,
        expected,
        message,
        operator: func.name,
        generatedMessage,
        stackStartFn: func
      });
    }

    const keys = Object.keys(expected);

    if (isError(expected))
      keys.push('name', 'message');

    if (keys.length === 0)
      throw new TypeError('"expected" may not be an empty object.');

    for (const key of keys) {
      const expect = expected[key];
      const value = err[key];

      if (typeof value === 'string'
          && isRegExp(expect)
          && expect.test(value)) {
        continue;
      }

      if ((key in err) && isDeepEqual(value, expect, false))
        continue;

      throw new AssertionError({
        actual: err,
        expected: expected,
        message,
        operator: func.name,
        generatedMessage,
        stackStartFn: func
      });
    }

    return true;
  }

  if (expected.prototype !== undefined && (err instanceof expected))
    return true;

  if (Error.isPrototypeOf(expected))
    return false;

  return expected.call({}, err) === true;
}

/*
 * Comparisons
 */

function isDeepEqual(x, y, fail) {
  try {
    return compare(x, y, null);
  } catch (e) {
    return fail;
  }
}

function compare(a, b, cache) {
  // Primitives.
  if (Object.is(a, b))
    return true;

  if (!isObject(a) || !isObject(b))
    return false;

  // Semi-primitives.
  if (objectString(a) !== objectString(b))
    return false;

  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;

  if (isBuffer(a) && isBuffer(b))
    return a.equals(b);

  if (isDate(a))
    return Object.is(a.getTime(), b.getTime());

  if (isRegExp(a)) {
    return a.source === b.source
        && a.global === b.global
        && a.multiline === b.multiline
        && a.lastIndex === b.lastIndex
        && a.ignoreCase === b.ignoreCase;
  }

  if (isError(a)) {
    if (a.message !== b.message)
      return false;
  }

  if (isArrayBuffer(a)) {
    a = new Uint8Array(a);
    b = new Uint8Array(b);
  }

  if (isView(a) && !isBuffer(a)) {
    if (isBuffer(b))
      return false;

    const x = new Uint8Array(a.buffer);
    const y = new Uint8Array(b.buffer);

    if (x.length !== y.length)
      return false;

    for (let i = 0; i < x.length; i++) {
      if (x[i] !== y[i])
        return false;
    }

    return true;
  }

  if (isSet(a)) {
    if (a.size !== b.size)
      return false;

    const keys = new Set([...a, ...b]);

    return keys.size === a.size;
  }

  // Recursive.
  if (!cache) {
    cache = {
      a: new Map(),
      b: new Map(),
      p: 0
    };
  } else {
    const aa = cache.a.get(a);

    if (aa != null) {
      const bb = cache.b.get(b);
      if (bb != null)
        return aa === bb;
    }

    cache.p += 1;
  }

  cache.a.set(a, cache.p);
  cache.b.set(b, cache.p);

  const ret = recurse(a, b, cache);

  cache.a.delete(a);
  cache.b.delete(b);

  return ret;
}

function recurse(a, b, cache) {
  if (isMap(a)) {
    if (a.size !== b.size)
      return false;

    const keys = new Set([...a.keys(), ...b.keys()]);

    if (keys.size !== a.size)
      return false;

    for (const key of keys) {
      if (!compare(a.get(key), b.get(key), cache))
        return false;
    }

    return true;
  }

  if (isArray(a)) {
    if (a.length !== b.length)
      return false;

    for (let i = 0; i < a.length; i++) {
      if (!compare(a[i], b[i], cache))
        return false;
    }

    return true;
  }

  const ak = ownKeys(a);
  const bk = ownKeys(b);

  if (ak.length !== bk.length)
    return false;

  const keys = new Set([...ak, ...bk]);

  if (keys.size !== ak.length)
    return false;

  for (const key of keys) {
    if (!compare(a[key], b[key], cache))
      return false;
  }

  return true;
}

function ownKeys(obj) {
  const keys = Object.keys(obj);

  if (!Object.getOwnPropertySymbols)
    return keys;

  if (!Object.getOwnPropertyDescriptor)
    return keys;

  const symbols = Object.getOwnPropertySymbols(obj);

  for (const symbol of symbols) {
    const desc = Object.getOwnPropertyDescriptor(obj, symbol);

    if (desc && desc.enumerable)
      keys.push(symbol);
  }

  return keys;
}

/*
 * Helpers
 */

function objectString(obj) {
  if (obj === undefined)
    return '[object Undefined]';

  if (obj === null)
    return '[object Null]';

  try {
    return Object.prototype.toString.call(obj);
  } catch (e) {
    return '[object Object]';
  }
}

function objectType(obj) {
  return objectString(obj).slice(8, -1);
}

function objectName(obj) {
  const type = objectType(obj);

  if (obj == null)
    return type;

  if (type !== 'Object' && type !== 'Error')
    return type;

  let ctor, name;

  try {
    ctor = obj.constructor;
  } catch (e) {
    ;
  }

  if (ctor == null)
    return type;

  try {
    name = ctor.name;
  } catch (e) {
    return type;
  }

  if (typeof name !== 'string' || name.length === 0)
    return type;

  return name;
}

function funcName(func) {
  let name;

  try {
    name = func.name;
  } catch (e) {
    ;
  }

  if (typeof name !== 'string' || name.length === 0)
    return 'Function';

  return `Function: ${name}`;
}

function isArray(obj) {
  return Array.isArray(obj);
}

function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer;
}

function isBuffer(obj) {
  return isObject(obj)
      && typeof obj.writeUInt32LE === 'function'
      && typeof obj.equals === 'function';
}

function isDate(obj) {
  return obj instanceof Date;
}

function isError(obj) {
  return obj instanceof Error;
}

function isMap(obj) {
  return obj instanceof Map;
}

function isObject(obj) {
  return obj && typeof obj === 'object';
}

function isPromise(obj) {
  return obj instanceof Promise;
}

function isRegExp(obj) {
  return obj instanceof RegExp;
}

function isSet(obj) {
  return obj instanceof Set;
}

function isView(obj) {
  return ArrayBuffer.isView(obj);
}

function isEncoding(enc) {
  if (typeof enc !== 'string')
    return false;

  switch (enc) {
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'hex':
    case 'latin1':
    case 'ucs2':
    case 'utf8':
    case 'utf16le':
      return true;
  }

  return false;
}

function bufferize(actual, expected, enc) {
  if (typeof expected === 'string') {
    if (!isBuffer(actual))
      return null;

    const {constructor} = actual;

    if (!constructor || typeof constructor.from !== 'function')
      return null;

    if (!isEncoding(enc))
      return null;

    if (enc === 'hex' && (expected.length & 1))
      return null;

    const raw = constructor.from(expected, enc);

    if (enc === 'hex' && raw.length !== (expected.length >>> 1))
      return null;

    return raw;
  }

  return expected;
}

/*
 * API
 */

assert.AssertionError = AssertionError;
assert.assert = assert;
assert.strict = assert;
assert.ok = assert;
assert.equal = equal;
assert.notEqual = notEqual;
assert.strictEqual = equal;
assert.notStrictEqual = notEqual;
assert.fail = fail;
assert.throws = throws;
assert.doesNotThrow = doesNotThrow;
assert.rejects = rejects;
assert.doesNotReject = doesNotReject;
assert.ifError = ifError;
assert.deepEqual = deepEqual;
assert.notDeepEqual = notDeepEqual;
assert.deepStrictEqual = deepEqual;
assert.notDeepStrictEqual = notDeepEqual;
assert.bufferEqual = bufferEqual;
assert.notBufferEqual = notBufferEqual;
assert.enforce = enforce;
assert.range = range;

/*
 * Expose
 */

module.exports = assert;

},{}],191:[function(req,module,exports){
(function (Buffer){
/*!
 * bufio.js - buffer utilities for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

const custom = req('./custom');
const encoding = req('./encoding');
const enforce = req('./enforce');
const EncodingError = req('./error');
const BufferReader = req('./reader');
const BufferWriter = req('./writer');
const StaticWriter = req('./staticwriter');
const Struct = req('./struct');

exports.custom = custom;
exports.encoding = encoding;
exports.EncodingError = EncodingError;
exports.BufferReader = BufferReader;
exports.BufferWriter = BufferWriter;
exports.StaticWriter = StaticWriter;
exports.Struct = Struct;

exports.read = function read(data, zeroCopy) {
  return new BufferReader(data, zeroCopy);
};

exports.write = function write(size) {
  return size != null
    ? new StaticWriter(size)
    : new BufferWriter();
};

exports.pool = function pool(size) {
  return StaticWriter.pool(size);
};

function _read(func, size) {
  return function(data, off) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');

    if (off + size > data.length)
      throw new EncodingError(off, 'Out of bounds read');

    return func(data, off);
  };
}

function _readn(func) {
  return function(data, off, len) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');
    enforce((len >>> 0) === len, 'len', 'integer');

    if (off + len > data.length)
      throw new EncodingError(off, 'Out of bounds read');

    return func(data, off, len);
  };
}

function _readvar(func) {
  return function(data, off) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');
    return func(data, off);
  };
}

function _write(func, size) {
  return function(data, num, off) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');

    if (off + size > data.length)
      throw new EncodingError(off, 'Out of bounds write');

    return func(data, num, off);
  };
}

function _writen(func) {
  return function(data, num, off, len) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');
    enforce((len >>> 0) === len, 'len', 'integer');

    if (off + len > data.length)
      throw new EncodingError(off, 'Out of bounds write');

    return func(data, num, off, len);
  };
}

function _writecb(func, size) {
  return function(data, num, off) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');

    if (off + size(num) > data.length)
      throw new EncodingError(off, 'Out of bounds write');

    return func(data, num, off);
  };
}

exports.readU = _readn(encoding.readU);
exports.readU64 = _read(encoding.readU64, 8);
exports.readU56 = _read(encoding.readU56, 7);
exports.readU48 = _read(encoding.readU48, 6);
exports.readU40 = _read(encoding.readU40, 5);
exports.readU32 = _read(encoding.readU32, 4);
exports.readU24 = _read(encoding.readU24, 3);
exports.readU16 = _read(encoding.readU16, 2);
exports.readU8 = _read(encoding.readU8, 1);

exports.readUBE = _readn(encoding.readUBE);
exports.readU64BE = _read(encoding.readU64BE, 8);
exports.readU56BE = _read(encoding.readU56BE, 7);
exports.readU48BE = _read(encoding.readU48BE, 6);
exports.readU40BE = _read(encoding.readU40BE, 5);
exports.readU32BE = _read(encoding.readU32BE, 4);
exports.readU24BE = _read(encoding.readU24BE, 3);
exports.readU16BE = _read(encoding.readU16BE, 2);

exports.readI = _readn(encoding.readI);
exports.readI64 = _read(encoding.readI64, 8);
exports.readI56 = _read(encoding.readI56, 7);
exports.readI48 = _read(encoding.readI48, 6);
exports.readI40 = _read(encoding.readI40, 5);
exports.readI32 = _read(encoding.readI32, 4);
exports.readI24 = _read(encoding.readI24, 3);
exports.readI16 = _read(encoding.readI16, 2);
exports.readI8 = _read(encoding.readI8, 1);

exports.readIBE = _readn(encoding.readIBE);
exports.readI64BE = _read(encoding.readI64BE, 8);
exports.readI56BE = _read(encoding.readI56BE, 7);
exports.readI48BE = _read(encoding.readI48BE, 6);
exports.readI40BE = _read(encoding.readI40BE, 5);
exports.readI32BE = _read(encoding.readI32BE, 4);
exports.readI24BE = _read(encoding.readI24BE, 3);
exports.readI16BE = _read(encoding.readI16BE, 2);

exports.readFloat = _read(encoding.readFloat, 4);
exports.readFloatBE = _read(encoding.readFloatBE, 4);
exports.readDouble = _read(encoding.readDouble, 8);
exports.readDoubleBE = _read(encoding.readDoubleBE, 8);

exports.writeU = _writen(encoding.writeU);
exports.writeU64 = _write(encoding.writeU64, 8);
exports.writeU56 = _write(encoding.writeU56, 7);
exports.writeU48 = _write(encoding.writeU48, 6);
exports.writeU40 = _write(encoding.writeU40, 5);
exports.writeU32 = _write(encoding.writeU32, 4);
exports.writeU24 = _write(encoding.writeU24, 3);
exports.writeU16 = _write(encoding.writeU16, 2);
exports.writeU8 = _write(encoding.writeU8, 1);

exports.writeUBE = _writen(encoding.writeUBE);
exports.writeU64BE = _write(encoding.writeU64BE, 8);
exports.writeU56BE = _write(encoding.writeU56BE, 7);
exports.writeU48BE = _write(encoding.writeU48BE, 6);
exports.writeU40BE = _write(encoding.writeU40BE, 5);
exports.writeU32BE = _write(encoding.writeU32BE, 4);
exports.writeU24BE = _write(encoding.writeU24BE, 3);
exports.writeU16BE = _write(encoding.writeU16BE, 2);

exports.writeI = _writen(encoding.writeI);
exports.writeI64 = _write(encoding.writeI64, 8);
exports.writeI56 = _write(encoding.writeI56, 7);
exports.writeI48 = _write(encoding.writeI48, 6);
exports.writeI40 = _write(encoding.writeI40, 5);
exports.writeI32 = _write(encoding.writeI32, 4);
exports.writeI24 = _write(encoding.writeI24, 3);
exports.writeI16 = _write(encoding.writeI16, 2);
exports.writeI8 = _write(encoding.writeI8, 1);

exports.writeIBE = _writen(encoding.writeIBE);
exports.writeI64BE = _write(encoding.writeI64BE, 8);
exports.writeI56BE = _write(encoding.writeI56BE, 7);
exports.writeI48BE = _write(encoding.writeI48BE, 6);
exports.writeI40BE = _write(encoding.writeI40BE, 5);
exports.writeI32BE = _write(encoding.writeI32BE, 4);
exports.writeI24BE = _write(encoding.writeI24BE, 3);
exports.writeI16BE = _write(encoding.writeI16BE, 2);

exports.writeFloat = _write(encoding.writeFloat, 4);
exports.writeFloatBE = _write(encoding.writeFloatBE, 4);
exports.writeDouble = _write(encoding.writeDouble, 8);
exports.writeDoubleBE = _write(encoding.writeDoubleBE, 8);

exports.readVarint = _readvar(encoding.readVarint);
exports.writeVarint = _writecb(encoding.writeVarint, encoding.sizeVarint);
exports.sizeVarint = encoding.sizeVarint;
exports.readVarint2 = _readvar(encoding.readVarint2);
exports.writeVarint2 = _writecb(encoding.writeVarint2, encoding.sizeVarint2);
exports.sizeVarint2 = encoding.sizeVarint2;

exports.sliceBytes = encoding.sliceBytes;
exports.readBytes = encoding.readBytes;
exports.writeBytes = encoding.writeBytes;
exports.readString = encoding.readString;
exports.writeString = encoding.writeString;

exports.realloc = encoding.realloc;
exports.copy = encoding.copy;
exports.concat = encoding.concat;

exports.sizeVarBytes = encoding.sizeVarBytes;
exports.sizeVarlen = encoding.sizeVarlen;
exports.sizeVarString = encoding.sizeVarString;

}).call(this,{"isBuffer":req("../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":305,"./custom":192,"./encoding":193,"./enforce":194,"./error":195,"./reader":196,"./staticwriter":197,"./struct":198,"./writer":199}],192:[function(req,module,exports){
'use strict';

exports.custom = 'inspect';

},{}],193:[function(req,module,exports){
(function (Buffer){
/*!
 * encoding.js - encoding utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

/* eslint no-implicit-coercion: "off" */

'use strict';

const enforce = req('./enforce');
const EncodingError = req('./error');

/*
 * Constants
 */

const HI = 1 / 0x100000000;
const {MAX_SAFE_INTEGER} = Number;
const F32_ARRAY = new Float32Array(1);
const F328_ARRAY = new Uint8Array(F32_ARRAY.buffer);
const F64_ARRAY = new Float64Array(1);
const F648_ARRAY = new Uint8Array(F64_ARRAY.buffer);

F32_ARRAY[0] = -1;

const BIG_ENDIAN = F328_ARRAY[3] === 0;

/*
 * Read Unsigned LE
 */

function readU(data, off, len) {
  switch (len) {
    case 8:
      return readU64(data, off);
    case 7:
      return readU56(data, off);
    case 6:
      return readU48(data, off);
    case 5:
      return readU40(data, off);
    case 4:
      return readU32(data, off);
    case 3:
      return readU24(data, off);
    case 2:
      return readU16(data, off);
    case 1:
      return readU8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readU64(data, off) {
  const hi = readU32(data, off + 4);
  const lo = readU32(data, off);
  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readU56(data, off) {
  const hi = readU24(data, off + 4);
  const lo = readU32(data, off);
  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readU48(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + data[off++] * 0x1000000
    + data[off++] * 0x100000000
    + data[off] * 0x10000000000);
}

function readU40(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + data[off++] * 0x1000000
    + data[off] * 0x100000000);
}

function readU32(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + data[off] * 0x1000000);
}

function readU24(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off] * 0x10000);
}

function readU16(data, off) {
  return data[off++] + data[off] * 0x100;
}

function readU8(data, off) {
  return data[off];
}

/*
 * Read Unsigned BE
 */

function readUBE(data, off, len) {
  switch (len) {
    case 8:
      return readU64BE(data, off);
    case 7:
      return readU56BE(data, off);
    case 6:
      return readU48BE(data, off);
    case 5:
      return readU40BE(data, off);
    case 4:
      return readU32BE(data, off);
    case 3:
      return readU24BE(data, off);
    case 2:
      return readU16BE(data, off);
    case 1:
      return readU8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readU64BE(data, off) {
  const hi = readU32BE(data, off);
  const lo = readU32BE(data, off + 4);
  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readU56BE(data, off) {
  const hi = readU24BE(data, off);
  const lo = readU32BE(data, off + 3);
  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readU48BE(data, off) {
  return (data[off++] * 0x10000000000
    + data[off++] * 0x100000000
    + data[off++] * 0x1000000
    + data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readU40BE(data, off) {
  return (data[off++] * 0x100000000
    + data[off++] * 0x1000000
    + data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readU32BE(data, off) {
  return (data[off++] * 0x1000000
    + data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readU24BE(data, off) {
  return (data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readU16BE(data, off) {
  return data[off++] * 0x100 + data[off];
}

/*
 * Read Signed LE
 */

function readI(data, off, len) {
  switch (len) {
    case 8:
      return readI64(data, off);
    case 7:
      return readI56(data, off);
    case 6:
      return readI48(data, off);
    case 5:
      return readI40(data, off);
    case 4:
      return readI32(data, off);
    case 3:
      return readI24(data, off);
    case 2:
      return readI16(data, off);
    case 1:
      return readI8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readI64(data, off) {
  const hi = readI32(data, off + 4);
  const lo = readU32(data, off);
  check(isSafe(hi, lo), 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readI56(data, off) {
  const hi = readI24(data, off + 4);
  const lo = readU32(data, off);
  check(isSafe(hi, lo), 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readI48(data, off) {
  const val = data[off + 4] + data[off + 5] * 0x100;

  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + data[off] * 0x1000000
    + (val | (val & 0x8000) * 0x1fffe) * 0x100000000);
}

function readI40(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + data[off++] * 0x1000000
    + (data[off] | (data[off] & 0x80) * 0x1fffffe) * 0x100000000);
}

function readI32(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + (data[off] << 24));
}

function readI24(data, off) {
  const val = (data[off++]
    + data[off++] * 0x100
    + data[off] * 0x10000);
  return val | (val & 0x800000) * 0x1fe;
}

function readI16(data, off) {
  const val = data[off++] + data[off] * 0x100;
  return val | (val & 0x8000) * 0x1fffe;
}

function readI8(data, off) {
  const val = data[off];
  return val | (val & 0x80) * 0x1fffffe;
}

/*
 * Read Signed BE
 */

function readIBE(data, off, len) {
  switch (len) {
    case 8:
      return readI64BE(data, off);
    case 7:
      return readI56BE(data, off);
    case 6:
      return readI48BE(data, off);
    case 5:
      return readI40BE(data, off);
    case 4:
      return readI32BE(data, off);
    case 3:
      return readI24BE(data, off);
    case 2:
      return readI16BE(data, off);
    case 1:
      return readI8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readI64BE(data, off) {
  const hi = readI32BE(data, off);
  const lo = readU32BE(data, off + 4);
  check(isSafe(hi, lo), 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readI56BE(data, off) {
  const hi = readI24BE(data, off);
  const lo = readU32BE(data, off + 3);
  check(isSafe(hi, lo), 'Number exceeds 2^53-1');
  return hi * 0x100000000 + lo;
}

function readI48BE(data, off) {
  const val = data[off++] * 0x100 + data[off++];

  return ((val | (val & 0x8000) * 0x1fffe) * 0x100000000
    + data[off++] * 0x1000000
    + data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readI40BE(data, off) {
  const val = data[off++];

  return ((val | (val & 0x80) * 0x1fffffe) * 0x100000000
    + data[off++] * 0x1000000
    + data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readI32BE(data, off) {
  return ((data[off++] << 24)
    + data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);
}

function readI24BE(data, off) {
  const val = (data[off++] * 0x10000
    + data[off++] * 0x100
    + data[off]);

  return val | (val & 0x800000) * 0x1fe;
}

function readI16BE(data, off) {
  const val = data[off++] * 0x100 + data[off];
  return val | (val & 0x8000) * 0x1fffe;
}

/*
 * Read Float
 */

function _readFloatBackwards(data, off) {
  F328_ARRAY[3] = data[off++];
  F328_ARRAY[2] = data[off++];
  F328_ARRAY[1] = data[off++];
  F328_ARRAY[0] = data[off];
  return F32_ARRAY[0];
}

function _readFloatForwards(data, off) {
  F328_ARRAY[0] = data[off++];
  F328_ARRAY[1] = data[off++];
  F328_ARRAY[2] = data[off++];
  F328_ARRAY[3] = data[off];
  return F32_ARRAY[0];
}

function _readDoubleBackwards(data, off) {
  F648_ARRAY[7] = data[off++];
  F648_ARRAY[6] = data[off++];
  F648_ARRAY[5] = data[off++];
  F648_ARRAY[4] = data[off++];
  F648_ARRAY[3] = data[off++];
  F648_ARRAY[2] = data[off++];
  F648_ARRAY[1] = data[off++];
  F648_ARRAY[0] = data[off];
  return F64_ARRAY[0];
}

function _readDoubleForwards(data, off) {
  F648_ARRAY[0] = data[off++];
  F648_ARRAY[1] = data[off++];
  F648_ARRAY[2] = data[off++];
  F648_ARRAY[3] = data[off++];
  F648_ARRAY[4] = data[off++];
  F648_ARRAY[5] = data[off++];
  F648_ARRAY[6] = data[off++];
  F648_ARRAY[7] = data[off];
  return F64_ARRAY[0];
}

const readFloat = BIG_ENDIAN ? _readFloatBackwards : _readFloatForwards;
const readFloatBE = BIG_ENDIAN ? _readFloatForwards : _readFloatBackwards;
const readDouble = BIG_ENDIAN ? _readDoubleBackwards : _readDoubleForwards;
const readDoubleBE = BIG_ENDIAN ? _readDoubleForwards : _readDoubleBackwards;

/*
 * Write Unsigned LE
 */

function writeU(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64(dst, num, off);
    case 7:
      return writeU56(dst, num, off);
    case 6:
      return writeU48(dst, num, off);
    case 5:
      return writeU40(dst, num, off);
    case 4:
      return writeU32(dst, num, off);
    case 3:
      return writeU24(dst, num, off);
    case 2:
      return writeU16(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeU64(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write64(dst, num, off, false);
}

function writeU56(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write56(dst, num, off, false);
}

function writeU48(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  dst[off++] = hi;
  dst[off++] = hi >>> 8;

  return off;
}

function writeU40(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  dst[off++] = hi;

  return off;
}

function writeU32(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

function writeU24(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

function writeU16(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  dst[off++] = num;
  dst[off++] = num >>> 8;
  return off;
}

function writeU8(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  dst[off] = num;
  return off + 1;
}

/*
 * Write Unsigned BE
 */

function writeUBE(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64BE(dst, num, off);
    case 7:
      return writeU56BE(dst, num, off);
    case 6:
      return writeU48BE(dst, num, off);
    case 5:
      return writeU40BE(dst, num, off);
    case 4:
      return writeU32BE(dst, num, off);
    case 3:
      return writeU24BE(dst, num, off);
    case 2:
      return writeU16BE(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeU64BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write64(dst, num, off, true);
}

function writeU56BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write56(dst, num, off, true);
}

function writeU48BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = hi >>> 8;
  dst[off++] = hi;
  dst[off + 3] = num;
  num >>>= 8;
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;

  return off + 4;
}

function writeU40BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = hi;
  dst[off + 3] = num;
  num >>>= 8;
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;

  return off + 4;
}

function writeU32BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  dst[off + 3] = num;
  num >>>= 8;
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;
  return off + 4;
}

function writeU24BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;
  return off + 3;
}

function writeU16BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  dst[off++] = num >>> 8;
  dst[off++] = num;
  return off;
}

/*
 * Write Signed LE
 */

function writeI(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64(dst, num, off);
    case 7:
      return writeU56(dst, num, off);
    case 6:
      return writeU48(dst, num, off);
    case 5:
      return writeU40(dst, num, off);
    case 4:
      return writeU24(dst, num, off);
    case 3:
      return writeU32(dst, num, off);
    case 2:
      return writeU16(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeI64(dst, num, off) {
  return writeU64(dst, num, off);
}

function writeI56(dst, num, off) {
  return writeU56(dst, num, off);
}

function writeI48(dst, num, off) {
  return writeU48(dst, num, off);
}

function writeI40(dst, num, off) {
  return writeU40(dst, num, off);
}

function writeI32(dst, num, off) {
  return writeU32(dst, num, off);
}

function writeI24(dst, num, off) {
  return writeU24(dst, num, off);
}

function writeI16(dst, num, off) {
  return writeU16(dst, num, off);
}

function writeI8(dst, num, off) {
  return writeU8(dst, num, off);
}

/*
 * Write Signed BE
 */

function writeIBE(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64BE(dst, num, off);
    case 7:
      return writeU56BE(dst, num, off);
    case 6:
      return writeU48BE(dst, num, off);
    case 5:
      return writeU40BE(dst, num, off);
    case 4:
      return writeU32BE(dst, num, off);
    case 3:
      return writeU24BE(dst, num, off);
    case 2:
      return writeU16BE(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeI64BE(dst, num, off) {
  return writeU64BE(dst, num, off);
}

function writeI56BE(dst, num, off) {
  return writeU56BE(dst, num, off);
}

function writeI48BE(dst, num, off) {
  return writeU48BE(dst, num, off);
}

function writeI40BE(dst, num, off) {
  return writeU40BE(dst, num, off);
}

function writeI32BE(dst, num, off) {
  return writeU32BE(dst, num, off);
}

function writeI24BE(dst, num, off) {
  return writeU24BE(dst, num, off);
}

function writeI16BE(dst, num, off) {
  return writeU16BE(dst, num, off);
}

function _writeDoubleForwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');
  F64_ARRAY[0] = num;
  dst[off++] = F648_ARRAY[0];
  dst[off++] = F648_ARRAY[1];
  dst[off++] = F648_ARRAY[2];
  dst[off++] = F648_ARRAY[3];
  dst[off++] = F648_ARRAY[4];
  dst[off++] = F648_ARRAY[5];
  dst[off++] = F648_ARRAY[6];
  dst[off++] = F648_ARRAY[7];
  return off;
}

function _writeDoubleBackwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');
  F64_ARRAY[0] = num;
  dst[off++] = F648_ARRAY[7];
  dst[off++] = F648_ARRAY[6];
  dst[off++] = F648_ARRAY[5];
  dst[off++] = F648_ARRAY[4];
  dst[off++] = F648_ARRAY[3];
  dst[off++] = F648_ARRAY[2];
  dst[off++] = F648_ARRAY[1];
  dst[off++] = F648_ARRAY[0];
  return off;
}

function _writeFloatForwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');
  F32_ARRAY[0] = num;
  dst[off++] = F328_ARRAY[0];
  dst[off++] = F328_ARRAY[1];
  dst[off++] = F328_ARRAY[2];
  dst[off++] = F328_ARRAY[3];
  return off;
}

function _writeFloatBackwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');
  F32_ARRAY[0] = num;
  dst[off++] = F328_ARRAY[3];
  dst[off++] = F328_ARRAY[2];
  dst[off++] = F328_ARRAY[1];
  dst[off++] = F328_ARRAY[0];
  return off;
}

const writeFloat = BIG_ENDIAN ? _writeFloatBackwards : _writeFloatForwards;
const writeFloatBE = BIG_ENDIAN ? _writeFloatForwards : _writeFloatBackwards;
const writeDouble = BIG_ENDIAN ? _writeDoubleBackwards : _writeDoubleForwards;
const writeDoubleBE = BIG_ENDIAN ? _writeDoubleForwards : _writeDoubleBackwards;

/*
 * Varints
 */

function readVarint(data, off) {
  let value, size;

  checkRead(off < data.length, off);

  switch (data[off]) {
    case 0xff:
      size = 9;
      checkRead(off + size <= data.length, off);
      value = readU64(data, off + 1);
      check(value > 0xffffffff, off, 'Non-canonical varint');
      break;
    case 0xfe:
      size = 5;
      checkRead(off + size <= data.length, off);
      value = readU32(data, off + 1);
      check(value > 0xffff, off, 'Non-canonical varint');
      break;
    case 0xfd:
      size = 3;
      checkRead(off + size <= data.length, off);
      value = readU16(data, off + 1);
      check(value >= 0xfd, off, 'Non-canonical varint');
      break;
    default:
      size = 1;
      value = data[off];
      break;
  }

  return new Varint(size, value);
}

function writeVarint(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  if (num < 0xfd) {
    dst[off++] = num;
    return off;
  }

  if (num <= 0xffff) {
    dst[off++] = 0xfd;
    return writeU16(dst, num, off);
  }

  if (num <= 0xffffffff) {
    dst[off++] = 0xfe;
    return writeU32(dst, num, off);
  }

  dst[off++] = 0xff;
  return writeU64(dst, num, off);
}

function sizeVarint(num) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  if (num < 0xfd)
    return 1;

  if (num <= 0xffff)
    return 3;

  if (num <= 0xffffffff)
    return 5;

  return 9;
}

function readVarint2(data, off) {
  let num = 0;
  let size = 0;

  for (;;) {
    checkRead(off < data.length, off);

    const ch = data[off++];
    size += 1;

    // Number.MAX_SAFE_INTEGER >>> 7
    check(num <= 0x3fffffffffff - (ch & 0x7f), off, 'Number exceeds 2^53-1');

    // num = (num << 7) | (ch & 0x7f);
    num = (num * 0x80) + (ch & 0x7f);

    if ((ch & 0x80) === 0)
      break;

    check(num !== MAX_SAFE_INTEGER, off, 'Number exceeds 2^53-1');
    num += 1;
  }

  return new Varint(size, num);
}

function writeVarint2(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const tmp = [];

  let len = 0;

  for (;;) {
    tmp[len] = (num & 0x7f) | (len ? 0x80 : 0x00);
    if (num <= 0x7f)
      break;
    // num = (num >>> 7) - 1;
    num = ((num - (num % 0x80)) / 0x80) - 1;
    len += 1;
  }

  checkRead(off + len + 1 <= dst.length, off);

  do {
    dst[off++] = tmp[len];
  } while (len--);

  return off;
}

function sizeVarint2(num) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  let size = 0;

  for (;;) {
    size += 1;
    if (num <= 0x7f)
      break;
    // num = (num >>> 7) - 1;
    num = ((num - (num % 0x80)) / 0x80) - 1;
  }

  return size;
}

/*
 * Bytes
 */

function sliceBytes(data, off, size) {
  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce((size >>> 0) === size, 'size', 'integer');

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds read');

  return data.slice(off, off + size);
}

function readBytes(data, off, size) {
  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce((size >>> 0) === size, 'size', 'integer');

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds read');

  const buf = Buffer.allocUnsafe(size);
  data.copy(buf, 0, off, off + size);
  return buf;
}

function writeBytes(data, value, off) {
  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  enforce(Buffer.isBuffer(value), 'value', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');

  if (off + value.length > data.length)
    throw new EncodingError(off, 'Out of bounds write');

  return value.copy(data, off, 0, value.length);
}

function readString(data, off, size, enc) {
  if (enc == null)
    enc = 'binary';

  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce((size >>> 0) === size, 'size', 'integer');
  enforce(typeof enc === 'string', 'enc', 'string');

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds read');

  return data.toString(enc, off, off + size);
}

function writeString(data, str, off, enc) {
  if (enc == null)
    enc = 'binary';

  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  enforce(typeof str === 'string', 'str', 'string');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce(typeof enc === 'string', 'enc', 'string');

  if (str.length === 0)
    return 0;

  const size = Buffer.byteLength(str, enc);

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds write');

  return data.write(str, off, enc);
}

function realloc(data, size) {
  enforce(Buffer.isBuffer(data), 'data', 'buffer');

  const buf = Buffer.allocUnsafe(size);
  data.copy(buf, 0);
  return buf;
}

function copy(data) {
  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  return realloc(data, data.length);
}

function concat(a, b) {
  enforce(Buffer.isBuffer(a), 'a', 'buffer');
  enforce(Buffer.isBuffer(b), 'b', 'buffer');

  const size = a.length + b.length;
  const buf = Buffer.allocUnsafe(size);

  a.copy(buf, 0);
  b.copy(buf, a.length);

  return buf;
}

/*
 * Size Helpers
 */

function sizeVarBytes(data) {
  enforce(Buffer.isBuffer(data), 'data', 'buffer');
  return sizeVarint(data.length) + data.length;
}

function sizeVarlen(len) {
  return sizeVarint(len) + len;
}

function sizeVarString(str, enc) {
  if (enc == null)
    enc = 'binary';

  enforce(typeof str === 'string', 'str', 'string');
  enforce(typeof enc === 'string', 'enc', 'string');

  if (str.length === 0)
    return 1;

  const len = Buffer.byteLength(str, enc);

  return sizeVarint(len) + len;
}

/*
 * Helpers
 */

function isSafe(hi, lo) {
  if (hi < 0) {
    hi = ~hi;
    if (lo === 0)
      hi += 1;
  }

  return (hi & 0xffe00000) === 0;
}

function write64(dst, num, off, be) {
  let neg = false;

  if (num < 0) {
    num = -num;
    neg = true;
  }

  let hi = (num * HI) | 0;
  let lo = num | 0;

  if (neg) {
    if (lo === 0) {
      hi = (~hi + 1) | 0;
    } else {
      hi = ~hi;
      lo = ~lo + 1;
    }
  }

  if (be) {
    off = writeI32BE(dst, hi, off);
    off = writeI32BE(dst, lo, off);
  } else {
    off = writeI32(dst, lo, off);
    off = writeI32(dst, hi, off);
  }

  return off;
}

function write56(dst, num, off, be) {
  let neg = false;

  if (num < 0) {
    num = -num;
    neg = true;
  }

  let hi = (num * HI) | 0;
  let lo = num | 0;

  if (neg) {
    if (lo === 0) {
      hi = (~hi + 1) | 0;
    } else {
      hi = ~hi;
      lo = ~lo + 1;
    }
  }

  if (be) {
    off = writeI24BE(dst, hi, off);
    off = writeI32BE(dst, lo, off);
  } else {
    off = writeI32(dst, lo, off);
    off = writeI24(dst, hi, off);
  }

  return off;
}

class Varint {
  constructor(size, value) {
    this.size = size;
    this.value = value;
  }
}

function isNumber(num) {
  return typeof num === 'number' && isFinite(num);
}

function checkRead(value, offset) {
  if (!value)
    throw new EncodingError(offset, 'Out of bounds read', checkRead);
}

function check(value, offset, reason) {
  if (!value)
    throw new EncodingError(offset, reason, check);
}

/*
 * Expose
 */

exports.readU = readU;
exports.readU64 = readU64;
exports.readU56 = readU56;
exports.readU48 = readU48;
exports.readU40 = readU40;
exports.readU32 = readU32;
exports.readU24 = readU24;
exports.readU16 = readU16;
exports.readU8 = readU8;

exports.readUBE = readUBE;
exports.readU64BE = readU64BE;
exports.readU56BE = readU56BE;
exports.readU48BE = readU48BE;
exports.readU40BE = readU40BE;
exports.readU32BE = readU32BE;
exports.readU24BE = readU24BE;
exports.readU16BE = readU16BE;

exports.readI = readI;
exports.readI64 = readI64;
exports.readI56 = readI56;
exports.readI48 = readI48;
exports.readI40 = readI40;
exports.readI32 = readI32;
exports.readI24 = readI24;
exports.readI16 = readI16;
exports.readI8 = readI8;

exports.readIBE = readIBE;
exports.readI64BE = readI64BE;
exports.readI56BE = readI56BE;
exports.readI48BE = readI48BE;
exports.readI40BE = readI40BE;
exports.readI32BE = readI32BE;
exports.readI24BE = readI24BE;
exports.readI16BE = readI16BE;

exports.readFloat = readFloat;
exports.readFloatBE = readFloatBE;
exports.readDouble = readDouble;
exports.readDoubleBE = readDoubleBE;

exports.writeU = writeU;
exports.writeU64 = writeU64;
exports.writeU56 = writeU56;
exports.writeU48 = writeU48;
exports.writeU40 = writeU40;
exports.writeU32 = writeU32;
exports.writeU24 = writeU24;
exports.writeU16 = writeU16;
exports.writeU8 = writeU8;

exports.writeUBE = writeUBE;
exports.writeU64BE = writeU64BE;
exports.writeU56BE = writeU56BE;
exports.writeU48BE = writeU48BE;
exports.writeU40BE = writeU40BE;
exports.writeU32BE = writeU32BE;
exports.writeU24BE = writeU24BE;
exports.writeU16BE = writeU16BE;

exports.writeI = writeI;
exports.writeI64 = writeI64;
exports.writeI56 = writeI56;
exports.writeI48 = writeI48;
exports.writeI40 = writeI40;
exports.writeI32 = writeI32;
exports.writeI24 = writeI24;
exports.writeI16 = writeI16;
exports.writeI8 = writeI8;

exports.writeIBE = writeIBE;
exports.writeI64BE = writeI64BE;
exports.writeI56BE = writeI56BE;
exports.writeI48BE = writeI48BE;
exports.writeI40BE = writeI40BE;
exports.writeI32BE = writeI32BE;
exports.writeI24BE = writeI24BE;
exports.writeI16BE = writeI16BE;

exports.writeFloat = writeFloat;
exports.writeFloatBE = writeFloatBE;
exports.writeDouble = writeDouble;
exports.writeDoubleBE = writeDoubleBE;

exports.readVarint = readVarint;
exports.writeVarint = writeVarint;
exports.sizeVarint = sizeVarint;
exports.readVarint2 = readVarint2;
exports.writeVarint2 = writeVarint2;
exports.sizeVarint2 = sizeVarint2;

exports.sliceBytes = sliceBytes;
exports.readBytes = readBytes;
exports.writeBytes = writeBytes;
exports.readString = readString;
exports.writeString = writeString;

exports.realloc = realloc;
exports.copy = copy;
exports.concat = concat;

exports.sizeVarBytes = sizeVarBytes;
exports.sizeVarlen = sizeVarlen;
exports.sizeVarString = sizeVarString;

}).call(this,req("buffer").Buffer)
},{"./enforce":194,"./error":195,"buffer":303}],194:[function(req,module,exports){
/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

/*
 * Enforce
 */

function enforce(value, name, type) {
  if (!value) {
    const err = new TypeError(`'${name}' must be a(n) ${type}.`);
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, enforce);
    throw err;
  }
}

/*
 * Expose
 */

module.exports = enforce;

},{}],195:[function(req,module,exports){
/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

/**
 * Encoding Error
 * @extends {Error}
 */

class EncodingError extends Error {
  /**
   * Create an encoding error.
   * @constructor
   * @param {Number} offset
   * @param {String} reason
   */

  constructor(offset, reason, start) {
    super();

    this.type = 'EncodingError';
    this.name = 'EncodingError';
    this.code = 'ERR_ENCODING';
    this.message = `${reason} (offset=${offset}).`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, start || EncodingError);
  }
}

/*
 * Expose
 */

module.exports = EncodingError;

},{}],196:[function(req,module,exports){
(function (Buffer){
/*!
 * reader.js - buffer reader for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

const enforce = req('./enforce');
const encoding = req('./encoding');
const EncodingError = req('./error');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);

/**
 * Buffer Reader
 */

class BufferReader {
  /**
   * Create a buffer reader.
   * @constructor
   * @param {Buffer} data
   * @param {Boolean?} zeroCopy - Do not reallocate buffers when
   * slicing. Note that this can lead to memory leaks if not used
   * carefully.
   */

  constructor(data, zeroCopy = false) {
    enforce(Buffer.isBuffer(data), 'data', 'buffer');
    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

    this.data = data;
    this.offset = 0;
    this.zeroCopy = zeroCopy;
    this.stack = [];
  }

  /**
   * Assertion.
   * @param {Number} size
   */

  check(size) {
    if (this.offset + size > this.data.length)
      throw new EncodingError(this.offset, 'Out of bounds read', this.check);
  }

  /**
   * Get total size of passed-in Buffer.
   * @returns {Buffer}
   */

  getSize() {
    return this.data.length;
  }

  /**
   * Calculate number of bytes left to read.
   * @returns {Number}
   */

  left() {
    this.check(0);
    return this.data.length - this.offset;
  }

  /**
   * Seek to a position to read from by offset.
   * @param {Number} off - Offset (positive or negative).
   */

  seek(off) {
    enforce(Number.isSafeInteger(off), 'off', 'integer');

    if (this.offset + off < 0)
      throw new EncodingError(this.offset, 'Out of bounds read');

    this.check(off);
    this.offset += off;

    return this;
  }

  /**
   * Mark the current starting position.
   */

  start() {
    this.stack.push(this.offset);
    return this.offset;
  }

  /**
   * Stop reading. Pop the start position off the stack
   * and calculate the size of the data read.
   * @returns {Number} Size.
   * @throws on empty stack.
   */

  end() {
    if (this.stack.length === 0)
      throw new Error('Cannot end without a stack item.');

    const start = this.stack.pop();

    return this.offset - start;
  }

  /**
   * Stop reading. Pop the start position off the stack
   * and return the data read.
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer} Data read.
   * @throws on empty stack.
   */

  endData(zeroCopy = false) {
    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

    if (this.stack.length === 0)
      throw new Error('Cannot end without a stack item.');

    const start = this.stack.pop();
    const end = this.offset;
    const size = end - start;
    const data = this.data;

    if (size === data.length)
      return data;

    if (this.zeroCopy || zeroCopy)
      return data.slice(start, end);

    const ret = Buffer.allocUnsafe(size);
    data.copy(ret, 0, start, end);

    return ret;
  }

  /**
   * Destroy the reader. Remove references to the data.
   */

  destroy() {
    this.data = EMPTY;
    this.offset = 0;
    this.stack.length = 0;
    return this;
  }

  /**
   * Read uint8.
   * @returns {Number}
   */

  readU8() {
    this.check(1);
    const ret = this.data[this.offset];
    this.offset += 1;
    return ret;
  }

  /**
   * Read uint16le.
   * @returns {Number}
   */

  readU16() {
    this.check(2);
    const ret = encoding.readU16(this.data, this.offset);
    this.offset += 2;
    return ret;
  }

  /**
   * Read uint16be.
   * @returns {Number}
   */

  readU16BE() {
    this.check(2);
    const ret = encoding.readU16BE(this.data, this.offset);
    this.offset += 2;
    return ret;
  }

  /**
   * Read uint24le.
   * @returns {Number}
   */

  readU24() {
    this.check(3);
    const ret = encoding.readU24(this.data, this.offset);
    this.offset += 3;
    return ret;
  }

  /**
   * Read uint24be.
   * @returns {Number}
   */

  readU24BE() {
    this.check(3);
    const ret = encoding.readU24BE(this.data, this.offset);
    this.offset += 3;
    return ret;
  }

  /**
   * Read uint32le.
   * @returns {Number}
   */

  readU32() {
    this.check(4);
    const ret = encoding.readU32(this.data, this.offset);
    this.offset += 4;
    return ret;
  }

  /**
   * Read uint32be.
   * @returns {Number}
   */

  readU32BE() {
    this.check(4);
    const ret = encoding.readU32BE(this.data, this.offset);
    this.offset += 4;
    return ret;
  }

  /**
   * Read uint40le.
   * @returns {Number}
   */

  readU40() {
    this.check(5);
    const ret = encoding.readU40(this.data, this.offset);
    this.offset += 5;
    return ret;
  }

  /**
   * Read uint40be.
   * @returns {Number}
   */

  readU40BE() {
    this.check(5);
    const ret = encoding.readU40BE(this.data, this.offset);
    this.offset += 5;
    return ret;
  }

  /**
   * Read uint48le.
   * @returns {Number}
   */

  readU48() {
    this.check(6);
    const ret = encoding.readU48(this.data, this.offset);
    this.offset += 6;
    return ret;
  }

  /**
   * Read uint48be.
   * @returns {Number}
   */

  readU48BE() {
    this.check(6);
    const ret = encoding.readU48BE(this.data, this.offset);
    this.offset += 6;
    return ret;
  }

  /**
   * Read uint56le.
   * @returns {Number}
   */

  readU56() {
    this.check(7);
    const ret = encoding.readU56(this.data, this.offset);
    this.offset += 7;
    return ret;
  }

  /**
   * Read uint56be.
   * @returns {Number}
   */

  readU56BE() {
    this.check(7);
    const ret = encoding.readU56BE(this.data, this.offset);
    this.offset += 7;
    return ret;
  }

  /**
   * Read uint64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readU64() {
    this.check(8);
    const ret = encoding.readU64(this.data, this.offset);
    this.offset += 8;
    return ret;
  }

  /**
   * Read uint64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readU64BE() {
    this.check(8);
    const ret = encoding.readU64BE(this.data, this.offset);
    this.offset += 8;
    return ret;
  }

  /**
   * Read int8.
   * @returns {Number}
   */

  readI8() {
    this.check(1);
    const ret = encoding.readI8(this.data, this.offset);
    this.offset += 1;
    return ret;
  }

  /**
   * Read int16le.
   * @returns {Number}
   */

  readI16() {
    this.check(2);
    const ret = encoding.readI16(this.data, this.offset);
    this.offset += 2;
    return ret;
  }

  /**
   * Read int16be.
   * @returns {Number}
   */

  readI16BE() {
    this.check(2);
    const ret = encoding.readI16BE(this.data, this.offset);
    this.offset += 2;
    return ret;
  }

  /**
   * Read int24le.
   * @returns {Number}
   */

  readI24() {
    this.check(3);
    const ret = encoding.readI24(this.data, this.offset);
    this.offset += 3;
    return ret;
  }

  /**
   * Read int24be.
   * @returns {Number}
   */

  readI24BE() {
    this.check(3);
    const ret = encoding.readI24BE(this.data, this.offset);
    this.offset += 3;
    return ret;
  }

  /**
   * Read int32le.
   * @returns {Number}
   */

  readI32() {
    this.check(4);
    const ret = encoding.readI32(this.data, this.offset);
    this.offset += 4;
    return ret;
  }

  /**
   * Read int32be.
   * @returns {Number}
   */

  readI32BE() {
    this.check(4);
    const ret = encoding.readI32BE(this.data, this.offset);
    this.offset += 4;
    return ret;
  }

  /**
   * Read int40le.
   * @returns {Number}
   */

  readI40() {
    this.check(5);
    const ret = encoding.readI40(this.data, this.offset);
    this.offset += 5;
    return ret;
  }

  /**
   * Read int40be.
   * @returns {Number}
   */

  readI40BE() {
    this.check(5);
    const ret = encoding.readI40BE(this.data, this.offset);
    this.offset += 5;
    return ret;
  }

  /**
   * Read int48le.
   * @returns {Number}
   */

  readI48() {
    this.check(6);
    const ret = encoding.readI48(this.data, this.offset);
    this.offset += 6;
    return ret;
  }

  /**
   * Read int48be.
   * @returns {Number}
   */

  readI48BE() {
    this.check(6);
    const ret = encoding.readI48BE(this.data, this.offset);
    this.offset += 6;
    return ret;
  }

  /**
   * Read int56le.
   * @returns {Number}
   */

  readI56() {
    this.check(7);
    const ret = encoding.readI56(this.data, this.offset);
    this.offset += 7;
    return ret;
  }

  /**
   * Read int56be.
   * @returns {Number}
   */

  readI56BE() {
    this.check(7);
    const ret = encoding.readI56BE(this.data, this.offset);
    this.offset += 7;
    return ret;
  }

  /**
   * Read int64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readI64() {
    this.check(8);
    const ret = encoding.readI64(this.data, this.offset);
    this.offset += 8;
    return ret;
  }

  /**
   * Read int64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readI64BE() {
    this.check(8);
    const ret = encoding.readI64BE(this.data, this.offset);
    this.offset += 8;
    return ret;
  }

  /**
   * Read float le.
   * @returns {Number}
   */

  readFloat() {
    this.check(4);
    const ret = encoding.readFloat(this.data, this.offset);
    this.offset += 4;
    return ret;
  }

  /**
   * Read float be.
   * @returns {Number}
   */

  readFloatBE() {
    this.check(4);
    const ret = encoding.readFloatBE(this.data, this.offset);
    this.offset += 4;
    return ret;
  }

  /**
   * Read double float le.
   * @returns {Number}
   */

  readDouble() {
    this.check(8);
    const ret = encoding.readDouble(this.data, this.offset);
    this.offset += 8;
    return ret;
  }

  /**
   * Read double float be.
   * @returns {Number}
   */

  readDoubleBE() {
    this.check(8);
    const ret = encoding.readDoubleBE(this.data, this.offset);
    this.offset += 8;
    return ret;
  }

  /**
   * Read a varint.
   * @returns {Number}
   */

  readVarint() {
    const {size, value} = encoding.readVarint(this.data, this.offset);
    this.offset += size;
    return value;
  }

  /**
   * Read a varint (type 2).
   * @returns {Number}
   */

  readVarint2() {
    const {size, value} = encoding.readVarint2(this.data, this.offset);
    this.offset += size;
    return value;
  }

  /**
   * Read N bytes (will do a fast slice if zero copy).
   * @param {Number} size
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */

  readBytes(size, zeroCopy = false) {
    enforce((size >>> 0) === size, 'size', 'integer');
    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

    this.check(size);

    let ret;
    if (this.zeroCopy || zeroCopy) {
      ret = this.data.slice(this.offset, this.offset + size);
    } else {
      ret = Buffer.allocUnsafe(size);
      this.data.copy(ret, 0, this.offset, this.offset + size);
    }

    this.offset += size;

    return ret;
  }

  /**
   * Read a varint number of bytes (will do a fast slice if zero copy).
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */

  readVarBytes(zeroCopy = false) {
    return this.readBytes(this.readVarint(), zeroCopy);
  }

  /**
   * Slice N bytes and create a child reader.
   * @param {Number} size
   * @returns {BufferReader}
   */

  readChild(size) {
    enforce((size >>> 0) === size, 'size', 'integer');

    this.check(size);

    const data = this.data.slice(0, this.offset + size);

    const br = new this.constructor(data);
    br.offset = this.offset;

    this.offset += size;

    return br;
  }

  /**
   * Read a string.
   * @param {Number} size
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */

  readString(size, enc) {
    if (enc == null)
      enc = 'binary';

    enforce((size >>> 0) === size, 'size', 'integer');
    enforce(typeof enc === 'string', 'enc', 'string');

    this.check(size);

    const ret = this.data.toString(enc, this.offset, this.offset + size);

    this.offset += size;

    return ret;
  }

  /**
   * Read a 32-byte hash.
   * @param {String} enc - `"hex"` or `null`.
   * @returns {Hash|Buffer}
   */

  readHash(enc) {
    if (enc)
      return this.readString(32, enc);
    return this.readBytes(32);
  }

  /**
   * Read string of a varint length.
   * @param {String} enc - Any buffer-supported encoding.
   * @param {Number?} limit - Size limit.
   * @returns {String}
   */

  readVarString(enc, limit = 0) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof enc === 'string', 'enc', 'string');
    enforce((limit >>> 0) === limit, 'limit', 'integer');

    const size = this.readVarint();

    if (limit !== 0 && size > limit)
      throw new EncodingError(this.offset, 'String exceeds limit');

    return this.readString(size, enc);
  }

  /**
   * Read a null-terminated string.
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */

  readNullString(enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof enc === 'string', 'enc', 'string');

    let i = this.offset;

    for (; i < this.data.length; i++) {
      if (this.data[i] === 0)
        break;
    }

    if (i === this.data.length)
      throw new EncodingError(this.offset, 'No NUL terminator');

    const ret = this.readString(i - this.offset, enc);

    this.offset = i + 1;

    return ret;
  }

  /**
   * Create a checksum from the last start position.
   * @param {Function} hash
   * @returns {Number} Checksum.
   */

  createChecksum(hash) {
    enforce(typeof hash === 'function', 'hash', 'function');

    let start = 0;

    if (this.stack.length > 0)
      start = this.stack[this.stack.length - 1];

    const data = this.data.slice(start, this.offset);

    return encoding.readU32(hash(data), 0);
  }

  /**
   * Verify a 4-byte checksum against a calculated checksum.
   * @param {Function} hash
   * @returns {Number} checksum
   * @throws on bad checksum
   */

  verifyChecksum(hash) {
    const checksum = this.createChecksum(hash);
    const expect = this.readU32();

    if (checksum !== expect)
      throw new EncodingError(this.offset, 'Checksum mismatch');

    return checksum;
  }
}

/*
 * Expose
 */

module.exports = BufferReader;

}).call(this,req("buffer").Buffer)
},{"./encoding":193,"./enforce":194,"./error":195,"buffer":303}],197:[function(req,module,exports){
(function (Buffer){
/*!
 * staticwriter.js - buffer writer for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

const enforce = req('./enforce');
const encoding = req('./encoding');
const EncodingError = req('./error');

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const POOL_SIZE = 100 << 10;

let POOL = null;

/**
 * Statically Allocated Writer
 */

class StaticWriter {
  /**
   * Statically allocated buffer writer.
   * @constructor
   * @param {Number|Buffer} options
   */

  constructor(options) {
    this.data = EMPTY;
    this.offset = 0;

    if (options != null)
      this.init(options);
  }

  /**
   * Assertion.
   * @param {Number} size
   */

  check(size) {
    if (this.offset + size > this.data.length)
      throw new EncodingError(this.offset, 'Out of bounds write', this.check);
  }

  /**
   * Initialize options.
   * @param {Object} options
   */

  init(options) {
    if (Buffer.isBuffer(options)) {
      this.data = options;
      this.offset = 0;
      return this;
    }

    enforce((options >>> 0) === options, 'size', 'integer');

    this.data = Buffer.allocUnsafe(options);
    this.offset = 0;

    return this;
  }

  /**
   * Allocate writer from preallocated 100kb pool.
   * @param {Number} size
   * @returns {StaticWriter}
   */

  static pool(size) {
    enforce((size >>> 0) === size, 'size', 'integer');

    if (size <= POOL_SIZE) {
      if (!POOL)
        POOL = Buffer.allocUnsafe(POOL_SIZE);

      const bw = new StaticWriter();
      bw.data = POOL.slice(0, size);
      return bw;
    }

    return new StaticWriter(size);
  }

  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */

  render() {
    const {data, offset} = this;

    if (offset !== data.length)
      throw new EncodingError(offset, 'Out of bounds write');

    this.destroy();

    return data;
  }

  /**
   * Slice the final buffer at written offset.
   * @returns {Buffer} Rendered buffer.
   */

  slice() {
    const {data, offset} = this;

    if (offset > data.length)
      throw new EncodingError(offset, 'Out of bounds write');

    this.destroy();

    return data.slice(0, offset);
  }

  /**
   * Get size of data written so far.
   * @returns {Number}
   */

  getSize() {
    return this.offset;
  }

  /**
   * Seek to relative offset.
   * @param {Number} off
   */

  seek(off) {
    enforce(Number.isSafeInteger(off), 'off', 'integer');

    if (this.offset + off < 0)
      throw new EncodingError(this.offset, 'Out of bounds write');

    this.check(off);
    this.offset += off;

    return this;
  }

  /**
   * Destroy the buffer writer.
   */

  destroy() {
    this.data = EMPTY;
    this.offset = 0;
    return this;
  }

  /**
   * Write uint8.
   * @param {Number} value
   */

  writeU8(value) {
    this.check(1);
    this.offset = encoding.writeU8(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint16le.
   * @param {Number} value
   */

  writeU16(value) {
    this.check(2);
    this.offset = encoding.writeU16(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint16be.
   * @param {Number} value
   */

  writeU16BE(value) {
    this.check(2);
    this.offset = encoding.writeU16BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint24le.
   * @param {Number} value
   */

  writeU24(value) {
    this.check(3);
    this.offset = encoding.writeU24(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint24be.
   * @param {Number} value
   */

  writeU24BE(value) {
    this.check(3);
    this.offset = encoding.writeU24BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint32le.
   * @param {Number} value
   */

  writeU32(value) {
    this.check(4);
    this.offset = encoding.writeU32(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint32be.
   * @param {Number} value
   */

  writeU32BE(value) {
    this.check(4);
    this.offset = encoding.writeU32BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint40le.
   * @param {Number} value
   */

  writeU40(value) {
    this.check(5);
    this.offset = encoding.writeU40(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint40be.
   * @param {Number} value
   */

  writeU40BE(value) {
    this.check(5);
    this.offset = encoding.writeU40BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint48le.
   * @param {Number} value
   */

  writeU48(value) {
    this.check(6);
    this.offset = encoding.writeU48(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint48be.
   * @param {Number} value
   */

  writeU48BE(value) {
    this.check(6);
    this.offset = encoding.writeU48BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint56le.
   * @param {Number} value
   */

  writeU56(value) {
    this.check(7);
    this.offset = encoding.writeU56(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint56be.
   * @param {Number} value
   */

  writeU56BE(value) {
    this.check(7);
    this.offset = encoding.writeU56BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint64le.
   * @param {Number} value
   */

  writeU64(value) {
    this.check(8);
    this.offset = encoding.writeU64(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint64be.
   * @param {Number} value
   */

  writeU64BE(value) {
    this.check(8);
    this.offset = encoding.writeU64BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int8.
   * @param {Number} value
   */

  writeI8(value) {
    this.check(1);
    this.offset = encoding.writeI8(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int16le.
   * @param {Number} value
   */

  writeI16(value) {
    this.check(2);
    this.offset = encoding.writeI16(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int16be.
   * @param {Number} value
   */

  writeI16BE(value) {
    this.check(2);
    this.offset = encoding.writeI16BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int24le.
   * @param {Number} value
   */

  writeI24(value) {
    this.check(3);
    this.offset = encoding.writeI24(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int24be.
   * @param {Number} value
   */

  writeI24BE(value) {
    this.check(3);
    this.offset = encoding.writeI24BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int32le.
   * @param {Number} value
   */

  writeI32(value) {
    this.check(4);
    this.offset = encoding.writeI32(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int32be.
   * @param {Number} value
   */

  writeI32BE(value) {
    this.check(4);
    this.offset = encoding.writeI32BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int40le.
   * @param {Number} value
   */

  writeI40(value) {
    this.check(5);
    this.offset = encoding.writeI40(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int40be.
   * @param {Number} value
   */

  writeI40BE(value) {
    this.check(5);
    this.offset = encoding.writeI40BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int48le.
   * @param {Number} value
   */

  writeI48(value) {
    this.check(6);
    this.offset = encoding.writeI48(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int48be.
   * @param {Number} value
   */

  writeI48BE(value) {
    this.check(6);
    this.offset = encoding.writeI48BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int56le.
   * @param {Number} value
   */

  writeI56(value) {
    this.check(7);
    this.offset = encoding.writeI56(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int56be.
   * @param {Number} value
   */

  writeI56BE(value) {
    this.check(7);
    this.offset = encoding.writeI56BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int64le.
   * @param {Number} value
   */

  writeI64(value) {
    this.check(8);
    this.offset = encoding.writeI64(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int64be.
   * @param {Number} value
   */

  writeI64BE(value) {
    this.check(8);
    this.offset = encoding.writeI64BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write float le.
   * @param {Number} value
   */

  writeFloat(value) {
    this.check(4);
    this.offset = encoding.writeFloat(this.data, value, this.offset);
    return this;
  }

  /**
   * Write float be.
   * @param {Number} value
   */

  writeFloatBE(value) {
    this.check(4);
    this.offset = encoding.writeFloatBE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write double le.
   * @param {Number} value
   */

  writeDouble(value) {
    this.check(8);
    this.offset = encoding.writeDouble(this.data, value, this.offset);
    return this;
  }

  /**
   * Write double be.
   * @param {Number} value
   */

  writeDoubleBE(value) {
    this.check(8);
    this.offset = encoding.writeDoubleBE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write a varint.
   * @param {Number} value
   */

  writeVarint(value) {
    this.offset = encoding.writeVarint(this.data, value, this.offset);
    return this;
  }

  /**
   * Write a varint (type 2).
   * @param {Number} value
   */

  writeVarint2(value) {
    this.offset = encoding.writeVarint2(this.data, value, this.offset);
    return this;
  }

  /**
   * Write bytes.
   * @param {Buffer} value
   */

  writeBytes(value) {
    enforce(Buffer.isBuffer(value), 'value', 'buffer');
    this.check(value.length);
    this.offset += value.copy(this.data, this.offset);
    return this;
  }

  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */

  writeVarBytes(value) {
    enforce(Buffer.isBuffer(value), 'value', 'buffer');
    this.writeVarint(value.length);
    this.writeBytes(value);
    return this;
  }

  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */

  copy(value, start, end) {
    enforce(Buffer.isBuffer(value), 'value', 'buffer');
    enforce((start >>> 0) === start, 'start', 'integer');
    enforce((end >>> 0) === end, 'end', 'integer');
    enforce(end >= start, 'start', 'integer');

    this.check(end - start);
    this.offset += value.copy(this.data, this.offset, start, end);

    return this;
  }

  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0)
      return this;

    const size = Buffer.byteLength(value, enc);
    this.check(size);

    this.offset += this.data.write(value, this.offset, enc);

    return this;
  }

  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */

  writeHash(value) {
    if (typeof value !== 'string') {
      enforce(Buffer.isBuffer(value), 'value', 'buffer');
      enforce(value.length === 32, 'value', '32-byte hash');
      this.writeBytes(value);
      return this;
    }
    enforce(value.length === 64, 'value', '32-byte hash');
    this.check(32);
    this.offset += this.data.write(value, this.offset, 'hex');
    return this;
  }

  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeVarString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0) {
      this.writeVarint(0);
      return this;
    }

    const size = Buffer.byteLength(value, enc);

    this.writeVarint(size);
    this.check(size);
    this.offset += this.data.write(value, this.offset, enc);

    return this;
  }

  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeNullString(value, enc) {
    this.writeString(value, enc);
    this.writeU8(0);
    return this;
  }

  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */

  writeChecksum(hash) {
    enforce(typeof hash === 'function', 'hash', 'function');

    this.check(4);

    const data = this.data.slice(0, this.offset);

    hash(data).copy(this.data, this.offset, 0, 4);

    this.offset += 4;

    return this;
  }

  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */

  fill(value, size) {
    enforce((value & 0xff) === value, 'value', 'byte');
    enforce((size >>> 0) === size, 'size', 'integer');

    this.check(size);

    this.data.fill(value, this.offset, this.offset + size);
    this.offset += size;

    return this;
  }
}

/*
 * Expose
 */

module.exports = StaticWriter;

}).call(this,req("buffer").Buffer)
},{"./encoding":193,"./enforce":194,"./error":195,"buffer":303}],198:[function(req,module,exports){
(function (Buffer){
/*!
 * struct.js - struct object for bcoin
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

const enforce = req('./enforce');
const BufferReader = req('./reader');
const BufferWriter = req('./writer');
const StaticWriter = req('./staticwriter');
const {custom} = req('./custom');

/**
 * Struct
 */

class Struct {
  constructor() {}

  inject(obj) {
    enforce(obj instanceof this.constructor, 'obj', 'struct');
    return this.decode(obj.encode());
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  /*
   * Bindable
   */

  getSize(extra) {
    return -1;
  }

  write(bw, extra) {
    return bw;
  }

  read(br, extra) {
    return this;
  }

  toString() {
    return Object.prototype.toString.call(this);
  }

  fromString(str, extra) {
    return this;
  }

  getJSON() {
    return this;
  }

  fromJSON(json, extra) {
    return this;
  }

  fromOptions(options, extra) {
    return this;
  }

  from(options, extra) {
    return this.fromOptions(options, extra);
  }

  format() {
    return this.getJSON();
  }

  /*
   * API
   */

  encode(extra) {
    const size = this.getSize(extra);
    const bw = size === -1
      ? new BufferWriter()
      : new StaticWriter(size);
    this.write(bw, extra);
    return bw.render();
  }

  decode(data, extra) {
    const br = new BufferReader(data);
    this.read(br, extra);
    return this;
  }

  toHex(extra) {
    return this.encode(extra).toString('hex');
  }

  fromHex(str, extra) {
    enforce(typeof str === 'string', 'str', 'string');

    const size = str.length >>> 1;
    const data = Buffer.from(str, 'hex');

    if (data.length !== size)
      throw new Error('Invalid hex string.');

    return this.decode(data, extra);
  }

  toBase64(extra) {
    return this.encode(extra).toString('base64');
  }

  fromBase64(str, extra) {
    enforce(typeof str === 'string', 'str', 'string');

    const data = Buffer.from(str, 'base64');

    if (str.length > size64(data.length))
      throw new Error('Invalid base64 string.');

    return this.decode(data, extra);
  }

  toJSON() {
    return this.getJSON();
  }

  [custom]() {
    return this.format();
  }

  /*
   * Static API
   */

  static read(br, extra) {
    return new this().read(br, extra);
  }

  static decode(data, extra) {
    return new this().decode(data, extra);
  }

  static fromHex(str, extra) {
    return new this().fromHex(str, extra);
  }

  static fromBase64(str, extra) {
    return new this().fromBase64(str, extra);
  }

  static fromString(str, extra) {
    return new this().fromString(str, extra);
  }

  static fromJSON(json, extra) {
    return new this().fromJSON(json, extra);
  }

  static fromOptions(options, extra) {
    return new this().fromOptions(options, extra);
  }

  static from(options, extra) {
    return new this().from(options, extra);
  }

  /*
   * Aliases
   */

  toWriter(bw, extra) {
    return this.write(bw, extra);
  }

  fromReader(br, extra) {
    return this.read(br, extra);
  }

  toRaw(extra) {
    return this.encode(extra);
  }

  fromRaw(data, extra) {
    return this.decode(data, extra);
  }

  /*
   * Static Aliases
   */

  static fromReader(br, extra) {
    return this.read(br, extra);
  }

  static fromRaw(data, extra) {
    return this.decode(data, extra);
  }
}

/*
 * Helpers
 */

function size64(size) {
  const expect = ((4 * size / 3) + 3) & ~3;
  return expect >>> 0;
}

/*
 * Expose
 */

module.exports = Struct;

}).call(this,req("buffer").Buffer)
},{"./custom":192,"./enforce":194,"./reader":196,"./staticwriter":197,"./writer":199,"buffer":303}],199:[function(req,module,exports){
(function (Buffer){
/*!
 * writer.js - buffer writer for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

'use strict';

const enforce = req('./enforce');
const encoding = req('./encoding');
const EncodingError = req('./error');

/*
 * Constants
 */

const SEEK = 0;
const U8 = 1;
const U16 = 2;
const U16BE = 3;
const U24 = 4;
const U24BE = 5;
const U32 = 6;
const U32BE = 7;
const U40 = 8;
const U40BE = 9;
const U48 = 10;
const U48BE = 11;
const U56 = 12;
const U56BE = 13;
const U64 = 14;
const U64BE = 15;
const I8 = 16;
const I16 = 17;
const I16BE = 18;
const I24 = 19;
const I24BE = 20;
const I32 = 21;
const I32BE = 22;
const I40 = 23;
const I40BE = 24;
const I48 = 25;
const I48BE = 26;
const I56 = 27;
const I56BE = 28;
const I64 = 29;
const I64BE = 30;
const FL = 31;
const FLBE = 32;
const DBL = 33;
const DBLBE = 34;
const VARINT = 35;
const VARINT2 = 36;
const BYTES = 37;
const STR = 38;
const CHECKSUM = 39;
const FILL = 40;

/**
 * Buffer Writer
 */

class BufferWriter {
  /**
   * Create a buffer writer.
   * @constructor
   */

  constructor() {
    this.ops = [];
    this.offset = 0;
  }

  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */

  render() {
    const data = Buffer.allocUnsafe(this.offset);

    let off = 0;

    for (const op of this.ops) {
      switch (op.type) {
        case SEEK:
          off += op.value;
          break;
        case U8:
          off = encoding.writeU8(data, op.value, off);
          break;
        case U16:
          off = encoding.writeU16(data, op.value, off);
          break;
        case U16BE:
          off = encoding.writeU16BE(data, op.value, off);
          break;
        case U24:
          off = encoding.writeU24(data, op.value, off);
          break;
        case U24BE:
          off = encoding.writeU24BE(data, op.value, off);
          break;
        case U32:
          off = encoding.writeU32(data, op.value, off);
          break;
        case U32BE:
          off = encoding.writeU32BE(data, op.value, off);
          break;
        case U40:
          off = encoding.writeU40(data, op.value, off);
          break;
        case U40BE:
          off = encoding.writeU40BE(data, op.value, off);
          break;
        case U48:
          off = encoding.writeU48(data, op.value, off);
          break;
        case U48BE:
          off = encoding.writeU48BE(data, op.value, off);
          break;
        case U56:
          off = encoding.writeU56(data, op.value, off);
          break;
        case U56BE:
          off = encoding.writeU56BE(data, op.value, off);
          break;
        case U64:
          off = encoding.writeU64(data, op.value, off);
          break;
        case U64BE:
          off = encoding.writeU64BE(data, op.value, off);
          break;
        case I8:
          off = encoding.writeI8(data, op.value, off);
          break;
        case I16:
          off = encoding.writeI16(data, op.value, off);
          break;
        case I16BE:
          off = encoding.writeI16BE(data, op.value, off);
          break;
        case I24:
          off = encoding.writeI24(data, op.value, off);
          break;
        case I24BE:
          off = encoding.writeI24BE(data, op.value, off);
          break;
        case I32:
          off = encoding.writeI32(data, op.value, off);
          break;
        case I32BE:
          off = encoding.writeI32BE(data, op.value, off);
          break;
        case I40:
          off = encoding.writeI40(data, op.value, off);
          break;
        case I40BE:
          off = encoding.writeI40BE(data, op.value, off);
          break;
        case I48:
          off = encoding.writeI48(data, op.value, off);
          break;
        case I48BE:
          off = encoding.writeI48BE(data, op.value, off);
          break;
        case I56:
          off = encoding.writeI56(data, op.value, off);
          break;
        case I56BE:
          off = encoding.writeI56BE(data, op.value, off);
          break;
        case I64:
          off = encoding.writeI64(data, op.value, off);
          break;
        case I64BE:
          off = encoding.writeI64BE(data, op.value, off);
          break;
        case FL:
          off = encoding.writeFloat(data, op.value, off);
          break;
        case FLBE:
          off = encoding.writeFloatBE(data, op.value, off);
          break;
        case DBL:
          off = encoding.writeDouble(data, op.value, off);
          break;
        case DBLBE:
          off = encoding.writeDoubleBE(data, op.value, off);
          break;
        case VARINT:
          off = encoding.writeVarint(data, op.value, off);
          break;
        case VARINT2:
          off = encoding.writeVarint2(data, op.value, off);
          break;
        case BYTES:
          off += op.data.copy(data, off);
          break;
        case STR:
          off += data.write(op.value, off, op.enc);
          break;
        case CHECKSUM:
          off += op.func(data.slice(0, off)).copy(data, off, 0, 4);
          break;
        case FILL:
          data.fill(op.value, off, off + op.size);
          off += op.size;
          break;
        default:
          throw new Error('Invalid type.');
      }
    }

    if (off !== data.length)
      throw new EncodingError(off, 'Out of bounds write');

    this.destroy();

    return data;
  }

  /**
   * Get size of data written so far.
   * @returns {Number}
   */

  getSize() {
    return this.offset;
  }

  /**
   * Seek to relative offset.
   * @param {Number} offset
   */

  seek(off) {
    enforce(Number.isSafeInteger(off), 'off', 'integer');

    if (this.offset + off < 0)
      throw new EncodingError(this.offset, 'Out of bounds write');

    this.offset += off;
    this.ops.push(new NumberOp(SEEK, off));

    return this;
  }

  /**
   * Destroy the buffer writer. Remove references to `ops`.
   */

  destroy() {
    this.ops.length = 0;
    this.offset = 0;
    return this;
  }

  /**
   * Write uint8.
   * @param {Number} value
   */

  writeU8(value) {
    this.offset += 1;
    this.ops.push(new NumberOp(U8, value));
    return this;
  }

  /**
   * Write uint16le.
   * @param {Number} value
   */

  writeU16(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(U16, value));
    return this;
  }

  /**
   * Write uint16be.
   * @param {Number} value
   */

  writeU16BE(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(U16BE, value));
    return this;
  }

  /**
   * Write uint24le.
   * @param {Number} value
   */

  writeU24(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(U24, value));
    return this;
  }

  /**
   * Write uint24be.
   * @param {Number} value
   */

  writeU24BE(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(U24BE, value));
    return this;
  }

  /**
   * Write uint32le.
   * @param {Number} value
   */

  writeU32(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(U32, value));
    return this;
  }

  /**
   * Write uint32be.
   * @param {Number} value
   */

  writeU32BE(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(U32BE, value));
    return this;
  }

  /**
   * Write uint40le.
   * @param {Number} value
   */

  writeU40(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(U40, value));
    return this;
  }

  /**
   * Write uint40be.
   * @param {Number} value
   */

  writeU40BE(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(U40BE, value));
    return this;
  }

  /**
   * Write uint48le.
   * @param {Number} value
   */

  writeU48(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(U48, value));
    return this;
  }

  /**
   * Write uint48be.
   * @param {Number} value
   */

  writeU48BE(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(U48BE, value));
    return this;
  }

  /**
   * Write uint56le.
   * @param {Number} value
   */

  writeU56(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(U56, value));
    return this;
  }

  /**
   * Write uint56be.
   * @param {Number} value
   */

  writeU56BE(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(U56BE, value));
    return this;
  }

  /**
   * Write uint64le.
   * @param {Number} value
   */

  writeU64(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(U64, value));
    return this;
  }

  /**
   * Write uint64be.
   * @param {Number} value
   */

  writeU64BE(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(U64BE, value));
    return this;
  }

  /**
   * Write int8.
   * @param {Number} value
   */

  writeI8(value) {
    this.offset += 1;
    this.ops.push(new NumberOp(I8, value));
    return this;
  }

  /**
   * Write int16le.
   * @param {Number} value
   */

  writeI16(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(I16, value));
    return this;
  }

  /**
   * Write int16be.
   * @param {Number} value
   */

  writeI16BE(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(I16BE, value));
    return this;
  }

  /**
   * Write int24le.
   * @param {Number} value
   */

  writeI24(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(I24, value));
    return this;
  }

  /**
   * Write int24be.
   * @param {Number} value
   */

  writeI24BE(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(I24BE, value));
    return this;
  }

  /**
   * Write int32le.
   * @param {Number} value
   */

  writeI32(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(I32, value));
    return this;
  }

  /**
   * Write int32be.
   * @param {Number} value
   */

  writeI32BE(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(I32BE, value));
    return this;
  }

  /**
   * Write int40le.
   * @param {Number} value
   */

  writeI40(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(I40, value));
    return this;
  }

  /**
   * Write int40be.
   * @param {Number} value
   */

  writeI40BE(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(I40BE, value));
    return this;
  }

  /**
   * Write int48le.
   * @param {Number} value
   */

  writeI48(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(I48, value));
    return this;
  }

  /**
   * Write int48be.
   * @param {Number} value
   */

  writeI48BE(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(I48BE, value));
    return this;
  }

  /**
   * Write int56le.
   * @param {Number} value
   */

  writeI56(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(I56, value));
    return this;
  }

  /**
   * Write int56be.
   * @param {Number} value
   */

  writeI56BE(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(I56BE, value));
    return this;
  }

  /**
   * Write int64le.
   * @param {Number} value
   */

  writeI64(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(I64, value));
    return this;
  }

  /**
   * Write int64be.
   * @param {Number} value
   */

  writeI64BE(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(I64BE, value));
    return this;
  }

  /**
   * Write float le.
   * @param {Number} value
   */

  writeFloat(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(FL, value));
    return this;
  }

  /**
   * Write float be.
   * @param {Number} value
   */

  writeFloatBE(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(FLBE, value));
    return this;
  }

  /**
   * Write double le.
   * @param {Number} value
   */

  writeDouble(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(DBL, value));
    return this;
  }

  /**
   * Write double be.
   * @param {Number} value
   */

  writeDoubleBE(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(DBLBE, value));
    return this;
  }

  /**
   * Write a varint.
   * @param {Number} value
   */

  writeVarint(value) {
    this.offset += encoding.sizeVarint(value);
    this.ops.push(new NumberOp(VARINT, value));
    return this;
  }

  /**
   * Write a varint (type 2).
   * @param {Number} value
   */

  writeVarint2(value) {
    this.offset += encoding.sizeVarint2(value);
    this.ops.push(new NumberOp(VARINT2, value));
    return this;
  }

  /**
   * Write bytes.
   * @param {Buffer} value
   */

  writeBytes(value) {
    enforce(Buffer.isBuffer(value), 'value', 'buffer');

    if (value.length === 0)
      return this;

    this.offset += value.length;
    this.ops.push(new BufferOp(BYTES, value));

    return this;
  }

  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */

  writeVarBytes(value) {
    enforce(Buffer.isBuffer(value), 'value', 'buffer');

    this.offset += encoding.sizeVarint(value.length);
    this.ops.push(new NumberOp(VARINT, value.length));

    if (value.length === 0)
      return this;

    this.offset += value.length;
    this.ops.push(new BufferOp(BYTES, value));

    return this;
  }

  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */

  copy(value, start, end) {
    enforce(Buffer.isBuffer(value), 'value', 'buffer');
    enforce((start >>> 0) === start, 'start', 'integer');
    enforce((end >>> 0) === end, 'end', 'integer');
    enforce(end >= start, 'start', 'integer');

    const buf = value.slice(start, end);

    this.writeBytes(buf);

    return this;
  }

  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0)
      return this;

    this.offset += Buffer.byteLength(value, enc);
    this.ops.push(new StringOp(STR, value, enc));

    return this;
  }

  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */

  writeHash(value) {
    if (typeof value !== 'string') {
      enforce(Buffer.isBuffer(value), 'value', 'buffer');
      enforce(value.length === 32, 'value', '32-byte hash');
      this.writeBytes(value);
      return this;
    }
    enforce(value.length === 64, 'value', '32-byte hash');
    this.writeString(value, 'hex');
    return this;
  }

  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeVarString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0) {
      this.ops.push(new NumberOp(VARINT, 0));
      return this;
    }

    const size = Buffer.byteLength(value, enc);

    this.offset += encoding.sizeVarint(size);
    this.offset += size;

    this.ops.push(new NumberOp(VARINT, size));
    this.ops.push(new StringOp(STR, value, enc));

    return this;
  }

  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeNullString(value, enc) {
    this.writeString(value, enc);
    this.writeU8(0);
    return this;
  }

  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */

  writeChecksum(hash) {
    enforce(typeof hash === 'function', 'hash', 'function');
    this.offset += 4;
    this.ops.push(new FunctionOp(CHECKSUM, hash));
    return this;
  }

  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */

  fill(value, size) {
    enforce((value & 0xff) === value, 'value', 'byte');
    enforce((size >>> 0) === size, 'size', 'integer');

    if (size === 0)
      return this;

    this.offset += size;
    this.ops.push(new FillOp(FILL, value, size));

    return this;
  }
}

/*
 * Helpers
 */

class WriteOp {
  constructor(type) {
    this.type = type;
  }
}

class NumberOp extends WriteOp {
  constructor(type, value) {
    super(type);
    this.value = value;
  }
}

class BufferOp extends WriteOp {
  constructor(type, data) {
    super(type);
    this.data = data;
  }
}

class StringOp extends WriteOp {
  constructor(type, value, enc) {
    super(type);
    this.value = value;
    this.enc = enc;
  }
}

class FunctionOp extends WriteOp {
  constructor(type, func) {
    super(type);
    this.func = func;
  }
}

class FillOp extends WriteOp {
  constructor(type, value, size) {
    super(type);
    this.value = value;
    this.size = size;
  }
}

/*
 * Expose
 */

module.exports = BufferWriter;

}).call(this,req("buffer").Buffer)
},{"./encoding":193,"./enforce":194,"./error":195,"buffer":303}],200:[function(req,module,exports){
var objectKeys = req('object-keys');
var isArguments = req('is-arguments');
var is = req('object-is');
var isRegex = req('is-regex');
var flags = req('regexp.prototype.flags');
var isDate = req('is-date-object');

var getTime = Date.prototype.getTime;

function deepEqual(actual, expected, options) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? is(actual, expected) : actual === expected) {
    return true;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
    return opts.strict ? is(actual, expected) : actual == expected;
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // eslint-disable-next-line no-use-before-define
  return objEquiv(actual, expected, opts);
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }
  return true;
}

function objEquiv(a, b, opts) {
  /* eslint max-statements: [2, 50] */
  var i, key;
  if (typeof a !== typeof b) { return false; }
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) { return false; }

  if (isArguments(a) !== isArguments(b)) { return false; }

  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) { return false; }
  if (aIsRegex || bIsRegex) {
    return a.source === b.source && flags(a) === flags(b);
  }

  if (isDate(a) && isDate(b)) {
    return getTime.call(a) === getTime.call(b);
  }

  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) { return false; }
  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
    if (a.length !== b.length) { return false; }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  if (typeof a !== typeof b) { return false; }

  try {
    var ka = objectKeys(a);
    var kb = objectKeys(b);
  } catch (e) { // happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) { return false; }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) { return false; }
  }
  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) { return false; }
  }

  return true;
}

module.exports = deepEqual;

},{"is-arguments":230,"is-date-object":231,"is-regex":233,"object-is":238,"object-keys":240,"regexp.prototype.flags":254}],201:[function(req,module,exports){
'use strict';

var keys = req('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"object-keys":240}],202:[function(req,module,exports){
'use strict';

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

},{}],203:[function(req,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],204:[function(req,module,exports){
'use strict';

var implementation = req('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":203}],205:[function(req,module,exports){
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function(obj, prop, a, b, c) {
  if (!isObject(obj) || !prop) {
    return obj;
  }

  prop = toString(prop);

  // allowing for multiple properties to be passed as
  // a string or array, but much faster (3-4x) than doing
  // `[].slice.call(arguments)`
  if (a) prop += '.' + toString(a);
  if (b) prop += '.' + toString(b);
  if (c) prop += '.' + toString(c);

  if (prop in obj) {
    return obj[prop];
  }

  var segs = prop.split('.');
  var len = segs.length;
  var i = -1;

  while (obj && (++i < len)) {
    var key = segs[i];
    while (key[key.length - 1] === '\\') {
      key = key.slice(0, -1) + '.' + segs[++i];
    }
    obj = obj[key];
  }
  return obj;
};

function isObject(val) {
  return val !== null && (typeof val === 'object' || typeof val === 'function');
}

function toString(val) {
  if (!val) return '';
  if (Array.isArray(val)) {
    return val.join('.');
  }
  return val;
}

},{}],206:[function(req,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

var parser = req('graphql/language/parser');

var parse = parser.parse;

// Strip insignificant whitespace
// Note that this could do a lot more, such as reorder fields etc.
function normalize(string) {
  return string.replace(/[\s,]+/g, ' ').trim();
}

// A map docString -> graphql document
var docCache = {};

// A map fragmentName -> [normalized source]
var fragmentSourceMap = {};

function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}

// For testing.
function resetCaches() {
  docCache = {};
  fragmentSourceMap = {};
}

// Take a unstripped parsed document (query/mutation or even fragment), and
// check all fragment definitions, checking for name->source uniqueness.
// We also want to make sure only unique fragments exist in the document.
var printFragmentWarnings = true;
function processFragments(ast) {
  var astFragmentMap = {};
  var definitions = [];

  for (var i = 0; i < ast.definitions.length; i++) {
    var fragmentDefinition = ast.definitions[i];

    if (fragmentDefinition.kind === 'FragmentDefinition') {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);

      // We know something about this fragment
      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {

        // this is a problem because the app developer is trying to register another fragment with
        // the same name as one previously registered. So, we tell them about it.
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\n"
            + "graphql-tag enforces all fragment names across your application to be unique; read more about\n"
            + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }

        fragmentSourceMap[fragmentName][sourceKey] = true;

      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
        fragmentSourceMap[fragmentName] = {};
        fragmentSourceMap[fragmentName][sourceKey] = true;
      }

      if (!astFragmentMap[sourceKey]) {
        astFragmentMap[sourceKey] = true;
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  }

  ast.definitions = definitions;
  return ast;
}

function disableFragmentWarnings() {
  printFragmentWarnings = false;
}

function stripLoc(doc, removeLocAtThisLevel) {
  var docType = Object.prototype.toString.call(doc);

  if (docType === '[object Array]') {
    return doc.map(function (d) {
      return stripLoc(d, removeLocAtThisLevel);
    });
  }

  if (docType !== '[object Object]') {
    throw new Error('Unexpected input.');
  }

  // We don't want to remove the root loc field so we can use it
  // for fragment substitution (see below)
  if (removeLocAtThisLevel && doc.loc) {
    delete doc.loc;
  }

  // https://github.com/apollographql/graphql-tag/issues/40
  if (doc.loc) {
    delete doc.loc.startToken;
    delete doc.loc.endToken;
  }

  var keys = Object.keys(doc);
  var key;
  var value;
  var valueType;

  for (key in keys) {
    if (keys.hasOwnProperty(key)) {
      value = doc[keys[key]];
      valueType = Object.prototype.toString.call(value);

      if (valueType === '[object Object]' || valueType === '[object Array]') {
        doc[keys[key]] = stripLoc(value, true);
      }
    }
  }

  return doc;
}

var experimentalFragmentVariables = false;
function parseDocument(doc) {
  var cacheKey = normalize(doc);

  if (docCache[cacheKey]) {
    return docCache[cacheKey];
  }

  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });
  if (!parsed || parsed.kind !== 'Document') {
    throw new Error('Not a valid GraphQL document.');
  }

  // check that all "new" fragments inside the documents are consistent with
  // existing fragments of the same name
  parsed = processFragments(parsed);
  parsed = stripLoc(parsed, false);
  docCache[cacheKey] = parsed;

  return parsed;
}

function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}

function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}

// XXX This should eventually disallow arbitrary string interpolation, like Relay does
function gql(/* arguments */) {
  var args = Array.prototype.slice.call(arguments);

  var literals = args[0];

  // We always get literals[0] and then matching post literals for each arg given
  var result = (typeof(literals) === "string") ? literals : literals[0];

  for (var i = 1; i < args.length; i++) {
    if (args[i] && args[i].kind && args[i].kind === 'Document') {
      result += args[i].loc.source.body;
    } else {
      result += args[i];
    }

    result += literals[i];
  }

  return parseDocument(result);
}

// Support typescript, which isn't as nice as Babel about default exports
gql.default = gql;
gql.resetCaches = resetCaches;
gql.disableFragmentWarnings = disableFragmentWarnings;
gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

module.exports = gql;

})));


},{"graphql/language/parser":220}],207:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLError = GraphQLError;
exports.printError = printError;

var _isObjectLike = _interopreqDefault(req("../jsutils/isObjectLike"));

var _location = req("../language/location");

var _printLocation = req("../language/printLocation");

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GraphQLError( // eslint-disable-line no-redeclare
message, nodes, source, positions, path, originalError, extensions) {
  // Compute list of blame nodes.
  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


  var _source = source;

  if (!_source && _nodes) {
    var node = _nodes[0];
    _source = node && node.loc && node.loc.source;
  }

  var _positions = positions;

  if (!_positions && _nodes) {
    _positions = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push(node.loc.start);
      }

      return list;
    }, []);
  }

  if (_positions && _positions.length === 0) {
    _positions = undefined;
  }

  var _locations;

  if (positions && source) {
    _locations = positions.map(function (pos) {
      return (0, _location.getLocation)(source, pos);
    });
  } else if (_nodes) {
    _locations = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push((0, _location.getLocation)(node.loc.source, node.loc.start));
      }

      return list;
    }, []);
  }

  var _extensions = extensions;

  if (_extensions == null && originalError != null) {
    var originalExtensions = originalError.extensions;

    if ((0, _isObjectLike.default)(originalExtensions)) {
      _extensions = originalExtensions;
    }
  }

  Object.defineProperties(this, {
    message: {
      value: message,
      // By being enumerable, JSON.stringify will include `message` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: true,
      writable: true
    },
    locations: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _locations || undefined,
      // By being enumerable, JSON.stringify will include `locations` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_locations)
    },
    path: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: path || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(path)
    },
    nodes: {
      value: _nodes || undefined
    },
    source: {
      value: _source || undefined
    },
    positions: {
      value: _positions || undefined
    },
    originalError: {
      value: originalError
    },
    extensions: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _extensions || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_extensions)
    }
  }); // Include (non-enumerable) stack trace.

  if (originalError && originalError.stack) {
    Object.defineProperty(this, 'stack', {
      value: originalError.stack,
      writable: true,
      configurable: true
    });
  } else if (Error.captureStackTrace) {
    Error.captureStackTrace(this, GraphQLError);
  } else {
    Object.defineProperty(this, 'stack', {
      value: Error().stack,
      writable: true,
      configurable: true
    });
  }
}

GraphQLError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: GraphQLError
  },
  name: {
    value: 'GraphQLError'
  },
  toString: {
    value: function toString() {
      return printError(this);
    }
  }
});
/**
 * Prints a GraphQLError to a string, representing useful location information
 * about the error's position in the source.
 */

function printError(error) {
  var output = error.message;

  if (error.nodes) {
    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];

      if (node.loc) {
        output += '\n\n' + (0, _printLocation.printLocation)(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
      var location = _error$locations2[_i4];
      output += '\n\n' + (0, _printLocation.printSourceLocation)(error.source, location);
    }
  }

  return output;
}

},{"../jsutils/isObjectLike":213,"../language/location":219,"../language/printLocation":221}],208:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.syntaxError = syntaxError;

var _GraphQLError = req("./GraphQLError");

/**
 * Produces a GraphQLError representing a syntax error, containing useful
 * descriptive information about the syntax error's position in the source.
 */
function syntaxError(source, position, description) {
  return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), undefined, source, [position]);
}

},{"./GraphQLError":207}],209:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defineToJSON;

var _nodejsCustomInspectSymbol = _interopreqDefault(req("./nodejsCustomInspectSymbol"));

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The `defineToJSON()` function defines toJSON() and inspect() prototype
 * methods, if no function provided they become aliases for toString().
 */
function defineToJSON(classObject) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;
  classObject.prototype.toJSON = fn;
  classObject.prototype.inspect = fn;

  if (_nodejsCustomInspectSymbol.default) {
    classObject.prototype[_nodejsCustomInspectSymbol.default] = fn;
  }
}

},{"./nodejsCustomInspectSymbol":214}],210:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defineToStringTag;

/**
 * The `defineToStringTag()` function checks first to see if the runtime
 * supports the `Symbol` class and then if the `Symbol.toStringTag` constant
 * is defined as a `Symbol` instance. If both conditions are met, the
 * Symbol.toStringTag property is defined as a getter that returns the
 * supplied class constructor's name.
 *
 * @method defineToStringTag
 *
 * @param {Class<any>} classObject a class such as Object, String, Number but
 * typically one of your own creation through the class keyword; `class A {}`,
 * for example.
 */
function defineToStringTag(classObject) {
  if (typeof Symbol === 'function' && Symbol.toStringTag) {
    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
      get: function get() {
        return this.constructor.name;
      }
    });
  }
}

},{}],211:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = devAssert;

function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);

  if (!booleanCondition) {
    throw new Error(message);
  }
}

},{}],212:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inspect;

var _nodejsCustomInspectSymbol = _interopreqDefault(req("./nodejsCustomInspectSymbol"));

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */

function inspect(value) {
  return formatValue(value, []);
}

function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value === null) {
        return 'null';
      }

      return formatObjectValue(value, seenValues);

    default:
      return String(value);
  }
}

function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return '[Circular]';
  }

  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);

  if (customInspectFn !== undefined) {
    // $FlowFixMe(>=0.90.0)
    var customValue = customInspectFn.call(value); // check for infinite recursion

    if (customValue !== value) {
      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }

  return formatObject(value, seenValues);
}

function formatObject(object, seenValues) {
  var keys = Object.keys(object);

  if (keys.length === 0) {
    return '{}';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[' + getObjectTag(object) + ']';
  }

  var properties = keys.map(function (key) {
    var value = formatValue(object[key], seenValues);
    return key + ': ' + value;
  });
  return '{ ' + properties.join(', ') + ' }';
}

function formatArray(array, seenValues) {
  if (array.length === 0) {
    return '[]';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[Array]';
  }

  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];

  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }

  if (remaining === 1) {
    items.push('... 1 more item');
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }

  return '[' + items.join(', ') + ']';
}

function getCustomFn(object) {
  var customInspectFn = object[String(_nodejsCustomInspectSymbol.default)];

  if (typeof customInspectFn === 'function') {
    return customInspectFn;
  }

  if (typeof object.inspect === 'function') {
    return object.inspect;
  }
}

function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

  if (tag === 'Object' && typeof object.constructor === 'function') {
    var name = object.constructor.name;

    if (typeof name === 'string' && name !== '') {
      return name;
    }
  }

  return tag;
}

},{"./nodejsCustomInspectSymbol":214}],213:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isObjectLike;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Return true if `value` is object-like. A value is object-like if it's not
 * `null` and has a `typeof` result of "object".
 */
function isObjectLike(value) {
  return _typeof(value) == 'object' && value !== null;
}

},{}],214:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;
var _default = nodejsCustomInspectSymbol;
exports.default = _default;

},{}],215:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedentBlockStringValue = dedentBlockStringValue;
exports.getBlockStringIndentation = getBlockStringIndentation;
exports.printBlockString = printBlockString;

/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 */
function dedentBlockStringValue(rawString) {
  // Expand a block string's raw value into independent lines.
  var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

  var commonIndent = getBlockStringIndentation(lines);

  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  } // Remove leading and trailing blank lines.


  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }

  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  } // Return a string of the lines joined with U+000A.


  return lines.join('\n');
} // @internal


function getBlockStringIndentation(lines) {
  var commonIndent = null;

  for (var i = 1; i < lines.length; i++) {
    var line = lines[i];
    var indent = leadingWhitespace(line);

    if (indent === line.length) {
      continue; // skip empty lines
    }

    if (commonIndent === null || indent < commonIndent) {
      commonIndent = indent;

      if (commonIndent === 0) {
        break;
      }
    }
  }

  return commonIndent === null ? 0 : commonIndent;
}

function leadingWhitespace(str) {
  var i = 0;

  while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
    i++;
  }

  return i;
}

function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 */


function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSingleLine = value.indexOf('\n') === -1;
  var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
  var hasTrailingQuote = value[value.length - 1] === '"';
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;
  var result = ''; // Format a multi-line block quote to account for leading space.

  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += '\n' + indentation;
  }

  result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

  if (printAsMultipleLines) {
    result += '\n';
  }

  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}

},{}],216:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectiveLocation = void 0;

/**
 * The set of allowed directive location values.
 */
var DirectiveLocation = Object.freeze({
  // Request Definitions
  QUERY: 'QUERY',
  MUTATION: 'MUTATION',
  SUBSCRIPTION: 'SUBSCRIPTION',
  FIELD: 'FIELD',
  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
  // Type System Definitions
  SCHEMA: 'SCHEMA',
  SCALAR: 'SCALAR',
  OBJECT: 'OBJECT',
  FIELD_DEFINITION: 'FIELD_DEFINITION',
  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
  INTERFACE: 'INTERFACE',
  UNION: 'UNION',
  ENUM: 'ENUM',
  ENUM_VALUE: 'ENUM_VALUE',
  INPUT_OBJECT: 'INPUT_OBJECT',
  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
});
/**
 * The enum type representing the directive location values.
 */

exports.DirectiveLocation = DirectiveLocation;

},{}],217:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Kind = void 0;

/**
 * The set of allowed kind values for AST nodes.
 */
var Kind = Object.freeze({
  // Name
  NAME: 'Name',
  // Document
  DOCUMENT: 'Document',
  OPERATION_DEFINITION: 'OperationDefinition',
  VARIABLE_DEFINITION: 'VariableDefinition',
  SELECTION_SET: 'SelectionSet',
  FIELD: 'Field',
  ARGUMENT: 'Argument',
  // Fragments
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_FRAGMENT: 'InlineFragment',
  FRAGMENT_DEFINITION: 'FragmentDefinition',
  // Values
  VARIABLE: 'Variable',
  INT: 'IntValue',
  FLOAT: 'FloatValue',
  STRING: 'StringValue',
  BOOLEAN: 'BooleanValue',
  NULL: 'NullValue',
  ENUM: 'EnumValue',
  LIST: 'ListValue',
  OBJECT: 'ObjectValue',
  OBJECT_FIELD: 'ObjectField',
  // Directives
  DIRECTIVE: 'Directive',
  // Types
  NAMED_TYPE: 'NamedType',
  LIST_TYPE: 'ListType',
  NON_NULL_TYPE: 'NonNullType',
  // Type System Definitions
  SCHEMA_DEFINITION: 'SchemaDefinition',
  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
  // Type Definitions
  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
  FIELD_DEFINITION: 'FieldDefinition',
  INPUT_VALUE_DEFINITION: 'InputValueDefinition',
  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
  // Directive Definitions
  DIRECTIVE_DEFINITION: 'DirectiveDefinition',
  // Type System Extensions
  SCHEMA_EXTENSION: 'SchemaExtension',
  // Type Extensions
  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
  UNION_TYPE_EXTENSION: 'UnionTypeExtension',
  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
});
/**
 * The enum type representing the possible kind values of AST nodes.
 */

exports.Kind = Kind;

},{}],218:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLexer = createLexer;
exports.isPunctuatorToken = isPunctuatorToken;

var _defineToJSON = _interopreqDefault(req("../jsutils/defineToJSON"));

var _syntaxError = req("../error/syntaxError");

var _blockString = req("./blockString");

var _tokenKind = req("./tokenKind");

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given a Source object, this returns a Lexer for that source.
 * A Lexer is a stateful stream generator in that every time
 * it is advanced, it returns the next token in the Source. Assuming the
 * source lexes, the final Token emitted by the lexer will be of kind
 * EOF, after which the lexer will repeatedly return the same EOF token
 * whenever called.
 */
function createLexer(source, options) {
  var startOfFileToken = new Tok(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);
  var lexer = {
    source: source,
    options: options,
    lastToken: startOfFileToken,
    token: startOfFileToken,
    line: 1,
    lineStart: 0,
    advance: advanceLexer,
    lookahead: lookahead
  };
  return lexer;
}

function advanceLexer() {
  this.lastToken = this.token;
  var token = this.token = this.lookahead();
  return token;
}

function lookahead() {
  var token = this.token;

  if (token.kind !== _tokenKind.TokenKind.EOF) {
    do {
      // Note: next is only mutable during parsing, so we cast to allow this.
      token = token.next || (token.next = readToken(this, token));
    } while (token.kind === _tokenKind.TokenKind.COMMENT);
  }

  return token;
}
/**
 * The return type of createLexer.
 */


// @internal
function isPunctuatorToken(token) {
  var kind = token.kind;
  return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
}
/**
 * Helper function for constructing the Token object.
 */


function Tok(kind, start, end, line, column, prev, value) {
  this.kind = kind;
  this.start = start;
  this.end = end;
  this.line = line;
  this.column = column;
  this.value = value;
  this.prev = prev;
  this.next = null;
} // Print a simplified form when appearing in JSON/util.inspect.


(0, _defineToJSON.default)(Tok, function () {
  return {
    kind: this.kind,
    value: this.value,
    line: this.line,
    column: this.column
  };
});

function printCharCode(code) {
  return (// NaN/undefined represents access beyond the end of the file.
    isNaN(code) ? _tokenKind.TokenKind.EOF : // Trust JSON for ASCII.
    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.
    "\"\\u".concat(('00' + code.toString(16).toUpperCase()).slice(-4), "\"")
  );
}
/**
 * Gets the next token from the source starting at the given position.
 *
 * This skips over whitespace until it finds the next lexable token, then lexes
 * punctuators immediately or calls the appropriate helper function for more
 * complicated tokens.
 */


function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = positionAfterWhitespace(body, prev.end, lexer);
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;

  if (pos >= bodyLength) {
    return new Tok(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
  }

  var code = body.charCodeAt(pos); // SourceCharacter

  switch (code) {
    // !
    case 33:
      return new Tok(_tokenKind.TokenKind.BANG, pos, pos + 1, line, col, prev);
    // #

    case 35:
      return readComment(source, pos, line, col, prev);
    // $

    case 36:
      return new Tok(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, line, col, prev);
    // &

    case 38:
      return new Tok(_tokenKind.TokenKind.AMP, pos, pos + 1, line, col, prev);
    // (

    case 40:
      return new Tok(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, line, col, prev);
    // )

    case 41:
      return new Tok(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, line, col, prev);
    // .

    case 46:
      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
        return new Tok(_tokenKind.TokenKind.SPREAD, pos, pos + 3, line, col, prev);
      }

      break;
    // :

    case 58:
      return new Tok(_tokenKind.TokenKind.COLON, pos, pos + 1, line, col, prev);
    // =

    case 61:
      return new Tok(_tokenKind.TokenKind.EQUALS, pos, pos + 1, line, col, prev);
    // @

    case 64:
      return new Tok(_tokenKind.TokenKind.AT, pos, pos + 1, line, col, prev);
    // [

    case 91:
      return new Tok(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);
    // ]

    case 93:
      return new Tok(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);
    // {

    case 123:
      return new Tok(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, line, col, prev);
    // |

    case 124:
      return new Tok(_tokenKind.TokenKind.PIPE, pos, pos + 1, line, col, prev);
    // }

    case 125:
      return new Tok(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, line, col, prev);
    // A-Z _ a-z

    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 95:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
      return readName(source, pos, line, col, prev);
    // - 0-9

    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return readNumber(source, pos, code, line, col, prev);
    // "

    case 34:
      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
        return readBlockString(source, pos, line, col, prev, lexer);
      }

      return readString(source, pos, line, col, prev);
  }

  throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));
}
/**
 * Report a message that an unexpected character was encountered.
 */


function unexpectedCharacterMessage(code) {
  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }

  if (code === 39) {
    // '
    return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
  }

  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
/**
 * Reads from body starting at startPosition until it finds a non-whitespace
 * character, then returns the position of that character for lexing.
 */


function positionAfterWhitespace(body, startPosition, lexer) {
  var bodyLength = body.length;
  var position = startPosition;

  while (position < bodyLength) {
    var code = body.charCodeAt(position); // tab | space | comma | BOM

    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
      ++position;
    } else if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else {
      break;
    }
  }

  return position;
}
/**
 * Reads a comment token from the source file.
 *
 * #[\u0009\u0020-\uFFFF]*
 */


function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;

  do {
    code = body.charCodeAt(++position);
  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator
  code > 0x001f || code === 0x0009));

  return new Tok(_tokenKind.TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
}
/**
 * Reads a number token from the source file, either a float
 * or an int depending on whether a decimal point appears.
 *
 * Int:   -?(0|[1-9][0-9]*)
 * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
 */


function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;

  if (code === 45) {
    // -
    code = body.charCodeAt(++position);
  }

  if (code === 48) {
    // 0
    code = body.charCodeAt(++position);

    if (code >= 48 && code <= 57) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }

  if (code === 46) {
    // .
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }

  if (code === 69 || code === 101) {
    // E e
    isFloat = true;
    code = body.charCodeAt(++position);

    if (code === 43 || code === 45) {
      // + -
      code = body.charCodeAt(++position);
    }

    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  } // Numbers cannot be followed by . or e


  if (code === 46 || code === 69 || code === 101) {
    throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }

  return new Tok(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
}
/**
 * Returns the new position in the source after reading digits.
 */


function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;

  if (code >= 48 && code <= 57) {
    // 0 - 9
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57); // 0 - 9


    return position;
  }

  throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
/**
 * Reads a string token from the source file.
 *
 * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
 */


function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = '';

  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator
  code !== 0x000a && code !== 0x000d) {
    // Closing Quote (")
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return new Tok(_tokenKind.TokenKind.STRING, start, position + 1, line, col, prev, value);
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    ++position;

    if (code === 92) {
      // \
      value += body.slice(chunkStart, position - 1);
      code = body.charCodeAt(position);

      switch (code) {
        case 34:
          value += '"';
          break;

        case 47:
          value += '/';
          break;

        case 92:
          value += '\\';
          break;

        case 98:
          value += '\b';
          break;

        case 102:
          value += '\f';
          break;

        case 110:
          value += '\n';
          break;

        case 114:
          value += '\r';
          break;

        case 116:
          value += '\t';
          break;

        case 117:
          {
            // uXXXX
            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));

            if (charCode < 0) {
              var invalidSequence = body.slice(position + 1, position + 5);
              throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
            }

            value += String.fromCharCode(charCode);
            position += 4;
            break;
          }

        default:
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }

      ++position;
      chunkStart = position;
    }
  }

  throw (0, _syntaxError.syntaxError)(source, position, 'Unterminated string.');
}
/**
 * Reads a block string token from the source file.
 *
 * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
 */


function readBlockString(source, start, line, col, prev, lexer) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = '';

  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
    // Closing Triple-Quote (""")
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new Tok(_tokenKind.TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else if ( // Escape Triple-Quote (\""")
    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }

  throw (0, _syntaxError.syntaxError)(source, position, 'Unterminated string.');
}
/**
 * Converts four hexadecimal chars to the integer that the
 * string represents. For example, uniCharCode('0','0','0','f')
 * will return 15, and uniCharCode('0','0','f','f') returns 255.
 *
 * Returns a negative number on error, if a char was invalid.
 *
 * This is implemented by noting that char2hex() returns -1 on error,
 * which means the result of ORing the char2hex() will also be negative.
 */


function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
/**
 * Converts a hex character to its integer value.
 * '0' becomes 0, '9' becomes 9
 * 'A' becomes 10, 'F' becomes 15
 * 'a' becomes 10, 'f' becomes 15
 *
 * Returns -1 on error.
 */


function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 // 0-9
  : a >= 65 && a <= 70 ? a - 55 // A-F
  : a >= 97 && a <= 102 ? a - 87 // a-f
  : -1;
}
/**
 * Reads an alphanumeric + underscore name from the source.
 *
 * [_A-Za-z][_0-9A-Za-z]*
 */


function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;

  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _
  code >= 48 && code <= 57 || // 0-9
  code >= 65 && code <= 90 || // A-Z
  code >= 97 && code <= 122) // a-z
  ) {
    ++position;
  }

  return new Tok(_tokenKind.TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
}

},{"../error/syntaxError":208,"../jsutils/defineToJSON":209,"./blockString":215,"./tokenKind":224}],219:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLocation = getLocation;

/**
 * Represents a location in a Source.
 */

/**
 * Takes a Source and a UTF-8 character offset, and returns the corresponding
 * line and column as a SourceLocation.
 */
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}

},{}],220:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseValue = parseValue;
exports.parseType = parseType;

var _inspect = _interopreqDefault(req("../jsutils/inspect"));

var _devAssert = _interopreqDefault(req("../jsutils/devAssert"));

var _defineToJSON = _interopreqDefault(req("../jsutils/defineToJSON"));

var _syntaxError = req("../error/syntaxError");

var _kinds = req("./kinds");

var _source = req("./source");

var _lexer = req("./lexer");

var _directiveLocation = req("./directiveLocation");

var _tokenKind = req("./tokenKind");

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given a GraphQL source, parses it into a Document.
 * Throws GraphQLError if a syntax error is encountered.
 */
function parse(source, options) {
  var parser = new Parser(source, options);
  return parser.parseDocument();
}
/**
 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
 * that value.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: valueFromAST().
 */


function parseValue(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(_tokenKind.TokenKind.SOF);
  var value = parser.parseValueLiteral(false);
  parser.expectToken(_tokenKind.TokenKind.EOF);
  return value;
}
/**
 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
 * that type.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Types directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: typeFromAST().
 */


function parseType(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(_tokenKind.TokenKind.SOF);
  var type = parser.parseTypeReference();
  parser.expectToken(_tokenKind.TokenKind.EOF);
  return type;
}

var Parser =
/*#__PURE__*/
function () {
  function Parser(source, options) {
    var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
    sourceObj instanceof _source.Source || (0, _devAssert.default)(0, "Must provide Source. Received: ".concat((0, _inspect.default)(sourceObj)));
    this._lexer = (0, _lexer.createLexer)(sourceObj);
    this._options = options || {};
  }
  /**
   * Converts a name lex token into a name parse node.
   */


  var _proto = Parser.prototype;

  _proto.parseName = function parseName() {
    var token = this.expectToken(_tokenKind.TokenKind.NAME);
    return {
      kind: _kinds.Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  } // Implements the parsing rules in the Document section.

  /**
   * Document : Definition+
   */
  ;

  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.DOCUMENT,
      definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),
      loc: this.loc(start)
    };
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   */
  ;

  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(_tokenKind.TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case 'query':
        case 'mutation':
        case 'subscription':
          return this.parseOperationDefinition();

        case 'fragment':
          return this.parseFragmentDefinition();

        case 'schema':
        case 'scalar':
        case 'type':
        case 'interface':
        case 'union':
        case 'enum':
        case 'input':
        case 'directive':
          return this.parseTypeSystemDefinition();

        case 'extend':
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }

    throw this.unexpected();
  } // Implements the parsing rules in the Operations section.

  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  ;

  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;

    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
      return {
        kind: _kinds.Kind.OPERATION_DEFINITION,
        operation: 'query',
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }

    var operation = this.parseOperationType();
    var name;

    if (this.peek(_tokenKind.TokenKind.NAME)) {
      name = this.parseName();
    }

    return {
      kind: _kinds.Kind.OPERATION_DEFINITION,
      operation: operation,
      name: name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * OperationType : one of query mutation subscription
   */
  ;

  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);

    switch (operationToken.value) {
      case 'query':
        return 'query';

      case 'mutation':
        return 'mutation';

      case 'subscription':
        return 'subscription';
    }

    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  ;

  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  ;

  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  }
  /**
   * Variable : $ Name
   */
  ;

  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(_tokenKind.TokenKind.DOLLAR);
    return {
      kind: _kinds.Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  }
  /**
   * SelectionSet : { Selection+ }
   */
  ;

  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.SELECTION_SET,
      selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  ;

  _proto.parseSelection = function parseSelection() {
    return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  ;

  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;

    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }

    return {
      kind: _kinds.Kind.FIELD,
      alias: alias,
      name: name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,
      loc: this.loc(start)
    };
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  ;

  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  ;

  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(_tokenKind.TokenKind.COLON);
    return {
      kind: _kinds.Kind.ARGUMENT,
      name: name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };

  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Fragments section.

  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  ;

  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(_tokenKind.TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword('on');

    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
      return {
        kind: _kinds.Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }

    return {
      kind: _kinds.Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  ;

  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var start = this._lexer.token;
    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes
    // the grammar of FragmentDefinition:
    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

    if (this._options.experimentalFragmentVariables) {
      return {
        kind: _kinds.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }

    return {
      kind: _kinds.Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * FragmentName : Name but not `on`
   */
  ;

  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === 'on') {
      throw this.unexpected();
    }

    return this.parseName();
  } // Implements the parsing rules in the Values section.

  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  ;

  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;

    switch (token.kind) {
      case _tokenKind.TokenKind.BRACKET_L:
        return this.parseList(isConst);

      case _tokenKind.TokenKind.BRACE_L:
        return this.parseObject(isConst);

      case _tokenKind.TokenKind.INT:
        this._lexer.advance();

        return {
          kind: _kinds.Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind.TokenKind.FLOAT:
        this._lexer.advance();

        return {
          kind: _kinds.Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind.TokenKind.STRING:
      case _tokenKind.TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();

      case _tokenKind.TokenKind.NAME:
        if (token.value === 'true' || token.value === 'false') {
          this._lexer.advance();

          return {
            kind: _kinds.Kind.BOOLEAN,
            value: token.value === 'true',
            loc: this.loc(token)
          };
        } else if (token.value === 'null') {
          this._lexer.advance();

          return {
            kind: _kinds.Kind.NULL,
            loc: this.loc(token)
          };
        }

        this._lexer.advance();

        return {
          kind: _kinds.Kind.ENUM,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind.TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }

        break;
    }

    throw this.unexpected();
  };

  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;

    this._lexer.advance();

    return {
      kind: _kinds.Kind.STRING,
      value: token.value,
      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  ;

  _proto.parseList = function parseList(isConst) {
    var _this = this;

    var start = this._lexer.token;

    var item = function item() {
      return _this.parseValueLiteral(isConst);
    };

    return {
      kind: _kinds.Kind.LIST,
      values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  }
  /**
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   */
  ;

  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;

    var start = this._lexer.token;

    var item = function item() {
      return _this2.parseObjectField(isConst);
    };

    return {
      kind: _kinds.Kind.OBJECT,
      fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  ;

  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(_tokenKind.TokenKind.COLON);
    return {
      kind: _kinds.Kind.OBJECT_FIELD,
      name: name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Directives section.

  /**
   * Directives[Const] : Directive[?Const]+
   */
  ;

  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];

    while (this.peek(_tokenKind.TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }

    return directives;
  }
  /**
   * Directive[Const] : @ Name Arguments[?Const]?
   */
  ;

  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(_tokenKind.TokenKind.AT);
    return {
      kind: _kinds.Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Types section.

  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  ;

  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;

    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(_tokenKind.TokenKind.BRACKET_R);
      type = {
        kind: _kinds.Kind.LIST_TYPE,
        type: type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }

    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
      return {
        kind: _kinds.Kind.NON_NULL_TYPE,
        type: type,
        loc: this.loc(start)
      };
    }

    return type;
  }
  /**
   * NamedType : Name
   */
  ;

  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: _kinds.Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Type Definition section.

  /**
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  ;

  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    // Many definitions begin with a description and req a lookahead.
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;

    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
      switch (keywordToken.value) {
        case 'schema':
          return this.parseSchemaDefinition();

        case 'scalar':
          return this.parseScalarTypeDefinition();

        case 'type':
          return this.parseObjectTypeDefinition();

        case 'interface':
          return this.parseInterfaceTypeDefinition();

        case 'union':
          return this.parseUnionTypeDefinition();

        case 'enum':
          return this.parseEnumTypeDefinition();

        case 'input':
          return this.parseInputObjectTypeDefinition();

        case 'directive':
          return this.parseDirectiveDefinition();
      }
    }

    throw this.unexpected(keywordToken);
  };

  _proto.peekDescription = function peekDescription() {
    return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  ;

  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }
   */
  ;

  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    this.expectKeyword('schema');
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
    return {
      kind: _kinds.Kind.SCHEMA_DEFINITION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  ;

  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(_tokenKind.TokenKind.COLON);
    var type = this.parseNamedType();
    return {
      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
      operation: operation,
      type: type,
      loc: this.loc(start)
    };
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  ;

  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('scalar');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  ;

  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('type');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  ;

  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var types = [];

    if (this.expectOptionalKeyword('implements')) {
      // Optional leading ampersand
      this.expectOptionalToken(_tokenKind.TokenKind.AMP);

      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || // Legacy support for the SDL?
      this._options.allowLegacySDLImplementsInterfaces && this.peek(_tokenKind.TokenKind.NAME));
    }

    return types;
  }
  /**
   * FieldsDefinition : { FieldDefinition+ }
   */
  ;

  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    // Legacy support for the SDL?
    if (this._options.allowLegacySDLEmptyFields && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {
      this._lexer.advance();

      this._lexer.advance();

      return [];
    }

    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  ;

  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(_tokenKind.TokenKind.COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.FIELD_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      type: type,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  ;

  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  ;

  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(_tokenKind.TokenKind.COLON);
    var type = this.parseTypeReference();
    var defaultValue;

    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }

    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
      description: description,
      name: name,
      type: type,
      defaultValue: defaultValue,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  ;

  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('interface');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  ;

  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('union');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: _kinds.Kind.UNION_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  ;

  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    var types = [];

    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
      // Optional leading pipe
      this.expectOptionalToken(_tokenKind.TokenKind.PIPE);

      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));
    }

    return types;
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  ;

  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('enum');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  }
  /**
   * EnumValuesDefinition : { EnumValueDefinition+ }
   */
  ;

  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   *
   * EnumValue : Name
   */
  ;

  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  ;

  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('input');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * InputFieldsDefinition : { InputValueDefinition+ }
   */
  ;

  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  ;

  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();

    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
      switch (keywordToken.value) {
        case 'schema':
          return this.parseSchemaExtension();

        case 'scalar':
          return this.parseScalarTypeExtension();

        case 'type':
          return this.parseObjectTypeExtension();

        case 'interface':
          return this.parseInterfaceTypeExtension();

        case 'union':
          return this.parseUnionTypeExtension();

        case 'enum':
          return this.parseEnumTypeExtension();

        case 'input':
          return this.parseInputObjectTypeExtension();
      }
    }

    throw this.unexpected(keywordToken);
  }
  /**
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   */
  ;

  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('schema');
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);

    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.SCHEMA_EXTENSION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  ;

  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('scalar');
    var name = this.parseName();
    var directives = this.parseDirectives(true);

    if (directives.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  ;

  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('type');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();

    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * InterfaceTypeExtension :
   *   - extend interface Name Directives[Const]? FieldsDefinition
   *   - extend interface Name Directives[Const]
   */
  ;

  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('interface');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();

    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  ;

  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('union');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();

    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.UNION_TYPE_EXTENSION,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  ;

  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('enum');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();

    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  ;

  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('input');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();

    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   */
  ;

  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('directive');
    this.expectToken(_tokenKind.TokenKind.AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword('repeatable');
    this.expectKeyword('on');
    var locations = this.parseDirectiveLocations();
    return {
      kind: _kinds.Kind.DIRECTIVE_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      repeatable: repeatable,
      locations: locations,
      loc: this.loc(start)
    };
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  ;

  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    // Optional leading pipe
    this.expectOptionalToken(_tokenKind.TokenKind.PIPE);
    var locations = [];

    do {
      locations.push(this.parseDirectiveLocation());
    } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));

    return locations;
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  ;

  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();

    if (_directiveLocation.DirectiveLocation[name.value] !== undefined) {
      return name;
    }

    throw this.unexpected(start);
  } // Core parsing utility functions

  /**
   * Returns a location object, used to identify the place in
   * the source that created a given parsed object.
   */
  ;

  _proto.loc = function loc(startToken) {
    if (!this._options.noLocation) {
      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);
    }
  }
  /**
   * Determines if the next token is of a given kind
   */
  ;

  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing
   * the lexer. Otherwise, do not change the parser state and throw an error.
   */
  ;

  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;

    if (token.kind === kind) {
      this._lexer.advance();

      return token;
    }

    throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected ".concat(kind, ", found ").concat(getTokenDesc(token)));
  }
  /**
   * If the next token is of the given kind, return that token after advancing
   * the lexer. Otherwise, do not change the parser state and return undefined.
   */
  ;

  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;

    if (token.kind === kind) {
      this._lexer.advance();

      return token;
    }

    return undefined;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  ;

  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;

    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected \"".concat(value, "\", found ").concat(getTokenDesc(token)));
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing
   * the lexer. Otherwise, do not change the parser state and return "false".
   */
  ;

  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;

    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
      this._lexer.advance();

      return true;
    }

    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token
   * is encountered.
   */
  ;

  _proto.unexpected = function unexpected(atToken) {
    var token = atToken || this._lexer.token;
    return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token)));
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by
   * the parseFn. This list begins with a lex token of openKind
   * and ends with a lex token of closeKind. Advances the parser
   * to the next lex token after the closing token.
   */
  ;

  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];

    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }

    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always
   * return non-empty list that begins with a lex token of openKind and ends
   * with a lex token of closeKind. Advances the parser to the next lex token
   * after the closing token.
   */
  ;

  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];

      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));

      return nodes;
    }

    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by
   * the parseFn. This list begins with a lex token of openKind
   * and ends with a lex token of closeKind. Advances the parser
   * to the next lex token after the closing token.
   */
  ;

  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];

    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));

    return nodes;
  };

  return Parser;
}();

function Loc(startToken, endToken, source) {
  this.start = startToken.start;
  this.end = endToken.end;
  this.startToken = startToken;
  this.endToken = endToken;
  this.source = source;
} // Print a simplified form when appearing in JSON/util.inspect.


(0, _defineToJSON.default)(Loc, function () {
  return {
    start: this.start,
    end: this.end
  };
});
/**
 * A helper function to describe a token as a string for debugging
 */

function getTokenDesc(token) {
  var value = token.value;
  return value ? "".concat(token.kind, " \"").concat(value, "\"") : token.kind;
}

},{"../error/syntaxError":208,"../jsutils/defineToJSON":209,"../jsutils/devAssert":211,"../jsutils/inspect":212,"./directiveLocation":216,"./kinds":217,"./lexer":218,"./source":223,"./tokenKind":224}],221:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printLocation = printLocation;
exports.printSourceLocation = printSourceLocation;

var _location = req("../language/location");

/**
 * Render a helpful description of the location in the GraphQL Source document.
 */
function printLocation(location) {
  return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
}
/**
 * Render a helpful description of the location in the GraphQL Source document.
 */


function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex]; // Special case for minified documents

  if (locationLine.length > 120) {
    var sublineIndex = Math.floor(columnNum / 80);
    var sublineColumnNum = columnNum % 80;
    var sublines = [];

    for (var i = 0; i < locationLine.length; i += 80) {
      sublines.push(locationLine.slice(i, i + 80));
    }

    return locationStr + printPrefixedLines([["".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {
      return ['', subline];
    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));
  }

  return locationStr + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1), lines[lineIndex - 1]], ["".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function (_ref3) {
    var prefix = _ref3[0],
        line = _ref3[1];
    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function lpad(len, str) {
  return whitespace(len - str.length) + str;
}

},{"../language/location":219}],222:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.print = print;

var _visitor = req("./visitor");

var _blockString = req("./blockString");

/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */
function print(ast) {
  return (0, _visitor.visit)(ast, {
    leave: printDocASTReducer
  });
} // TODO: provide better type coverage in future


var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? (0, _blockString.printBlockString)(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: function SchemaDefinition(_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        repeatable = _ref31.repeatable,
        locations = _ref31.locations;
    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter(function (x) {
    return x;
  }).join(separator || '') : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */


function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || '') : '';
}

function indent(maybeString) {
  return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
}

function isMultiline(string) {
  return string.indexOf('\n') !== -1;
}

function hasMultilineItems(maybeArray) {
  return maybeArray && maybeArray.some(isMultiline);
}

},{"./blockString":215,"./visitor":225}],223:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Source = void 0;

var _devAssert = _interopreqDefault(req("../jsutils/devAssert"));

var _defineToStringTag = _interopreqDefault(req("../jsutils/defineToStringTag"));

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A representation of source input to GraphQL.
 * `name` and `locationOffset` are optional. They are useful for clients who
 * store GraphQL documents in source files; for example, if the GraphQL input
 * starts at line 40 in a file named Foo.graphql, it might be useful for name to
 * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
 * line and column in locationOffset are 1-indexed
 */
var Source = function Source(body, name, locationOffset) {
  this.body = body;
  this.name = name || 'GraphQL request';
  this.locationOffset = locationOffset || {
    line: 1,
    column: 1
  };
  this.locationOffset.line > 0 || (0, _devAssert.default)(0, 'line in locationOffset is 1-indexed and must be positive');
  this.locationOffset.column > 0 || (0, _devAssert.default)(0, 'column in locationOffset is 1-indexed and must be positive');
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported


exports.Source = Source;
(0, _defineToStringTag.default)(Source);

},{"../jsutils/defineToStringTag":210,"../jsutils/devAssert":211}],224:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TokenKind = void 0;

/**
 * An exported enum describing the different kinds of tokens that the
 * lexer emits.
 */
var TokenKind = Object.freeze({
  SOF: '<SOF>',
  EOF: '<EOF>',
  BANG: '!',
  DOLLAR: '$',
  AMP: '&',
  PAREN_L: '(',
  PAREN_R: ')',
  SPREAD: '...',
  COLON: ':',
  EQUALS: '=',
  AT: '@',
  BRACKET_L: '[',
  BRACKET_R: ']',
  BRACE_L: '{',
  PIPE: '|',
  BRACE_R: '}',
  NAME: 'Name',
  INT: 'Int',
  FLOAT: 'Float',
  STRING: 'String',
  BLOCK_STRING: 'BlockString',
  COMMENT: 'Comment'
});
/**
 * The enum type representing the token kinds values.
 */

exports.TokenKind = TokenKind;

},{}],225:[function(req,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.visitInParallel = visitInParallel;
exports.visitWithTypeInfo = visitWithTypeInfo;
exports.getVisitFn = getVisitFn;
exports.BREAK = exports.QueryDocumentKeys = void 0;

var _inspect = _interopreqDefault(req("../jsutils/inspect"));

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
exports.QueryDocumentKeys = QueryDocumentKeys;
var BREAK = Object.freeze({});
/**
 * visit() will walk through an AST using a depth first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

exports.BREAK = BREAK;

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

  /* eslint-disable no-undef-init */
  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error('Invalid AST Node: ' + (0, _inspect.default)(node));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : visitorKeys[node.kind] || [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}

function isNode(maybeNode) {
  return Boolean(maybeNode && typeof maybeNode.kind === 'string');
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */


function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          false);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          true);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
/**
 * Creates a new visitor instance which maintains a provided TypeInfo instance
 * along with visiting visitor.
 */


function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter: function enter(node) {
      typeInfo.enter(node);
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      false);

      if (fn) {
        var result = fn.apply(visitor, arguments);

        if (result !== undefined) {
          typeInfo.leave(node);

          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }

        return result;
      }
    },
    leave: function leave(node) {
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      true);
      var result;

      if (fn) {
        result = fn.apply(visitor, arguments);
      }

      typeInfo.leave(node);
      return result;
    }
  };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */


function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}

},{"../jsutils/inspect":212}],226:[function(req,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = req('isobject');
var hasValues = req('has-values');
var get = req('get-value');

module.exports = function(obj, prop, noZero) {
  if (isObject(obj)) {
    return hasValues(get(obj, prop), noZero);
  }
  return hasValues(obj, prop);
};

},{"get-value":205,"has-values":228,"isobject":227}],227:[function(req,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isArray = req('isarray');

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && isArray(val) === false;
};

},{"isarray":234}],228:[function(req,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function hasValue(o, noZero) {
  if (o === null || o === undefined) {
    return false;
  }

  if (typeof o === 'boolean') {
    return true;
  }

  if (typeof o === 'number') {
    if (o === 0 && noZero === true) {
      return false;
    }
    return true;
  }

  if (o.length !== undefined) {
    return o.length !== 0;
  }

  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      return true;
    }
  }
  return false;
};

},{}],229:[function(req,module,exports){
'use strict';

var bind = req('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":204}],230:[function(req,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{}],231:[function(req,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],232:[function(req,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = req('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

},{"isobject":235}],233:[function(req,module,exports){
'use strict';

var has = req('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":229}],234:[function(req,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],235:[function(req,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],236:[function(req,module,exports){
(function (global){
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.req && freeModule.req('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      // Like with sourceURL, we take care to not check the option's prototype,
      // as this configuration is a code injection vector.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://reqjs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],237:[function(req,module,exports){
(function (global){
"use strict";

// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
exports.default = global.fetch.bind(global);

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],238:[function(req,module,exports){
"use strict";

/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.is */

var NumberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	} else if (a === b) {
		return true;
	} else if (NumberIsNaN(a) && NumberIsNaN(b)) {
		return true;
	}
	return false;
};


},{}],239:[function(req,module,exports){
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = req('./isArguments'); // eslint-disable-line global-req
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

},{"./isArguments":241}],240:[function(req,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = req('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : req('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./implementation":239,"./isArguments":241}],241:[function(req,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],242:[function(req,module,exports){
'use strict';

var isObject = req('is-plain-object');
var unset = req('unset-value');

module.exports = function omitDeep(value, keys) {
  if (typeof value === 'undefined') {
    return {};
  }

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = omitDeep(value[i], keys);
    }
    return value;
  }

  if (!isObject(value)) {
    return value;
  }

  if (typeof keys === 'string') {
    keys = [keys];
  }

  if (!Array.isArray(keys)) {
    return value;
  }

  for (var j = 0; j < keys.length; j++) {
    unset(value, keys[j]);
  }

  for (var key in value) {
    if (value.hasOwnProperty(key)) {
      value[key] = omitDeep(value[key], keys);
    }
  }

  return value;
};

},{"is-plain-object":232,"unset-value":261}],243:[function(req,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var context = req('@wry/context');

function defaultDispose() { }
var Cache = /** @class */ (function () {
    function Cache(max, dispose) {
        if (max === void 0) { max = Infinity; }
        if (dispose === void 0) { dispose = defaultDispose; }
        this.max = max;
        this.dispose = dispose;
        this.map = new Map();
        this.newest = null;
        this.oldest = null;
    }
    Cache.prototype.has = function (key) {
        return this.map.has(key);
    };
    Cache.prototype.get = function (key) {
        var entry = this.getEntry(key);
        return entry && entry.value;
    };
    Cache.prototype.getEntry = function (key) {
        var entry = this.map.get(key);
        if (entry && entry !== this.newest) {
            var older = entry.older, newer = entry.newer;
            if (newer) {
                newer.older = older;
            }
            if (older) {
                older.newer = newer;
            }
            entry.older = this.newest;
            entry.older.newer = entry;
            entry.newer = null;
            this.newest = entry;
            if (entry === this.oldest) {
                this.oldest = newer;
            }
        }
        return entry;
    };
    Cache.prototype.set = function (key, value) {
        var entry = this.getEntry(key);
        if (entry) {
            return entry.value = value;
        }
        entry = {
            key: key,
            value: value,
            newer: null,
            older: this.newest
        };
        if (this.newest) {
            this.newest.newer = entry;
        }
        this.newest = entry;
        this.oldest = this.oldest || entry;
        this.map.set(key, entry);
        return entry.value;
    };
    Cache.prototype.clean = function () {
        while (this.oldest && this.map.size > this.max) {
            this.delete(this.oldest.key);
        }
    };
    Cache.prototype.delete = function (key) {
        var entry = this.map.get(key);
        if (entry) {
            if (entry === this.newest) {
                this.newest = entry.older;
            }
            if (entry === this.oldest) {
                this.oldest = entry.newer;
            }
            if (entry.newer) {
                entry.newer.older = entry.older;
            }
            if (entry.older) {
                entry.older.newer = entry.newer;
            }
            this.map.delete(key);
            this.dispose(entry.value, key);
            return true;
        }
        return false;
    };
    return Cache;
}());

var parentEntrySlot = new context.Slot();

var reusableEmptyArray = [];
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
// Since this package might be used browsers, we should avoid using the
// Node built-in assert module.
function assert(condition, optionalMessage) {
    if (!condition) {
        throw new Error(optionalMessage || "assertion failure");
    }
}
function valueIs(a, b) {
    var len = a.length;
    return (
    // Unknown values are not equal to each other.
    len > 0 &&
        // Both values must be ordinary (or both exceptional) to be equal.
        len === b.length &&
        // The underlying value or exception must be the same.
        a[len - 1] === b[len - 1]);
}
function valueGet(value) {
    switch (value.length) {
        case 0: throw new Error("unknown value");
        case 1: return value[0];
        case 2: throw value[1];
    }
}
function valueCopy(value) {
    return value.slice(0);
}
var Entry = /** @class */ (function () {
    function Entry(fn, args) {
        this.fn = fn;
        this.args = args;
        this.parents = new Set();
        this.childValues = new Map();
        // When this Entry has children that are dirty, this property becomes
        // a Set containing other Entry objects, borrowed from emptySetPool.
        // When the set becomes empty, it gets recycled back to emptySetPool.
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        ++Entry.count;
    }
    // This is the most important method of the Entry API, because it
    // determines whether the cached this.value can be returned immediately,
    // or must be recomputed. The overall performance of the caching system
    // depends on the truth of the following observations: (1) this.dirty is
    // usually false, (2) this.dirtyChildren is usually null/empty, and thus
    // (3) valueGet(this.value) is usually returned without recomputation.
    Entry.prototype.recompute = function () {
        assert(!this.recomputing, "already recomputing");
        if (!rememberParent(this) && maybeReportOrphan(this)) {
            // The recipient of the entry.reportOrphan callback decided to dispose
            // of this orphan entry by calling entry.dispose(), so we don't need to
            // (and should not) proceed with the recomputation.
            return void 0;
        }
        return mightBeDirty(this)
            ? reallyRecompute(this)
            : valueGet(this.value);
    };
    Entry.prototype.setDirty = function () {
        if (this.dirty)
            return;
        this.dirty = true;
        this.value.length = 0;
        reportDirty(this);
        // We can go ahead and unsubscribe here, since any further dirty
        // notifications we receive will be redundant, and unsubscribing may
        // free up some resources, e.g. file watchers.
        maybeUnsubscribe(this);
    };
    Entry.prototype.dispose = function () {
        var _this = this;
        forgetChildren(this).forEach(maybeReportOrphan);
        maybeUnsubscribe(this);
        // Because this entry has been kicked out of the cache (in index.js),
        // we've lost the ability to find out if/when this entry becomes dirty,
        // whether that happens through a subscription, because of a direct call
        // to entry.setDirty(), or because one of its children becomes dirty.
        // Because of this loss of future information, we have to assume the
        // worst (that this entry might have become dirty very soon), so we must
        // immediately mark this entry's parents as dirty. Normally we could
        // just call entry.setDirty() rather than calling parent.setDirty() for
        // each parent, but that would leave this entry in parent.childValues
        // and parent.dirtyChildren, which would prevent the child from being
        // truly forgotten.
        this.parents.forEach(function (parent) {
            parent.setDirty();
            forgetChild(parent, _this);
        });
    };
    Entry.count = 0;
    return Entry;
}());
function rememberParent(child) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
        child.parents.add(parent);
        if (!parent.childValues.has(child)) {
            parent.childValues.set(child, []);
        }
        if (mightBeDirty(child)) {
            reportDirtyChild(parent, child);
        }
        else {
            reportCleanChild(parent, child);
        }
        return parent;
    }
}
function reallyRecompute(entry) {
    // Since this recomputation is likely to re-remember some of this
    // entry's children, we forget our children here but do not call
    // maybeReportOrphan until after the recomputation finishes.
    var originalChildren = forgetChildren(entry);
    // Set entry as the parent entry while calling recomputeNewValue(entry).
    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);
    if (maybeSubscribe(entry)) {
        // If we successfully recomputed entry.value and did not fail to
        // (re)subscribe, then this Entry is no longer explicitly dirty.
        setClean(entry);
    }
    // Now that we've had a chance to re-remember any children that were
    // involved in the recomputation, we can safely report any orphan
    // children that remain.
    originalChildren.forEach(maybeReportOrphan);
    return valueGet(entry.value);
}
function recomputeNewValue(entry) {
    entry.recomputing = true;
    // Set entry.value as unknown.
    entry.value.length = 0;
    try {
        // If entry.fn succeeds, entry.value will become a normal Value.
        entry.value[0] = entry.fn.apply(null, entry.args);
    }
    catch (e) {
        // If entry.fn throws, entry.value will become exceptional.
        entry.value[1] = e;
    }
    // Either way, this line is always reached.
    entry.recomputing = false;
}
function mightBeDirty(entry) {
    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
    entry.dirty = false;
    if (mightBeDirty(entry)) {
        // This Entry may still have dirty children, in which case we can't
        // let our parents know we're clean just yet.
        return;
    }
    reportClean(entry);
}
function reportDirty(child) {
    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });
}
function reportClean(child) {
    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });
}
// Let a parent Entry know that one of its children may be dirty.
function reportDirtyChild(parent, child) {
    // Must have called rememberParent(child) before calling
    // reportDirtyChild(parent, child).
    assert(parent.childValues.has(child));
    assert(mightBeDirty(child));
    if (!parent.dirtyChildren) {
        parent.dirtyChildren = emptySetPool.pop() || new Set;
    }
    else if (parent.dirtyChildren.has(child)) {
        // If we already know this child is dirty, then we must have already
        // informed our own parents that we are dirty, so we can terminate
        // the recursion early.
        return;
    }
    parent.dirtyChildren.add(child);
    reportDirty(parent);
}
// Let a parent Entry know that one of its children is no longer dirty.
function reportCleanChild(parent, child) {
    // Must have called rememberChild(child) before calling
    // reportCleanChild(parent, child).
    assert(parent.childValues.has(child));
    assert(!mightBeDirty(child));
    var childValue = parent.childValues.get(child);
    if (childValue.length === 0) {
        parent.childValues.set(child, valueCopy(child.value));
    }
    else if (!valueIs(childValue, child.value)) {
        parent.setDirty();
    }
    removeDirtyChild(parent, child);
    if (mightBeDirty(parent)) {
        return;
    }
    reportClean(parent);
}
function removeDirtyChild(parent, child) {
    var dc = parent.dirtyChildren;
    if (dc) {
        dc.delete(child);
        if (dc.size === 0) {
            if (emptySetPool.length < POOL_TARGET_SIZE) {
                emptySetPool.push(dc);
            }
            parent.dirtyChildren = null;
        }
    }
}
// If the given entry has a reportOrphan method, and no remaining parents,
// call entry.reportOrphan and return true iff it returns true. The
// reportOrphan function should return true to indicate entry.dispose()
// has been called, and the entry has been removed from any other caches
// (see index.js for the only current example).
function maybeReportOrphan(entry) {
    return entry.parents.size === 0 &&
        typeof entry.reportOrphan === "function" &&
        entry.reportOrphan() === true;
}
// Removes all children from this entry and returns an array of the
// removed children.
function forgetChildren(parent) {
    var children = reusableEmptyArray;
    if (parent.childValues.size > 0) {
        children = [];
        parent.childValues.forEach(function (_value, child) {
            forgetChild(parent, child);
            children.push(child);
        });
    }
    // After we forget all our children, this.dirtyChildren must be empty
    // and therefore must have been reset to null.
    assert(parent.dirtyChildren === null);
    return children;
}
function forgetChild(parent, child) {
    child.parents.delete(parent);
    parent.childValues.delete(child);
    removeDirtyChild(parent, child);
}
function maybeSubscribe(entry) {
    if (typeof entry.subscribe === "function") {
        try {
            maybeUnsubscribe(entry); // Prevent double subscriptions.
            entry.unsubscribe = entry.subscribe.apply(null, entry.args);
        }
        catch (e) {
            // If this Entry has a subscribe function and it threw an exception
            // (or an unsubscribe function it previously returned now throws),
            // return false to indicate that we were not able to subscribe (or
            // unsubscribe), and this Entry should remain dirty.
            entry.setDirty();
            return false;
        }
    }
    // Returning true indicates either that there was no entry.subscribe
    // function or that it succeeded.
    return true;
}
function maybeUnsubscribe(entry) {
    var unsubscribe = entry.unsubscribe;
    if (typeof unsubscribe === "function") {
        entry.unsubscribe = void 0;
        unsubscribe();
    }
}

// A trie data structure that holds object keys weakly, yet can also hold
// non-object keys, unlike the native `WeakMap`.
var KeyTrie = /** @class */ (function () {
    function KeyTrie(weakness) {
        this.weakness = weakness;
    }
    KeyTrie.prototype.lookup = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
        }
        return this.lookupArray(array);
    };
    KeyTrie.prototype.lookupArray = function (array) {
        var node = this;
        array.forEach(function (key) { return node = node.getChildTrie(key); });
        return node.data || (node.data = Object.create(null));
    };
    KeyTrie.prototype.getChildTrie = function (key) {
        var map = this.weakness && isObjRef(key)
            ? this.weak || (this.weak = new WeakMap())
            : this.strong || (this.strong = new Map());
        var child = map.get(key);
        if (!child)
            map.set(key, child = new KeyTrie(this.weakness));
        return child;
    };
    return KeyTrie;
}());
function isObjRef(value) {
    switch (typeof value) {
        case "object":
            if (value === null)
                break;
        // Fall through to return true...
        case "function":
            return true;
    }
    return false;
}

// The defaultMakeCacheKey function is remarkably powerful, because it gives
// a unique object for any shallow-identical list of arguments. If you need
// to implement a custom makeCacheKey function, you may find it helpful to
// delegate the final work to defaultMakeCacheKey, which is why we export it
// here. However, you may want to avoid defaultMakeCacheKey if your runtime
// does not support WeakMap, or you have the ability to return a string key.
// In those cases, just write your own custom makeCacheKey functions.
var keyTrie = new KeyTrie(typeof WeakMap === "function");
function defaultMakeCacheKey() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return keyTrie.lookupArray(args);
}
var caches = new Set();
function wrap(originalFunction, options) {
    if (options === void 0) { options = Object.create(null); }
    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });
    var disposable = !!options.disposable;
    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
    function optimistic() {
        if (disposable && !parentEntrySlot.hasValue()) {
            // If there's no current parent computation, and this wrapped
            // function is disposable (meaning we don't care about entry.value,
            // just dependency tracking), then we can short-cut everything else
            // in this function, because entry.recompute() is going to recycle
            // the entry object without recomputing anything, anyway.
            return void 0;
        }
        var key = makeCacheKey.apply(null, arguments);
        if (key === void 0) {
            return originalFunction.apply(null, arguments);
        }
        var args = Array.prototype.slice.call(arguments);
        var entry = cache.get(key);
        if (entry) {
            entry.args = args;
        }
        else {
            entry = new Entry(originalFunction, args);
            cache.set(key, entry);
            entry.subscribe = options.subscribe;
            if (disposable) {
                entry.reportOrphan = function () { return cache.delete(key); };
            }
        }
        var value = entry.recompute();
        // Move this entry to the front of the least-recently used queue,
        // since we just finished computing its value.
        cache.set(key, entry);
        caches.add(cache);
        // Clean up any excess entries in the cache, but only if there is no
        // active parent entry, meaning we're not in the middle of a larger
        // computation that might be flummoxed by the cleaning.
        if (!parentEntrySlot.hasValue()) {
            caches.forEach(function (cache) { return cache.clean(); });
            caches.clear();
        }
        // If options.disposable is truthy, the caller of wrap is telling us
        // they don't care about the result of entry.recompute(), so we should
        // avoid returning the value, so it won't be accidentally used.
        return disposable ? void 0 : value;
    }
    optimistic.dirty = function () {
        var key = makeCacheKey.apply(null, arguments);
        var child = key !== void 0 && cache.get(key);
        if (child) {
            child.setDirty();
        }
    };
    return optimistic;
}

Object.defineProperty(exports, 'asyncFromGen', {
  enumerable: true,
  get: function () {
    return context.asyncFromGen;
  }
});
Object.defineProperty(exports, 'bindContext', {
  enumerable: true,
  get: function () {
    return context.bind;
  }
});
Object.defineProperty(exports, 'noContext', {
  enumerable: true,
  get: function () {
    return context.noContext;
  }
});
Object.defineProperty(exports, 'setTimeout', {
  enumerable: true,
  get: function () {
    return context.setTimeout;
  }
});
exports.KeyTrie = KeyTrie;
exports.defaultMakeCacheKey = defaultMakeCacheKey;
exports.wrap = wrap;


},{"@wry/context":3}],244:[function(req,module,exports){
/*
Proxima Client to be used for accessing Proxima repositories
*/

const Proxima = req("./src/proxima/index.js");
const Subgraph = req("./src/subgraph/index.js")
const Proofs = req("./src/proof/index.js");

module.exports = {
  Proxima,
  Subgraph,
  Proofs
};

},{"./src/proof/index.js":247,"./src/proxima/index.js":249,"./src/subgraph/index.js":251}],245:[function(req,module,exports){
(function (Buffer){
/*!
 * common.js - tree common functions
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/handshake-org/urkel
 */

'use strict';

const assert = req('bsert');

/*
 * Constants
 */

const INTERNAL_PREFIX = Buffer.from([0x01]);
const LEAF_PREFIX = Buffer.from([0x00]);
const EMPTY = Buffer.alloc(0);

/*
 * Common
 */

function hasBit(key, index) {
  const oct = index >>> 3;
  const bit = index & 7;
  return (key[oct] >>> (7 - bit)) & 1;
}

function setBit(key, index, b) {
  const oct = index >>> 3;
  const bit = index & 7;
  key[oct] |= b << (7 - bit);
}


/*

TODO Change this
*/
function hashInternal(hash, left, right) {
  return hash.multi(INTERNAL_PREFIX, left, right);
}

function hashLeaf(hash, key, valueHash) {
  return hash.multi(LEAF_PREFIX, key, valueHash);
}

function hashValue(hash, key, value) {
  const valueHash = hash.digest(value);
  return hashLeaf(hash, key, valueHash);
}

function parseU32(name) {
  assert(typeof name === 'string');

  if (name.length !== 10)
    return -1;

  let num = 0;

  for (let i = 0; i < 10; i++) {
    const ch = name.charCodeAt(i);

    if (ch < 0x30 || ch > 0x39)
      return -1;

    num *= 10;
    num += ch - 0x30;

    if (num > 0xffffffff)
      return -1;
  }

  return num;
}

function serializeU32(num) {
  assert((num >>> 0) === num);

  let str = num.toString(10);

  while (str.length < 10)
    str = '0' + str;

  return str;
}

function randomString() {
  const m = Number.MAX_SAFE_INTEGER;
  const n = Math.random() * m;
  const s = Math.floor(n);
  return s.toString(32);
}

function randomPath(path) {
  assert(typeof path === 'string');

  while (path.length > 1) {
    const ch = path[path.length - 1];

    if (ch !== '/' && ch !== '\\')
      break;

    path = path.slice(0, -1);
  }
  return `${path}.${randomString()}~`;
}

function readU16(data, off) {
  return data[off++] + data[off] * 0x100;
}

function readU24(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off] * 0x10000);
}

function readU32(data, off) {
  return (data[off++]
    + data[off++] * 0x100
    + data[off++] * 0x10000
    + data[off] * 0x1000000);
}

function writeU16(dst, num, off) {
  dst[off++] = num;
  dst[off++] = num >>> 8;
  return off;
}

function writeUNBytes(data, num, off, n) {
  let total = 0;
  let i = 0

  while (i < n) {
    data[off++] = num
    i += 1
    num = num >>> 8
  }
  return off;
}

function writeU24(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

function randomBytes(size) {
  assert((size & 0xffff) === size);

  const bytes = Buffer.allocUnsafe(size);

  // Does not need to be cryptographically
  // strong, just needs to be _different_
  // from everyone else to make an attack
  // not worth trying. Predicting one user's
  // key does nothing to help an attacker.
  for (let i = 0; i < bytes.length; i++)
    bytes[i] = (Math.random() * 0x100) >>> 0;

  return bytes;
}

//function parseString
function pack(bytes) {
    var str = "";
    for(var i = 0; i < bytes.length; i += 2) {
        var char = bytes[i] << 8;
        if (bytes[i + 1])
            char |= bytes[i + 1];
        str += String.fromCharCode(char);
    }
    return str;
}

function unpack(str) {
    var bytes = [];
    for(var i = 0; i < str.length; i++) {
        var char = str.charCodeAt(i);
        bytes.push(char >>> 8);
        bytes.push(char & 0xFF);
    }
    return bytes;
}

function checksum(hash, data, key) {
  switch (hash.name) {
    case 'BLAKE2b160':
    case 'BLAKE2b256':
    case 'BLAKE2b384':
    case 'BLAKE2b512':
    case 'BLAKE2s160':
    case 'BLAKE2s224':
    case 'BLAKE2s256':
      // Hack.
      hash = hash.__proto__;
      break;
  }

  // Special case for blake2.
  if (hash.name === 'BLAKE2b' || hash.name === 'BLAKE2s')
    return hash.digest(data, 20, key);

  assert(hash.size >= 20);

  return hash.multi(data, key).slice(0, 20);
}

/*
 * Expose
 */

exports.EMPTY = EMPTY;
exports.hasBit = hasBit;
exports.setBit = setBit;
exports.hashInternal = hashInternal;
exports.hashLeaf = hashLeaf;
exports.hashValue = hashValue;
exports.parseU32 = parseU32;
exports.serializeU32 = serializeU32;
exports.randomString = randomString;
exports.randomPath = randomPath;
exports.readU16 = readU16;
exports.readU24 = readU24;
exports.readU32 = readU32;
exports.writeU16 = writeU16;
exports.writeU24 = writeU24;
exports.writeU32 = writeU32;
exports.pack = pack;
exports.unpack = unpack;
exports.randomBytes = randomBytes;
exports.checksum = checksum;

}).call(this,req("buffer").Buffer)
},{"bsert":190,"buffer":303}],246:[function(req,module,exports){
/*!
 * errors.js - tree errors
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/handshake-org/urkel
 */

'use strict';

const assert = req('bsert');

/**
 * Missing Node Error
 */

class MissingNodeError extends Error {
  /**
   * Create an error.
   * @constructor
   * @param {Object?} options
   */

  constructor(options = {}) {
    super();

    this.type = 'MissingNodeError';
    this.name = 'MissingNodeError';
    this.code = 'ERR_MISSING_NODE';
    this.rootHash = options.rootHash || null;
    this.nodeHash = options.nodeHash || null;
    this.key = options.key || null;
    this.depth = options.depth >>> 0;
    this.message = 'Missing node.';

    if (this.nodeHash)
      this.message = `Missing node: ${this.nodeHash.toString('hex')}.`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, MissingNodeError);
  }
}

/**
 * IO Error
 */

class IOError extends Error {
  /**
   * Create an error.
   * @constructor
   */

  constructor(syscall, index, pos, size) {
    super();

    this.type = 'IOError';
    this.name = 'IOError';
    this.code = 'ERR_IO';
    this.syscall = syscall;
    this.index = index;
    this.pos = pos;
    this.size = size;
    this.message = `Invalid ${syscall} for file ${index} at ${pos}:${size}.`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, IOError);
  }
}

class EncodingError extends Error {
  /**
   * Create an encoding error.
   * @constructor
   * @param {Number} offset
   * @param {String} reason
   */

  constructor(offset, reason, start) {
    super();

    this.type = 'EncodingError';
    this.name = 'EncodingError';
    this.code = 'ERR_ENCODING';
    this.message = `${reason} (offset=${offset}).`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, start || EncodingError);
  }
}

/**
 * Assertion Error
 */

class AssertionError extends assert.AssertionError {
  constructor(message) {
    super({ message });
  }
}

/*
 * Expose
 */

exports.MissingNodeError = MissingNodeError;
exports.IOError = IOError;
exports.EncodingError = EncodingError;
exports.AssertionError = AssertionError;

},{"bsert":190}],247:[function(req,module,exports){
(function (Buffer){

'use strict';

var Proof = req("./proof.js");
var Common = req("./common");
const bcrypto = req('bcrypto');
const {BLAKE2b} = bcrypto;
var assert = req('bsert');
var _ = req("lodash")

function verify(value, rawProof) {
  try {
    let {proof, root, key, proof_value}  = parseProof(rawProof)
    checkValue(proof_value, value)
    let [code, data] = proof.verify(root, key, BLAKE2b, 256)
    return (code === 0)
  } catch(err) {
    console.log(err)
    return false
  }
}

function parseProof(rawProof) {
  let proofJSON = JSON.parse(rawProof.proof)
  let proof = new Proof()
  proof.fromJSON(proofJSON, BLAKE2b, 256)
  let value = JSON.parse(Buffer.from(proofJSON.value, 'hex').toString())
  let key = Buffer.from(proofJSON.key_value, 'hex')
  let root = Buffer.from(rawProof.root, 'hex')
  return {proof: proof, root: root, key: key, proof_value: value}
}

function checkValue(proof_value, value) {
  if (_.isEqual(proof_value, value)) {
  return true
  }
for (var key in value) {
  if (_.isEqual(proof_value[key], value[key])) {
    return true
  }
}
return false
}

module.exports = {
  Proof,
  checkValue,
  parseProof,
  verify}

}).call(this,req("buffer").Buffer)
},{"./common":245,"./proof.js":248,"bcrypto":20,"bsert":190,"buffer":303,"lodash":236}],248:[function(req,module,exports){
(function (Buffer){
/*!
 * proof.js - tree proofs
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/handshake-org/urkel
 */

'use strict';

const assert = req('bsert');
const common = req('./common');
const errors = req('./errors');

const {
  hasBit,
  setBit,
  hashInternal,
  hashLeaf,
  hashValue,
  readU16,
  writeU16
} = common;

const {
  AssertionError,
  EncodingError
} = errors;

/*
 * Constants
 */

const TYPE_DEADEND = 0;
const TYPE_COLLISION = 1;
const TYPE_EXISTS = 2;
const TYPE_UNKNOWN = 3;

const PROOF_OK = 0;
const PROOF_HASH_MISMATCH = 1;
const PROOF_SAME_KEY = 2;
const PROOF_UNKNOWN_ERROR = 3;

/**
 * Proof types.
 * @enum {Number}
 */

const types = {
  TYPE_DEADEND,
  TYPE_COLLISION,
  TYPE_EXISTS,
  TYPE_UNKNOWN
};

/**
 * Proof types (strings).
 * @const {String[]}
 * @default
 */

const typesByVal = [
  'TYPE_DEADEND',
  'TYPE_COLLISION',
  'TYPE_EXISTS',
  'TYPE_UNKNOWN'
];

/**
 * Verification error codes.
 * @enum {Number}
 */

const codes = {
  PROOF_OK,
  PROOF_HASH_MISMATCH,
  PROOF_SAME_KEY,
  PROOF_UNKNOWN_ERROR
};

/**
 * Verification error codes (strings).
 * @const {String[]}
 * @default
 */

const codesByVal = [
  'PROOF_OK',
  'PROOF_HASH_MISMATCH',
  'PROOF_SAME_KEY',
  'PROOF_UNKNOWN_ERROR'
];

/**
 * Proof
 */

class Proof {
  constructor() {
    this.type = TYPE_DEADEND;
    this.nodes = [];
    this.key = null;
    this.hash = null;
    this.value = null;
  }

  get depth() {
    return this.nodes.length;
  }

  isSane(hash, bits) {
    assert(hash && typeof hash.digest === 'function');
    assert((bits >>> 0) === bits);
    assert(bits > 0 && (bits & 7) === 0);

    if (this.nodes.length > bits)
      return false;

    switch (this.type) {
      case TYPE_DEADEND:
        if (this.key || this.hash || this.value)
          return false;
        break;
      case TYPE_COLLISION:
        if (!this.key || !this.hash || this.value || this.key.length !== (bits >>> 3) || this.hash.length !== hash.size)
          return false;
        break;
      case TYPE_EXISTS:
        if (this.key || this.hash || !this.value || this.value.length > 0xffff)
          return false;
        break;
      default:
        return false;
    }
    return true;
  }



  push(node) {
    assert(Buffer.isBuffer(node));
    this.nodes.push(Buffer.from(node));
    return this;
  }

  verify(root, key, hash, bits) {
    assert(Buffer.isBuffer(root));
    assert(Buffer.isBuffer(key));
    assert(hash && typeof hash.digest === 'function');
    assert((bits >>> 0) === bits);
    assert(bits > 0 && (bits & 7) === 0);
    assert(root.length === hash.size);

    assert(key.length === (bits >>> 3));

    if (!this.isSane(hash, bits))
      return [PROOF_UNKNOWN_ERROR, null];

    let leaf = null;

    // Re-create the leaf.
    switch (this.type) {
      case TYPE_DEADEND:
        leaf = hash.zero;
        break;
      case TYPE_COLLISION:
        if (this.key.equals(key))
          return [PROOF_SAME_KEY, null];
        leaf = hashLeaf(hash, this.key, this.hash);
        break;
      case TYPE_EXISTS:
        leaf = hashValue(hash, key, this.value);
        break;
      }
    assert(leaf);

    let next = leaf;

    // Traverse bits right to left.
    for (let i = this.nodes.length - 1; i >= 0; i--) {
      const node = this.nodes[i];

      if (hasBit(key, i))
        next = hashInternal(hash, node, next);
      else
        next = hashInternal(hash, next, node);
    }

    if (!next.equals(root))
      return [PROOF_HASH_MISMATCH, null];

    return [PROOF_OK, this.value];
  }

  getSize(hash, bits) {
    assert(hash && typeof hash.digest === 'function');
    assert((bits >>> 0) === bits);
    assert(bits > 0 && (bits & 7) === 0);
    assert(bits < (1 << 14));
    assert(this.isSane(hash, bits));

    let size = 0;

    size += 2;
    size += (this.nodes.length + 7) >>> 3;

    for (const node of this.nodes) {
      if (!node.equals(hash.zero))
        size += node.length;
    }

    switch (this.type) {
      case TYPE_DEADEND:
        break;
      case TYPE_COLLISION:
        size += bits >>> 3;
        size += hash.size;
        break;
      case TYPE_EXISTS:
        size += 2;
        size += this.value.length;
        break;
    }

    return size;
  }

  write(data, off, hash, bits) {
    assert(Buffer.isBuffer(data));
    assert((off >>> 0) === off);

    const size = this.getSize(hash, bits);
    const count = this.nodes.length;
    const bsize = (count + 7) >>> 3;
    const field = (this.type << 14) | count;

    let pos = off;

    checkWrite(pos + size <= data.length, pos);

    pos = writeU16(data, field, pos);

    data.fill(0x00, pos, pos + bsize);
    pos += bsize;

    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];

      if (node.equals(hash.zero)) {
        setBit(data, (off + 2) * 8 + i, 1);
        continue;
      }

      pos += node.copy(data, pos);
    }

    switch (this.type) {
      case TYPE_DEADEND:
        break;
      case TYPE_COLLISION:
        pos += this.key.copy(data, pos);
        pos += this.hash.copy(data, pos);
        break;
      case TYPE_EXISTS:
        pos = writeU16(data, this.value.length, pos);
        pos += this.value.copy(data, pos);
        break;
    }

    checkWrite((pos - off) === size, pos);

    return pos;
  }

  writeBW(bw, hash, bits) {
    assert(bw && typeof bw.writeU8 === 'function');
    if (bw.data)
      bw.offset = this.write(bw.data, bw.offset, hash, bits);
    else
      bw.writeBytes(this.encode(hash, bits));
    return bw;
  }

  read(data, off, hash, bits) {
    assert(Buffer.isBuffer(data));
    assert((off >>> 0) === off);
    assert(hash && typeof hash.digest === 'function');
    assert((bits >>> 0) === bits);
    assert(bits > 0 && (bits & 7) === 0);
    assert(bits < (1 << 14));

    let pos = off;

    checkRead(pos + 2 <= data.length, pos);

    const field = readU16(data, pos);
    pos += 2;

    this.type = field >>> 14;

    const count = field & ~(3 << 14);

    if (count > bits)
      throw new EncodingError(pos, 'Proof too large');

    const bsize = (count + 7) >>> 3;

    checkRead(pos + bsize <= data.length, pos);
    pos += bsize;

    for (let i = 0; i < count; i++) {
      if (hasBit(data, (off + 2) * 8 + i)) {
        this.nodes.push(hash.zero);
        continue;
      }

      const node = copy(data, pos, hash.size);
      pos += hash.size;

      this.nodes.push(node);
    }

    switch (this.type) {
      case TYPE_DEADEND: {
        break;
      }

      case TYPE_COLLISION: {
        this.key = copy(data, pos, bits >>> 3);
        pos += bits >>> 3;

        this.hash = copy(data, pos, hash.size);
        pos += hash.size;

        break;
      }

      case TYPE_EXISTS: {
        checkRead(pos + 2 <= data.length, pos);

        const size = readU16(data, pos);
        pos += 2;

        this.value = copy(data, pos, size);
        pos += size;

        break;
      }

      default: {
        throw new EncodingError(pos, 'Invalid type.');
      }
    }

    return pos;
  }

  readBR(br, hash, bits) {
    assert(br && typeof br.readU8 === 'function');
    br.offset = this.read(br.data, br.offset, hash, bits);
    return this;
  }

  encode(hash, bits) {
    const size = this.getSize(hash, bits);
    const data = Buffer.allocUnsafe(size);
    this.write(data, 0, hash, bits);
    return data;
  }

  decode(data, hash, bits) {
    this.read(data, 0, hash, bits);
    return this;
  }

  toJSON() {
    return {
      type: typesByVal[this.type],
      nodes: this.nodes.map(node => node.toString('hex')),
      key: this.key ? this.key.toString('hex') : undefined,
      hash: this.hash ? this.hash.toString('hex') : undefined,
      value: this.value ? this.value.toString('hex') : undefined
    };
  }

  fromJSON(json, hash, bits) {
    assert(hash && typeof hash.digest === 'function');
    assert(bits > 0 && (bits & 7) === 0);
    assert(bits < (1 << 14));
    assert((bits >>> 0) === bits);



    if (!json || typeof json !== 'object')
      throw new EncodingError(0, 'Invalid JSON object');

    if (typeof json.type !== 'string' || !types.hasOwnProperty(json.type))
      throw new EncodingError(0, 'Type field must be a string');

    const type = types[json.type];

    if (!Array.isArray(json.nodes))
      throw new EncodingError(0, 'Nodes field must be an array');

    if (json.nodes.length > bits)
      throw new EncodingError(0, 'Proof too large');

    this.type = type;

    for (const item of json.nodes)
      this.nodes.push(parseHex(item, hash.size));

    switch (type) {
      case TYPE_DEADEND:
        break;
      case TYPE_COLLISION:
        this.key = parseHex(json.key, bits >>> 3);
        this.hash = parseHex(json.hash, hash.size);
        break;
      case TYPE_EXISTS:
        this.value = parseHex(json.value, -1);
        break;
      case TYPE_UNKNOWN:
        throw new EncodingError(0, 'Invalid type');
      default:
        throw new AssertionError('Invalid type.');
    }

    return this;
  }

  static type(value) {
    assert((value & 0xff) === value);

    if (value >= typesByVal.length)
      value = TYPE_UNKNOWN;

    return typesByVal[value];
  }

  static code(value) {
    assert((value & 0xff) === value);

    if (value >= codesByVal.length)
      value = PROOF_UNKNOWN_ERROR;

    return codesByVal[value];
  }

  static read(data, off, hash, bits) {
    return new this().read(data, off, hash, bits);
  }

  static readBR(br, hash, bits) {
    return new this().readBR(br, hash, bits);
  }

  static decode(data, hash, bits) {
    return new this().decode(data, hash, bits);
  }

  static fromJSON(json, hash, bits) {
    return new this().fromJSON(json, hash, bits);
  }
}

Proof.types = types;
Proof.typesByVal = typesByVal;
Proof.codes = codes;
Proof.codesByVal = codesByVal;

Proof.TYPE_DEADEND = TYPE_DEADEND;
Proof.TYPE_EXISTS = TYPE_EXISTS;
Proof.TYPE_COLLISION = TYPE_COLLISION;
Proof.TYPE_UNKNOWN = TYPE_UNKNOWN;

/*
 * Helpers
 */

function copy(data, pos, size) {
  checkRead(pos + size <= data.length, pos, copy);
  const buf = Buffer.allocUnsafe(size);
  data.copy(buf, 0, pos, pos + size);
  return buf;
}

function checkWrite(ok, offset, start) {
  if (!ok) {
    throw new EncodingError(offset,
      'Out of bounds write',
      start || checkWrite);
  }
}

function checkRead(ok, offset, start) {
  if (!ok) {
    throw new EncodingError(offset,
      'Out of bounds read',
      start || checkRead);
  }
}

function parseHex(str, size) {
  assert(size === -1 || (size >>> 0) === size);

  if (typeof str !== 'string')
    throw new EncodingError(0, 'Field must be a string');

  if ((str.length >>> 1) > 0xffff)
    throw new EncodingError(0, 'Hex string too large');

  if (size !== -1 && (str.length >>> 1) !== size)
    throw new EncodingError(0, 'Unexpected hex string size');

  const data = Buffer.from(str, 'hex');

  if (data.length !== (str.length >>> 1))
    throw new EncodingError(0, 'Invalid hex string');

  return data;
}

/*
 * Expose
 */

module.exports = Proof;

}).call(this,req("buffer").Buffer)
},{"./common":245,"./errors":246,"bsert":190,"buffer":303}],249:[function(req,module,exports){

const Proxima = req("./proxima.js");

module.exports = Proxima;

},{"./proxima.js":250}],250:[function(req,module,exports){
'use strict';

const Subgraph = req('../subgraph/index.js');

class Proxima {
  constructor() {
    this._subgraphs = {}
  }

  addSubgraph(name, subgraph) {
    if (subgraph instanceof Subgraph) {
      this._subgraphs[name] = subgraph
    } else {
      throw new Error("Incorrect type for subgraph")
    }
  }

  get subgraphs() {
    return this._subgraphs
  }
}

module.exports = Proxima

},{"../subgraph/index.js":251}],251:[function(req,module,exports){
const Subgraph = req('./subgraph.js');

module.exports = Subgraph;

},{"./subgraph.js":252}],252:[function(req,module,exports){
'use strict';
const Proof = req('../proof/index.js');
const gql = req('graphql-tag');
const { ApolloClient } =  req('apollo-client');
const {InMemoryCache } =  req('apollo-cache-inmemory');
const { createHttpLink } = req('apollo-link-http');
const fetch = req("node-fetch");

class Subgraph {
  constructor(client_uri, query, audit, args={}) {
    this.validate(client_uri, query, audit)
    this._client = this.constructClient(client_uri)
    this._query = query
    this.audit = audit
    this.verify = Proof.verify
  }

  validate(client_uri, query, audit) {
    if (!(audit instanceof Function)) {
      throw new Error("Audit must be a function")
    }
    if (!(client_uri) || !(query) || !(audit)) {
       throw new Error("Missing an argument")
    }
    return true
  }

  constructClient(client_uri) {
    const cache = new InMemoryCache();
    const link = createHttpLink({
      uri: client_uri,
      fetch: fetch,
    });
    return new ApolloClient({uri: client_uri, cache:cache, link: link,});
  }

  get client() {
    return this._client
  }

  set client(client) {
    if (client instanceof ApolloClient) {
      this._client = client
    }
  }

  get query() {
    return this._query
  }

  async audit(value) {
    let resp = await this.audit(value)
    return resp
  }

  verify(value, proof) {
    return this._verify(value, proof)
  }
}

module.exports = Subgraph

},{"../proof/index.js":247,"apollo-cache-inmemory":6,"apollo-client":8,"apollo-link-http":12,"graphql-tag":206,"node-fetch":237}],253:[function(req,module,exports){
'use strict';

var toObject = Object;
var TypeErr = TypeError;

module.exports = function flags() {
	if (this != null && this !== toObject(this)) {
		throw new TypeErr('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
};

},{}],254:[function(req,module,exports){
'use strict';

var define = req('define-properties');

var implementation = req('./implementation');
var getPolyfill = req('./polyfill');
var shim = req('./shim');

var flagsBound = Function.call.bind(implementation);

define(flagsBound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = flagsBound;

},{"./implementation":253,"./polyfill":255,"./shim":256,"define-properties":201}],255:[function(req,module,exports){
'use strict';

var implementation = req('./implementation');

var supportsDescriptors = req('define-properties').supportsDescriptors;
var gOPD = Object.getOwnPropertyDescriptor;
var TypeErr = TypeError;

module.exports = function getPolyfill() {
	if (!supportsDescriptors) {
		throw new TypeErr('RegExp.prototype.flags reqs a true ES5 environment that supports property descriptors');
	}
	if (/a/mig.flags === 'gim') {
		var descriptor = gOPD(RegExp.prototype, 'flags');
		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
			return descriptor.get;
		}
	}
	return implementation;
};

},{"./implementation":253,"define-properties":201}],256:[function(req,module,exports){
'use strict';

var supportsDescriptors = req('define-properties').supportsDescriptors;
var getPolyfill = req('./polyfill');
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

module.exports = function shimFlags() {
	if (!supportsDescriptors || !getProto) {
		throw new TypeErr('RegExp.prototype.flags reqs a true ES5 environment that supports property descriptors');
	}
	var polyfill = getPolyfill();
	var proto = getProto(regex);
	var descriptor = gOPD(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill) {
		defineProperty(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill
		});
	}
	return polyfill;
};

},{"./polyfill":255,"define-properties":201}],257:[function(req,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = req('./ponyfill.js');

var _ponyfill2 = _interopreqDefault(_ponyfill);

function _interopreqDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ponyfill.js":258}],258:[function(req,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],259:[function(req,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = req('tslib');

var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {
    obj.__proto__ = proto;
    return obj;
} : _a;
var InvariantError = /** @class */ (function (_super) {
    tslib.__extends(InvariantError, _super);
    function InvariantError(message) {
        if (message === void 0) { message = genericMessage; }
        var _this = _super.call(this, typeof message === "number"
            ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"
            : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError.prototype);
        return _this;
    }
    return InvariantError;
}(Error));
function invariant(condition, message) {
    if (!condition) {
        throw new InvariantError(message);
    }
}
function wrapConsoleMethod(method) {
    return function () {
        return console[method].apply(console, arguments);
    };
}
(function (invariant) {
    invariant.warn = wrapConsoleMethod("warn");
    invariant.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
// Code that uses ts-invariant with rollup-plugin-invariant may want to
// import this process stub to avoid errors evaluating process.env.NODE_ENV.
// However, because most ESM-to-CJS compilers will rewrite the process import
// as tsInvariant.process, which prevents proper replacement by minifiers, we
// also attempt to define the stub globally when it is not already defined.
exports.process = { env: {} };
if (typeof process === "object") {
    exports.process = process;
}
else
    try {
        // Using Function to evaluate this assignment in global scope also escapes
        // the strict mode of the current module, thereby allowing the assignment.
        // Inspired by https://github.com/facebook/regenerator/pull/369.
        Function("stub", "process = stub")(exports.process);
    }
    catch (atLeastWeTried) {
        // The assignment can fail if a Content Security Policy heavy-handedly
        // forbids Function usage. In those environments, developers should take
        // extra care to replace process.env.NODE_ENV in their production builds,
        // or define an appropriate global.process polyfill.
    }
var invariant$1 = invariant;

exports.default = invariant$1;
exports.InvariantError = InvariantError;
exports.invariant = invariant;


}).call(this,req('_process'))
},{"_process":307,"tslib":260}],260:[function(req,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],261:[function(req,module,exports){
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = req('isobject');
var has = req('has-value');

module.exports = function unset(obj, prop) {
  if (!isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (obj.hasOwnProperty(prop)) {
    delete obj[prop];
    return true;
  }

  if (has(obj, prop)) {
    var segs = prop.split('.');
    var last = segs.pop();
    while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
      last = segs.pop().slice(0, -1) + '.' + last;
    }
    while (segs.length) obj = obj[prop = segs.shift()];
    return (delete obj[last]);
  }
  return true;
};

},{"has-value":226,"isobject":235}],262:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var zenObservable_1 = req("./zenObservable");
tslib_1.__exportStar(req("./zenObservable"), exports);
exports.default = zenObservable_1.Observable;

},{"./zenObservable":263,"tslib":260}],263:[function(req,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = req("tslib");
var zen_observable_1 = tslib_1.__importDefault(req("zen-observable"));
exports.Observable = zen_observable_1.default;

},{"tslib":260,"zen-observable":264}],264:[function(req,module,exports){
module.exports = req('./lib/Observable.js').Observable;

},{"./lib/Observable.js":265}],265:[function(req,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// === Symbol Support ===

var hasSymbols = function () {
  return typeof Symbol === 'function';
};
var hasSymbol = function (name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function (name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

var SymbolIterator = getSymbol('iterator');
var SymbolObservable = getSymbol('observable');
var SymbolSpecies = getSymbol('species');

// === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];

  if (value == null) return undefined;

  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');

  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== undefined) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = undefined;
    }
  }
  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;

  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = undefined;
  subscription._state = 'ready';
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';

  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);
    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;
      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;
      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({ type: type, value: value });
    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{ type: type, value: value }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription = function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription);

    // ASSERT: observer is an object
    // ASSERT: subscriber is callable

    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';

    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  _createClass(Subscription, [{
    key: 'unsubscribe',
    value: function unsubscribe() {
      if (this._state !== 'closed') {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    }
  }, {
    key: 'closed',
    get: function () {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver = function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: 'next',
    value: function next(value) {
      onNotify(this._subscription, 'next', value);
    }
  }, {
    key: 'error',
    value: function error(value) {
      onNotify(this._subscription, 'error', value);
    }
  }, {
    key: 'complete',
    value: function complete() {
      onNotify(this._subscription, 'complete');
    }
  }, {
    key: 'closed',
    get: function () {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable = exports.Observable = function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');

    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');

    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: 'subscribe',
    value: function subscribe(observer) {
      if (typeof observer !== 'object' || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }
      return new Subscription(observer, this._subscriber);
    }
  }, {
    key: 'forEach',
    value: function forEach(fn) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (typeof fn !== 'function') {
          reject(new TypeError(fn + ' is not a function'));
          return;
        }

        function done() {
          subscription.unsubscribe();
          resolve();
        }

        var subscription = _this.subscribe({
          next: function (value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },

          error: reject,
          complete: resolve
        });
      });
    }
  }, {
    key: 'map',
    value: function map(fn) {
      var _this2 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        return _this2.subscribe({
          next: function (value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'filter',
    value: function filter(fn) {
      var _this3 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        return _this3.subscribe({
          next: function (value) {
            try {
              if (!fn(value)) return;
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'reduce',
    value: function reduce(fn) {
      var _this4 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;

      return new C(function (observer) {
        return _this4.subscribe({
          next: function (value) {
            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));

            observer.next(acc);
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'concat',
    value: function concat() {
      var _this5 = this;

      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }

      var C = getSpecies(this);

      return new C(function (observer) {
        var subscription = void 0;
        var index = 0;

        function startNext(next) {
          subscription = next.subscribe({
            next: function (v) {
              observer.next(v);
            },
            error: function (e) {
              observer.error(e);
            },
            complete: function () {
              if (index === sources.length) {
                subscription = undefined;
                observer.complete();
              } else {
                startNext(C.from(sources[index++]));
              }
            }
          });
        }

        startNext(_this5);

        return function () {
          if (subscription) {
            subscription.unsubscribe();
            subscription = undefined;
          }
        };
      });
    }
  }, {
    key: 'flatMap',
    value: function flatMap(fn) {
      var _this6 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        var subscriptions = [];

        var outer = _this6.subscribe({
          next: function (value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }

            var inner = C.from(value).subscribe({
              next: function (value) {
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });

            subscriptions.push(inner);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            completeIfDone();
          }
        });

        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }
  }, {
    key: SymbolObservable,
    value: function () {
      return this;
    }
  }], [{
    key: 'from',
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;

      if (x == null) throw new TypeError(x + ' is not an object');

      var method = getMethod(x, SymbolObservable);
      if (method) {
        var observable = method.call(x);

        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');

        if (isObservable(observable) && observable.constructor === C) return observable;

        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      if (hasSymbol('iterator')) {
        method = getMethod(x, SymbolIterator);
        if (method) {
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var item = _step.value;

                  observer.next(item);
                  if (observer.closed) return;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              observer.complete();
            });
          });
        }
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;
            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      }

      throw new TypeError(x + ' is not observable');
    }
  }, {
    key: 'of',
    value: function of() {
      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      var C = typeof this === 'function' ? this : Observable;

      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;
          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }
          observer.complete();
        });
      });
    }
  }, {
    key: SymbolSpecies,
    get: function () {
      return this;
    }
  }]);

  return Observable;
}();

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: SymbolObservable,
      hostReportError: hostReportError
    },
    configurable: true
  });
}
},{}],266:[function(req,module,exports){
var deepEqual = req('deep-equal')
const {BINANCE_TYPES, parseQuery} = req('../common/queries.js')
const requestAuditValue = req('./request.js')
const transformAudit = req('./transform.js')

function make_audit(audit_base_uri) {
  return async function(value) {
    let audit_result = await binance_audit(audit_base_uri, value)
    return audit_result
  }
}
//list push
async function binance_audit(audit_base_uri, given_value) {
  let {value, proof, type} = parseQuery(given_value)
  let audit_value = await requestAuditValue(audit_base_uri, value, type) //(then)
  //if audit value is nil should throw
  let expected_value = transformAudit(audit_value, value, type)
  let audit_result = auditCorrectness(expected_value, value)
  return audit_result
}

function auditCorrectness(expected_value, value) {
  if (deepEqual(expected_value, value)) {
    return true
  }
  let scalarEqualityCheck;
  for (var key in value) {
    scalarEqualityCheck = (expected_value[key] && value[key] == expected_value[key])
    if (scalarEqualityCheck || deepEqual(expected_value[key], value[key]) || auditCorrectness(expected_value[key], value[key])) {
      continue
    } else {
      return false
    }
  }
  return true
}







module.exports = {make_audit}

},{"../common/queries.js":270,"./request.js":267,"./transform.js":268,"deep-equal":200}],267:[function(req,module,exports){

const axios = req('axios')

'use strict'

const PARSE_URI = {
"fees": fees_parse_uri,
"tokens": tokens_parse_uri,
"block_stats": blockStats_parse_uri,
"markets": markets_parse_uri,
"validators":validators_parse_uri,
"marketDepth":marketDepth_parse_uri,
"market_tickers":marketTickers_parse_uri,
"market_ticker":marketTickers_parse_uri,
"market_candlesticks":  marketCandlesticks_parse_uri,
"account": account_parse_uri,
"transaction": transaction_parse_uri,
"order": order_parse_uri,
"trade": trade_parse_uri,
"atomic_swap": atomicSwap_parse_uri,
}


async function requestAuditValue(audit_base_uri, value, type){
  let audit_uri = parse_uri(audit_base_uri, value, type)
  var response = await Promise.resolve(axios.get(audit_uri))
  return response["data"]
}

function parse_uri(audit_uri, value, type) {
  if (!PARSE_URI[type]) {
    return ""
  }
  return PARSE_URI[type](audit_uri, value)
}

function marketCandlesticks_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/klines?symbol="+ val["symbol"] + "&interval=" + val["interval"]
}

function marketTickers_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/ticker/24hr"
}

function marketDepth_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/depth?symbol=" + val["symbol_pair"]
}

function marketDepth_translate_res(res, args = {}) {
  res["symbol_pair"] = args["symbol_pair"]
  return res
}
function account_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/account/" + val["address"]
}

function trade_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/trades?height=" + val["height"]
}

function order_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/orders/" + val["orderId"]
}

function transaction_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v2/transactions-in-block/" + val["blockHeight"]
}

function atomicSwap_parse_uri(audit_uri, value) {
  return audit_uri + "/api/v1/atomic-swaps/" + val["swapId"]
}

function blockStats_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/node-info"
}

function blockStats_translate_res(res, args = {}) {
  return res["sync_info"]
}

function validators_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/validators"
}

function markets_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/markets"
}

function tokens_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/tokens"
}

function fees_parse_uri(audit_uri, val) {
  return audit_uri + "/api/v1/fees"
}

function default_parse_uri(audit_uri, val) {
  return audit_uri
}

module.exports = requestAuditValue;

},{"axios":272}],268:[function(req,module,exports){

'use strict';

const TRANSFORM_AUDIT = {
  "fees": feesTransform,
  // "tokens": tokens_translate_res,
  // "block_stats": blockStats_translate_res,
  // "markets": markets_translate_res,
  // "validators":validators_translate_res,
  // "market_depth":marketDepth_translate_res,
  // "market_tickers":marketTickers_translate_res,
  // "market_candlesticks":  marketCandlesticks_translate_res,
  // "account": account_translate_res,
  // "transaction": transaction_translate_res,
  // "order": order_translate_res,
  // "trade": trade_translate_res,
  // "atomic_swap": atomicSwap_translate_res
}

function transformAudit(audit_value, value, type) {
  let transformedAudit = value
  if (TRANSFORM_AUDIT[type]) {
    transformedAudit = TRANSFORM_AUDIT[type](audit_value, value)
  }
  return transformedAudit
}

function feesTransform(audit_value, value) {
  for (index in audit_value) {
    let res = responses[index]
    if ((!res["msg_type"]) && (res["dex_fee_fields"])) {
      res["msg_type"] = "dex_fee_fields"
      console.log(res["dex_fee_fields"])
    }
    if ((res["msg_type"] == "") && (res["fixed_fee_fields"])) {
      res["msg_type"] = "fixed_fee_fields"
    }
    responses[index] = res
  }
  return responses
}


module.exports = transformAudit;

},{}],269:[function(req,module,exports){

'use strict'
const gql = req('graphql-tag');



const FEES = gql`
  query fees($prove: Boolean) {
    fees(prove: $prove) {
      fees {
        msg_type
        fee
        fee_for
        multi_transfer_fee
        lower_limit_as_multi
      }
      proof {
        root
        proof
      }

    }
  }
`;

const VALIDATORS = gql`
  query validators($prove: Boolean){
    validators(prove: $prove) {
      validators {
        address
        pub_key
        voting_power
        accum
      }
      proof {
        root
        proof
      }
    }
  }
`;

const BLOCK_STATS = gql`
  query blockStats($prove: Boolean) {
    blockStats(prove: $prove) {
      block_stats {
        latest_block_hash
        latest_app_hash
        latest_block_height
        latest_block_time
        catching_up
      }
      proof {
        root
        proof
      }
    }
  }
`;

const MARKETS = gql`
  query markets($limit: Int, $offset: Int, $prove: Boolean) {
    markets(limit: $limit, offset: $offset, prove: $prove) {
      markets {
        base_asset_symbol
        quote_asset_symbol
        tick_size
        lot_size
      }
      proof {
        root
        proof
      }
    }
  }
`;

const TOKENS = gql`
  query tokens($limit: Int, $offset: Int, $prove: Boolean){
    tokens(limit: $limit, offset: $offset, prove: $prove) {
      tokens {
        name
        symbol
        original_symbol
        total_supply
        owner
      }
      proof {
        root
        proof
      }
    }
  }
`;

const MARKET_TICKERS = gql`
  query marketTickers($limit: Int, $offset: Int, $prove: Boolean){
    marketTickers(limit: $limit, offset: $offset, prove: $prove) {
      market_tickers {
        askPrice
        askQuantity
        bidPrice
        closeTime
        count
        firstId
        highPrice
        lastId
        lastPrice
        lastQuantity
        lowPrice
        openTime
        prevClosePrice
        priceChange
        priceChangePercent
        quoteVolume
        symbol
        volume
        weightedAvgPrice
      }
      proof {
        root
        proof
      }
    }
  }
`;

const MARKET_TICKER = gql`
  query marketTicker($symbol: String, $prove: Boolean){
    marketTicker(symbol: $symbol, prove: $prove) {
      market_ticker {
        askPrice
        askQuantity
        bidPrice
        closeTime
        count
        firstId
        highPrice
        lastId
        lastPrice
        lastQuantity
        lowPrice
        openTime
        prevClosePrice
        priceChange
        priceChangePercent
        quoteVolume
        symbol
        volume
        weightedAvgPrice
      }
      proof {
        root
        proof
      }
    }
  }
`;

const MARKET_DEPTH = gql`
  query marketDepth($symbol_pair: String, $prove: Boolean) {
    marketDepth(symbol_pair: $symbol_pair, prove: $prove) {
    market_depth {
      symbol_pair
      bids
      asks
    }
    proof {
      root
      proof
    }
    }
  }
`;

const MARKET_CANDLESTICKS = gql`
  query marketCandleSticks($symbol: String, $startTime: String, $endTime: String, $interval: CandleStickInterval, $limit: Int, $prove: Boolean) {
    marketCandleSticks(symbol: $symbol, startTime: $startTime, endTime: $endTime, interval: $interval, limit: $limit, prove: $prove) {
      market_candlesticks {
        closing_price
          closing_time
          highest_price
          lowest_price
          String_of_trades
          opening_price
          opening_time
          quote_asset_volume
          volume
      }
      proof {
        root
        proof
      }
    }
  }
`;

const ACCOUNT = gql`
  query account($address: String, $prove: Boolean){
    account(address: $address, prove: $prove) {
      account {
        account_number
        address
        public_key
        sequence
        balances {
          symbol
          free
          locked
          frozen
        }
      }
      proof {
        root
        proof
      }
    }
  }
`;

const TRADES = gql`
  query trades($address: String, $symbol: String, $quoteAssetSymbol: String, $blockHeight: String, $startTime: String, $endTime: String, $buyerOrderId: String, $sellerOrderId: String, $orderSide: OrderSide, $limit: Int, $offset: Int, $prove: Boolean) {
    trades(address: $address, symbol: $symbol, quoteAssetSymbol: $quoteAssetSymbol, blockHeight: $blockHeight, startTime: $startTime, endTime: $endTime, buyerOrderId: $buyerOrderId, sellerOrderId: $sellerOrderId, orderSide: $orderSide, limit: $limit, offset: $prove, prove: $prove){
    trade {
          baseAsset
        blockHeight
        buyFee
        buyerId
        buyerOrderId
        buySingleFee
        price
        quantity
        quoteAsset
        sellFee
        sellerId
        sellerOrderId
        sellSingleFee
        symbol
        tickType
        time
        tradeId
        }
        proof {
          root
          proof
        }
      }
  }
`;

const TRADE = gql`
query trade($tradeId: String, $prove: Boolean) {
  trade(tradeId: $tradeId, prove: $prove) {
trade {
      baseAsset
      blockHeight
      buyFee
      buyerId
      buyerOrderId
      buySingleFee
      price
      quantity
      quoteAsset
      sellFee
      sellerId
      sellerOrderId
      sellSingleFee
      symbol
      tickType
      time
      tradeId
    }
    proof {
      root
      proof
    }
}
  }
`;

const ATOMIC_SWAPS = gql`
query atomicSwaps($fromAddress: String, $toAddress: String, $startTime: String, $endTime: String, $limit: Int, $offset: Int, $prove: Boolean) {
  atomicSwaps(fromAddress: $fromAddress, toAddress: $toAddress, startTime: $startTime, endTime: $endTime, limit: $limit, offset: $offset, prove: $prove) {
  atomic_swap {
    closedTime
  createdTime
  crossChain
  expectedIncome
  expireHeight
  fromAddr
  inAmount
  outAmount
  randomString
  randomStringHash
  recipientOtherChain
  status
  swapId
  timestamp
  toAddr
  updateTime
  }
  proof {
    root
    proof
  }
}
}
`;

const ATOMIC_SWAP = gql`
  query atomicSwap($swapId: String, $prove: Boolean) {
  atomicSwap(swapId: $swapId, prove: $prove) {
  atomic_swap {
    closedTime
  createdTime
  crossChain
  expectedIncome
  expireHeight
  fromAddr
  inAmount
  outAmount
  randomString
  randomStringHash
  recipientOtherChain
  status
  swapId
  timestamp
  toAddr
  updateTime
  }
  proof {
    root
    proof
  }
}
}
`;

const ORDERS = gql`
query orders($address: String, $symbol: String, $start: String, $end: String, $orderSide: OrderSide, $open: Boolean, $status: OrderStatus, $total: Int, $limit: Int, $offset: Int, $prove: Boolean) {
  orders(address: $address, symbol: $symbol, start: $start, end: $end, orderSide: $orderSide, open: $open, status: $status, total: $total, limit: $limit, offset: $offset, prove: $prove){
  order {
  cumulateQuantity
  fee
  lastExecutedPrice
  lastExecutedQuantity
  orderCreateTime
  orderId
  owner
  price
  quantity
  side
  status
  symbol
  timeInForce
  tradeId
  transactionHash
  transactionTime
  type
  }
  proof {
    root
    proof
  }
}
}
`;

const ORDER = gql`
query order($orderId: String, $prove: Boolean) {
  order(orderId: $orderId, prove: $prove){
  order {
  cumulateQuantity
  fee
  lastExecutedPrice
  lastExecutedQuantity
  orderCreateTime
  orderId
  owner
  price
  quantity
  side
  status
  symbol
  timeInForce
  tradeId
  transactionHash
  transactionTime
  type
  }
  proof {
    root
    proof
  }
}
}
`;

const TRANSACTIONS = gql`
  query transactions($address: String, $txType: TxType, $txAsset: String, $txSide: TxSide, $blockHeight: String, $startTime: String, $endTime: String, $limit: Int, $offset: Int, $prove: Boolean){
    transactions(address: $address, txType: $txType, txAsset: $txAsset, txSide: $txSide, blockHeight: $blockHeight, startTime: $startTime, endTime: $endTime, limit: $limit, offset: $offset, prove: $prove) {
      transaction {
        blockHeight
        code
        data
        fromAddr
        memo
        orderId
        proposalId
        sequence
        source
        swapId
        timeStamp
        toAddr
        txAsset
        txFee
        txHash
        txType
        value
      }
      proof {
        root
        proof
      }
    }
  }
`;


const TRANSACTION = gql`
  query transaction($txHash: String, $prove: Boolean){
    transaction(txHash: $txHash, prove: $prove) {
      transaction {
        blockHeight
        code
        data
        fromAddr
        memo
        orderId
        proposalId
        sequence
        source
        swapId
        timeStamp
        toAddr
        txAsset
        txFee
        txHash
        txType
        value
      }
      proof {
        root
        proof
      }
    }
  }
`;

// const QUERY_MAP = {
// "fees": FEES,
// "tokens": TOKENS,
// "block_stats": BLOCK_STATS,
// "markets": MARKETS,
// "validators": VALIDATORS,
// "marketDepth": MARKET_DEPTH,
// "market_tickers": MARKET_TICKERS,
// "market_ticker": MARKET_TICKER,
// "market_candlesticks":  MARKET_CANDLESTICKS,
// "account": ACCOUNT,
// "transaction": TRANSACTION,
// "transactions": TRANSACTIONS,
// "order": ORDER,
// "trade": TRADE,
// "atomic_swap": ATOMIC_SWAP
// }

const QUERIES = {
  TRANSACTION,
  //TRANSACTIONS,
  //ORDERS,
  ORDER,
  MARKET_TICKER,
  MARKET_TICKERS,
  // ATOMIC_SWAP,
  // ATOMIC_SWAPS,
  ACCOUNT,
  MARKETS,
  TOKENS,
  TRADE,
  // TRADES,
  VALIDATORS,
  BLOCK_STATS,
  MARKET_DEPTH,
  MARKET_CANDLESTICKS,
  FEES
}


module.exports = {
  QUERIES
};

},{"graphql-tag":206}],270:[function(req,module,exports){
'use strict';
var omitDeep = req('omit-deep');

const BINANCE_TYPES = [
  "fees",
  "tokens",
  "token",
  "block_stats",
  "markets",
  "market",
  "validators",
  "market_depth",
  "market_tickers",
  "market",
  "market_candlesticks",
  "account",
  "transaction",
  "order",
  "trade",
  "atomic_swap",
]

const BINANCE_QUERIES = {
  "blockStats": "block_stats",
  "fees": "fees",
  "tokens": "tokens",
  "account": "account",
  "orders": "order",
  "order" : "order",
  "transactions":"transaction",
  "transaction":"transaction",
  "markets" : "markets",
  "marketTicker":"market_ticker",
  "marketTickers":"market_tickers",
  "marketDepth": "market_depth",
  // marketCandleSticks
  // trades
  // trade
  // atomicSwaps
  // atomicSwap
  "validators": "validators",
  // timelocks
}


function preprocessQuery(query) {
  query = JSON.parse(JSON.stringify(query))
  query = omitDeep(query, ["__typename"])
  return query
}
//check if iterable/if proof associated
function parseQuery(query) {
  query = preprocessQuery(query)
  let {value, type} = binanceUnwrapQuery(query)
  let proof = value["proof"]
  value = value[type]
  return {value, proof, type}
}

function binanceUnwrapQuery(query_value) {

  let value;
  for (var key in BINANCE_QUERIES) {
    let query = key
    let type = BINANCE_QUERIES[query]
    if (query_value[query] && query_value[query][type]) {
      value = query_value[query]
      return {value, type}
    }
    if (query_value[type]) {
      value = query_value
      return {value, type}
    }
  }
  return {value, type: null}
}

module.exports = {BINANCE_TYPES, parseQuery}

},{"omit-deep":242}],271:[function(req,module,exports){
const ApolloClient = req('apollo-boost');
const {Subgraph, Proofs} = req('proxima-client');
const {QUERIES, QUERY_MAP} = req("./common/index.js");
const audit = req("./audit/audit.js");


function createBinanceSubgraph(args = {}) {
  let audit_fn = audit.make_audit(args.audit_uri)
  let queries = QUERIES
  let binance_subgraph = new Subgraph(args.client_uri, queries,  audit_fn)
  return binance_subgraph
}


module.exports =  createBinanceSubgraph

},{"./audit/audit.js":266,"./common/index.js":269,"apollo-boost":5,"proxima-client":244}],272:[function(req,module,exports){
module.exports = req('./lib/axios');
},{"./lib/axios":274}],273:[function(req,module,exports){
(function (process){
'use strict';

var utils = req('./../utils');
var settle = req('./../core/settle');
var buildURL = req('./../helpers/buildURL');
var parseHeaders = req('./../helpers/parseHeaders');
var isURLSameOrigin = req('./../helpers/isURLSameOrigin');
var createError = req('../core/createError');
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || req('./../helpers/btoa');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = req('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

}).call(this,req('_process'))
},{"../core/createError":280,"./../core/settle":283,"./../helpers/btoa":287,"./../helpers/buildURL":288,"./../helpers/cookies":290,"./../helpers/isURLSameOrigin":292,"./../helpers/parseHeaders":294,"./../utils":296,"_process":307}],274:[function(req,module,exports){
'use strict';

var utils = req('./utils');
var bind = req('./helpers/bind');
var Axios = req('./core/Axios');
var defaults = req('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = req('./cancel/Cancel');
axios.CancelToken = req('./cancel/CancelToken');
axios.isCancel = req('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = req('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":275,"./cancel/CancelToken":276,"./cancel/isCancel":277,"./core/Axios":278,"./defaults":285,"./helpers/bind":286,"./helpers/spread":295,"./utils":296}],275:[function(req,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],276:[function(req,module,exports){
'use strict';

var Cancel = req('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":275}],277:[function(req,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],278:[function(req,module,exports){
'use strict';

var defaults = req('./../defaults');
var utils = req('./../utils');
var InterceptorManager = req('./InterceptorManager');
var dispatchRequest = req('./dispatchRequest');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"./../defaults":285,"./../utils":296,"./InterceptorManager":279,"./dispatchRequest":281}],279:[function(req,module,exports){
'use strict';

var utils = req('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":296}],280:[function(req,module,exports){
'use strict';

var enhanceError = req('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":282}],281:[function(req,module,exports){
'use strict';

var utils = req('./../utils');
var transformData = req('./transformData');
var isCancel = req('../cancel/isCancel');
var defaults = req('../defaults');
var isAbsoluteURL = req('./../helpers/isAbsoluteURL');
var combineURLs = req('./../helpers/combineURLs');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":277,"../defaults":285,"./../helpers/combineURLs":289,"./../helpers/isAbsoluteURL":291,"./../utils":296,"./transformData":284}],282:[function(req,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

},{}],283:[function(req,module,exports){
'use strict';

var createError = req('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":280}],284:[function(req,module,exports){
'use strict';

var utils = req('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":296}],285:[function(req,module,exports){
(function (process){
'use strict';

var utils = req('./utils');
var normalizeHeaderName = req('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = req('./adapters/xhr');
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = req('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this,req('_process'))
},{"./adapters/http":273,"./adapters/xhr":273,"./helpers/normalizeHeaderName":293,"./utils":296,"_process":307}],286:[function(req,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],287:[function(req,module,exports){
'use strict';

// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

},{}],288:[function(req,module,exports){
'use strict';

var utils = req('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":296}],289:[function(req,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],290:[function(req,module,exports){
'use strict';

var utils = req('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);

},{"./../utils":296}],291:[function(req,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],292:[function(req,module,exports){
'use strict';

var utils = req('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);

},{"./../utils":296}],293:[function(req,module,exports){
'use strict';

var utils = req('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":296}],294:[function(req,module,exports){
'use strict';

var utils = req('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":296}],295:[function(req,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],296:[function(req,module,exports){
'use strict';

var bind = req('./helpers/bind');
var isBuffer = req('is-buffer');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":286,"is-buffer":297}],297:[function(req,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],298:[function(req,module,exports){
(function (global){
'use strict';

var objectAssign = req('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = req('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization reqs the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":306,"util/":301}],299:[function(req,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],300:[function(req,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],301:[function(req,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = req('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = req('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,req('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":300,"_process":307,"inherits":299}],302:[function(req,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],303:[function(req,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = req('base64-js')
var ieee754 = req('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is reqd by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you req old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,req("buffer").Buffer)
},{"base64-js":302,"buffer":303,"ieee754":304}],304:[function(req,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],305:[function(req,module,exports){
arguments[4][297][0].apply(exports,arguments)
},{"dup":297}],306:[function(req,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],307:[function(req,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],308:[function(req,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = req('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,req("timers").setImmediate,req("timers").clearImmediate)
},{"process/browser.js":307,"timers":308}]},{},[1]);

module.exports = createBinanceSubgraph
